<Type Name="CIColorCubeWithColorSpace" FullName="MonoTouch.CoreImage.CIColorCubeWithColorSpace">
  <TypeSignature Language="C#" Value="public class CIColorCubeWithColorSpace : MonoTouch.CoreImage.CIColorCube" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit CIColorCubeWithColorSpace extends MonoTouch.CoreImage.CIColorCube" />
  <AssemblyInfo apistyle="classic">
    <AssemblyName>monotouch</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo apistyle="unified">
    <AssemblyName>Xamarin.iOS</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>MonoTouch.CoreImage.CIColorCube</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>MonoTouch.ObjCRuntime.iOS(7, 0)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>MonoTouch.ObjCRuntime.Mac(10, 9, false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>A filter that modifies the source pixels using a 3D color-table and then maps the result to a color space.</summary>
    <remarks>
      <para>The following example shows this filter in use</para>
      <example>
        <code lang="C#">
// Create the CIImage from a file
CIImage flower = CIImage.FromCGImage (UIImage.FromFile ("flower.png").CGImage);

// Setup the color cube data
float [] color_cube_data = {
	0, 0, 0, 1,
	.1f, 0, 1, 1,
	0, 1, 0, 1,
	1, 1, 0, 1,
	0, 0, 1, 1,
	1, 0, 1, 1,
	0, 1, 1, 1,
	1, 1, 1, 1
};

var byteArray = new byte[color_cube_data.Length * 4];
Buffer.BlockCopy(color_cube_data, 0, byteArray, 0, byteArray.Length);
var data = NSData.FromArray (byteArray);

// Create a CIColorCubeWithColorSpace filter with the input image
using (var cs = CGColorSpace.CreateDeviceRGB ()) {
	var color_cube_with_color_space = new CIColorCubeWithColorSpace () {
		Image = flower,
		CubeDimension = 2,
		CubeData = data,
		ColorSpace = cs
	};

	// Get the altered image from the filter
	var output = color_cube_with_color_space.OutputImage;

	// To render the results, we need to create a context, and then
	// use one of the context rendering APIs, in this case, we render the
	// result into a CoreGraphics image, which is merely a useful representation
	//
	var context = CIContext.FromOptions (null);

	var cgimage = context.CreateCGImage (output, output.Extent);

	// The above cgimage can be added to a screen view, for example, this
	// would add it to a UIImageView on the screen:
	myImageView.Image = UIImage.FromImage (cgimage);
}
        </code>
      </example>
      <para>
        With the following image input:
      </para>
      <para>
        <img href="flower.png" />
      </para>
      <para>
         Produces the following output:
      </para>
      <para>
        <img href="color_cube_with_color_space.png" />
      </para>
      <para>
      	"Flower" Â© 2012 Milica Sekulic, used under a Creative Commons Attribution-ShareAlike license: http://creativecommons.org/licenses/by-sa/3.0/ 
      </para>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public CIColorCubeWithColorSpace ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public CIColorCubeWithColorSpace (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Pointer (handle) to the unmanaged object.</param>
        <summary>A constructor used when creating managed representations of unmanaged objects;  Called by the runtime.</summary>
        <remarks>
          <para>This constructor is invoked by the runtime infrastructure (<see cref="M:MonoTouch.ObjCRuntime.GetNSObject (System.IntPtr)" />) to create a new managed representation for a pointer to an unmanaged Objective-C object.    You should not invoke this method directly, instead you should call the GetNSObject method as it will prevent two instances of a managed object to point to the same native object.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ColorSpace">
      <MemberSignature Language="C#" Value="public MonoTouch.CoreGraphics.CGColorSpace ColorSpace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.CoreGraphics.CGColorSpace ColorSpace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.CoreGraphics.CGColorSpace</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the color space to use.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
