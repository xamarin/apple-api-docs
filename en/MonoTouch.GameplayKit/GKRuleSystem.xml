<Type Name="GKRuleSystem" FullName="MonoTouch.GameplayKit.GKRuleSystem">
  <TypeSignature Language="C#" Value="public class GKRuleSystem : MonoTouch.Foundation.NSObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit GKRuleSystem extends MonoTouch.Foundation.NSObject" />
  <AssemblyInfo apistyle="classic">
    <AssemblyName>monotouch</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo apistyle="unified">
    <AssemblyName>Xamarin.iOS</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>MonoTouch.Foundation.NSObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>MonoTouch.Foundation.Register("GKRuleSystem", true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_9_0)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.Mac_10_0 | MonoTouch.ObjCRuntime.Platform.Mac_10_1 | MonoTouch.ObjCRuntime.Platform.Mac_10_2 | MonoTouch.ObjCRuntime.Platform.Mac_10_3 | MonoTouch.ObjCRuntime.Platform.Mac_10_4 | MonoTouch.ObjCRuntime.Platform.Mac_10_5 | MonoTouch.ObjCRuntime.Platform.Mac_10_6 | MonoTouch.ObjCRuntime.Platform.Mac_10_7 | MonoTouch.ObjCRuntime.Platform.Mac_10_8 | MonoTouch.ObjCRuntime.Platform.Mac_10_9 | MonoTouch.ObjCRuntime.Platform.Mac_10_10 | MonoTouch.ObjCRuntime.Platform.Mac_10_10_3 | MonoTouch.ObjCRuntime.Platform.Mac_10_11 | MonoTouch.ObjCRuntime.Platform.Mac_Version | MonoTouch.ObjCRuntime.Platform.Mac_Arch64 | MonoTouch.ObjCRuntime.Platform.Mac_Arch)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Maintains a collection of <see cref="T:MonoTouch.GameplayKit.GKRule" /> objects, activating them as appropriate.</summary>
    <remarks>
      <para>The <see cref="T:Monotouch.GameplayKit.GKRuleSystem" /> class allows developers to build expert systems. Both classical and fuzzy-logic systems are supported.</para>
      <para>At any time, a <see cref="T:Monotouch.GameplayKit.GKRule" /> is either in the <see cref="P:Monotouch.GameplayKit.GKRuleSystem.Agenda" /> collection of rules to be evaluated or the <see cref="P:Monotouch.GameplayKit.GKRuleSystem.Executed" /> collection. The <see cref="M:Monotouch.GameplayKit.GKRuleSystem.Reset" /> method moves all rules back to the <see cref="P:Monotouch.GameplayKit.GKRuleSystem.Agenda" /> collection. </para>
      <para>The method <see cref="M:Monotouch.GameplayKit.GKRuleSystem.Evaluate" /> evaluates the predicates of every rule in the <see cref="P:Monotouch.GameplayKit.GKRuleSystem.Agenda" />, according to their <see cref="P:Monotouch.GameplayKit.GKRule.Salience" /> and, secondarily, the order in which they were added to the <see cref="T:Monotouch.GameplayKit.GKRuleSystem" />. Rules whose predicate evaluates to <see langword="true" /> have their action function executed and are placed in the <see cref="P:Monotouch.GameplayKit.GKRuleSystem.Executed" /> collection.</para>
      <para>The following demonstrates the "FizzBuzz" challenge: If a number is evenly divisible by 3, output "fizz". If evenly divisible by 5, output "buzz". Otherwise, output the number itself. Note that this code properly sets the <c>output</c> to "buzzfizz" on an input of 15, since both the <c>fizzRule</c> and <c>buzzRule</c> evaluate to <see langword="true" />.</para>
      <example>
        <code lang="C#"><![CDATA[
var clearRule = GKRule.FromPredicate ((rules) => reset, rules => {
	output = "";
	reset = false;
});
clearRule.Salience = 1;

var fizzRule = GKRule.FromPredicate (mod (3), rules => {
	output += "fizz";
});
fizzRule.Salience = 2;
var buzzRule = GKRule.FromPredicate (mod (5), rules => { 
	output += "buzz";
});
buzzRule.Salience = 2;

var outputRule = GKRule.FromPredicate (rules => true, rules => {
	System.Console.WriteLine (output == "" ? input.ToString () : output);
	reset = true;
});
outputRule.Salience = 3;

var rs = new GKRuleSystem ();
rs.AddRules (new [] {
	clearRule,
	fizzRule,
	buzzRule,
	outputRule
});

for (input = 1; input < 16; input++) {
	rs.Evaluate ();
	rs.Reset ();
}
          
          ]]></code>
      </example>
    </remarks>
    <related type="PlatformDocAPI" href="https://developer.apple.com/library/ios/documentation/GameplayKit/Reference/GKRuleSystem_Class/index.html">Apple documentation for <c>GKRuleSystem</c></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GKRuleSystem ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("init")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Default constructor, initializes a new instance of this class.</summary>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName=".ctor" apistyle="classic">
      <MemberSignature Language="C#" Value="public GKRuleSystem (MonoTouch.Foundation.NSCoder coder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class MonoTouch.Foundation.NSCoder coder) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("initWithCoder:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.DesignatedInitializer</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="coder" Type="MonoTouch.Foundation.NSCoder" />
      </Parameters>
      <Docs>
        <param name="coder">The unarchiver object.</param>
        <summary>A constructor that initializes the object from the data stored in the unarchiver object.</summary>
        <remarks>
          <para>This constructor is provided to allow the class to be initialized from an unarchiver (for example, during NIB deserialization).   This is part of the <see cref="T:MonoTouch.Foundation.NSCoding" />  protocol.</para>
          <para>If you want to create a subclass of this object and continue to support deserialization from an archive, you should implement a constructor with an identical signature: taking a single parameter of type <see cref="T:MonoTouch.Foundation.NSCoder" /> and decorate it with the [Export("initWithCoder:"] attribute declaration.</para>
          <para>The state of this object can also be serialized by using the companion method, EncodeTo.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GKRuleSystem (MonoTouch.Foundation.NSObjectFlag t);" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class MonoTouch.Foundation.NSObjectFlag t) cil managed" apistyle="classic" />
      <MemberSignature Language="C#" Value="protected GKRuleSystem (MonoTouch.Foundation.NSObjectFlag t);" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class MonoTouch.Foundation.NSObjectFlag t) cil managed" apistyle="unified" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="t" Type="MonoTouch.Foundation.NSObjectFlag" />
      </Parameters>
      <Docs>
        <param name="t">Unused sentinel value, pass NSObjectFlag.Empty.</param>
        <summary>Constructor to call on derived classes to skip initialization and merely allocate the object.</summary>
        <remarks>
          <para>This constructor should be called by derived classes when they completely construct the object in managed code and merely want the runtime to allocate and initialize the NSObject.   This is required to implement the two-step initialization process that Objective-C uses, the first step is to perform the object allocation, the second step is to initialize the object.   When you invoke the constructor that takes the NSObjectFlag.Empty you taking advantage of a direct path that goes all the way up to NSObject to merely allocate the object's memory and bind the Objective-C and C# objects together.    The actual initialization of the object is up to you.</para>
          <para>This constructor is typically used by the binding generator to allocate the object, but prevent the actual initialization to take place.   Once the allocation has taken place, the constructor has to initialize the object.   With constructors generated by the binding generator this means that it manually invokes one of the "init" methods to initialize the object.</para>
          <para>It is your responsibility to completely initialize the object if you chain up using the NSObjectFlag.Empty path.</para>
          <para>In general, if your constructors invokes the NSObjectFlag.Empty base implementation, then it should be calling an Objective-C init method.   If this is not the case, you should instead chain to the proper constructor in your class. </para>
          <para>The argument value is ignored and merely ensures that the only code that is executed is the construction phase is the basic NSObject allocation and runtime type registration.  Typically the chaining would look like this:</para>
          <example>
            <code lang="C#">
//
// The NSObjectFlag merely allocates the object and registers the
// C# class with the Objective-C runtime if necessary, but no actual
// initXxx method is invoked, that is done later in the constructor
//
// This is taken from MonoTouch's source code:
//
[Export ("initWithFrame:")]
public UIView (System.Drawing.RectangleF frame) : base (NSObjectFlag.Empty)
{
// Invoke the init method now.
	var initWithFrame = new Selector ("initWithFrame:").Handle;
	if (IsDirectBinding)
		Handle = MonoTouch.ObjCRuntime.Messaging.IntPtr_objc_msgSend_RectangleF (this.Handle, initWithFrame, frame);
	else
		Handle = MonoTouch.ObjCRuntime.Messaging.IntPtr_objc_msgSendSuper_RectangleF (this.SuperHandle, initWithFrame, frame);
}
</code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GKRuleSystem (IntPtr handle);" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle) cil managed" apistyle="classic" />
      <MemberSignature Language="C#" Value="protected GKRuleSystem (IntPtr handle);" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig specialname rtspecialname instance void .ctor(native int handle) cil managed" apistyle="unified" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Pointer (handle) to the unmanaged object.</param>
        <summary>A constructor used when creating managed representations of unmanaged objects;  Called by the runtime.</summary>
        <remarks>
          <para>This constructor is invoked by the runtime infrastructure (<see cref="M:MonoTouch.ObjCRuntime.GetNSObject (System.IntPtr)" />) to create a new managed representation for a pointer to an unmanaged Objective-C object.    You should not invoke this method directly, instead you should call the GetNSObject method as it will prevent two instances of a managed object to point to the same native object.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddRule">
      <MemberSignature Language="C#" Value="public virtual void AddRule (MonoTouch.GameplayKit.GKRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddRule(class MonoTouch.GameplayKit.GKRule rule) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("addRule:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="MonoTouch.GameplayKit.GKRule" />
      </Parameters>
      <Docs>
        <param name="rule">To be added.</param>
        <summary>Adds <paramref name="rule" /> to the system, placing it in the <see cref="P:Monotouch.GameplayKit.GKRuleSystem.Agenda" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddRules">
      <MemberSignature Language="C#" Value="public virtual void AddRules (MonoTouch.GameplayKit.GKRule[] rules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddRules(class MonoTouch.GameplayKit.GKRule[] rules) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("addRulesFromArray:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rules" Type="MonoTouch.GameplayKit.GKRule[]" />
      </Parameters>
      <Docs>
        <param name="rules">To be added.</param>
        <summary>Adds <paramref name="rules" /> to the system, placing them in the <see cref="P:Monotouch.GameplayKit.GKRuleSystem.Agenda" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Agenda">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.GameplayKit.GKRule[] Agenda { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.GameplayKit.GKRule[] Agenda" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("agenda")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.GameplayKit.GKRule[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The collection of <see cref="T:Monotouch.GameplayKit.GKRule" /> objects whose predicates have not yet evaluated to <see langword="true" />.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AssertFact">
      <MemberSignature Language="C#" Value="public virtual void AssertFact (MonoTouch.Foundation.NSObject fact);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AssertFact(class MonoTouch.Foundation.NSObject fact) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("assertFact:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fact" Type="MonoTouch.Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="fact">To be added.</param>
        <summary>Adds the <paramref name="fact" /> to the system's knowledge-base, with a grade of 1.0.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AssertFact">
      <MemberSignature Language="C#" Value="public virtual void AssertFact (MonoTouch.Foundation.NSObject fact, float grade);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AssertFact(class MonoTouch.Foundation.NSObject fact, float32 grade) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("assertFact:grade:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fact" Type="MonoTouch.Foundation.NSObject" />
        <Parameter Name="grade" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="fact">To be added.</param>
        <param name="grade">The amount by which to change the truth grade of the <paramref name="fact" />.</param>
        <summary>Adds the <paramref name="fact" /> to the system's knowledge-base, increasing it's truth-value by <paramref name="grade" />.</summary>
        <remarks>
          <para>If the truth grade of a fact goes to 0.0 or below, it is removed from the <see cref="P:Monotouch.GameplayKit.GKRuleSystem.Facts" /> collection.</para>
          <para>Note that this process adds <paramref name="grade" /> to the internally-stored grade of the <paramref name="fact" />. To set an absolute value, developers must first call <see cref="M:Monotouch.GameplayKit.GKRuleSystem.RetractFact(NSObject)" /> to erase the current internal belief in the fact.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClassHandle">
      <MemberSignature Language="C#" Value="public override IntPtr ClassHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ClassHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The handle for this class.</summary>
        <value>The pointer to the Objective-C class.</value>
        <remarks>Each MonoTouch class mirrors an unmanaged Objective-C class.   This value contains the pointer to the Objective-C class, it is similar to calling objc_getClass with the object name.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <para>If set to <see langword="true" />, the method is invoked directly and will dispose manage and unmanaged resources;   If set to <see langword="false" /> the method is being called by the garbage collector finalizer and should only release unmanaged resources.</para>
        </param>
        <summary>Releases the resources used by the GKRuleSystem object.</summary>
        <remarks>
          <para>This Dispose method releases the resources used by the GKRuleSystem class.</para>
          <para>This method is called by both the Dispose() method and the object finalizer (Finalize).    When invoked by the Dispose method, the parameter disposing <paramref name="disposing" /> is set to <see langword="true" /> and any managed object references that this object holds are also disposed or released;  when invoked by the object finalizer, on the finalizer thread the value is set to <see langword="false" />. </para>
          <para>Calling the Dispose method when you are finished using the GKRuleSystem ensures that all external resources used by this managed object are released as soon as possible.  Once you have invoked the Dispose method, the object is no longer useful and you should no longer make any calls to it.</para>
          <para>  For more information on how to override this method and on the Dispose/IDisposable pattern, read the ``Implementing a Dispose Method'' document at http://msdn.microsoft.com/en-us/library/fs2xkftw.aspx</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Evaluate">
      <MemberSignature Language="C#" Value="public virtual void Evaluate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Evaluate() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("evaluate")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Evaluates the predicates in the <see cref="P:Monotouch.GameplayKit.GKRuleSystem.Agenda" /> and executes actions of those evaluating to <see langword="true" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Executed">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.GameplayKit.GKRule[] Executed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.GameplayKit.GKRule[] Executed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("executed")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.GameplayKit.GKRule[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rules in the system that have been evaluated as <see langword="true" /> and had their actions executed.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Facts">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.Foundation.NSObject[] Facts { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.Foundation.NSObject[] Facts" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("facts")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSObject[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An arbitrary set of objects about which the <see cref="T:Monotouch.GameplayKit.GKRuleSystem" /> maintains a truth grade in the range [0,1].</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGrade">
      <MemberSignature Language="C#" Value="public virtual float GetGrade (MonoTouch.Foundation.NSObject fact);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float32 GetGrade(class MonoTouch.Foundation.NSObject fact) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("gradeForFact:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fact" Type="MonoTouch.Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="fact">To be added.</param>
        <summary>Retrieves the truth grade for the <paramref name="fact" />.</summary>
        <returns>A value in the range [0,1], in which 0 represents certainty that the fact is false and 1.0 represents certainty that it is true.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMaximumGrade">
      <MemberSignature Language="C#" Value="public virtual float GetMaximumGrade (MonoTouch.Foundation.NSObject[] facts);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float32 GetMaximumGrade(class MonoTouch.Foundation.NSObject[] facts) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("maximumGradeForFacts:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="facts" Type="MonoTouch.Foundation.NSObject[]" />
      </Parameters>
      <Docs>
        <param name="facts">To be added.</param>
        <summary>Retrieves the maximum truth grade among the <paramref name="facts" />. (Fuzzy OR)</summary>
        <returns>To be added.</returns>
        <remarks>
          <para>In fuzzy logic, the confidence in a conclusion is equal to the confidence in one of the precedent facts. In a fuzzy OR, the confidence in the conclusion is the maximum value of its precedent facts. In a fuzzy AND, the confidence is the minimum.For instance, a car’s desirability might be caused by it being great fun to drive OR having great gas mileage. If a car had a 0.4 grade for <c>funToDrive</c> but <c>greatMileage</c> of 0.8, the <c>carDesirability</c> would be set to 0.8 — the maximum of its precedents. <c>funToDrive</c>, in turn, might require power AND handling. So a car with <c>plentyOfHorsepower</c> of 1.0 but <c>goodHandling</c> of 0.4 would end up with a <c>funToDrive</c> grade of 0.4 — the minimum of its precedents.</para>
          <para>
            <img href="GKRuleSystemFuzzyOperators.png" />
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMinimumGrade">
      <MemberSignature Language="C#" Value="public virtual float GetMinimumGrade (MonoTouch.Foundation.NSObject[] facts);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float32 GetMinimumGrade(class MonoTouch.Foundation.NSObject[] facts) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("minimumGradeForFacts:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="facts" Type="MonoTouch.Foundation.NSObject[]" />
      </Parameters>
      <Docs>
        <param name="facts">To be added.</param>
        <summary>Retrieves the minimum truth grade among the <paramref name="facts" />. (Fuzzy AND)</summary>
        <returns>To be added.</returns>
        <remarks>
          <para>In fuzzy logic, the confidence in a conclusion is equal to the confidence in one of the precedent facts. In a fuzzy OR, the confidence in the conclusion is the maximum value of its precedent facts. In a fuzzy AND, the confidence is the minimum.For instance, a car’s desirability might be caused by it being great fun to drive OR having great gas mileage. If a car had a 0.4 grade for <c>funToDrive</c> but <c>greatMileage</c> of 0.8, the <c>carDesirability</c> would be set to 0.8 — the maximum of its precedents. <c>funToDrive</c>, in turn, might require power AND handling. So a car with <c>plentyOfHorsepower</c> of 1.0 but <c>goodHandling</c> of 0.4 would end up with a <c>funToDrive</c> grade of 0.4 — the minimum of its precedents.</para>
          <para>
            <img href="GKRuleSystemFuzzyOperators.png" />
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAllRules">
      <MemberSignature Language="C#" Value="public virtual void RemoveAllRules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAllRules() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("removeAllRules")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Removes all the <see cref="T:Monotouch.GameplayKit.GKRule" /> objects in the <see cref="T:Monotouch.GameplayKit.GKRuleSystem" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public virtual void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("reset")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Moves all <see cref="T:Monotouch.GameplayKit.GKRule" /> objects from the <see cref="P:Monotouch.GameplayKit.GKRuleSystem.Executed" /> collection to the <see cref="P:Monotouch.GameplayKit.GKRuleSystem.Agenda" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RetractFact">
      <MemberSignature Language="C#" Value="public virtual void RetractFact (MonoTouch.Foundation.NSObject fact);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RetractFact(class MonoTouch.Foundation.NSObject fact) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("retractFact:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fact" Type="MonoTouch.Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="fact">To be added.</param>
        <summary>Removes the <paramref name="fact" /> from the <see cref="P:Monotouch.GameplayKit.GKRuleSystem.Facts" /> collection.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RetractFact">
      <MemberSignature Language="C#" Value="public virtual void RetractFact (MonoTouch.Foundation.NSObject fact, float grade);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RetractFact(class MonoTouch.Foundation.NSObject fact, float32 grade) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("retractFact:grade:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fact" Type="MonoTouch.Foundation.NSObject" />
        <Parameter Name="grade" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="fact">To be added.</param>
        <param name="grade">To be added.</param>
        <summary>Subtracts <paramref name="grade" /> from the internal confidence in <paramref name="fact" />. If the internal confidence drops to 0.0, the <paramref name="fact" /> is removed.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Rules">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.GameplayKit.GKRule[] Rules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.GameplayKit.GKRule[] Rules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("rules")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.GameplayKit.GKRule[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>All of the rules in the system, whether in <see cref="P:Monotouch.GameplayKit.GKRuleSystem.Agenda" /> or <see cref="P:Monotouch.GameplayKit.GKRuleSystem.Executed" />.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="State">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.Foundation.NSMutableDictionary State { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.Foundation.NSMutableDictionary State" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("state")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSMutableDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A mutable dictionary intended to hold the state information upon which the <see cref="P:Monotouch.GameplayKit.GKRuleSystem.Rules" /> operate.</summary>
        <value>To be added.</value>
        <remarks>
          <para>If the underlying <see cref="T:Monotouch.Foundation.NSMutableDictionary" /> is manipulated outside of the action of a constituent <see cref="T:Monotouch.GameplayKit.GKRule" />, deveopers must call <see cref="M:Monotouch.GameplayKit.GKRuleSystem.Reset" /> and <see cref="M:Monotouch.GameplayKit.GKRuleSystem.Evaluate" /> for the modified data to be acted upon.</para>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>