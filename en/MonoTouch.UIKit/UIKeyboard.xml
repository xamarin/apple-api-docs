<Type Name="UIKeyboard" FullName="MonoTouch.UIKit.UIKeyboard">
  <TypeSignature Language="C#" Value="public static class UIKeyboard" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit UIKeyboard extends System.Object" />
  <AssemblyInfo apistyle="classic">
    <AssemblyName>monotouch</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo apistyle="unified">
    <AssemblyName>Xamarin.iOS</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>MonoTouch.ObjCRuntime.Unavailable(MonoTouch.ObjCRuntime.PlatformName.TvOS, MonoTouch.ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>The iPhone virtual keyboard.</summary>
    <remarks>
      <para>

	The UIKeyboard class contains constants and methods to track
	the visibility of the iPhone virtual keyboard.  iOS posts a
	number of notifications when the keyboard is shown, hidden or
	moved in the screen.   

      </para>
      <para>

	The preferred way of receiving UIKeyboard notification is to
	use the <see cref="T:MonoTouch.UIKit.UIKeyboard+Notifications" /> class,
	which provides a strongly-typed set of APIs to track the
	changes to the keyboard state and provides strongly-typed
	accessors to the various parameters of the keyboard changes.

      </para>
      <example>
        <code lang="C#"><![CDATA[
//
// Lambda style
//

// listening
notification = UIKeyboard.Notifications.ObserveDidChangeFrame ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("FrameBegin", args.FrameBegin);
    Console.WriteLine ("FrameEnd", args.FrameEnd);
    Console.WriteLine ("AnimationDuration", args.AnimationDuration);
    Console.WriteLine ("AnimationCurve", args.AnimationCurve);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, MonoTouch.UIKit.UIKeyboardEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("FrameBegin", args.FrameBegin);
    Console.WriteLine ("FrameEnd", args.FrameEnd);
    Console.WriteLine ("AnimationDuration", args.AnimationDuration);
    Console.WriteLine ("AnimationCurve", args.AnimationCurve);
}

void Setup ()
{
    notification = UIKeyboard.Notifications.ObserveDidChangeFrame (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
      </example>
    </remarks>
    <related type="sample" href="http://samples.xamarin.com/Samples/ByGuid?guid=23a2571b-45eb-4889-bb67-d88937cb68c1">monocatalog</related>
  </Docs>
  <Members>
    <Member MemberName="AnimationCurveFromNotification">
      <MemberSignature Language="C#" Value="public static uint AnimationCurveFromNotification (MonoTouch.Foundation.NSNotification n);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 AnimationCurveFromNotification(class MonoTouch.Foundation.NSNotification n) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="n" Type="MonoTouch.Foundation.NSNotification" />
      </Parameters>
      <Docs>
        <param name="n">notification and its payload.</param>
        <summary>Deprecated: helper method to extract the animation curve from a notification.</summary>
        <returns>
        </returns>
        <remarks>Use the <see cref="T:MonoTouch.UIKit.UIKeyboard+Notifications" /> strongly typed methods instead.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AnimationCurveUserInfoKey">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString AnimationCurveUserInfoKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString AnimationCurveUserInfoKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIKeyboardAnimationCurveUserInfoKey", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Introduced(MonoTouch.ObjCRuntime.PlatformName.iOS, 3, 2, MonoTouch.ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Unavailable(MonoTouch.ObjCRuntime.PlatformName.TvOS, MonoTouch.ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Introduced(MonoTouch.ObjCRuntime.PlatformName.iOS, 3, 2, MonoTouch.ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Unavailable(MonoTouch.ObjCRuntime.PlatformName.TvOS, MonoTouch.ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UIKeyboardAnimationCurveUserInfoKey</summary>
        <value>
        </value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AnimationDurationFromNotification">
      <MemberSignature Language="C#" Value="public static double AnimationDurationFromNotification (MonoTouch.Foundation.NSNotification n);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 AnimationDurationFromNotification(class MonoTouch.Foundation.NSNotification n) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="n" Type="MonoTouch.Foundation.NSNotification" />
      </Parameters>
      <Docs>
        <param name="n">notification and its payload.</param>
        <summary>Deprecated: helper method to extract the animation duration from a notification.</summary>
        <returns>
        </returns>
        <remarks>Use the <see cref="T:MonoTouch.UIKit.UIKeyboard+Notifications" /> strongly typed methods instead.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AnimationDurationUserInfoKey">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString AnimationDurationUserInfoKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString AnimationDurationUserInfoKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIKeyboardAnimationDurationUserInfoKey", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Introduced(MonoTouch.ObjCRuntime.PlatformName.iOS, 3, 2, MonoTouch.ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Unavailable(MonoTouch.ObjCRuntime.PlatformName.TvOS, MonoTouch.ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Introduced(MonoTouch.ObjCRuntime.PlatformName.iOS, 3, 2, MonoTouch.ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Unavailable(MonoTouch.ObjCRuntime.PlatformName.TvOS, MonoTouch.ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UIKeyboardAnimationDurationUserInfoKey</summary>
        <value>
        </value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BoundsFromNotification">
      <MemberSignature Language="C#" Value="public static System.Drawing.RectangleF BoundsFromNotification (MonoTouch.Foundation.NSNotification n);" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Drawing.RectangleF BoundsFromNotification(class MonoTouch.Foundation.NSNotification n) cil managed" apistyle="classic" />
      <MemberSignature Language="C#" Value="public static MonoTouch.CoreGraphics.CGRect BoundsFromNotification (MonoTouch.Foundation.NSNotification n);" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype MonoTouch.CoreGraphics.CGRect BoundsFromNotification(class MonoTouch.Foundation.NSNotification n) cil managed" apistyle="unified" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Deprecated(MonoTouch.ObjCRuntime.PlatformName.iOS, 3, 2, MonoTouch.ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType apistyle="classic">System.Drawing.RectangleF</ReturnType>
        <ReturnType apistyle="unified">MonoTouch.CoreGraphics.CGRect</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="n" Type="MonoTouch.Foundation.NSNotification" />
      </Parameters>
      <Docs>
        <param name="n">notification and its payload.</param>
        <summary>Deprecated: helper method to extract the keyboard bounds from a notification.</summary>
        <returns>
        </returns>
        <remarks>Use the <see cref="T:MonoTouch.UIKit.UIKeyboard+Notifications" /> strongly typed methods instead.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BoundsUserInfoKey">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString BoundsUserInfoKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString BoundsUserInfoKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIKeyboardBoundsUserInfoKey", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Deprecated(MonoTouch.ObjCRuntime.PlatformName.iOS, 3, 2, MonoTouch.ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Introduced(MonoTouch.ObjCRuntime.PlatformName.iOS, 2, 0, MonoTouch.ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Unavailable(MonoTouch.ObjCRuntime.PlatformName.TvOS, MonoTouch.ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Deprecated(MonoTouch.ObjCRuntime.PlatformName.iOS, 3, 2, MonoTouch.ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Introduced(MonoTouch.ObjCRuntime.PlatformName.iOS, 2, 0, MonoTouch.ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Unavailable(MonoTouch.ObjCRuntime.PlatformName.TvOS, MonoTouch.ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UIKeyboardBoundsUserInfoKey</summary>
        <value>
        </value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CenterBeginFromNotification">
      <MemberSignature Language="C#" Value="public static System.Drawing.PointF CenterBeginFromNotification (MonoTouch.Foundation.NSNotification n);" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Drawing.PointF CenterBeginFromNotification(class MonoTouch.Foundation.NSNotification n) cil managed" apistyle="classic" />
      <MemberSignature Language="C#" Value="public static MonoTouch.CoreGraphics.CGPoint CenterBeginFromNotification (MonoTouch.Foundation.NSNotification n);" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype MonoTouch.CoreGraphics.CGPoint CenterBeginFromNotification(class MonoTouch.Foundation.NSNotification n) cil managed" apistyle="unified" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Deprecated(MonoTouch.ObjCRuntime.PlatformName.iOS, 3, 2, MonoTouch.ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType apistyle="classic">System.Drawing.PointF</ReturnType>
        <ReturnType apistyle="unified">MonoTouch.CoreGraphics.CGPoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="n" Type="MonoTouch.Foundation.NSNotification" />
      </Parameters>
      <Docs>
        <param name="n">notification and its payload.</param>
        <summary>Deprecated: helper method to extract the center start from a notification</summary>
        <returns>
        </returns>
        <remarks>Use the <see cref="T:MonoTouch.UIKit.UIKeyboard+Notifications" /> strongly typed methods instead.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CenterBeginUserInfoKey">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString CenterBeginUserInfoKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString CenterBeginUserInfoKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIKeyboardCenterBeginUserInfoKey", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Deprecated(MonoTouch.ObjCRuntime.PlatformName.iOS, 3, 2, MonoTouch.ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Introduced(MonoTouch.ObjCRuntime.PlatformName.iOS, 2, 0, MonoTouch.ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Unavailable(MonoTouch.ObjCRuntime.PlatformName.TvOS, MonoTouch.ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Deprecated(MonoTouch.ObjCRuntime.PlatformName.iOS, 3, 2, MonoTouch.ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Introduced(MonoTouch.ObjCRuntime.PlatformName.iOS, 2, 0, MonoTouch.ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Unavailable(MonoTouch.ObjCRuntime.PlatformName.TvOS, MonoTouch.ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UIKeyboardCenterBeginUserInfoKey</summary>
        <value>
        </value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CenterEndFromNotification">
      <MemberSignature Language="C#" Value="public static System.Drawing.PointF CenterEndFromNotification (MonoTouch.Foundation.NSNotification n);" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Drawing.PointF CenterEndFromNotification(class MonoTouch.Foundation.NSNotification n) cil managed" apistyle="classic" />
      <MemberSignature Language="C#" Value="public static MonoTouch.CoreGraphics.CGPoint CenterEndFromNotification (MonoTouch.Foundation.NSNotification n);" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype MonoTouch.CoreGraphics.CGPoint CenterEndFromNotification(class MonoTouch.Foundation.NSNotification n) cil managed" apistyle="unified" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Deprecated(MonoTouch.ObjCRuntime.PlatformName.iOS, 3, 2, MonoTouch.ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType apistyle="classic">System.Drawing.PointF</ReturnType>
        <ReturnType apistyle="unified">MonoTouch.CoreGraphics.CGPoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="n" Type="MonoTouch.Foundation.NSNotification" />
      </Parameters>
      <Docs>
        <param name="n">notification and its payload.</param>
        <summary>Deprecated: helper method to extract the center end from a notification.</summary>
        <returns>
        </returns>
        <remarks>Use the <see cref="T:MonoTouch.UIKit.UIKeyboard+Notifications" /> strongly typed methods instead.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CenterEndUserInfoKey">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString CenterEndUserInfoKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString CenterEndUserInfoKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIKeyboardCenterEndUserInfoKey", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Deprecated(MonoTouch.ObjCRuntime.PlatformName.iOS, 3, 2, MonoTouch.ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Introduced(MonoTouch.ObjCRuntime.PlatformName.iOS, 2, 0, MonoTouch.ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Unavailable(MonoTouch.ObjCRuntime.PlatformName.TvOS, MonoTouch.ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Deprecated(MonoTouch.ObjCRuntime.PlatformName.iOS, 3, 2, MonoTouch.ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Introduced(MonoTouch.ObjCRuntime.PlatformName.iOS, 2, 0, MonoTouch.ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Unavailable(MonoTouch.ObjCRuntime.PlatformName.TvOS, MonoTouch.ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UIKeyboardCenterEndUserInfoKey</summary>
        <value>
        </value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DidChangeFrameNotification">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString DidChangeFrameNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString DidChangeFrameNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Advice("Use UIKeyboard.Notifications.ObserveDidChangeFrame helper method instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIKeyboardDidChangeFrameNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Introduced(MonoTouch.ObjCRuntime.PlatformName.iOS, 5, 0, MonoTouch.ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Unavailable(MonoTouch.ObjCRuntime.PlatformName.TvOS, MonoTouch.ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Introduced(MonoTouch.ObjCRuntime.PlatformName.iOS, 5, 0, MonoTouch.ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Unavailable(MonoTouch.ObjCRuntime.PlatformName.TvOS, MonoTouch.ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for DidChangeFrame</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:MonoTouch.Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIKit.UIKeyboard+Notifications" />.<see cref="M:UIKit.UIKeyboard+Notifications.ObserveDidChangeFrameNotification" /> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="C#"><![CDATA[
//
// Lambda style
//

// listening
notification = UIKeyboard.Notifications.ObserveDidChangeFrame ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("FrameBegin", args.FrameBegin);
    Console.WriteLine ("FrameEnd", args.FrameEnd);
    Console.WriteLine ("AnimationDuration", args.AnimationDuration);
    Console.WriteLine ("AnimationCurve", args.AnimationCurve);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, MonoTouch.UIKit.UIKeyboardEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("FrameBegin", args.FrameBegin);
    Console.WriteLine ("FrameEnd", args.FrameEnd);
    Console.WriteLine ("AnimationDuration", args.AnimationDuration);
    Console.WriteLine ("AnimationCurve", args.AnimationCurve);
}

void Setup ()
{
    notification = UIKeyboard.Notifications.ObserveDidChangeFrame (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIKeyboard.DidChangeFrameNotification, (notification) => {Console.WriteLine ("Received the notification UIKeyboard", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIKeyboard", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIKeyboard.DidChangeFrameNotification, Callback);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DidHideNotification">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString DidHideNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString DidHideNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Advice("Use UIKeyboard.Notifications.ObserveDidHide helper method instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIKeyboardDidHideNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Unavailable(MonoTouch.ObjCRuntime.PlatformName.TvOS, MonoTouch.ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Unavailable(MonoTouch.ObjCRuntime.PlatformName.TvOS, MonoTouch.ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for DidHide</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:MonoTouch.Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIKit.UIKeyboard+Notifications" />.<see cref="M:UIKit.UIKeyboard+Notifications.ObserveDidHideNotification" /> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="C#"><![CDATA[
//
// Lambda style
//

// listening
notification = UIKeyboard.Notifications.ObserveDidHide ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("FrameBegin", args.FrameBegin);
    Console.WriteLine ("FrameEnd", args.FrameEnd);
    Console.WriteLine ("AnimationDuration", args.AnimationDuration);
    Console.WriteLine ("AnimationCurve", args.AnimationCurve);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, MonoTouch.UIKit.UIKeyboardEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("FrameBegin", args.FrameBegin);
    Console.WriteLine ("FrameEnd", args.FrameEnd);
    Console.WriteLine ("AnimationDuration", args.AnimationDuration);
    Console.WriteLine ("AnimationCurve", args.AnimationCurve);
}

void Setup ()
{
    notification = UIKeyboard.Notifications.ObserveDidHide (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIKeyboard.DidHideNotification, (notification) => {Console.WriteLine ("Received the notification UIKeyboard", notification); });


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIKeyboard", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIKeyboard.DidHideNotification, Callback);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DidShowNotification">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString DidShowNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString DidShowNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Advice("Use UIKeyboard.Notifications.ObserveDidShow helper method instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIKeyboardDidShowNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Unavailable(MonoTouch.ObjCRuntime.PlatformName.TvOS, MonoTouch.ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Unavailable(MonoTouch.ObjCRuntime.PlatformName.TvOS, MonoTouch.ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for DidShow</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:MonoTouch.Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIKit.UIKeyboard+Notifications" />.<see cref="M:UIKit.UIKeyboard+Notifications.ObserveDidShowNotification" /> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="C#"><![CDATA[
//
// Lambda style
//

// listening
notification = UIKeyboard.Notifications.ObserveDidShow ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("FrameBegin", args.FrameBegin);
    Console.WriteLine ("FrameEnd", args.FrameEnd);
    Console.WriteLine ("AnimationDuration", args.AnimationDuration);
    Console.WriteLine ("AnimationCurve", args.AnimationCurve);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, MonoTouch.UIKit.UIKeyboardEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("FrameBegin", args.FrameBegin);
    Console.WriteLine ("FrameEnd", args.FrameEnd);
    Console.WriteLine ("AnimationDuration", args.AnimationDuration);
    Console.WriteLine ("AnimationCurve", args.AnimationCurve);
}

void Setup ()
{
    notification = UIKeyboard.Notifications.ObserveDidShow (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIKeyboard.DidShowNotification, (notification) => {Console.WriteLine ("Received the notification UIKeyboard", notification); });


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIKeyboard", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIKeyboard.DidShowNotification, Callback);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FrameBeginFromNotification">
      <MemberSignature Language="C#" Value="public static System.Drawing.RectangleF FrameBeginFromNotification (MonoTouch.Foundation.NSNotification n);" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Drawing.RectangleF FrameBeginFromNotification(class MonoTouch.Foundation.NSNotification n) cil managed" apistyle="classic" />
      <MemberSignature Language="C#" Value="public static MonoTouch.CoreGraphics.CGRect FrameBeginFromNotification (MonoTouch.Foundation.NSNotification n);" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype MonoTouch.CoreGraphics.CGRect FrameBeginFromNotification(class MonoTouch.Foundation.NSNotification n) cil managed" apistyle="unified" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType apistyle="classic">System.Drawing.RectangleF</ReturnType>
        <ReturnType apistyle="unified">MonoTouch.CoreGraphics.CGRect</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="n" Type="MonoTouch.Foundation.NSNotification" />
      </Parameters>
      <Docs>
        <param name="n">notification and its payload.</param>
        <summary>Deprecated: helper method to extract the keyboard's starting frame from a notification</summary>
        <returns>
        </returns>
        <remarks>Use the <see cref="T:MonoTouch.UIKit.UIKeyboard+Notifications" /> strongly typed methods instead.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FrameBeginUserInfoKey">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString FrameBeginUserInfoKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString FrameBeginUserInfoKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIKeyboardFrameBeginUserInfoKey", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Introduced(MonoTouch.ObjCRuntime.PlatformName.iOS, 3, 2, MonoTouch.ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Unavailable(MonoTouch.ObjCRuntime.PlatformName.TvOS, MonoTouch.ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Introduced(MonoTouch.ObjCRuntime.PlatformName.iOS, 3, 2, MonoTouch.ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Unavailable(MonoTouch.ObjCRuntime.PlatformName.TvOS, MonoTouch.ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UIKeyboardFrameBeginUserInfoKey</summary>
        <value>
        </value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FrameEndFromNotification">
      <MemberSignature Language="C#" Value="public static System.Drawing.RectangleF FrameEndFromNotification (MonoTouch.Foundation.NSNotification n);" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Drawing.RectangleF FrameEndFromNotification(class MonoTouch.Foundation.NSNotification n) cil managed" apistyle="classic" />
      <MemberSignature Language="C#" Value="public static MonoTouch.CoreGraphics.CGRect FrameEndFromNotification (MonoTouch.Foundation.NSNotification n);" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype MonoTouch.CoreGraphics.CGRect FrameEndFromNotification(class MonoTouch.Foundation.NSNotification n) cil managed" apistyle="unified" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType apistyle="classic">System.Drawing.RectangleF</ReturnType>
        <ReturnType apistyle="unified">MonoTouch.CoreGraphics.CGRect</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="n" Type="MonoTouch.Foundation.NSNotification" />
      </Parameters>
      <Docs>
        <param name="n">notification and its payload.</param>
        <summary>Deprecated: helper method to extract the keyboard's ending frame from a notification</summary>
        <returns>
        </returns>
        <remarks>Use the <see cref="T:MonoTouch.UIKit.UIKeyboard+Notifications" /> strongly typed methods instead.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FrameEndUserInfoKey">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString FrameEndUserInfoKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString FrameEndUserInfoKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIKeyboardFrameEndUserInfoKey", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Introduced(MonoTouch.ObjCRuntime.PlatformName.iOS, 3, 2, MonoTouch.ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Unavailable(MonoTouch.ObjCRuntime.PlatformName.TvOS, MonoTouch.ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Introduced(MonoTouch.ObjCRuntime.PlatformName.iOS, 3, 2, MonoTouch.ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Unavailable(MonoTouch.ObjCRuntime.PlatformName.TvOS, MonoTouch.ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UIKeyboardFrameEndUserInfoKey</summary>
        <value>
        </value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLocalUserInfoKey">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString IsLocalUserInfoKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString IsLocalUserInfoKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIKeyboardIsLocalUserInfoKey", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Introduced(MonoTouch.ObjCRuntime.PlatformName.iOS, 9, 0, MonoTouch.ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Unavailable(MonoTouch.ObjCRuntime.PlatformName.TvOS, MonoTouch.ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Introduced(MonoTouch.ObjCRuntime.PlatformName.iOS, 9, 0, MonoTouch.ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Unavailable(MonoTouch.ObjCRuntime.PlatformName.TvOS, MonoTouch.ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WillChangeFrameNotification">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString WillChangeFrameNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString WillChangeFrameNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Advice("Use UIKeyboard.Notifications.ObserveWillChangeFrame helper method instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIKeyboardWillChangeFrameNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Introduced(MonoTouch.ObjCRuntime.PlatformName.iOS, 5, 0, MonoTouch.ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Unavailable(MonoTouch.ObjCRuntime.PlatformName.TvOS, MonoTouch.ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Introduced(MonoTouch.ObjCRuntime.PlatformName.iOS, 5, 0, MonoTouch.ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Unavailable(MonoTouch.ObjCRuntime.PlatformName.TvOS, MonoTouch.ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for WillChangeFrame</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:MonoTouch.Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIKit.UIKeyboard+Notifications" />.<see cref="M:UIKit.UIKeyboard+Notifications.ObserveWillChangeFrameNotification" /> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="C#"><![CDATA[
//
// Lambda style
//

// listening
notification = UIKeyboard.Notifications.ObserveWillChangeFrame ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("FrameBegin", args.FrameBegin);
    Console.WriteLine ("FrameEnd", args.FrameEnd);
    Console.WriteLine ("AnimationDuration", args.AnimationDuration);
    Console.WriteLine ("AnimationCurve", args.AnimationCurve);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, MonoTouch.UIKit.UIKeyboardEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("FrameBegin", args.FrameBegin);
    Console.WriteLine ("FrameEnd", args.FrameEnd);
    Console.WriteLine ("AnimationDuration", args.AnimationDuration);
    Console.WriteLine ("AnimationCurve", args.AnimationCurve);
}

void Setup ()
{
    notification = UIKeyboard.Notifications.ObserveWillChangeFrame (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIKeyboard.WillChangeFrameNotification, (notification) => {Console.WriteLine ("Received the notification UIKeyboard", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIKeyboard", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIKeyboard.WillChangeFrameNotification, Callback);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WillHideNotification">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString WillHideNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString WillHideNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Advice("Use UIKeyboard.Notifications.ObserveWillHide helper method instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIKeyboardWillHideNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Unavailable(MonoTouch.ObjCRuntime.PlatformName.TvOS, MonoTouch.ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Unavailable(MonoTouch.ObjCRuntime.PlatformName.TvOS, MonoTouch.ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for WillHide</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:MonoTouch.Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIKit.UIKeyboard+Notifications" />.<see cref="M:UIKit.UIKeyboard+Notifications.ObserveWillHideNotification" /> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="C#"><![CDATA[
//
// Lambda style
//

// listening
notification = UIKeyboard.Notifications.ObserveWillHide ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("FrameBegin", args.FrameBegin);
    Console.WriteLine ("FrameEnd", args.FrameEnd);
    Console.WriteLine ("AnimationDuration", args.AnimationDuration);
    Console.WriteLine ("AnimationCurve", args.AnimationCurve);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, MonoTouch.UIKit.UIKeyboardEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("FrameBegin", args.FrameBegin);
    Console.WriteLine ("FrameEnd", args.FrameEnd);
    Console.WriteLine ("AnimationDuration", args.AnimationDuration);
    Console.WriteLine ("AnimationCurve", args.AnimationCurve);
}

void Setup ()
{
    notification = UIKeyboard.Notifications.ObserveWillHide (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}</code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIKeyboard.WillHideNotification, (notification) => {Console.WriteLine ("Received the notification UIKeyboard", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIKeyboard", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIKeyboard.WillHideNotification, Callback);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WillShowNotification">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString WillShowNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString WillShowNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Advice("Use UIKeyboard.Notifications.ObserveWillShow helper method instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIKeyboardWillShowNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Unavailable(MonoTouch.ObjCRuntime.PlatformName.TvOS, MonoTouch.ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Unavailable(MonoTouch.ObjCRuntime.PlatformName.TvOS, MonoTouch.ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for WillShow</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:MonoTouch.Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIKit.UIKeyboard+Notifications" />.<see cref="M:UIKit.UIKeyboard+Notifications.ObserveWillShowNotification" /> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="C#"><![CDATA[ 
//
// Lambda style
//

// listening
notification = UIKeyboard.Notifications.ObserveWillShow ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("FrameBegin", args.FrameBegin);
    Console.WriteLine ("FrameEnd", args.FrameEnd);
    Console.WriteLine ("AnimationDuration", args.AnimationDuration);
    Console.WriteLine ("AnimationCurve", args.AnimationCurve);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, MonoTouch.UIKit.UIKeyboardEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("FrameBegin", args.FrameBegin);
    Console.WriteLine ("FrameEnd", args.FrameEnd);
    Console.WriteLine ("AnimationDuration", args.AnimationDuration);
    Console.WriteLine ("AnimationCurve", args.AnimationCurve);
}

void Setup ()
{
    notification = UIKeyboard.Notifications.ObserveWillShow (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIKeyboard.WillShowNotification, (notification) => {Console.WriteLine ("Received the notification UIKeyboard", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIKeyboard", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIKeyboard.WillShowNotification, Callback);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
