<Type Name="UITableViewCell" FullName="MonoTouch.UIKit.UITableViewCell">
  <TypeSignature Language="C#" Value="public class UITableViewCell : MonoTouch.UIKit.UIView" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit UITableViewCell extends MonoTouch.UIKit.UIView" />
  <AssemblyInfo>
    <AssemblyName>monotouch</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>MonoTouch.UIKit.UIView</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>MonoTouch.Foundation.Register("UITableViewCell", true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>A <see cref="T:MonoTouch.UIKit.UIView" /> that displays an element displayed by the <see cref="T:MonoTouch.UIKit.UITableView" />. Cells can be reused.</summary>
    <remarks>
      <para>A <see cref="T:MonoTouch.UIKit.UITableViewCell"/> represents a single cell (row) in a <see cref="T:MonoTouch.UIKit.UITableView"/>. <see cref="T:MonoTouch.UIKit.UITableViewCell"/>s are typically allocated in the <see cref="M:MonoTouch.UIKit.UITableViewSource.GetRow"/> method of <see cref="T:MonoTouch.UIKit.UITableViewSource"/> if <see cref="M:MonoTouch.UIKit.UITableView.DequeueReusableCell"/> returns <see langword="null"/>. (See discussion at <see cref="T:MonoTouch.UIKit.UITableView"/> or <see cref="M:MonoTouch.UIKit.UITableViewSource.GetCell"/>).</para>
      <para>There are four predefined <see cref="T:MonoTouch.UIKit.UITableViewCell"/> styles, which can be created by using the <see cref="C:MonoTouch.UIKit.UITableViewCell(UITableViewCellStyle,NSString)"/> constructor. These predefined styles appear as follows:</para>
      <para><img href="MonoTouch.UIKit.UITableViewCellStyle.png"/></para>
      <para>All of the predefined styles have <see cref="P:MonoTouch.UIKit.UITableViewCell.TextLabel"/> and <see cref="P:MonoTouch.UIKit.UITableViewCell.DetailTextLabel"/> properties of type <see cref="T:MonoTouch.UIKit.UITextLabel"/> and all but <see cref="F:MonoTouch.UIKit.UITableViewCellStyle.Value2"/> have a <see cref="P:MonoTouch.UIKit.UITableViewCell.Image"/> of type <see cref="T:MonoTouch.UIKit.UIImage"/>. Assignment to the <see cref="P:MonoTouch.UIKit.UITableViewCell.Image"/> property of a cell initialized with the <see cref="F:MonoTouch.UIKit.UITableViewCellStyle.Value2"/> style will result in a runtime exception.</para>
      <para>A <see cref="T:MonoTouch.UIKit.UITableViewCell"/> may combine its <see cref="P:MonoTouch.UIKit.UITableViewCell.ContentView"/> with a <see cref="T:MonoTouch.UIKit.UIView"/> assigned to its <see cref="P:MonoTouch.UIKit.UITableViewCell.AccessoryView"/> property. Accessory views are often used with standard <see cref="T:MonoTouch.UIKit.UITableViewCellAccessory"/>s, such as a checkmark or disclosure indicator. When being edited, a <see cref="T:MonoTouch.UIKit.UITableViewCell"/> will combine its <see cref="P:MonoTouch.UIKit.UITableViewCell.ContentView"/> with an editing control on the left and, optionally, a reordering control on the right.</para>
      <para><img href="MonoTouch.UIKit.UITableViewCell.Structure.png"/></para>
      <para>In a non-selected cell, the <see cref="P:MonoTouch.UIKit.UITableViewCell.BackgroundView"/> is displayed, while a selected cell will show its <see cref="P:MonoTouch.UIKit.UITableViewCell.SelectedBackgroundView"/> view.</para>
      <para>To customize <see cref="T:MonoTouch.UIKit.UITableViewCell"/>s, application developers can either customize the views used by one of the predefined styles or can subclass <see cref="T:MonoTouch.UIKit.UITableViewCell"/>. (In addition, application developers will often override <see cref="M:MonoTouch.UIKit.UITableViewSource.GetHeightForRow"/>.)</para>
      <block subset="none" type="note">
      <para>Application developers should prefer subclassing <see cref="T:MonoTouch.UIKit.UITableViewCell"/> over extensive customization of predefined styles. Xamarin's experience is that subclassing is less error-prone. Although subclassing introduces the normal overhead of a new class, this is generally a minor trade-off in comparison to the importance and complexity of the customized cell.</para>
        
        <para>Because <see cref="T:MonoTouch.UIKit.UITableViewCell"/>s appear rapidly during scrolling, application developers should avoid layout recalculations and higher-cost rendering techniques such as the use of transparent views.</para>
        <para>Application developers should make a strong effort to reuse cells with the <see cref="M:MonoTouch.UIKit.UITableView.DequeueCellForReuse"/> method of <see cref="T:MonoTouch.UIKit.UITableView"/>. </para>
      </block>
    </remarks>
     <related type="article" href="http://docs.xamarin.com/guides/ios/user_interface/tables">Working with Tables and Cells</related>
    <related type="sample" href="http://samples.xamarin.com/Samples/ByGuid?guid=4912a5a3-7b98-4886-9d50-1b0c417f6037">LazyTableImages</related>
    <related type="sample" href="http://samples.xamarin.com/Samples/ByGuid?guid=23a2571b-45eb-4889-bb67-d88937cb68c1">monocatalog</related>
    <related type="sample" href="http://samples.xamarin.com/Samples/ByGuid?guid=05e33228-333b-4150-b596-cd7696277a3c">MonoDevelopTouchCells</related>
    <related type="sample" href="http://samples.xamarin.com/Samples/ByGuid?guid=a96da854-7c59-4e25-9fb5-78be262620dd">RecipesAndPrinting</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UITableViewCell ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("init")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Default constructor that initializes a new instance of this class with no parameters.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UITableViewCell (MonoTouch.Foundation.NSCoder coder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class MonoTouch.Foundation.NSCoder coder) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("initWithCoder:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="coder" Type="MonoTouch.Foundation.NSCoder" />
      </Parameters>
      <Docs>
        <param name="coder">The unarchiver object.</param>
        <summary>A constructor that initializes the object from the data stored in the unarchiver object.</summary>
        <remarks>This constructor is provided to allow the class to be initialized from an unarchiver (for example, during NIB deserialization).</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UITableViewCell (MonoTouch.Foundation.NSObjectFlag t);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class MonoTouch.Foundation.NSObjectFlag t) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="t" Type="MonoTouch.Foundation.NSObjectFlag" />
      </Parameters>
      <Docs>
        <param name="t">Unused sentinel value, pass NSObjectFlag.Empty.</param>
        <summary>Constructor to call on derived classes to skip initialization and merely allocate the object.</summary>
        <remarks>
          <para>This constructor should be called by derived classes when they completely construct the object in managed code and merely want the runtime to allocate and initialize the NSObject.   This is required to implement the two-step initialization process that Objective-C uses, the first step is to perform the object allocation, the second step is to initialize the object.   When you invoke the constructor that takes the NSObjectFlag.Empty you taking advantage of a direct path that goes all the way up to NSObject to merely allocate the object's memory and bind the Objective-C and C# objects together.    The actual initialization of the object is up to you.</para>
          <para>This constructor is typically used by the binding generator to allocate the object, but prevent the actual initialization to take place.   Once the allocation has taken place, the constructor has to initialize the object.   With constructors generated by the binding generator this means that it manually invokes one of the "init" methods to initialize the object.</para>
          <para>It is your responsibility to completely initialize the object if you chain up using the NSObjectFlag.Empty path.</para>
          <para>In general, if your constructors invokes the NSObjectFlag.Empty base implementation, then it should be calling an Objective-C init method.   If this is not the case, you should instead chain to the proper constructor in your class. </para>
          <para>The argument value is ignored and merely ensures that the only code that is executed is the construction phase is the basic NSObject allocation and runtime type registration.  Typically the chaining would look like this:</para>
          <example>
            <code lang="C#">
//
// The NSObjectFlag merely allocates the object and registers the
// C# class with the Objective-C runtime if necessary, but no actual
// initXxx method is invoked, that is done later in the constructor
//
// This is taken from MonoTouch's source code:
//
[Export ("initWithFrame:")]
public UIView (System.Drawing.RectangleF frame) : base (NSObjectFlag.Empty)
{
// Invoke the init method now.
	var initWithFrame = new Selector ("initWithFrame:").Handle;
	if (IsDirectBinding)
		Handle = MonoTouch.ObjCRuntime.Messaging.IntPtr_objc_msgSend_RectangleF (this.Handle, initWithFrame, frame);
	else
		Handle = MonoTouch.ObjCRuntime.Messaging.IntPtr_objc_msgSendSuper_RectangleF (this.SuperHandle, initWithFrame, frame);
}
</code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UITableViewCell (System.Drawing.RectangleF frame);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Drawing.RectangleF frame) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("initWithFrame:")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="frame" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="frame">Frame used by the view, expressed in iOS points.</param>
        <summary>Initializes the UITableViewCell with the specified frame.</summary>
        <remarks>
          <para>This constructor is used to programmatically create a new instance of UITableViewCell with the specified dimension in the frame.   The object will only be displayed once it has been added to a view hierarchy by calling AddSubview in a containing view.</para>
          <para>This constructor is not invoked when deserializing objects from storyboards or XIB filesinstead the constructor that takes an NSCoder parameter is invoked.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UITableViewCell (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Pointer (handle) to the unmanaged object.</param>
        <summary>A constructor used when creating managed representations of unmanaged objects;  Called by the runtime.</summary>
        <remarks>
          <para>This constructor is invoked by the runtime infrastructure (<see cref="M:MonoTouch.ObjCRuntime.GetNSObject (System.IntPtr)" />) to create a new managed representation for a pointer to an unmanaged Objective-C object.    You should not invoke this method directly, instead you should call the GetNSObject method as it will prevent two instances of a managed object to point to the same native object.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UITableViewCell (MonoTouch.UIKit.UITableViewCellStyle style, MonoTouch.Foundation.NSString reuseIdentifier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype MonoTouch.UIKit.UITableViewCellStyle style, class MonoTouch.Foundation.NSString reuseIdentifier) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("initWithStyle:reuseIdentifier:")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="style" Type="MonoTouch.UIKit.UITableViewCellStyle" />
        <Parameter Name="reuseIdentifier" Type="MonoTouch.Foundation.NSString" />
      </Parameters>
      <Docs>
        <param name="style">The style to use for this cell.</param>
        <param name="reuseIdentifier">A string used to identify the cell object if it should be reused for mutiple rows in a table view. Pass <see langword="null" /> if the object should not be reused. The same reuse identifier string should be used for all cells that use the same class and layout.<para tool="nullallowed">This parameter can be <see langword="null" />.</para></param>
        <summary>Create a table cell with the given style and reuse identifier.</summary>
        <remarks>
          <para>The reuse identifier is associated with all cells (rows) in a table view that have the same layout (irrespective of their content) and can therefore be used interchangeably. The <see cref="M:MonoTouch.UIKit.UITableViewSource.GetCell(MonoTouch.UIKit.UITableView,MonoTouch.Foundation.NSIndexPath)" /> implementation calls <see cref="M:MonoTouch.UIKit.UITableView.DequeueReusableCell(MonoTouch.Foundation.NSString)" /> with a specific reuse identifier string to obtain a cached cell object with a particular layout to use as the basis for the row being constructed for viewing.</para>
          <para>To produce a layout different to those built-in to <see cref="T:MonoTouch.UIKit.UITableViewCell" />, create a custom cell. To set the row height of each cell differently, implement <see cref="M:MonoTouch.UIKit.UITableViewSource.GetHeightForRow(MonoTouch.UIKit.UITableView,MonoTouch.Foundation.NSIndexPath)" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UITableViewCell (MonoTouch.UIKit.UITableViewCellStyle style, string reuseIdentifier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype MonoTouch.UIKit.UITableViewCellStyle style, string reuseIdentifier) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="style" Type="MonoTouch.UIKit.UITableViewCellStyle" />
        <Parameter Name="reuseIdentifier" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="style">The style to use for this cell.</param>
        <param name="reuseIdentifier">A string used to identify the cell object if it should be reused for mutiple rows in a table view. Pass <see langword="null" /> if the object should not be reused. The same reuse identifier string should be used for all cells that use the same class and layout.</param>
        <summary>Create a table cell with the given style and reuse identifier.</summary>
        <remarks>
          <para>The reuse identifier is associated with all cells (rows) in a table view that have the same layout (irrespective of their content) and can therefore be used interchangeably. The <see cref="M:MonoTouch.UIKit.UITableViewSource.GetCell(MonoTouch.UIKit.UITableView,MonoTouch.Foundation.NSIndexPath)" /> implementation calls <see cref="M:MonoTouch.UIKit.UITableView.DequeueReusableCell(MonoTouch.Foundation.NSString)" /> with a specific reuse identifier string to obtain a cached cell object with a particular layout to use as the basis for the row being constructed for viewing.</para>
          <para>To produce a layout different to those built-in to <see cref="T:MonoTouch.UIKit.UITableViewCell" />, create a custom cell. To set the row height of each cell differently, implement <see cref="M:MonoTouch.UIKit.UITableViewSource.GetHeightForRow(MonoTouch.UIKit.UITableView,MonoTouch.Foundation.NSIndexPath)" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Accessory">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UITableViewCellAccessory Accessory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype MonoTouch.UIKit.UITableViewCellAccessory Accessory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("accessoryType")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setAccessoryType:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UITableViewCellAccessory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The type of standard accessory the cell should use (in its normal state).</summary>
        <value>Default value is <see cref="P:MonoTouch.UIKit.UITableViewCellAccessory.None" />.</value>
        <remarks>
          <para>If specified, the accessory view appears on the right side of a cell. Standard accessory view types include the 'disclosure indicator' right-chevron.</para>
          <para>If the accessory type is <see cref="P:MonoTouch.UIKit.UITableViewCellAccessory.DetailDisclosureButton" /> (and the cell is enabled) then when tapped it will call the <see cref="M:MonoTouch.UIKit.UITableViewSource.AccessoryButtonTapped(MonoTouch.UIKit.UITableView,MonoTouch.Foundation.NSIndexPath)" /> method. This method is seperate to the <see cref="M:MonoTouch.UIKit.UITableViewSource.RowSelected(MonoTouch.UIKit.UITableView,MonoTouch.Foundation.NSIndexPath)" /> method that is called if the rest of the cell is tapped.</para>
          <para>If a custom accessory view is set via <see cref="P:MonoTouch.UIKit.UITableViewCell.AccessoryView" /> then this Accessory property is ignored.</para>
          <para>The accessory image cross-fades between normal and editing states if it is set for both states; use the <see cref="P:MonoTouch.UIKit.UITableViewCell.EditingAccessory" /> property to set the accessory type to be displayed in editing mode. If an accessory is not defined for both states (normal and editing) the the accessory is animated to slide in or out, as required.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessoryView">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIView AccessoryView { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIView AccessoryView" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("accessoryView", MonoTouch.ObjCRuntime.ArgumentSemantic.Retain)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setAccessoryView:", MonoTouch.ObjCRuntime.ArgumentSemantic.Retain)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A view on the right side of a UITableViewCell (normal state).</summary>
        <value>
          <para>
          </para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>
          <para>If this property is not  <see langword="null" /> then the cell uses the given view as the accessory (for the normal state). The value of the <see cref="P:MonoTouch.UIKit.UITableViewCell.Accessory" /> is ignored when AccessoryView is set. The custom accessory view can be a control, a label or a custom view.</para>
          <para>The accessory view cross-fades between normal and editing states if it is set for both states; use the <see cref="P:MonoTouch.UIKit.UITableViewCell.EditingAccessoryView" /> property to set a custom accessory view to be displayed in editing mode. If an accessory is not defined for both states (normal and editing) the the accessory view is animated to slide in or out, as required.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Appearance">
      <MemberSignature Language="C#" Value="public static MonoTouch.UIKit.UITableViewCell.UITableViewCellAppearance Appearance { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.UIKit.UITableViewCell/UITableViewCellAppearance Appearance" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UITableViewCell+UITableViewCellAppearance</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Strongly-typed property that returns the UIAppearance class for this class.</summary>
        <value>
        </value>
        <remarks>Setting any appearance properties on this instance will affect the appearance of all instances of UITableViewCell.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppearanceWhenContainedIn">
      <MemberSignature Language="C#" Value="public static MonoTouch.UIKit.UITableViewCell.UITableViewCellAppearance AppearanceWhenContainedIn (Type[] containers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class MonoTouch.UIKit.UITableViewCell/UITableViewCellAppearance AppearanceWhenContainedIn(class System.Type[] containers) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UITableViewCell+UITableViewCellAppearance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containers" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="containers">List of types that you want to have as the containers to apply this particular appearance</param>
        <summary>Returns a strongly typed UIAppearance for instances of this class when the view is hosted in the specified hierarchy.</summary>
        <returns>The appearance proxy object that you can use to set properties when the given container hierarchy is active</returns>
        <remarks>
          <para>The returned object represents the UIAppearance proxy where you can set appearance properties for instances of UITableViewCell when those instances are contained in the hierarchy specified by the <paramref name="containers" /> parameter.</para>
          <para>The following example shows how the AppearanceWhenContainedIn method works</para>
          <example>
            <code lang="C#">
var mySliders = UISlider.AppearanceWhenContainedIn (typeof (UINavigationBar), typeof (UIPopoverController));
mySliders.TintColor = UIColor.Red;
</code>
          </example>
          <para>For more information, see the documentation for the <see cref="T:MonoTouch.UIKit.UIAppearance" /> class.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundView">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIView BackgroundView { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIView BackgroundView" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("backgroundView", MonoTouch.ObjCRuntime.ArgumentSemantic.Retain)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setBackgroundView:", MonoTouch.ObjCRuntime.ArgumentSemantic.Retain)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>
          <para>(More documentation for this node is coming)</para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClassHandle">
      <MemberSignature Language="C#" Value="public override IntPtr ClassHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ClassHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The handle for this class.</summary>
        <value>The pointer to the Objective-C class.</value>
        <remarks>Each MonoTouch class mirrors an unmanaged Objective-C class.   This value contains the pointer to the Objective-C class, it is similar to calling objc_getClass with the object name.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentView">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIView ContentView { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIView ContentView" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("contentView", MonoTouch.ObjCRuntime.ArgumentSemantic.Retain)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns the content view of the cell object (read-only).</summary>
        <value>
        </value>
        <remarks>This property returns the default superview for content displayed in the cell. To customize cells with additional views, add them to the content view so they will be positioned correctly as the cell transitions in and out of editing mode.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DetailTextLabel">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UILabel DetailTextLabel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UILabel DetailTextLabel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("detailTextLabel", MonoTouch.ObjCRuntime.ArgumentSemantic.Retain)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UILabel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns the secondary label of the table cell (read-only).</summary>
        <value>
        </value>
        <remarks>
          <para>UITableViewCell automatically creates the secondary (detail) label if the cell is created with a <see cref="T:MonoTouch.UIKit.UITableViewCellStyle" /> that supports a detail label.</para>
          <para>If the cell's style doesn't support a detail label, this property returns <see langword="null" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DidTransitionToState">
      <MemberSignature Language="C#" Value="public virtual void DidTransitionToState (MonoTouch.UIKit.UITableViewCellState mask);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DidTransitionToState(valuetype MonoTouch.UIKit.UITableViewCellState mask) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("didTransitionToState:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mask" Type="MonoTouch.UIKit.UITableViewCellState" />
      </Parameters>
      <Docs>
        <param name="mask">A bit mask indicating the state (or combination of states) the cell is transitioning to.</param>
        <summary>Called on the cell just after it transitions between cell states.</summary>
        <remarks>
          <para>UITableViewCell subclasses can implement this method to perform additional animations when it is changing state (such as from a normal state to editing move). This method is called at the end of the animation block to clean up after the state change (such as removing the editing and reordering controls when transitioning from editing to normal mode).</para>
          <para>Subclasses must always call <see langword="base" /> when overriding this method.</para>
          <para>Note that when the user swipes to delete, the cell transitions to the <see cref="P:MonoTouch.UIKit.UITableViewCellState.ShowingDeleteConfirmationMask" /> - but <see cref="P:MonoTouch.UIKit.UITableViewCellState.ShowingEditControlMask" /> is not set. Remember to test for the correct value when handling this case.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <para>If set to <see langword="true" />, the method is invoked directly and will dispose manage and unmanaged resources;   If set to <see langword="false" /> the method is being called by the garbage collector finalizer and should only release unmanaged resources.</para>
        </param>
        <summary>Releases the resources used by the UITableViewCell object.</summary>
        <remarks>
          <para>This Dispose method releases the resources used by the UITableViewCell class.</para>
          <para>This method is called by both the Dispose() method and the object finalizer (Finalize).    When invoked by the Dispose method, the parameter disposing <paramref name="disposing" /> is set to <see langword="true" /> and any managed object references that this object holds are also disposed or released;  when invoked by the object finalizer, on the finalizer thread the value is set to <see langword="false" />. </para>
          <para>Calling the Dispose method when you are finished using the UITableViewCell ensures that all external resources used by this managed object are released as soon as possible.  Once you have invoked the Dispose method, the object is no longer useful and you should no longer make any calls to it.</para>
          <para>  For more information on how to override this method and on the Dispose/IDisposable pattern, read the ``Implementing a Dispose Method'' document at http://msdn.microsoft.com/en-us/library/fs2xkftw.aspx</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Editing">
      <MemberSignature Language="C#" Value="public virtual bool Editing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Editing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("isEditing")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setEditing:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether the cell is in an editable state.</summary>
        <value>
          <see langword="true" /> if the cell is in the editing state, <see langword="false" /> if the cell is in the normal state.</value>
        <remarks>In the editing state, a cell displays the editing controls specified for it: the green insertion control or the red deletion control on the left, and/or the reordering control on the right. Use <see cref="P:MonoTouch.UIKit.UITableViewCell.EditingStyle" /> and <see cref="P:MonoTouch.UIKit.UITableViewCell.ShowsReorderControl" /> to specify which controls appear in the cell.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EditingAccessory">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UITableViewCellAccessory EditingAccessory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype MonoTouch.UIKit.UITableViewCellAccessory EditingAccessory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("editingAccessoryType")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setEditingAccessoryType:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UITableViewCellAccessory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The type of standard accessory the cell should use (in its editing state).</summary>
        <value>Default value is <see cref="P:MonoTouch.UIKit.UITableViewCellAccessory.None" />.</value>
        <remarks>
          <para>If specified, the accessory view appears on the right side of a cell. Standard accessory types include the 'disclosure indicator' right-chevron.</para>
          <para>If the accessory type is <see cref="P:MonoTouch.UIKit.UITableViewCellAccessory.DetailDisclosureButton" /> (and the cell is enabled) then when tapped it will call the <see cref="M:MonoTouch.UIKit.UITableViewSource.AccessoryButtonTapped(MonoTouch.UIKit.UITableView,MonoTouch.Foundation.NSIndexPath)" /> method. This method is seperate to the <see cref="M:MonoTouch.UIKit.UITableViewSource.RowSelected(MonoTouch.UIKit.UITableView,MonoTouch.Foundation.NSIndexPath)" /> method that is called if the rest of the cell is tapped.</para>
          <para>If a custom accessory view is set for the editing state via <see cref="P:MonoTouch.UIKit.UITableViewCell.EditingAccessoryView" /> then this EditingAccessory property is ignored.</para>
          <para>The accessory image cross-fades between normal and editing states if it is set for both states; use the <see cref="P:MonoTouch.UIKit.UITableViewCell.Accessory" /> property to set the accessory type to be displayed in the normal state. If an accessory is not defined for both states (normal and editing) the the accessory is animated to slide in or out, as required.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EditingAccessoryView">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIView EditingAccessoryView { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIView EditingAccessoryView" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("editingAccessoryView", MonoTouch.ObjCRuntime.ArgumentSemantic.Retain)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setEditingAccessoryView:", MonoTouch.ObjCRuntime.ArgumentSemantic.Retain)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A view on the right side of a UITableViewCell (editing state).</summary>
        <value>
          <para>
          </para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>
          <para>If this property is not <see langword="null" /> then the cell uses the given view as the accessory (for the editing state). The value of the <see cref="P:MonoTouch.UIKit.UITableViewCell.EditingAccessory" /> is ignored when EditingAccessoryView is set. The custom accessory view can be a control, a label or a custom view.</para>
          <para>The accessory view cross-fades between normal and editing states if it is set for both states; use the <see cref="P:MonoTouch.UIKit.UITableViewCell.AccessoryView" /> property to set a custom accessory view to be displayed in the normal state. If an accessory is not defined for both states (normal and editing) the the accessory view is animated to slide in or out, as required.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EditingStyle">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UITableViewCellEditingStyle EditingStyle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype MonoTouch.UIKit.UITableViewCellEditingStyle EditingStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("editingStyle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UITableViewCellEditingStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The editing style of the cell (read-only). Returns whether the cell is in an editable state, and if so whether it is showing an insertion or deletion control.</summary>
        <value>The default value is <see cref="P:MonoTouch.UIKit.UITableViewCellEditingStyle.None" /> (the cell is not currently editable).</value>
        <remarks>
          <para>The <see cref="M:MonoTouch.UIKit.UITableViewSource.EditingStyleForRow(MonoTouch.UIKit.UITableView,MonoTouch.Foundation.NSIndexPath)" /> method returns the value for each cell.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAppearance&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static MonoTouch.UIKit.UITableViewCell.UITableViewCellAppearance GetAppearance&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class MonoTouch.UIKit.UITableViewCell/UITableViewCellAppearance GetAppearance&lt;T&gt;() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UITableViewCell+UITableViewCellAppearance</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Highlighted">
      <MemberSignature Language="C#" Value="public virtual bool Highlighted { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Highlighted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("isHighlighted")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setHighlighted:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether the cell is highlighted.</summary>
        <value>Default value is <see langword="false" />.</value>
        <remarks>
          <para>Highlighting affects the appearance of labels, the image and background. When Highlighted is <see langword="true" />, the labels in the cell are drawn in their highlighted text color (which is white by default).</para>
          <para>When this property is set to <see langword="true" />, the transition to the new appearance is not animated. Use the <see cref="M:MonoTouch.UIKit.UITableViewCell.SetHighlighted(System.Boolean,System.Boolean)" /> method for animated highlight-state transitions.</para>
          <para>For highlighting to work properly, set the <see cref="P:MonoTouch.UIKit.UILabel.HighlightedTextColor" /> for the two labels (<see cref="P:MonoTouch.UIKit.UITableViewCell.TextLabel" /> and <see cref="P:MonoTouch.UIKit.UITableViewCell.DetailTextLabel" />), and set the <see cref="P:MonoTouch.UIKit.UImageView.HighlightedImage" /> property on the cell's <see cref="P:MonoTouch.UIKit.UITableViewCell.ImageView" />. </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ImageView">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIImageView ImageView { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIImageView ImageView" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("imageView", MonoTouch.ObjCRuntime.ArgumentSemantic.Retain)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIImageView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns the image view of the table cell (read-only).</summary>
        <value>
        </value>
        <remarks>The image appears on the left hand side of the cell, forcing the labels to move to the right. The image view object is created when the cell is created but initially there is no image set.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndentationLevel">
      <MemberSignature Language="C#" Value="public virtual int IndentationLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 IndentationLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("indentationLevel")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setIndentationLevel:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sets the indentation level of a cell, shifting the position of the cell's content.</summary>
        <value>Default value is zero (no indentation).</value>
        <remarks>The width of each level of indentation is determined by <see cref="P:MonoTouch.UIKit.UITableViewCell.IndentationWidth" /> property.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndentationWidth">
      <MemberSignature Language="C#" Value="public virtual float IndentationWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float32 IndentationWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("indentationWidth")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setIndentationWidth:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The width of each the indentation level.</summary>
        <value>Default indentation is 10 points.</value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MultipleSelectionBackgroundView">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIView MultipleSelectionBackgroundView { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIView MultipleSelectionBackgroundView" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(5, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("multipleSelectionBackgroundView")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setMultipleSelectionBackgroundView:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The background view used when a cell is selected inside a table view that allows multiple selection.</summary>
        <value>
          <para>
          </para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>If this property is not <see langword="null" />, it is used as the background view for any selected cells (when the containing table view allows mutiple selection). Mulitple selection is set on a <see cref="T:MonoTouch.UIKit.UITableView" /> using the <see cref="P:MonoTouch.UIKit.UITableView.AllowsMultipleSelection" /> and <see cref="P:MonoTouch.UIKit.UITableView.AllowsMultipleSelectionDuringEditing" /> properties.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PrepareForReuse">
      <MemberSignature Language="C#" Value="public virtual void PrepareForReuse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PrepareForReuse() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("prepareForReuse")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Prepares a cell for reuse by the table view's <see cref="T:MonoTouch.UIKit.UITableViewSource" />.</summary>
        <remarks>
          <para>If a <see cref="T:MonoTouch.UIKit.UITableView" /> is reusable - it has a ReuseIdentifier - this method is called just before the object is returned by <see cref="M:MonoTouch.UIKit.UITableView.DequeueReusableCell(System.String)" />. This method implementation should reset cell attributes that are not content-related, such as alpha, editing, and selection state. The <see cref="M:MonoTouch.UIKit.UITableViewSource.GetCell(MonoTouch.UIKit.UITableView,MonoTouch.Foundation.NSIndexPath)" /> should always reset the content when reusing a cell.</para>
          <para>Subclasses must always call <see langword="base" /> when overriding this method.</para>
          <para>If the cell object does not have a <see cref="P:MonoTouch.UIKit.UITableViewCell.ReuseIdentifier" />, this method is not called.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReuseIdentifier">
      <MemberSignature Language="C#" Value="public virtual string ReuseIdentifier { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ReuseIdentifier" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("reuseIdentifier", MonoTouch.ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A string that identifies a cell object so that it can be reused.</summary>
        <value>
        </value>
        <remarks>
          <para>The ReuseIdentifier is set in the cell's constructor and cannot be changed. When cells disappear from view, the <see cref="T:MonoTouch.UIKit.UITableView" /> object maintains a queue of those cell objects so they can be reused. The <see cref="M:MonoTouch.UIKit.UITableViewSource.GetCell(MonoTouch.UIKit.UITableView,MonoTouch.Foundation.NSIndexPath)" /> implementation then uses <see cref="M:MonoTouch.UIKit.UITableView.DequeueReusableCell(System.String)" /> with a given ReuseIdentifier to retrieve an existing cell of the correct type for reuse.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Selected">
      <MemberSignature Language="C#" Value="public virtual bool Selected { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Selected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("isSelected")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setSelected:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether the cell is selected.</summary>
        <value>Default value is <see langword="false" />.</value>
        <remarks>
          <para>Selection affects the appearance of labels, image and background. When the Selected property is set to <see langword="true" />, the labels are drawn in white and the background is set to the <see cref="P:MonoTouch.UIKit.UITableViewCell.SelectedBackgroundView" /> (if set).</para>
          <para>When this property is set to <see langword="true" />, the transition to the new appearance is not animated. Use the <see cref="M:MonoTouch.UIKit.UITableViewCell.SetSelected(System.Boolean,System.Boolean)" /> method for animated selection-state transitions.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectedBackgroundView">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIView SelectedBackgroundView { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIView SelectedBackgroundView" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("selectedBackgroundView", MonoTouch.ObjCRuntime.ArgumentSemantic.Retain)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setSelectedBackgroundView:", MonoTouch.ObjCRuntime.ArgumentSemantic.Retain)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The view that is used as the cell's background when it is selected.</summary>
        <value>Default is <see langword="null" /> for Plain tables and non-<see langword="null" /> for Grouped style tables.</value>
        <remarks>
          <para>
            <see cref="T:MonoTouch.UIKit.UITableView" /> adds the value of this proerty as a subview only when the cell is selected. It is added as a subview directly above the <see cref="P:MonoTouch.UIKit.UITableView.BackgroundView" /> if that is not <see langword="null" />, otherwise behind all other views.</para>
          <para>If <see cref="P:MonoTouch.UIKit.UITableViewCell.SetSelected(System.Boolean,System.Boolean)" /> is called, this view is animated in and out with an alpha fade.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionStyle">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UITableViewCellSelectionStyle SelectionStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype MonoTouch.UIKit.UITableViewCellSelectionStyle SelectionStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("selectionStyle")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setSelectionStyle:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UITableViewCellSelectionStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The selection style for a cell.</summary>
        <value>Default value is <see cref="P:MonoTouch.UIKit.UITableViewCellSelectionStyle.Blue" />.</value>
        <remarks>The selection style determines the color of a cell when it is selected.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetEditing">
      <MemberSignature Language="C#" Value="public virtual void SetEditing (bool editing, bool animated);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetEditing(bool editing, bool animated) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setEditing:animated:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="editing" Type="System.Boolean" />
        <Parameter Name="animated" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="editing">
          <see langword="true" /> to enter editing mode, <see langword="false" /> to leave it.</param>
        <param name="animated">
          <see langword="true" /> to animate the appearance/disappearance of the editing controls, <see langword="false" /> to immediately show/hide the controls.</param>
        <summary>Toggles the cell in and out of editing mode.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetHighlighted">
      <MemberSignature Language="C#" Value="public virtual void SetHighlighted (bool highlighted, bool animated);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetHighlighted(bool highlighted, bool animated) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setHighlighted:animated:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="highlighted" Type="System.Boolean" />
        <Parameter Name="animated" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="highlighted">
          <see langword="true" /> to highlight the cell, <see langword="false" /> to unhighlight.</param>
        <param name="animated">
          <see langword="true" /> to animate the highlight transition, <see langword="false" /> to make the transition immediate.</param>
        <summary>Sets the highlighted state of the cell, optionally animating the transition between states.</summary>
        <remarks>
          <para>Highlights or unhighlights the cell, animating the transition if <paramref name="animated" /> is <see langword="true" />. Highlighting changes the appearance of the cell's labels, image, and background.</para>
          <para>For highlighting to work properly, set the <see cref="P:MonoTouch.UIKit.UILabel.HighlightedTextColor" /> for the two labels (<see cref="P:MonoTouch.UIKit.UITableViewCell.TextLabel" /> and <see cref="P:MonoTouch.UIKit.UITableViewCell.DetailTextLabel" />), and set the <see cref="P:MonoTouch.UIKit.UImageView.HighlightedImage" /> property on the cell's <see cref="P:MonoTouch.UIKit.UITableViewCell.ImageView" />. </para>
          <para>Custom cells can override this method to make additional changes when transitioning between states.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSelected">
      <MemberSignature Language="C#" Value="public virtual void SetSelected (bool selected, bool animated);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetSelected(bool selected, bool animated) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setSelected:animated:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="selected" Type="System.Boolean" />
        <Parameter Name="animated" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="selected">
          <see langword="true" /> to select the cell, <see langword="false" /> to deselect.</param>
        <param name="animated">
          <see langword="true" /> to animate the selected transition, <see langword="false" /> to make the transition immediate.</param>
        <summary>Sets the selected state of the cell, optionally animating the transition between the states.</summary>
        <remarks>Selection changes the the appearance of the cell's labels, image, and background.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldIndentWhileEditing">
      <MemberSignature Language="C#" Value="public virtual bool ShouldIndentWhileEditing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShouldIndentWhileEditing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("shouldIndentWhileEditing")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setShouldIndentWhileEditing:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether the cell background is indented while in editing mode.</summary>
        <value>Default value is <see langword="true" />.</value>
        <remarks>
          <para>This property is not related to <see cref="P:MonoTouch.UIKit.UITableViewCell.IndentationLevel" />.</para>
          <para>This value can be overridden in <see cref="M:MonoTouch.UIKit.UITableViewSource.ShouldIndentWhileEditing(MonoTouch.UIKit.UITableView,MonoTouch.Foundation.NSIndexPath)" />.</para>
          <para>Only Grouped style table views are affected by this property, Plain table views ignore it.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowingDeleteConfirmation">
      <MemberSignature Language="C#" Value="public virtual bool ShowingDeleteConfirmation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowingDeleteConfirmation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("showingDeleteConfirmation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setShowingDeleteConfirmation:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether the delete confirmation button is currently showing in the cell (read-only).</summary>
        <value>Default value is <see langword="false" />.</value>
        <remarks>
          <para>When the deletion control (red cirle to the left of the cell) is showing and is tapped, the cell displays a Delete button on the right side of the cell (which is when this method returns <see langword="true" />).</para>
          <para>The text displayed in the Delete button is localized.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowsReorderControl">
      <MemberSignature Language="C#" Value="public virtual bool ShowsReorderControl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowsReorderControl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("showsReorderControl")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setShowsReorderControl:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether the reordering control is currently showing in the cell (read-only).</summary>
        <value>Default value is <see langword="false" />.</value>
        <remarks>
          <para>The reordering control consists of three grey, horizontal lines on the right side of the cell. Dragging this control causes the entire cell to be moved to another position in the table.</para>
          <para>The reordering control only appears if this property is set and the <see cref="M:MonoTouch.UIKit.UITableViewSource.MoveRow(MonoTouch.UIKit.UITableView,MonoTouch.Foundation.NSIndexPath,MonoTouch.Foundation.NSIndexPath)" /> method has been implemented on the <see cref="T:MonoTouch.UIKit.UITableViewSource" />. The reordering control can be selectively hidden on specific rows by returning <see langword="false" /> from <see cref="M:MonoTouch.UIKit.UITableViewSource.CanMoveRow(MonoTouch.UIKit.UITableView,MonoTouch.Foundation.NSIndexPath)" /></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextLabel">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UILabel TextLabel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UILabel TextLabel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("textLabel", MonoTouch.ObjCRuntime.ArgumentSemantic.Retain)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UILabel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns the label that displays the main text content in the cell (read-only).</summary>
        <value>
        </value>
        <remarks>
          <see cref="T:MonoTouch.UIKit.UITableViewCell" /> creates the label control when the cell is constructed in with a style that supports it.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WillTransitionToState">
      <MemberSignature Language="C#" Value="public virtual void WillTransitionToState (MonoTouch.UIKit.UITableViewCellState mask);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WillTransitionToState(valuetype MonoTouch.UIKit.UITableViewCellState mask) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("willTransitionToState:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mask" Type="MonoTouch.UIKit.UITableViewCellState" />
      </Parameters>
      <Docs>
        <param name="mask">A bit mask indicating the state/s the cell is transitioning to.</param>
        <summary>Called on the cell just before it transitions between states.</summary>
        <remarks>
          <para>UITableViewCell subclasses can implement this method to perform additional animations when it is changing state (such as from a normal state to editing move). A custom cell may create any new views that are required in the new state. <see cref="M:MonoTouch.UIKit.UIView.LayoutSubviews()" /> is then called which allows the code to position these new elements in their correct locations for the new state.</para>
          <para>Subclasses must always call <see langword="base" /> when overriding this method.</para>
          <para>Note that when the user swipes to delete, the cell transitions to the <see cref="P:MonoTouch.UIKit.UITableViewCellState.ShowingDeleteConfirmationMask" /> - but <see cref="P:MonoTouch.UIKit.UITableViewCellState.ShowingEditControlMask" /> is not set. Remember to test for the correct value when handling this case.</para>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
