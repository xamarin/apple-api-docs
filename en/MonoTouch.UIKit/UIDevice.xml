<Type Name="UIDevice" FullName="MonoTouch.UIKit.UIDevice">
  <TypeSignature Language="C#" Value="public class UIDevice : MonoTouch.Foundation.NSObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit UIDevice extends MonoTouch.Foundation.NSObject" />
  <AssemblyInfo apistyle="old">
    <AssemblyName>monotouch</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo apistyle="new">
    <AssemblyName>Xamarin.iOS</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>MonoTouch.Foundation.NSObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>MonoTouch.Foundation.Register("UIDevice", true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>MonoTouch.ObjCRuntime.Since(3, 2)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Device information, provided by the <see cref="P:MonoTouch.UIKit.UIDevice.CurrentDevice" /> singleton.</summary>
    <remarks>
      <para>Application developers must use the <see cref="P:MonoTouch.UIKit.UIDevice.CurrentDevice" /> singleton to get information on the current hardware platform. </para>
      <para tool="threads">The members of this class can be used from a background thread.</para>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIDevice ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("init")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Default constructor that initializes a new instance of this class with no parameters.</summary>
        <remarks>
          <para>
          </para>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIDevice (MonoTouch.Foundation.NSCoder coder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class MonoTouch.Foundation.NSCoder coder) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("initWithCoder:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="coder" Type="MonoTouch.Foundation.NSCoder" />
      </Parameters>
      <Docs>
        <param name="coder">The unarchiver object.</param>
        <summary>A constructor that initializes the object from the data stored in the unarchiver object.</summary>
        <remarks>
          <para>This constructor is provided to allow the class to be initialized from an unarchiver (for example, during NIB deserialization).</para>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIDevice (MonoTouch.Foundation.NSObjectFlag t);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class MonoTouch.Foundation.NSObjectFlag t) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="t" Type="MonoTouch.Foundation.NSObjectFlag" />
      </Parameters>
      <Docs>
        <param name="t">Unused sentinel value, pass NSObjectFlag.Empty.</param>
        <summary>Constructor to call on derived classes to skip initialization and merely allocate the object.</summary>
        <remarks>
          <para>This constructor should be called by derived classes when they completely construct the object in managed code and merely want the runtime to allocate and initialize the NSObject.   This is required to implement the two-step initialization process that Objective-C uses, the first step is to perform the object allocation, the second step is to initialize the object.   When you invoke the constructor that takes the NSObjectFlag.Empty you taking advantage of a direct path that goes all the way up to NSObject to merely allocate the object's memory and bind the Objective-C and C# objects together.    The actual initialization of the object is up to you.</para>
          <para>This constructor is typically used by the binding generator to allocate the object, but prevent the actual initialization to take place.   Once the allocation has taken place, the constructor has to initialize the object.   With constructors generated by the binding generator this means that it manually invokes one of the "init" methods to initialize the object.</para>
          <para>It is your responsibility to completely initialize the object if you chain up using the NSObjectFlag.Empty path.</para>
          <para>In general, if your constructors invokes the NSObjectFlag.Empty base implementation, then it should be calling an Objective-C init method.   If this is not the case, you should instead chain to the proper constructor in your class. </para>
          <para>The argument value is ignored and merely ensures that the only code that is executed is the construction phase is the basic NSObject allocation and runtime type registration.  Typically the chaining would look like this:</para>
          <example>
            <code lang="C#">
//
// The NSObjectFlag merely allocates the object and registers the
// C# class with the Objective-C runtime if necessary, but no actual
// initXxx method is invoked, that is done later in the constructor
//
// This is taken from MonoTouch's source code:
//
[Export ("initWithFrame:")]
public UIView (System.Drawing.RectangleF frame) : base (NSObjectFlag.Empty)
{
// Invoke the init method now.
	var initWithFrame = new Selector ("initWithFrame:").Handle;
	if (IsDirectBinding)
		Handle = MonoTouch.ObjCRuntime.Messaging.IntPtr_objc_msgSend_RectangleF (this.Handle, initWithFrame, frame);
	else
		Handle = MonoTouch.ObjCRuntime.Messaging.IntPtr_objc_msgSendSuper_RectangleF (this.SuperHandle, initWithFrame, frame);
}
</code>
          </example>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIDevice (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Pointer (handle) to the unmanaged object.</param>
        <summary>A constructor used when creating managed representations of unmanaged objects;  Called by the runtime.</summary>
        <remarks>
          <para>This constructor is invoked by the runtime infrastructure (<see cref="M:MonoTouch.ObjCRuntime.GetNSObject (System.IntPtr)" />) to create a new managed representation for a pointer to an unmanaged Objective-C object.    You should not invoke this method directly, instead you should call the GetNSObject method as it will prevent two instances of a managed object to point to the same native object.</para>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BatteryLevel">
      <MemberSignature Language="C#" Value="public virtual float BatteryLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float32 BatteryLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("batteryLevel")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Battery level indicator.</summary>
        <value>Battery percentage in the range [0..1] if battery monitoring is enabled, otherwise -1.</value>
        <remarks>
          <para>By default, <see cref="P:MonoTouch.UIKit.UIDevice.BatteryMonitoringEnabled" /> is <see langword="false" />. In that situation, <see cref="P:MonoTouch.UIKit.UIDevice.BatteryLevel" /> will be -1 (and <see cref="P:MonoTouch.UIKit.UIDevice.BatteryState" /> will be <see cref="P:MonoTouch.UIKit.UIDeviceBatteryState.Unknown" />).</para>
          <para>A value of 1.0 indicates a fully-charged device, while 0.0 indicates an empty battery.</para>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BatteryLevelDidChangeNotification">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString BatteryLevelDidChangeNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString BatteryLevelDidChangeNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIDeviceBatteryLevelDidChangeNotification", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for BatteryLevelDidChange</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:MonoTouch.Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIDevice+Notifications" />.<see cref="M:UIDevice+Notifications.ObserveBatteryLevelDidChangeNotification" /> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="c#">
//
// Lambda style
//

// listening
notification = UIDevice.Notifications.ObserveBatteryLevelDidChange ((sender, args) =&gt; {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, MonoTouch.Foundation.NSNotificationEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UIDevice.Notifications.ObserveBatteryLevelDidChange (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}</code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="c#">
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIDevice.BatteryLevelDidChangeNotification, (notification) =&gt; {Console.WriteLine ("Received the notification UIDevice", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIDevice", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIDevice.BatteryLevelDidChangeNotification, Callback);
}
</code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BatteryMonitoringEnabled">
      <MemberSignature Language="C#" Value="public virtual bool BatteryMonitoringEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BatteryMonitoringEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("isBatteryMonitoringEnabled")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setBatteryMonitoringEnabled:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Controls battery monitoring.   When set, you can receive battery level change events.</summary>
        <value>The default value is <see langword="false" />.</value>
        <remarks>
          <para>When set to the default value of <see langword="false" />, applications cannot read the <see cref="P:MonoTouch.UIKit.UIDevice.BatteryLevel" />, <see cref="P:MonoTouch.UIKit.UIDevice.BatteryState" />, or receive battery-state change notifications (<see cref="P:MonoTouch.UIKit.UIDevice.BatteryStateDidChangeNotification" />). </para>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BatteryState">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIDeviceBatteryState BatteryState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype MonoTouch.UIKit.UIDeviceBatteryState BatteryState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("batteryState")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIDeviceBatteryState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Current battery state if monitoring is enabled.</summary>
        <value>Battery state if battery monitoring is enabled, otherwise <see cref="P:MonoTouch.UIKit.UIDeviceBatteryState.Unknown" />.</value>
        <remarks>
          <para>By default, <see cref="P:MonoTouch.UIKit.UIDevice.BatteryMonitoringEnabled" /> is <see langword="false" />. In that situation, <see cref="P:MonoTouch.UIKit.UIDevice.BatteryState" /> will be <see cref="P:MonoTouch.UIKit.UIDeviceBatteryState.Unknown" /> (and <see cref="P:MonoTouch.UIKit.UIDevice.BatteryLevel" /> will be -1).</para>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BatteryStateDidChangeNotification">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString BatteryStateDidChangeNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString BatteryStateDidChangeNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIDeviceBatteryStateDidChangeNotification", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for BatteryStateDidChange</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:MonoTouch.Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIDevice+Notifications" />.<see cref="M:UIDevice+Notifications.ObserveBatteryStateDidChangeNotification" /> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="c#">
//
// Lambda style
//

// listening
notification = UIDevice.Notifications.ObserveBatteryStateDidChange ((sender, args) =&gt; {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, MonoTouch.Foundation.NSNotificationEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UIDevice.Notifications.ObserveBatteryStateDidChange (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}</code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="c#">
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIDevice.BatteryStateDidChangeNotification, (notification) =&gt; {Console.WriteLine ("Received the notification UIDevice", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIDevice", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIDevice.BatteryStateDidChangeNotification, Callback);
}
</code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginGeneratingDeviceOrientationNotifications">
      <MemberSignature Language="C#" Value="public virtual void BeginGeneratingDeviceOrientationNotifications ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginGeneratingDeviceOrientationNotifications() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("beginGeneratingDeviceOrientationNotifications")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Initiates posting device orientation notification events.</summary>
        <remarks>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckSystemVersion">
      <MemberSignature Language="C#" Value="public bool CheckSystemVersion (int major, int minor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CheckSystemVersion(int32 major, int32 minor) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="major" Type="System.Int32" />
        <Parameter Name="minor" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="major">To be added.</param>
        <param name="minor">To be added.</param>
        <summary>Whether the system version is greater than or equal to the specified major and minor values.</summary>
        <returns>
          <see langword="true" /> if the current system version is equal or greater than that specified in the arguments.</returns>
        <remarks>
          <para>This method returns <see langword="true" /> if the current version on the device is equal or greater than the version specified by <paramref name="major" /> and <paramref name="minor" />.</para>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClassHandle">
      <MemberSignature Language="C#" Value="public override IntPtr ClassHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ClassHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The handle for this class.</summary>
        <value>The pointer to the Objective-C class.</value>
        <remarks>
          <para>Each MonoTouch class mirrors an unmanaged Objective-C class.   This value contains the pointer to the Objective-C class, it is similar to calling objc_getClass with the object name.</para>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentDevice">
      <MemberSignature Language="C#" Value="public static MonoTouch.UIKit.UIDevice CurrentDevice { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.UIKit.UIDevice CurrentDevice" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("currentDevice")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIDevice</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns the UIDevice singleton instance.</summary>
        <value />
        <remarks>
          <para>Developers typically use property like this:</para>
          <example>
            <code lang="C#"><![CDATA[
 var device = UIDevice.CurrentDevice;
 Console.WriteLine (device.BatteryLevel);
  ]]></code>
          </example>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <para>If set to <see langword="true" />, the method is invoked directly and will dispose manage and unmanaged resources;   If set to <see langword="false" /> the method is being called by the garbage collector finalizer and should only release unmanaged resources.</para>
        </param>
        <summary>Releases the resources used by the UIDevice object.</summary>
        <remarks>
          <para>This Dispose method releases the resources used by the UIDevice class.</para>
          <para>This method is called by both the Dispose() method and the object finalizer (Finalize).    When invoked by the Dispose method, the parameter disposing <paramref name="disposing" /> is set to <see langword="true" /> and any managed object references that this object holds are also disposed or released;  when invoked by the object finalizer, on the finalizer thread the value is set to <see langword="false" />. </para>
          <para>Calling the Dispose method when you are finished using the UIDevice ensures that all external resources used by this managed object are released as soon as possible.  Once you have invoked the Dispose method, the object is no longer useful and you should no longer make any calls to it.</para>
          <para>  For more information on how to override this method and on the Dispose/IDisposable pattern, read the ``Implementing a Dispose Method'' document at http://msdn.microsoft.com/en-us/library/fs2xkftw.aspx</para>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndGeneratingDeviceOrientationNotifications">
      <MemberSignature Language="C#" Value="public virtual void EndGeneratingDeviceOrientationNotifications ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndGeneratingDeviceOrientationNotifications() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("endGeneratingDeviceOrientationNotifications")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stops posting device orientation notification events. </summary>
        <remarks>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GeneratesDeviceOrientationNotifications">
      <MemberSignature Language="C#" Value="public virtual bool GeneratesDeviceOrientationNotifications { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool GeneratesDeviceOrientationNotifications" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("isGeneratingDeviceOrientationNotifications")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determines whether device orientation notifications are posted.</summary>
        <value>The default value is based on the device hardware.</value>
        <remarks>
          <para>Note that if the hardware supports orientation notifications, this value will be <see langword="true" /> even if the user has locked the display orientation of the device. 
          </para>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IdentifierForVendor">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.Foundation.NSUuid IdentifierForVendor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.Foundation.NSUuid IdentifierForVendor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("identifierForVendor", MonoTouch.ObjCRuntime.ArgumentSemantic.Strong)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSUuid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An identifier, unique to the device, based on the App Store vendor or, if not from the App Store, the bundle identifier.</summary>
        <value>To be added.</value>
        <remarks>
          <para>This identifier is the same for a particular device for all apps that come from the same vendor. This identifier is not the same across devices.</para>
          <para>If the app does not come from the App Store, the "vendor" of the device is calculated based on the bundle ID. In iOS 7 and later, the "vendor" is based on all elements of the bundle ID except the last component. In other words, if the bundle ID is <c>com.mycompany.mydivision.app1</c>, the "vendor" will be calculated as <c>com.mycompany.mydivision</c>. On iOS 6 and previous, the "vendor" is calculated from the first two components, so a bundle ID of <c>com.mycompany.mydivision.app1</c> would base the vendor on <c>com.mycompany</c>.</para>
          <para>The <see cref="M:MonoTouch.UIKit.Foundation.NSUuid.AsString()" /> method is often used to extract the actual identification, as shown in the following example:</para>
          <example>
            <code lang="C#"><![CDATA[
var nsUid = UIDevice.CurrentDevice.IdentifierForVendor;
var guidElements = nsUid.AsString();
Console.WriteLine("ToString() : {0}\nAsString() : {1}", nsUid, guidElements);
/*
ToString() : <__NSConcreteUUID 0x79ef50> 959E8282-D65E-486C-B1D3-17D720CF668E
AsString() : 959E8282-D65E-486C-B1D3-17D720CF668E
*/              
              ]]></code>
          </example>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMultitaskingSupported">
      <MemberSignature Language="C#" Value="public bool IsMultitaskingSupported { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMultitaskingSupported" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(4, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determines whether this version of iOS supports multitasking.</summary>
        <value>Determined by the hardware.</value>
        <remarks>
          <para>Unlike the Objective-C version of this method, there is no need to probe whether the operating system supports this selector.   The MonoTouch binding takes care of this automatically.   On older versions of iOS this returns false, in newer versions of iOS, this probes the operating to determine if multi-tasking capabilities are supported.</para>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalizedModel">
      <MemberSignature Language="C#" Value="public virtual string LocalizedModel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LocalizedModel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("localizedModel", MonoTouch.ObjCRuntime.ArgumentSemantic.Strong)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A localized string describing the current iOS device.</summary>
        <value />
        <remarks>
          <para>Use this property to display the name of the device in the current user selected locale.</para>
          <para>Note that this property is quite generic (e.g., "iPhone", "iPad")</para>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
        <altmember cref="P:MonoTouch.UIDevice.Model" />
        <altmember cref="P:MonoTouch.UIDevice.SystemName" />
        <altmember cref="P:MonoTouch.UIDevice.SystemVersion" />
      </Docs>
    </Member>
    <Member MemberName="Model">
      <MemberSignature Language="C#" Value="public virtual string Model { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Model" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("model", MonoTouch.ObjCRuntime.ArgumentSemantic.Strong)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The device model, in English.</summary>
        <value>To be added.</value>
        <remarks>
          <para>Note that this property is quite generic (e.g., "iPhone", "iPad")</para>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
        <altmember cref="P:MonoTouch.UIKit.UIDevice.LocalizedModel" />
        <altmember cref="P:MonoTouch.UIKit.UIDevice.SystemName" />
        <altmember cref="P:MonoTouch.UIKit.UIDevice.SystemVersion" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public virtual string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("name", MonoTouch.ObjCRuntime.ArgumentSemantic.Strong)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The device name set by the user.</summary>
        <value>Set by the user in Settings/General/Name</value>
        <remarks>
          <para>This is the device name set by the user in Settings/General/Name. Since it can be changed by the users, application developers should prefer the use of <see cref="P:MonoTouch.UIKit.UIDevice.IdentifierForVendor" /> as a long-lasting device identifier.</para>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
        <altmember cref="P:MonoTouch.UIKit.UIDevice.IdentifierForVendor" />
        <altmember cref="P:MonoTouch.UIKit.UIDevice.SystemName" />
        <altmember cref="P:MonoTouch.UIKit.UIDevice.Model" />
      </Docs>
    </Member>
    <Member MemberName="Orientation">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIDeviceOrientation Orientation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype MonoTouch.UIKit.UIDeviceOrientation Orientation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("orientation")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIDeviceOrientation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Current device orientation.</summary>
        <value />
        <remarks>
          <para>
          </para>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OrientationDidChangeNotification">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString OrientationDidChangeNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString OrientationDidChangeNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIDeviceOrientationDidChangeNotification", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for OrientationDidChange</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:MonoTouch.Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIDevice+Notifications" />.<see cref="M:UIDevice+Notifications.ObserveOrientationDidChangeNotification" /> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="c#">
//
// Lambda style
//

// listening
notification = UIDevice.Notifications.ObserveOrientationDidChange ((sender, args) =&gt; {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, MonoTouch.Foundation.NSNotificationEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UIDevice.Notifications.ObserveOrientationDidChange (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}</code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="c#">
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIDevice.OrientationDidChangeNotification, (notification) =&gt; {Console.WriteLine ("Received the notification UIDevice", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIDevice", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIDevice.OrientationDidChangeNotification, Callback);
}
</code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PlayInputClick">
      <MemberSignature Language="C#" Value="public virtual void PlayInputClick ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PlayInputClick() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("playInputClick")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(4, 2)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Plays the system "click" event in response to user taps.</summary>
        <remarks>
          <para>This method plays the standard system "keyboard click" sound when a user taps an input view or keyboard accessory view, with certain restrictions:</para>
          <list type="bullet">
            <item>
              <term>The user has enabled "Keyboard Clicks" in Settings / Sounds</term>
            </item>
            <item>
              <term>The <see cref="T:MonoTouch.UIKit.UIView" /> being tapped implements <see cref="T:MonoTouch.UIKit.IUIInputViewAudioFeedback" /> and overrides <see cref="M:MonoTouch.UIKit.IUIInputViewAudioFeedback.EnableInputClicksWhenVisible" /> to return <see langword="true" />.</term>
            </item>
          </list>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProximityMonitoringEnabled">
      <MemberSignature Language="C#" Value="public virtual bool ProximityMonitoringEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ProximityMonitoringEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("isProximityMonitoringEnabled")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setProximityMonitoringEnabled:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether the proximity sensor is available and enabled.</summary>
        <value>The default value is <see langword="false" />.</value>
        <remarks>
          <para>Application developers who wish to monitor proximity should set this property to <see langword="true" /> and then confirm that it has changed. On devices that do not support proximity warning, the setter will execute without raising an exception, but the value will remain <see langword="false" />. </para>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProximityState">
      <MemberSignature Language="C#" Value="public virtual bool ProximityState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ProximityState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("proximityState")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determines whether the device is close to the user.</summary>
        <value>
          <see langword="true" /> if the device is close to the user.</value>
        <remarks>
          <para>The proximity sensor is a device that detects when the device is being held close to the head. (It works by detecting infrared light being reflected back into the device.)</para>
          <para>This property represents the current state of the proximity sensor, returning <see langword="true" /> when the device is close to the user (for instance, when held to the ear during a phone call).</para>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProximityStateDidChangeNotification">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString ProximityStateDidChangeNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString ProximityStateDidChangeNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIDeviceProximityStateDidChangeNotification", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for ProximityStateDidChange</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:MonoTouch.Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIDevice+Notifications" />.<see cref="M:UIDevice+Notifications.ObserveProximityStateDidChangeNotification" /> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="c#">
//
// Lambda style
//

// listening
notification = UIDevice.Notifications.ObserveProximityStateDidChange ((sender, args) =&gt; {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, MonoTouch.Foundation.NSNotificationEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UIDevice.Notifications.ObserveProximityStateDidChange (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}</code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="c#">
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIDevice.ProximityStateDidChangeNotification, (notification) =&gt; {Console.WriteLine ("Received the notification UIDevice", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIDevice", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIDevice.ProximityStateDidChangeNotification, Callback);
}
</code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SystemName">
      <MemberSignature Language="C#" Value="public virtual string SystemName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SystemName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("systemName", MonoTouch.ObjCRuntime.ArgumentSemantic.Strong)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Operating system name on the device.</summary>
        <value>A value such as "iPhone OS".</value>
        <remarks>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SystemVersion">
      <MemberSignature Language="C#" Value="public virtual string SystemVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SystemVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("systemVersion", MonoTouch.ObjCRuntime.ArgumentSemantic.Strong)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Operating system version.</summary>
        <value>The current operating system version.</value>
        <remarks>
          <para>Application developers must not assume that this string can be directly parsed into a floating point number, since iOS versioning often involves multiple delimiters, such as with "7.0.4". </para>
          <para>Application developers can use <see cref="M:MonoTouch.UIKit.UIDevice.CheckSystemVersion" /> to ensure that the current operating system is equal to or exceeds a particular major/minor release.</para>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UniqueIdentifier">
      <MemberSignature Language="C#" Value="public virtual string UniqueIdentifier { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UniqueIdentifier" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Deprecated in iOS 5.0. Apple now reject application using it the selector is removed and an empty string is returned")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>This method is deprecated and returns an empty string. Use <see cref="P:MonoTouch.UIKit.UIDevice.IdentifierForVendor" />.</summary>
        <value>An empty string.</value>
        <remarks>
          <para>In early version of iOS, this method returned the device's unique device identifier. Now, it returns an empty string. Application developers should instead rely on <see cref="P:MonoTouch.UIKit.UIDevice.IdentifierForVendor" />.</para>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserInterfaceIdiom">
      <MemberSignature Language="C#" Value="public MonoTouch.UIKit.UIUserInterfaceIdiom UserInterfaceIdiom { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype MonoTouch.UIKit.UIUserInterfaceIdiom UserInterfaceIdiom" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIUserInterfaceIdiom</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Which kind of device the application is running (iPhone or iPad).</summary>
        <value>
        </value>
        <remarks>
          <para>Unlike the Objective-C version of this method, there is no need to probe whether the operating system supports this selector.   The MonoTouch binding takes care of this automatically.   When running on older versions of iOS this returns UIUserInterfaceIdiom.Phon, in newer versions of iOS, this probes the operating system to return the proper idiom.</para>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
