<?xml version="1.0" encoding="utf-8"?>
<Type Name="UITableView" FullName="MonoTouch.UIKit.UITableView">
  <TypeSignature Language="C#" Value="public class UITableView : MonoTouch.UIKit.UIScrollView" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit UITableView extends MonoTouch.UIKit.UIScrollView" />
  <AssemblyInfo>
    <AssemblyName>monotouch</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>MonoTouch.UIKit.UIScrollView</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>MonoTouch.Foundation.Register("UITableView", true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>A table view is used to display and edit hierarchical lists of information. A UITableView is limited to a single column because it is designed for a small screen.</summary>
    <remarks>
      <para>
        <see cref="T:MonoTouch.UIKit.UITableView" /> is a subclass of <see cref="T:MonoTouch.UIKit.UIScrollView" /> that allows users to scroll the table vertically (the closely-related <see cref="T:MonoTouch.UIKit.UICollectionView" /> class allows for horizontal scrolling and complex two-dimensional layouts). The table consists of <see cref="T:MonoTouch.UIKit.UITableViewCell" /> objects that are used to render the rows of the table. These cells have content -- labels, images, etc. -- and can also show accessories such as disclosure arrows or inputs controls. <see cref="T:MonoTouch.UIKit.UITableView" />s can enter an edit-mode in which rows can be inserted, deleted, and reordered.
      </para>
      <para>
        The Xamarin article <format type="text/html"><a href="http://docs.xamarin.com/guides/ios/user_interface/tables">Working with Tables</a></format> provides guidance on all aspects of <see cref="T:MonoTouch.UIKit.UITableView" /> use. 
      </para>
      <para>For most use-cases, it is not necessary for application developers to subclass <see cref="T:MonoTouch.UIKit.UITableView" /> or <see cref="T:MonoTouch.UIKit.UITableViewController" />, which provide the generic table behavior. Instead, application developers will generally subclass <see cref="T:MonoTouch.UIKit.UITableViewSource" /> to populate a table and, often, <see cref="T:MonoTouch.UIKit.UITableViewCell" /> to customize appearance and row behavior.</para>
      <format type="text/html">
        <h2>Table Parts and Functionality</h2>
      </format>
      <format type="text/html">
        <h3>Classes Overview</h3>
      </format>
      <para>The primary classes used to display table views are:</para>
      <para>
        <img href="UIKit.UITableView.Classes.png" />
      </para>
      <list type="table">
        <listheader>
          <term>Class</term>
          <description>Responsibility</description>
        </listheader>
        <item>
          <term>
            <see cref="T:MonoTouch.UIKit.UITableView" />
          </term>
          <description>
            A view that contains a collection of cells inside a scrolling container. The table view typically uses the entire screen in an iPhone app but may exist as part of a larger view on the iPad (or appear in a popover).  
          </description>
        </item>
        <item>
          <term>
            <see cref="T:MonoTouch.UIKit.UITableViewCell" />
          </term>
          <description>
            A view that represents a single cell (or row) in a table view. There are four built-in cell types and it is possible to create custom cells both in C# or with Interface Builder.
          </description>
        </item>
        <item>
          <term>
            <see cref="T:MonoTouch.UIKit.UITableViewSource" />
          </term>
          <description>
            Xamarin.iOS-exclusive abstract class that provides all the methods required to display a table, including row count, returning a cell view for each row, handling row selection and many other optional features. You must subclass this to get a <see cref="T:MonoTouch.UIKit.UITableView" /> working. (<see cref="T:MonoTouch.UIKit.UITableViewSource" /> combines <see cref="T:MonoTouch.UIKit.UITableViewDataSource" /> and <see cref="T:MonoTouch.UIKit.UITableViewDelegate" />. These classes are still available if the application developer chooses not to use <see cref="T:MonoTouch.UIKit.UITableViewSource" />.)
          </description>
        </item>
        <item>
          <term>
            <see cref="T:MonoTouch.Foundation.NSIndexPath" />
          </term>
          <description>
            Contains Row and Section properties that uniquely identify the position of a cell in a table.</description>
        </item>
        <item>
          <term>
            <see cref="T:MonoTouch.UIKit.UITableViewController" />
          </term>
          <description>
            A ready-to-use <see cref="T:MonoTouch.UIKit.UIViewController" /> that has a <see cref="T:MonoTouch.UIKit.UITableView" /> hardcoded as its view and made accessible via the <see cref="P:MonoTouch.UIKit.UITableViewController.TableView" /> property. </description>
        </item>
        <item>
          <term>
            <see cref="T:MonoTouch.UIKit.UIViewController" />
          </term>
          <description>
            If the table does not occupy the entire screen you can add a <see cref="T:MonoTouch.UIKit.UITableView" /> to any <see cref="T:MonoTouch.UIKit.UIViewController" /> with its <see cref="P:MonoTouch.UIKit.UIView.Frame" /> property set appropriately.</description>
        </item>
      </list>
      <format type="text/html">
        <h3>Components of a UITableView</h3>
      </format>
      <para>There are two <see cref="T:MonoTouch.UIKit.UITableViewStyle" /> styles: Plain and Grouped. The Plain style allows the section headers and footers to remain visible as the section is scrolled through, and can optionally support an index that appears along the right edge to quickly scroll to a specific section. The Grouped style displays sections in rounded-rectangles that visually group the rows, and provides a default background image behind the scrolling list. The style of the <see cref="T:MonoTouch.UIKit.UITableView" /> is specified as an argument to the <see cref="C:MonoTouch.UIKit.UITableView(System.Drawing.RectangleF, UITableViewStyle)" /> constructor and cannot be changed.  Grouped tables should not provide an index.</para>
      <para>Tables consist of the following parts:</para>
      <list type="table">
        <listheader>
          <term>Element</term>
          <description>Accessed via:</description>
          <description>Type</description>
        </listheader>
        <item>
          <term>Table Header</term>
          <description>
            <see cref="P:MonoTouch.UIKit.UITableView.TableHeaderView" />
          </description>
          <description>
            <see cref="T:MonoTouch.UIKit.UIView" />
          </description>
        </item>
        <item>
          <term>Section Header</term>
          <description>
            <see cref="M:MonoTouch.UIKit.UITableViewSource.GetViewForHeader" />
          </description>
          <description>
            <see cref="T:MonoTouch.UIKit.UITableViewHeaderFooterView" />
          </description>
        </item>
        <item>
          <term>Cells (also called Rows)</term>
          <description>
            <see cref="M:MonoTouch.UIKit.UITableViewSource.GetCell" />
          </description>
          <description>
            <see cref="T:MonoTouch.UIKit.UITableViewCell" />
          </description>
        </item>
        <item>
          <term>Section Footer</term>
          <description>
            <see cref="M:MonoTouch.UIKit.UITableViewSource.GetViewForFooter" />
          </description>
          <description>
            <see cref="T:MonoTouch.UIKit.UITableViewHeaderFooterView" />
          </description>
        </item>
        <item>
          <term>Index</term>
          <description>
            <see cref="M:MonoTouch.UIKit.UITableViewSource.SectionIndexTitles" />
          </description>
          <description>
            <see langword="string" />
            <c>[]</c>
          </description>
        </item>
        <item>
          <term>Edit mode (includes ‘swipe to delete’ and drag handles to change row order)</term>
          <description />
          <description />
        </item>
        <item>
          <term>Table Footer</term>
          <description>
            <see cref="P:MonoTouch.UIKit.UITableView.TableFooterView" />
          </description>
          <description>
            <see cref="T:MonoTouch.UIKit.UIView" />
          </description>
        </item>
      </list>
      <para>Section rows, headers, footers, edit controls and the index are displayed as follows:</para>
      <para>
        <img href="UIKit.UITableView.Components.png" />
      </para>
      <format type="text/html">
        <h2>Populating Table Cells</h2>
      </format>
      <para>
        <see cref="T:MonoTouch.UIKit.UITableView" />s are designed to work efficiently with tables with thousands of rows. In order to achieve this, each <see cref="T:MonoTouch.UIKit.UITableView" /> maintains a reusable cache of <see cref="T:MonoTouch.UIKit.UITableViewCell" />s only a few items larger than can be shown on the screen at any given time.
      </para>
      <para>A <see cref="T:MonoTouch.UIKit.UITableViewSource" /> object is responsible for managing the relationship between the relatively few <see cref="T:MonoTouch.UIKit.UITableViewCell" />s and the data is to be displayed. The <see cref="T:MonoTouch.UIKit.UITableViewSource" />'s <see cref="M:MonoTouch.UIKit.UITableViewSource.NumberOfSections" /> and <see cref="M:MonoTouch.UIKit.UITableViewSource.RowsInSection" /> methods allow the <see cref="T:MonoTouch.UIKit.UITableView" /> to request only the data necessary for the cells on the screen. A specific cell is identified by an <see cref="T:MonoTouch.Foundation.NSIndexPath" />, whose <see cref="P:MonoTouch.Foundation.NSIndexPath.Section" /> and <see cref="P:MonoTouch.Foundation.NSIndexPath.Row" />properties will specify a unique cell.</para>
      <para>As cells are about to be scrolled onto the screen, the <see cref="T:MonoTouch.UIKit.UITableView" /> automatically calls the <see cref="M:MonoTouch.UIKit.UITableViewSource.GetCell" /> method of the <see cref="T:MonoTouch.UIKit.UITableViewSource" /> object assigned to the <see cref="P:MonoTouch.UIKit.UITableView.Source" /> property of the <see cref="T:MonoTouch.UIKit.UITableView" /> (or, if the application developer prefers, the <see cref="M:MonoTouch.UIKit.UITableViewDataSource.GetRow" /> method of the <see cref="T:MonoTouch.UIKit.UITableViewDataSource" /> object referred to by the <see cref="P:MonoTouch.UIKit.UITableView.DataSource" /> property). </para>
      <para>The application developer's responsibilities when overriding <see cref="M:MonoTouch.UIKit.UITableViewSource.GetCell" /> changed with the introduction of iOS 6. Application developers targeting iOS 6 and later should register a <see cref="T:MonoTouch.UIKit.UITableViewCell" /> for reuse with the <see cref="T:MonoTouch.UIKit.UITableView" /> by calling either the <see cref="M:MonoTouch.UIKit.UITableView.RegisterClassForCellReuse" /> or <see cref="M:MonoTouch.UIKit.UITableView.RegisterNibForCellReuse" /> method. Once that is done, application developers do not need to check for null in their override of the <see cref="M:MonoTouch.UIKit.UITableViewSource.GetCell" /> method.</para>
      <para>If application developers are using the <see cref="M:MonoTouch.UIKit.UITableView.RegisterClassForCellReuse" /> with their own subclass of <see cref="T:MonoTouch.UIKit.UITableViewCell" />, that implementation must override the <see cref="C:MonoTouch.UIKit.UITableViewCell(IntPtr)" /> constructor and call the base constructor (i.e., <c>MyTableViewCell(IntPtr handle) : base(handle){}</c>).</para>
      <para>The application developer overrides the <see cref="M:MonoTouch.UIKit.UITableViewSource.GetCell" /> method so that it:</para>
      <list type="bullet">
        <item>
          <term>Attempts to retrieve a previously-allocated <see cref="T:MonoTouch.UIKit.UITableViewCell" /> from the <see cref="T:MonoTouch.UIKit.UITableView" />;</term>
        </item>
        <item>
          <term>If programming in iOS 5 and earlier, if that fails, initializes a new <see cref="T:MonoTouch.UIKit.UITableViewCell" /> of the appropriate type;</term>
        </item>
        <item>
          <term>Change the state of the retrieved-or-created <see cref="T:MonoTouch.UIKit.UITableViewCell" /> so that it reflects the values appropriate for the passed-in <see cref="T:MonoTouch.Foundation.NSIndexPath" />.
          </term>
        </item>
      </list>
      <para>Since the <see cref="M:MonoTouch.UIKit.UITableViewSource.GetCell" /> method will be called whenever a cell comes into view, application developers should avoid unnecessary computation.</para>
      <para>The <see cref="T:MonoTouch.UIKit.UITableView" />'s reuse queue is accessed via the <see cref="M:MonoTouch.UIKit.UITableView.DequeueReusableCell" /> method, which takes a <see langword="string" /> identifying the type of <see cref="T:MonoTouch.UIKit.UITableViewCell" /> to retrieve. In iOS 5 and earlier, that method may return <see langword="null" />, in which case the application developer should instantiate a new <see cref="T:MonoTouch.UIKit.UITableViewCell" />. In iOS 6 and later, while initializing the <see cref="T:MonoTouch.UIKit.UITableView" />, the application developer must use either <see cref="M:MonoTouch.UIKit.UITableView.RegisterClassForCellReuse" /> or <see cref="M:MonoTouch.UIKit.UITableView.RegisterNibForCellReuse" /> to associate a <see cref="T:MonoTouch.UIKit.UITableViewCell" /> type and it's reuse identifier so that the method <see cref="M:MonoTouch.UIKit.UITableViewSource.GetCell" /> can instantiate instances as necessary.</para>
      <para>The following shows a simple example of the <see cref="M:MonoTouch.UIKit.UITableViewSource.GetCell" /> method:</para>
      <example>
        <code lang="C#"><![CDATA[
          public override UITableViewCell GetCell (UITableView tableView, NSIndexPath indexPath)
          {
          //Attempt to retrieve previously-allocated cell
          var cell = tableView.DequeueReusableCell (this.cellTypeIdentifier);
          //The following check and code-block only necessary in applications that do not use RegisterClassforCellReuse or RegisterNibForCellReuse
          if (cell == null) {
          //No reusable cell, so initialize a new one
          cell = new UITableViewCell (UITableViewCellStyle.Default, this.cellTypeIdentifier);
          cell.Tag = Environment.TickCount;
          }
          
          // Change the state of the cell
          cell.TextLabel.Text = //...etc...
          
          // return the cell
          return cell;
          }
          ]]></code>
      </example>
      <format type="text/html">
        <h2>Customizing Table Appearance</h2>
      </format>
      <para>Other than the <see cref="P:MonoTouch.UIKit.UITableView.Style" /> property that specifies whether a <see cref="T:MonoTouch.UIKit.UITableView" /> is grouped or continuous, the appearance of the table is primarily determined by the <see cref="T:MonoTouch.UIKit.UITableViewCell" />s, the <see cref="T:MonoTouch.UIKit.UITableViewHeaderFooterView" />s used for section headers and footers, and the <see cref="T:MonoTouch.UIKit.UIView" />s used for the <see cref="P:MonoTouch.UIKit.UITableView.Header" /> and <see cref="P:MonoTouch.UIKit.UITableView.Footer" /> properties. The API documentation for <see cref="T:MonoTouch.UIKit.UITableViewCell" /> describes customization in detail. </para>
      <format type="text/html">
        <h2>Highlighting and Selection</h2>
      </format>
      <para>Selecting and highlighting in a <see cref="T:MonoTouch.UIKit.UITableView" /> follows this sequence:</para>
      <list type="table">
        <listheader>
          <!-- listheader bolds this row -->
          <term>User Action</term>
          <description>UITableViewDelegate (UITableViewSource) Methods</description>
          <description>UITableViewCell Properties</description>
        </listheader>
        <item>
          <term>Nothing touched</term>
          <description />
          <description>
            <c>Highlighted == <see langword="false" />; Selected == <see langword="false" /></c>
          </description>
        </item>
        <item>
          <term>Finger down in cell</term>
          <description>
            <see cref="M:MonoTouch.UIKit.UITableViewDelegate.ShouldHighlightRow" /> is called. If it returns <see langword="false" />, processing stops. 
          </description>
          <description />
        </item>
        <item>
          <term />
          <description>
            <see cref="M:MonoTouch.UIKit.UITableViewSource.RowHighlighted" /> is called.
          </description>
          <description>
            <c>Highlighted == <see langword="true" />; Selected == <see langword="false" /></c>
          </description>
        </item>
        <item>
          <term>Finger up</term>
          <description>
            <see cref="M:MonoTouch.UIKit.UITableViewDelegate.WillSelectRow" /> is called. If it returns <see langword="null" />, processing stops. Otherwise, whatever <see cref="T:MonoTouch.Foundation.NSIndexPath" /> it returns will be highlighted.
          </description>
          <description />
        </item>
        <item>
          <term />
          <description>
            <see cref="M:MonoTouch.UIKit.UITableViewDelegate.RowSelected" /> is called. <see cref="M:MonoTouch.UIKit.UITableViewDelegate.RowUnhighlighted" /> is called.
            
          </description>
          <description>
            <c>Highlighted == <see langword="false" />; Selected == <see langword="true" /></c>
          </description>
        </item>
      </list>
      <para>
        <img href="MonoTouch.UIKit.UITableView.HighlightAndSelect.png" />
      </para>
      <para>Deselecting a <see cref="T:MonoTouch.UIKit.UITableViewCell" /> follows a similar sequence:</para>
      <list type="table">
        <listheader>
          <!-- listheader bolds this row -->
          <term>User Action</term>
          <description>UITableViewDelegate (UITableViewSource) Methods</description>
          <description>UITableViewCell Properties</description>
        </listheader>
        <item>
          <term>Nothing touched while some <see cref="T:MonoTouch.UIKit.UITableViewCell" /> is highlighted.</term>
          <description />
          <description>
            <c>Highlighted == <see langword="false" />; Selected == <see langword="true" /></c>
          </description>
        </item>
        <item>
          <term>Finger taps cell (Deselect gesture)</term>
          <description>
            <see cref="M:MonoTouch.UIKit.UITableViewDelegate.WillDeselectRow" /> is called. If it returns <see langword="null" />, processing stops. Otherwise, whatever <see cref="T:MonoTouch.Foundation.NSIndexPath" /> is returned will be deselected. 
          </description>
          <description />
        </item>
        <item>
          <term />
          <description>
            <see cref="M:MonoTouch.UIKit.UITableViewDelegate.RowDeselected" /> is called.
          </description>
          <description>
            <c>Highlighted == <see langword="false" />; Selected == <see langword="false" /></c>
          </description>
        </item>
      </list>
      <block subset="none" type="note">
        <para>UITableView caches <see cref="T:MonoTouch.UIKit.UITableViewCell" /> objects only for visible rows, but caches the heights of rows, headers and footers for the entire table. It is possible to create custom <see cref="T:MonoTouch.UIKit.UITableViewCell" /> objects with varying heights and custom layouts.</para>
        <para>UITableView overrides <see cref="M:MonoTouch.UIKit.UIView.LayoutSubviews()" /> so that it calls <see cref="M:MonoTouch.UIKit.UITableView.ReloadData" /> only when you create a new instance or when you assign a new <see cref="P:MonoTouch.UIKit.UITableView.Source" /> (or <see cref="P:MonoTouch.UIKit.UITableView.DataSource" />).Reloading the table view clears current state (including the current selection). However if you explicitly call <see cref="M:MonoTouch.UIKit.UITableView.ReloadData()" /> it clears this state and any subsequent direct or indirect call to <see cref="M:MonoTouch.UIKit.UIView.LayoutSubviews()" /> does not trigger a reload.</para>
      </block>
    </remarks>
    <altmember cref="T:MonoTouch.UIKit.UICollectionView" />
    <related type="article" href="http://docs.xamarin.com/guides/ios/user_interface/tables">Working with Tables and Cells</related>
    <related type="recipe" href="http://docs.xamarin.com/recipes/ios/content_controls/tables">Tables and UITableViewController</related>
    <related type="sample" href="http://docs.xamarin.com/samples/ByGuid?guid=bacb96ca-e31b-4a41-a363-a716ad982b39">Tables and Lists</related>
    <related type="sample" href="http://samples.xamarin.com/Samples/ByGuid?guid=8325839c-471c-4409-8d96-caefe8a95d4a">Example_Data</related>
    <related type="sample" href="http://samples.xamarin.com/Samples/ByGuid?guid=23a2571b-45eb-4889-bb67-d88937cb68c1">monocatalog</related>
    <related type="sample" href="http://samples.xamarin.com/Samples/ByGuid?guid=a96da854-7c59-4e25-9fb5-78be262620dd">RecipesAndPrinting</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UITableView ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("init")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Default constructor that initializes a new instance of this class with no parameters.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UITableView (MonoTouch.Foundation.NSCoder coder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class MonoTouch.Foundation.NSCoder coder) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("initWithCoder:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="coder" Type="MonoTouch.Foundation.NSCoder" />
      </Parameters>
      <Docs>
        <param name="coder">The unarchiver object.</param>
        <summary>A constructor that initializes the object from the data stored in the unarchiver object.</summary>
        <remarks>This constructor is provided to allow the class to be initialized from an unarchiver (for example, during NIB deserialization).</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UITableView (MonoTouch.Foundation.NSObjectFlag t);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class MonoTouch.Foundation.NSObjectFlag t) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="t" Type="MonoTouch.Foundation.NSObjectFlag" />
      </Parameters>
      <Docs>
        <param name="t">Unused sentinel value, pass NSObjectFlag.Empty.</param>
        <summary>Constructor to call on derived classes to skip initialization and merely allocate the object.</summary>
        <remarks>
          <para>This constructor should be called by derived classes when they completely construct the object in managed code and merely want the runtime to allocate and initialize the NSObject.   This is required to implement the two-step initialization process that Objective-C uses, the first step is to perform the object allocation, the second step is to initialize the object.   When you invoke the constructor that takes the NSObjectFlag.Empty you taking advantage of a direct path that goes all the way up to NSObject to merely allocate the object's memory and bind the Objective-C and C# objects together.    The actual initialization of the object is up to you.</para>
          <para>This constructor is typically used by the binding generator to allocate the object, but prevent the actual initialization to take place.   Once the allocation has taken place, the constructor has to initialize the object.   With constructors generated by the binding generator this means that it manually invokes one of the "init" methods to initialize the object.</para>
          <para>It is your responsibility to completely initialize the object if you chain up using the NSObjectFlag.Empty path.</para>
          <para>In general, if your constructors invokes the NSObjectFlag.Empty base implementation, then it should be calling an Objective-C init method.   If this is not the case, you should instead chain to the proper constructor in your class. </para>
          <para>The argument value is ignored and merely ensures that the only code that is executed is the construction phase is the basic NSObject allocation and runtime type registration.  Typically the chaining would look like this:</para>
          <example>
            <code lang="C#">
//
// The NSObjectFlag merely allocates the object and registers the
// C# class with the Objective-C runtime if necessary, but no actual
// initXxx method is invoked, that is done later in the constructor
//
// This is taken from MonoTouch's source code:
//
[Export ("initWithFrame:")]
public UIView (System.Drawing.RectangleF frame) : base (NSObjectFlag.Empty)
{
// Invoke the init method now.
	var initWithFrame = new Selector ("initWithFrame:").Handle;
	if (IsDirectBinding)
		Handle = MonoTouch.ObjCRuntime.Messaging.IntPtr_objc_msgSend_RectangleF (this.Handle, initWithFrame, frame);
	else
		Handle = MonoTouch.ObjCRuntime.Messaging.IntPtr_objc_msgSendSuper_RectangleF (this.SuperHandle, initWithFrame, frame);
}
</code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UITableView (System.Drawing.RectangleF frame);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Drawing.RectangleF frame) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("initWithFrame:")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="frame" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="frame">Frame used by the view, expressed in iOS points.</param>
        <summary>Initializes the UITableView with the specified frame.</summary>
        <remarks>
          <para>This constructor is used to programmatically create a new instance of UITableView with the specified dimension in the frame.   The object will only be displayed once it has been added to a view hierarchy by calling AddSubview in a containing view.</para>
          <para>This constructor is not invoked when deserializing objects from storyboards or XIB filesinstead the constructor that takes an NSCoder parameter is invoked.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UITableView (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Pointer (handle) to the unmanaged object.</param>
        <summary>A constructor used when creating managed representations of unmanaged objects;  Called by the runtime.</summary>
        <remarks>
          <para>This constructor is invoked by the runtime infrastructure (<see cref="M:MonoTouch.ObjCRuntime.GetNSObject (System.IntPtr)" />) to create a new managed representation for a pointer to an unmanaged Objective-C object.    You should not invoke this method directly, instead you should call the GetNSObject method as it will prevent two instances of a managed object to point to the same native object.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UITableView (System.Drawing.RectangleF frame, MonoTouch.UIKit.UITableViewStyle style);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Drawing.RectangleF frame, valuetype MonoTouch.UIKit.UITableViewStyle style) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("initWithFrame:style:")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="frame" Type="System.Drawing.RectangleF" />
        <Parameter Name="style" Type="MonoTouch.UIKit.UITableViewStyle" />
      </Parameters>
      <Docs>
        <param name="frame">A rectangle specifying the initial location and size of the table view.</param>
        <param name="style">
          <see cref="T:MonoTouch.UIKit.UITableViewStyle" />: Plain or Grouped.</param>
        <summary>Creates a table view with the given <see cref="P:MonoTouch.UIKit.UITableView.Frame" /> and <see cref="T:MonoTouch.UIKit.UITableViewStyle" />.</summary>
        <remarks>You must specify the style of a table when you create it. You cannot change a table view's style. If you use the <see cref="C:MonoTouch.UIKit.UITableView(System.Drawing.RectangleF)" /> constructor, the Plain style is used by default.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowsMultipleSelection">
      <MemberSignature Language="C#" Value="public virtual bool AllowsMultipleSelection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowsMultipleSelection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(5, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("allowsMultipleSelection")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(5, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setAllowsMultipleSelection:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.ObjCRuntime.Since(5, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether more than one row can be selected (outside of editing mode).</summary>
        <value>
          <see langword="false" /> if multiple selection is prohibited, <see langword="true" /> if it is allowed.</value>
        <remarks>
          <para>When this property is <see langword="true" />, a check mark is placed next to each row that is tapped. Tapping the row again removes the check mark.</para>
          <para>Call <see cref="M:MonoTouch.UIKit.UITableView.IndexPathsForSelectedRows" /> to identify the selected rows.</para>
          <para>The default value of this property is <see langword="false" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowsMultipleSelectionDuringEditing">
      <MemberSignature Language="C#" Value="public virtual bool AllowsMultipleSelectionDuringEditing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowsMultipleSelectionDuringEditing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(5, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("allowsMultipleSelectionDuringEditing")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(5, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setAllowsMultipleSelectionDuringEditing:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.ObjCRuntime.Since(5, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether more than one row can be selected while in editing mode.</summary>
        <value>
          <see langword="false" /> if multiple selection is prohibited, <see langword="true" /> if it is allowed.</value>
        <remarks>
          <para>When this property is <see langword="true" />, a check mark is placed next to each row that is tapped. Tapping the row again removes the check mark. In addition, the UITableView does not query for editing styles when it goes into editing mode.</para>
          <para>Call <see cref="M:MonoTouch.UIKit.UITableView.IndexPathsForSelectedRows" /> to identify the selected rows.</para>
          <para>The default value of this property is <see langword="false" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowsSelection">
      <MemberSignature Language="C#" Value="public virtual bool AllowsSelection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowsSelection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("allowsSelection")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setAllowsSelection:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether a row can be selected.</summary>
        <value>
          <see langword="true" /> if row selection is allowed, <see langword="false" /> if not.</value>
        <remarks>If <see langword="true" /> (the default) then row selection is allowed. This property only affects cell selection when the table view is not in editing mode. To control selection in edting mode, use <see cref="P:MonoTouch.UIKit.UITableView.AllowsSelectionDuringEditing" />.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowsSelectionDuringEditing">
      <MemberSignature Language="C#" Value="public virtual bool AllowsSelectionDuringEditing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowsSelectionDuringEditing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("allowsSelectionDuringEditing")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setAllowsSelectionDuringEditing:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether a row can be selected while in editing mode.</summary>
        <value>
          <see langword="true" /> if row selection is allowed, <see langword="false" /> if not. The default is <see langword="false" />.</value>
        <remarks>If <see langword="true" /> then row selection is allowed during editing. This property only affects cell selection when the table view is in editing mode. To control selection in normal mode, use <see cref="P:MonoTouch.UIKit.UITableView.AllowsSelection" />.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Appearance">
      <MemberSignature Language="C#" Value="public static MonoTouch.UIKit.UITableView.UITableViewAppearance Appearance { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.UIKit.UITableView/UITableViewAppearance Appearance" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UITableView+UITableViewAppearance</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Strongly-typed property that returns the UIAppearance class for this class.</summary>
        <value>
        </value>
        <remarks>Setting any appearance properties on this instance will affect the appearance of all instances of UITableView.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppearanceWhenContainedIn">
      <MemberSignature Language="C#" Value="public static MonoTouch.UIKit.UITableView.UITableViewAppearance AppearanceWhenContainedIn (Type[] containers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class MonoTouch.UIKit.UITableView/UITableViewAppearance AppearanceWhenContainedIn(class System.Type[] containers) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UITableView+UITableViewAppearance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containers" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="containers">List of types that you want to have as the containers to apply this particular appearance</param>
        <summary>Returns a strongly typed UIAppearance for instances of this class when the view is hosted in the specified hierarchy.</summary>
        <returns>The appearance proxy object that you can use to set properties when the given container hierarchy is active</returns>
        <remarks>
          <para>The returned object represents the UIAppearance proxy where you can set appearance properties for instances of UITableView when those instances are contained in the hierarchy specified by the <paramref name="containers" /> parameter.</para>
          <para>The following example shows how the AppearanceWhenContainedIn method works</para>
          <example>
            <code lang="C#">
var mySliders = UISlider.AppearanceWhenContainedIn (typeof (UINavigationBar), typeof (UIPopoverController));
mySliders.TintColor = UIColor.Red;
</code>
          </example>
          <para>For more information, see the documentation for the <see cref="T:MonoTouch.UIKit.UIAppearance" /> class.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutomaticDimension">
      <MemberSignature Language="C#" Value="public static float AutomaticDimension { get; }" />
      <MemberSignature Language="ILAsm" Value=".property float32 AutomaticDimension" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UITableViewAutomaticDimension", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(5, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(5, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UITableViewAutomaticDimension</summary>
        <value>
        </value>
        <remarks>Return this value from <see cref="T:MonoTouch.UIKit.UITableViewSource" /> (or <see cref="T:MonoTouch.UIKit.UITableViewDelegate" />) methods that request dimension metrics when you want the UITableView to use a default value. For example, return this constant from <see cref="M:MonoTouch.UIKit.UITableViewSource.GetHeightForHeader" /> or <see cref="M:MonoTouch.UIKit.UITableViewSource.GetHeightForFooter" /> and the table view will use automatically use a height that accomodates the value returned from <see cref="M:MonoTouch.UIKit.UITableViewSource.TitleForHeader" /> or <see cref="M:MonoTouch.UIKit.UITableViewSource.TitleForFooter" /> respectively.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundView">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIView BackgroundView { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIView BackgroundView" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(3, 2)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("backgroundView")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(3, 2)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setBackgroundView:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.ObjCRuntime.Since(3, 2)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The background view of the table.</summary>
        <value>A <see cref="T:MonoTouch.UIKit.UIView" /><para tool="nullallowed">This value can be <see langword="null" />.</para></value>
        <remarks>A table view's background view is automatically resized to match the size of the table view. The background view is placed as a subview of the table behind all cell, header and footer views.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginUpdates">
      <MemberSignature Language="C#" Value="public virtual void BeginUpdates ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginUpdates() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("beginUpdates")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Call this method before inserting, updating or selecting rows that you wish to animate as one operation. <see cref="M:MonoTouch.UIKit.UITableView.EndUpdates" /> must be called after the modifications are complete.</summary>
        <remarks>
          <para>After calling this method, subsequent insertions, deletions and selection operations (eg. <see cref="M:MonoTouch.UIKit.UITableView.IndexPathsForVisibleRows" /> or <see cref="M:MonoTouch.UIKit.UITableView.CellAt" />) will be animated simultaneously. This group of methods must conclude with a call to <see cref="M:MonoTouch.UIKit.UITableView.EndUpdates" />. These method pairs can be nested.</para>
          <para>If you do not make the insertion, deletion and selection calls inside this block, table attributes such as row count might become invalid. Do not call <see cref="M:MonoTouch.UIKit.UITableView.ReloadData" /> within the group, otherwise you will need to perform any animations manually.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CellAt">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UITableViewCell CellAt (MonoTouch.Foundation.NSIndexPath ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class MonoTouch.UIKit.UITableViewCell CellAt(class MonoTouch.Foundation.NSIndexPath ns) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("cellForRowAtIndexPath:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UITableViewCell</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ns" Type="MonoTouch.Foundation.NSIndexPath" />
      </Parameters>
      <Docs>
        <param name="ns">An <see cref="T:MonoTouch.Foundation.NSIndexPath" /> that references a row in the table view.</param>
        <summary>Returns the table cell at the specified index path.</summary>
        <returns>A <see cref="T:MonoTouch.UIKit.UITableViewCell" /> object that represents a row in the table, or <see langword="null" /> if the row is not visible or the <see cref="T:MonoTouch.Foundation.NSIndexPath" /> is out of range.</returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClassHandle">
      <MemberSignature Language="C#" Value="public override IntPtr ClassHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ClassHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The handle for this class.</summary>
        <value>The pointer to the Objective-C class.</value>
        <remarks>Each MonoTouch class mirrors an unmanaged Objective-C class.   This value contains the pointer to the Objective-C class, it is similar to calling objc_getClass with the object name.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataSource">
      <MemberSignature Language="C#" Value="public MonoTouch.UIKit.UITableViewDataSource DataSource { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UITableViewDataSource DataSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UITableViewDataSource</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The object that acts as the data source for the table view.</summary>
        <value>
          <para>
          </para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>
          <para>The data source must subclass <see cref="T:MonoTouch.UIKit.UITableViewDataSource" />. MonoTouch provides an alternative to implementing both <see cref="T:MonoTouch.UIKit.UITableViewDataSource" /> and <see cref="T:MonoTouch.UIKit.UITableViewDelegate" />: the <see cref="T:MonoTouch.UIKit.UITableViewSource" /> class which should be assigned to <see cref="P:MonoTouch.UIKit.UITableView.Source" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Delegate">
      <MemberSignature Language="C#" Value="public MonoTouch.UIKit.UITableViewDelegate Delegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UITableViewDelegate Delegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UITableViewDelegate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An instance of the MonoTouch.UIKit.UITableViewDelegate model class which acts as the class delegate.</summary>
        <value>
          <para>The instance of the MonoTouch.UIKit.UITableViewDelegate model class</para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>
          <para>The delegate instance assigned to this object will be used to handle events or provide data on demand to this class.</para>
          <para>When setting the Delegate or WeakDelegate values events will be delivered to the specified instance instead of being delivered to the C#-style events</para>
          <para>This is the strongly typed version of the object, use the WeakDelegate property instead if you want to merely assign a class derived from NSObject that has been decorated with [Export] attributes.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteRows">
      <MemberSignature Language="C#" Value="public virtual void DeleteRows (MonoTouch.Foundation.NSIndexPath[] atIndexPaths, MonoTouch.UIKit.UITableViewRowAnimation withRowAnimation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DeleteRows(class MonoTouch.Foundation.NSIndexPath[] atIndexPaths, valuetype MonoTouch.UIKit.UITableViewRowAnimation withRowAnimation) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("deleteRowsAtIndexPaths:withRowAnimation:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="atIndexPaths" Type="MonoTouch.Foundation.NSIndexPath[]" />
        <Parameter Name="withRowAnimation" Type="MonoTouch.UIKit.UITableViewRowAnimation" />
      </Parameters>
      <Docs>
        <param name="atIndexPaths">Array of <see cref="T:MonoTouch.Foundation.NSIndexPath" /> objects that identify which rows to delete.</param>
        <param name="withRowAnimation">What type of animation to use when deleting the rows (eg. fade out or slide out from bottom). </param>
        <summary>Delete the rows referenced in the <paramref name="atIndexPaths" /> array. The deletion can optionally be animated.</summary>
        <remarks>
          <para>When this method is called inside an animation block defined by <see cref="M:MonoTouch.UIKit.UITableView.BeginUpdates" /> and <see cref="M:MonoTouch.UIKit.UITableView.EndUpdates" />, any insertions of rows or sections are deferred until after deletions have been processed. This happens regardless of the ordering of the insertion and deletion method calls within the animation block.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteSections">
      <MemberSignature Language="C#" Value="public virtual void DeleteSections (MonoTouch.Foundation.NSIndexSet sections, MonoTouch.UIKit.UITableViewRowAnimation withRowAnimation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DeleteSections(class MonoTouch.Foundation.NSIndexSet sections, valuetype MonoTouch.UIKit.UITableViewRowAnimation withRowAnimation) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("deleteSections:withRowAnimation:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sections" Type="MonoTouch.Foundation.NSIndexSet" />
        <Parameter Name="withRowAnimation" Type="MonoTouch.UIKit.UITableViewRowAnimation" />
      </Parameters>
      <Docs>
        <param name="sections">A set of section identifiers to delete. If a section exists after one that is deleted, it is moved up one index location.</param>
        <param name="withRowAnimation">What type of animation to use when deleting the rows (eg. fade out or slide out from bottom).</param>
        <summary>Deletes a section (or sections) from a table view, with an option to animate the operation.</summary>
        <remarks>
          <para>When this method is called inside an animation block defined by <see cref="M:MonoTouch.UIKit.UITableView.BeginUpdates" /> and <see cref="M:MonoTouch.UIKit.UITableView.EndUpdates" />, any insertions of rows or sections are deferred until after deletions have been processed. This happens regardless of the ordering of the insertion and deletion method calls within the animation block.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DequeueReusableCell">
      <MemberSignature Language="C#" Value="public MonoTouch.UIKit.UITableViewCell DequeueReusableCell (MonoTouch.Foundation.NSString identifier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class MonoTouch.UIKit.UITableViewCell DequeueReusableCell(class MonoTouch.Foundation.NSString identifier) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UITableViewCell</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identifier" Type="MonoTouch.Foundation.NSString" />
      </Parameters>
      <Docs>
        <param name="identifier">A string identifying the cell type being requested.</param>
        <summary>Returns a reusable table view cell that was created with the given ReuseIdentifier.</summary>
        <returns>A <see cref="T:MonoTouch.UIKit.UITableViewCell" /> associated with the <paramref name="identifier" />, or <see langword="null" /> if there is no cells in the queue with that particular <paramref name="identifier" />.</returns>
        <remarks>
          <para>The cell reuse cache is important for efficiency and application developers should use it for dynamic tables. </para>
          <para>Application developers targeting iOS 6 and later should use <see cref="M:MonoTouch.UIKit.UITableView.RegisterClassForCellReuse" /> or <see cref="M:MonoTouch.UIKit.UITableView.RegisterNibForCellReuse" />. Once a <see cref="T:MonoTouch.UIKit.UITableViewCell" /> class is registered, calls to <see cref="M:MonoTouch.UIKit.UITableView.DequeueReusableCell" /> will return a newly-instantiated object as necessary, rather than returning <see langword="null" />.</para>
          <para>Application developers should prefer the use of <see cref="T:MonoTouch.UIKit.UITableView.DequeueReusableCell(MonoTouch.Foundation.NSString,MonoTouch.Foundation.NSIndexPath)" />, which returns a <see cref="T:MonoTouch.UIKit.UITableViewCell" /> that is properly sized for the index path.</para>
        </remarks>
        <altmember cref="M:MonoTouch.UIKit.UITableView.RegisterClassForCellReuse" />
        <altmember cref="M:MonoTouch.UIKit.UITableView.RegisterNibForCellReuse" />
      </Docs>
    </Member>
    <Member MemberName="DequeueReusableCell">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UITableViewCell DequeueReusableCell (string identifier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class MonoTouch.UIKit.UITableViewCell DequeueReusableCell(string identifier) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("dequeueReusableCellWithIdentifier:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UITableViewCell</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identifier" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="identifier">A string identifying the cell type being requested.</param>
        <summary>Returns a reusable table view cell that was created with the given ReuseIdentifier.</summary>
        <returns>A <see cref="T:MonoTouch.UIKit.UITableViewCell" /> associated with the <paramref name="identifier" />, or <see langword="null" /> if there is no cells in the queue with that particular <paramref name="identifier" />.</returns>
        <remarks>
          <para>The cell reuse cache is important for efficiency and application developers should use it for dynamic tables. </para>
          <para>Application developers targeting iOS 6 and later should use <see cref="M:MonoTouch.UIKit.UITableView.RegisterClassForCellReuse" /> or <see cref="M:MonoTouch.UIKit.UITableView.RegisterNibForCellReuse" />. Once a <see cref="T:MonoTouch.UIKit.UITableViewCell" /> class is registered, calls to <see cref="M:MonoTouch.UIKit.UITableView.DequeueReusableCell" /> will return a newly-instantiated object as necessary, rather than returning <see langword="null" />.</para>
          <para>Application developers should prefer the use of <see cref="T:MonoTouch.UIKit.UITableView.DequeueReusableCell(MonoTouch.Foundation.NSString,MonoTouch.Foundation.NSIndexPath)" />, which returns a <see cref="T:MonoTouch.UIKit.UITableViewCell" /> that is properly sized for the index path.</para>
        </remarks>
        <altmember cref="M:MonoTouch.UIKit.UITableView.RegisterClassForCellReuse" />
        <altmember cref="M:MonoTouch.UIKit.UITableView.RegisterNibForCellReuse" />
      </Docs>
    </Member>
    <Member MemberName="DequeueReusableCell">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UITableViewCell DequeueReusableCell (MonoTouch.Foundation.NSString reuseIdentifier, MonoTouch.Foundation.NSIndexPath indexPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class MonoTouch.UIKit.UITableViewCell DequeueReusableCell(class MonoTouch.Foundation.NSString reuseIdentifier, class MonoTouch.Foundation.NSIndexPath indexPath) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("dequeueReusableCellWithIdentifier:forIndexPath:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UITableViewCell</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseIdentifier" Type="MonoTouch.Foundation.NSString" />
        <Parameter Name="indexPath" Type="MonoTouch.Foundation.NSIndexPath" />
      </Parameters>
      <Docs>
        <param name="reuseIdentifier">A string identifying the cell type being requested.</param>
        <param name="indexPath">The specific cell being requested.</param>
        <summary>Returns a reusable table view cell for the given <paramref name="reuseIdentifier" />, properly sized for the <paramref name="indexPath" />. </summary>
        <returns>A <see cref="T:MonoTouch.UIKit.UITableViewCell" /> associated with the <paramref name="identifier" />. </returns>
        <remarks>
          <para>This is the preferred method to call for cell reuse, as it calls <see cref="M:MonoTouch.UIKit.UITableViewSource.GetHeightForRow" /> and returns a properly-sized <see cref="T:MonoTouch.UIKit.UITableViewCell" />.</para>
          <para>This method must be preceded by cell registration using <see cref="M:MonoTouch.UIKit.UITableView.RegisterClassForCellReuse" /> or <see cref="M:MonoTouch.UIKit.UITableView.RegisterNibForCellReuse" />. Otherwise, an <c>NSInternalInconsistencyException</c> exception will be raised at runtime. </para>
          <para>The cell reuse cache is important for efficiency and application developers should use it for dynamic tables. </para>
        </remarks>
        <altmember cref="M:MonoTouch.UIKit.UITableView.RegisterClassForCellReuse" />
        <altmember cref="M:MonoTouch.UIKit.UITableView.RegisterNibForCellReuse" />
      </Docs>
    </Member>
    <Member MemberName="DequeueReusableHeaderFooterView">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UITableViewHeaderFooterView DequeueReusableHeaderFooterView (MonoTouch.Foundation.NSString reuseIdentifier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class MonoTouch.UIKit.UITableViewHeaderFooterView DequeueReusableHeaderFooterView(class MonoTouch.Foundation.NSString reuseIdentifier) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("dequeueReusableHeaderFooterViewWithIdentifier:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UITableViewHeaderFooterView</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseIdentifier" Type="MonoTouch.Foundation.NSString" />
      </Parameters>
      <Docs>
        <param name="reuseIdentifier">A string identify the type of <see cref="T:MonoTouch.UIKit.UITableViewHeaderFooterView" /> being requested.</param>
        <summary>Returns a reusable <see cref="T:MonoTouch.UIKit.UITableViewHeaderFooterView" /> for the given <paramref name="reuseIdentifier" />.</summary>
        <returns>A <see cref="T:MonoTouch.UIKit.UITableViewHeaderFooterView" /> associated with the <paramref name="reuseIdentifier" />.</returns>
        <remarks>
          <para>The table reuse cache is important for efficiency and application developers should use it for dynamic tables.</para>
          <para>Application developers targeting iOS 6 and later should use <see cref="M:MonoTouch.UIKit.UITableView.RegisterClassForHeaderFooterViewReuse" /> or <see cref="M:MonoTouch.UIKit.UITableView.RegisterNibForHeaderFooterViewReuse" />. Once a <see cref="T:MonoTouch.UIKit.UITableViewHeaderFooterView" /> class is registered, calls to <see cref="M:MonoTouch.UIKit.UITableView.DequeueReusableHeaderFooterView" /> will return a newly-instantiated object as necessary, rather than returning <see langword="null" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeselectRow">
      <MemberSignature Language="C#" Value="public virtual void DeselectRow (MonoTouch.Foundation.NSIndexPath indexPath, bool animated);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DeselectRow(class MonoTouch.Foundation.NSIndexPath indexPath, bool animated) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("deselectRowAtIndexPath:animated:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indexPath" Type="MonoTouch.Foundation.NSIndexPath" />
        <Parameter Name="animated" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="indexPath">An <see cref="T:MonoTouch.Foundation.NSIndexPath" /> identifying a row in the table view.<para tool="nullallowed">This parameter can be <see langword="null" />.</para></param>
        <param name="animated">
          <see langword="true" /> if the deseletion should be animated, <see langword="false" /> if it should occur immediately.</param>
        <summary>Deselect a given row in a table view, with an option to animate the deselection.</summary>
        <remarks>
          <para>Calling this method does not trigger <see cref="M:MonoTouch.UIKit.UITableViewSource.WillSelectRow(MonoTouch.UIKit.UITableView,MonoTouch.Foundation.NSIndexPath)" /> nor will it send <see cref="P:MonoTouch.UIKit.UITableView.SelectionDidChangeNotification" /> notifications.</para>
          <para>This method does not cause any scrolling to the deselected row.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <para>If set to <see langword="true" />, the method is invoked directly and will dispose manage and unmanaged resources;   If set to <see langword="false" /> the method is being called by the garbage collector finalizer and should only release unmanaged resources.</para>
        </param>
        <summary>Releases the resources used by the UITableView object.</summary>
        <remarks>
          <para>This Dispose method releases the resources used by the UITableView class.</para>
          <para>This method is called by both the Dispose() method and the object finalizer (Finalize).    When invoked by the Dispose method, the parameter disposing <paramref name="disposing" /> is set to <see langword="true" /> and any managed object references that this object holds are also disposed or released;  when invoked by the object finalizer, on the finalizer thread the value is set to <see langword="false" />. </para>
          <para>Calling the Dispose method when you are finished using the UITableView ensures that all external resources used by this managed object are released as soon as possible.  Once you have invoked the Dispose method, the object is no longer useful and you should no longer make any calls to it.</para>
          <para>  For more information on how to override this method and on the Dispose/IDisposable pattern, read the ``Implementing a Dispose Method'' document at http://msdn.microsoft.com/en-us/library/fs2xkftw.aspx</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Editing">
      <MemberSignature Language="C#" Value="public virtual bool Editing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Editing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("isEditing")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setEditing:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether the table view is in editing mode.</summary>
        <value>
          <see langword="true" /> if the table is currently in editing mode, <see langword="false" /> if not. The default is <see langword="false" />.</value>
        <remarks>When this property is <see langword="true" />, the table view is in editing mode: cells may show an insertion or deletion control on their left side and a reordering control on the right (depending on how the cell is configured). Tapping a control causes the table view to invoke the <see cref="T:MonoTouch.UIKit.UITableViewSource" /> method <see cref="M:MonoTouch.UIKit.UITableViewSource.CommitEditingStyle" />.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndUpdates">
      <MemberSignature Language="C#" Value="public virtual void EndUpdates ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndUpdates() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("endUpdates")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Finalize a series of method calls that insert, update or select rows to animate as one operation. <see cref="M:MonoTouch.UIKit.UITableView.BeginUpdates()" /> must be called before the modifications are made.</summary>
        <remarks>Call this method to bracket a series of table modifications (insert, delete or select rows) that began with <see cref="M:MonoTouch.UIKit.UITableView.BeginUpdates()" />. When EndUpdates is called the table view animates the operations simultaneously. Calls to <see cref="M:MonoTouch.UIKit.UITableView.BeginUpdates()" /> and EndUpdates can be nested. If you make insertion, deletion or selection calls outside of a <see cref="M:MonoTouch.UIKit.UITableView.BeginUpdates()" />/EndUpdates block then table attributes such as row count might become invalid.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EstimatedRowHeight">
      <MemberSignature Language="C#" Value="public virtual float EstimatedRowHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float32 EstimatedRowHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("estimatedRowHeight")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setEstimatedRowHeight:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The estimated height of individual rows in this UITableView.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EstimatedSectionFooterHeight">
      <MemberSignature Language="C#" Value="public virtual float EstimatedSectionFooterHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float32 EstimatedSectionFooterHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("estimatedSectionFooterHeight")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setEstimatedSectionFooterHeight:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The estimated height of section foots in this UITableView.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EstimatedSectionHeaderHeight">
      <MemberSignature Language="C#" Value="public virtual float EstimatedSectionHeaderHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float32 EstimatedSectionHeaderHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("estimatedSectionHeaderHeight")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setEstimatedSectionHeaderHeight:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The estimated height of section headers in this UITableView.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAppearance&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static MonoTouch.UIKit.UITableView.UITableViewAppearance GetAppearance&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class MonoTouch.UIKit.UITableView/UITableViewAppearance GetAppearance&lt;T&gt;() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UITableView+UITableViewAppearance</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">The subtype of <see cref="T:MonoTouch.UIKit.UITableView" /> for which the custom appearance is desired.</typeparam>
        <summary>The strongly-typed IUIAppearance for this object.</summary>
        <returns>A <see cref="T:MonoTouch.UIKit.UITableViewApearance" /> for the specified type.</returns>
        <remarks>
          <para>This method returns a <see cref="T:MonoTouch.UIKit.UITableView+UITableViewAppearance" /> that allows a custom subclass to have a different appearance than the base class.</para>
          <para>Because <see langword="static" /> methods in C# are not polymorphic, the type parameter <c>T</c> is required to specify the subclass for which the <see cref="T:MonoTouch.UIKit.UITableView+UITableViewAppearance" /> is desired.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFooterView">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UITableViewHeaderFooterView GetFooterView (int section);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class MonoTouch.UIKit.UITableViewHeaderFooterView GetFooterView(int32 section) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("footerViewForSection:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UITableViewHeaderFooterView</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="section" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="section">To be added.</param>
        <summary>The footer view for the specified section.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHeaderView">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UITableViewHeaderFooterView GetHeaderView (int section);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class MonoTouch.UIKit.UITableViewHeaderFooterView GetHeaderView(int32 section) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("headerViewForSection:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UITableViewHeaderFooterView</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="section" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="section">A zero-based index specifying which section's header is being requested.</param>
        <summary>Returns the <see cref="T:MonoTouch.UIKit.UITableViewHeaderFooterView" /> for the specified <paramref name="section" />. Returns <see langword="null" /> if there is no corresponding view.</summary>
        <returns>The <see cref="T:MonoTouch.UIKit.UITableViewHeaderFooterView" /> for the specified <paramref name="section" />. Returns <see langword="null" /> if there is no corresponding view</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexPathForCell">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.Foundation.NSIndexPath IndexPathForCell (MonoTouch.UIKit.UITableViewCell cell);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class MonoTouch.Foundation.NSIndexPath IndexPathForCell(class MonoTouch.UIKit.UITableViewCell cell) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("indexPathForCell:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSIndexPath</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cell" Type="MonoTouch.UIKit.UITableViewCell" />
      </Parameters>
      <Docs>
        <param name="cell">The <see cref="T:MonoTouch.UIKit.UITableViewCell" /> for which the index path is desired.</param>
        <summary>Calculates the index path for the specified <paramref name="cell" />.</summary>
        <returns>The <see cref="T:MonoTouch.Foundation.NSIndexPath" /> for the <paramref name="cell" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexPathForRowAtPoint">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.Foundation.NSIndexPath IndexPathForRowAtPoint (System.Drawing.PointF point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class MonoTouch.Foundation.NSIndexPath IndexPathForRowAtPoint(valuetype System.Drawing.PointF point) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("indexPathForRowAtPoint:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSIndexPath</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.PointF" />
      </Parameters>
      <Docs>
        <param name="point">A location, in the coordinate system of <c>this</c>, in the row for which the index path is desired.</param>
        <summary>Returns the <see cref="T:MonoTouch.Foundation.NSIndexPath" /> for the row at the indicated <paramref name="point" />.</summary>
        <returns>The <see cref="T:MonoTouch.Foundation.NSIndexPath" /> for the row at the indicated <paramref name="point" />. Returns <see langword="null" /> if <paramref name="point" /> is not within a row.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexPathForSelectedRow">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.Foundation.NSIndexPath IndexPathForSelectedRow { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.Foundation.NSIndexPath IndexPathForSelectedRow" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("indexPathForSelectedRow")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSIndexPath</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The <see cref="T:MonoTouch.Foundation.NSIndexPath" /> for the currently-selected row.</summary>
        <value>The <see cref="T:MonoTouch.Foundation.NSIndexPath" /> for the most-recently-selected of the currently-selected rows. Returns <see langword="null" /> if there are no selected rows.</value>
        <remarks>
          <para>If the <see cref="T:MonoTouch.UIKit.UITableView" /> contains more than one selected row, this property holds the most-recently-selected of the rows (see also <see cref="P:MonoTouch.UIKit.IndexPathsForSelectedRows" />).</para>
        </remarks>
        <altmember cref="P:MonoTouch.UIKit.UITableView.SelectedRow" />
      </Docs>
    </Member>
    <Member MemberName="IndexPathsForSelectedRows">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.Foundation.NSIndexPath[] IndexPathsForSelectedRows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.Foundation.NSIndexPath[] IndexPathsForSelectedRows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(5, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("indexPathsForSelectedRows")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(5, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSIndexPath[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An array of <see cref="T:MonoTouch.Foundation.NSIndexPath" />s for the selected rows.</summary>
        <value>An array of <see cref="T:MonoTouch.Foundation.NSIndexPath" />s corresponding to the currently-selected set of rows. Returns <see langword="null" /> if there are no selected rows.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexPathsForVisibleRows">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.Foundation.NSIndexPath[] IndexPathsForVisibleRows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.Foundation.NSIndexPath[] IndexPathsForVisibleRows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("indexPathsForVisibleRows")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSIndexPath[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An array of <see cref="T:MonoTouch.Foundation.NSIndexPath" />s for the set of currently-visible rows.</summary>
        <value>An array of <see cref="T:MonoTouch.Foundation.NSIndexPath" />s corresponding to the set of currently-visible rows.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexSearch">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString IndexSearch { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString IndexSearch" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UITableViewIndexSearch", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant <c>UITableViewIndexSearch</c></summary>
        <value>
        </value>
        <remarks>To be added.</remarks>
        <altmember cref="M:MonoTouch.UIKit.UITableViewSource.SectionIndexTitles" />
      </Docs>
    </Member>
    <Member MemberName="InsertRows">
      <MemberSignature Language="C#" Value="public virtual void InsertRows (MonoTouch.Foundation.NSIndexPath[] atIndexPaths, MonoTouch.UIKit.UITableViewRowAnimation withRowAnimation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void InsertRows(class MonoTouch.Foundation.NSIndexPath[] atIndexPaths, valuetype MonoTouch.UIKit.UITableViewRowAnimation withRowAnimation) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("insertRowsAtIndexPaths:withRowAnimation:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="atIndexPaths" Type="MonoTouch.Foundation.NSIndexPath[]" />
        <Parameter Name="withRowAnimation" Type="MonoTouch.UIKit.UITableViewRowAnimation" />
      </Parameters>
      <Docs>
        <param name="atIndexPaths">An array of <see cref="T:MonoTouch.Foundation.NSIndexPath" />s that indicate the desired insertion points.</param>
        <param name="withRowAnimation">What type of animation to use.</param>
        <summary>Inserts rows into the <see cref="T:MonoTouch.UIKit.UITableView" />.</summary>
        <remarks>
          <para>
            <c>UITableView</c> calls the relevant <see cref="T:MonoTouch.UIKit.UITableViewSource" /> methods (e.g., <see cref="M:MonoTouch.UIKit.UITableViewSource.GetCell" /> and related methods) immediately afterwards to get the cells and other content to display the visible rows.</para>
          <para>When this method is called within a <see cref="M:MonoTouch.UIKit.UITableView.BeginUpdates" />-<see cref="M:MonoTouch.UIKit.UITableView.EndUpdates" /> animation block, any insertions of rows or sections are deferred until after deletions have been processed. This happens regardless of the ordering of the insertion and deletion method calls within the animation block..</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertSections">
      <MemberSignature Language="C#" Value="public virtual void InsertSections (MonoTouch.Foundation.NSIndexSet sections, MonoTouch.UIKit.UITableViewRowAnimation withRowAnimation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void InsertSections(class MonoTouch.Foundation.NSIndexSet sections, valuetype MonoTouch.UIKit.UITableViewRowAnimation withRowAnimation) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("insertSections:withRowAnimation:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sections" Type="MonoTouch.Foundation.NSIndexSet" />
        <Parameter Name="withRowAnimation" Type="MonoTouch.UIKit.UITableViewRowAnimation" />
      </Parameters>
      <Docs>
        <param name="sections">A set of section identifiers to insert. If a section already exists at a given index, it is moved up down one index location.</param>
        <param name="withRowAnimation">What type of animation to use when inserting the rows (eg. fade in or slide in from left)</param>
        <summary>Inserts a section (or sections) from a table view, with an option to animate the operation.</summary>
        <remarks>
          <para>
            <c>UITableView</c> calls the relevant <see cref="T:MonoTouch.UIKit.UITableViewSource" /> methods immediately afterwards to get the cells and other content to display the visible rows.</para>
          <para>When this method is called inside an animation block defined by <see cref="M:MonoTouch.UIKit.UITableView.BeginUpdates" /> and <see cref="M:MonoTouch.UIKit.UITableView.EndUpdates" />, any insertions of rows or sections are deferred until after deletions have been processed. This happens regardless of the ordering of the insertion and deletion method calls within the animation block.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveRow">
      <MemberSignature Language="C#" Value="public virtual void MoveRow (MonoTouch.Foundation.NSIndexPath fromIndexPath, MonoTouch.Foundation.NSIndexPath toIndexPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MoveRow(class MonoTouch.Foundation.NSIndexPath fromIndexPath, class MonoTouch.Foundation.NSIndexPath toIndexPath) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("moveRowAtIndexPath:toIndexPath:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(5, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromIndexPath" Type="MonoTouch.Foundation.NSIndexPath" />
        <Parameter Name="toIndexPath" Type="MonoTouch.Foundation.NSIndexPath" />
      </Parameters>
      <Docs>
        <param name="fromIndexPath">An <see cref="T:MonoTouch.Foundation.NSIndexPath" /> indicating the original row.</param>
        <param name="toIndexPath">The desired location.</param>
        <summary>Moves a row from <paramref name="fromIndexPath" /> to <paramref name="toIndexPath" />.</summary>
        <remarks>
          <para>There is no function for moving an array of rows (in contrast to <see cref="M:MonoTouch.UIKit.UITableView.InsertRows" /> or <see cref="M:MonoTouch.UIKit.UITableView.DeleteRows" />). The applicatin developer must instead repeatedly call this function. If this function is called within a <see cref="M:MonoTouch.UIKit.UITableView.BeginUpdates" />-<see cref="M:MonoTouch.UIKit.UITableView.EndUpdates" /> animation block, all the row manipulation will occur as a single animation.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveSection">
      <MemberSignature Language="C#" Value="public virtual void MoveSection (int fromSection, int toSection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MoveSection(int32 fromSection, int32 toSection) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("moveSection:toSection:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(5, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromSection" Type="System.Int32" />
        <Parameter Name="toSection" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="fromSection">Index of the section to move.</param>
        <param name="toSection">Destination index for the section. The section currently at this index is moved up or down to accomodate the moved section.</param>
        <summary>Moves a section to a new location in the table view.</summary>
        <remarks>
          <para>This method can be combined with other MoveSection, <see cref="M:MonoTouch.UIKit.UITableView.InsertSections(MonoTouch.Foundation.NSIndexSet,MonoTouch.UIKit.UITableViewRowAnimation)" /> and <see cref="M:MonoTouch.UIKit.UITableView.DeleteSections(MonoTouch.Foundation.NSIndexSet,MonoTouch.UIKit.UITableViewRowAnimation)" /> operations within an animation block defined by <see cref="M:MonoTouch.UIKit.UITableView.BeginUpdates" /> and <see cref="M:MonoTouch.UIKit.UITableView.EndUpdates" />, so that all the changes occur in a single animation.</para>
          <para>Unlike the insertion and deletion methods, moving a section does not use an animation paramter. Moved sections always animate straight from their starting position to their new position. Only one section can be moved per method call, however to move multiple sections application developers can call this method repeatedly within a <see cref="M:MonoTouch.UIKit.UITableView.BeginUpdates" />-<see cref="M:MonoTouch.UIKit.UITableView.EndUpdates" /> animation block.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NumberOfRowsInSection">
      <MemberSignature Language="C#" Value="public virtual int NumberOfRowsInSection (int section);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 NumberOfRowsInSection(int32 section) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("numberOfRowsInSection:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="section" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="section">The index of the section to query. Section indexes start at zero.</param>
        <summary>Returns the number of rows (table cells) in a given section.</summary>
        <returns>Number of rows in the section.</returns>
        <remarks>UITableView retrieves this value from the <see cref="T:MonoTouch.UIKit.UITableViewSource" /> (or <see cref="T:MonoTouch.UIKit.UITableViewDataSource" />) and caches it.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NumberOfSections">
      <MemberSignature Language="C#" Value="public virtual int NumberOfSections ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 NumberOfSections() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("numberOfSections")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the number of sections in the table view.</summary>
        <returns>Number of sections in the table view.</returns>
        <remarks>UITableView retrieves this value from the <see cref="T:MonoTouch.UIKit.UITableViewSource" /> (or <see cref="T:MonoTouch.UIKit.UITableViewDataSource" />) and caches it.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RectForFooterInSection">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.RectangleF RectForFooterInSection (int section);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Drawing.RectangleF RectForFooterInSection(int32 section) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("rectForFooterInSection:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="section" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="section">The index of a section.</param>
        <summary>Returns the drawing area for the specified section's footer.</summary>
        <returns>A rectangle defining where the section footer is drawn by the table view.</returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RectForHeaderInSection">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.RectangleF RectForHeaderInSection (int section);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Drawing.RectangleF RectForHeaderInSection(int32 section) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("rectForHeaderInSection:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="section" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="section">The index of a section.</param>
        <summary>Returns the drawing area for the specified section's header.</summary>
        <returns>A rectangle defining where the section header is drawn by the table view.</returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RectForRowAtIndexPath">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.RectangleF RectForRowAtIndexPath (MonoTouch.Foundation.NSIndexPath indexPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Drawing.RectangleF RectForRowAtIndexPath(class MonoTouch.Foundation.NSIndexPath indexPath) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("rectForRowAtIndexPath:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indexPath" Type="MonoTouch.Foundation.NSIndexPath" />
      </Parameters>
      <Docs>
        <param name="indexPath">An index path to a specific row in the table view.</param>
        <summary>Returns the drawing area for the specified row.</summary>
        <returns>A rectangle defining where the row is drawn by the table view, or <see cref="T:System.Drawing.RectangleF.Empty" /> if the <paramref name="indexPath" /> is not valid.</returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RectForSection">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.RectangleF RectForSection (int section);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Drawing.RectangleF RectForSection(int32 section) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("rectForSection:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="section" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="section">The index of a section.</param>
        <summary>Returns the drawing area for the specified section.</summary>
        <returns>A rectangle defining where the section is drawn by the table view.</returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterClassForCellReuse">
      <MemberSignature Language="C#" Value="public void RegisterClassForCellReuse (Type cellType, MonoTouch.Foundation.NSString reuseIdentifier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClassForCellReuse(class System.Type cellType, class MonoTouch.Foundation.NSString reuseIdentifier) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cellType" Type="System.Type" />
        <Parameter Name="reuseIdentifier" Type="MonoTouch.Foundation.NSString" />
      </Parameters>
      <Docs>
        <param name="cellType">The type of a UITableViewCell to create when the specified reuseIdentifier is passed to DequeueReusableCell.</param>
        <param name="reuseIdentifier">The reuse identifier.</param>
        <summary>Registers a type to provide UITableViewCells for a specific reuseIdentifier.</summary>
        <remarks>
          <para>
              
              Mono can use this method to register the type of a class
              that should be instantiated if the UITableView needs to
              create a new cell in response to a request in
              DequeueReusableCell for the specified reuseIdentifier.
              
            </para>
          <para>
              
              Registering types with cell identifiers helps reduce the
              amount of code that you have to write in your GetCell
              method.  It means that your GetCell method only needs to
              call DequeueReusableCell with the reuse identifier, and
              if there is no available cell, the UITableView will
              create an instance of the specified type and return it.
              
            </para>
          <para> 
              
              The type that you register must provide a constructor
              that takes an IntPtr constructor and needs to chain to
              the <see cref="C:MonoTouch.UIKit.UITableViewCell(IntPtr)" />
              constructor.
              
            </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterClassForHeaderFooterViewReuse">
      <MemberSignature Language="C#" Value="public void RegisterClassForHeaderFooterViewReuse (Type cellType, MonoTouch.Foundation.NSString reuseIdentifier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClassForHeaderFooterViewReuse(class System.Type cellType, class MonoTouch.Foundation.NSString reuseIdentifier) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cellType" Type="System.Type" />
        <Parameter Name="reuseIdentifier" Type="MonoTouch.Foundation.NSString" />
      </Parameters>
      <Docs>
        <param name="cellType">The type of a UIView to create when the specified reuseIdentifier is passed to DequeueReusableCell.</param>
        <param name="reuseIdentifier">The reuse identifier.</param>
        <summary>Registers a type to provide UIViews for headers or footers for a specific reuseIdentifier.</summary>
        <remarks>
          <para>
              
              You can use this method to register the type of a class
              that should be instantiated if the UITableView needs to
              create a new header or footer in response to a request in
              DequeueReusableHeaderFooterView for the specified reuseIdentifier.
              
            </para>
          <para>
              
              Registering types with reuse identifiers helps reduce the
              amount of code that you have to write in your GetFooterView or GetHeaderView methods.
              It means that your code only needs to
              call DequeueReusableHeaderFooterView with the reuse identifier, and
              if there is no available cell, the UITableView will
              create an instance of the specified type and return it.
              
            </para>
          <para> 
              The type that you register must provide a constructor
              that takes an IntPtr constructor and needs to chain to
              the <see cref="C:MonoTouch.UIKit.UIView(IntPtr)" />
              constructor.
            </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterNibforCellReuse">
      <MemberSignature Language="C#" Value="public void RegisterNibforCellReuse (MonoTouch.UIKit.UINib nib, string reuseIdentifier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterNibforCellReuse(class MonoTouch.UIKit.UINib nib, string reuseIdentifier) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use RegisterNibForCellReuse")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nib" Type="MonoTouch.UIKit.UINib" />
        <Parameter Name="reuseIdentifier" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="nib">A nib object created from a nib file. This value cannot be null.</param>
        <param name="reuseIdentifier">A string to use as an identifier for the cell. This value cannot be null.</param>
        <summary>Registers a nib object (containing a <see cref="T:MonoTouch.UIKit.UITableViewCell" />) with the given identifer string.</summary>
        <remarks>After a nib object has been registered with a table view, calling <see cref="M:MonoTouch.UIKit.UITableView.DequeueReusableCell(MonoTouch.Foundation.NSString)" /> with the correct identifer will cause the table view to instantiate the cell from the nib object if there is not already an instance in the reuse queue.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterNibForCellReuse">
      <MemberSignature Language="C#" Value="public virtual void RegisterNibForCellReuse (MonoTouch.UIKit.UINib nib, string reuseIdentifier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterNibForCellReuse(class MonoTouch.UIKit.UINib nib, string reuseIdentifier) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("registerNib:forCellReuseIdentifier:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(5, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nib" Type="MonoTouch.UIKit.UINib" />
        <Parameter Name="reuseIdentifier" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="nib">A nib object created from a nib file. This value cannot be <see langword="null" />.</param>
        <param name="reuseIdentifier">A string to use as an identifier for the cell. This value cannot be <see langword="null" />.</param>
        <summary>Registers a nib object (containing a <see cref="T:MonoTouch.UIKit.UITableViewCell" />) with the given identifer string.</summary>
        <remarks>After a nib object has been registered with a table view, calling <see cref="M:MonoTouch.UIKit.UITableView.DequeueReusableCell(MonoTouch.Foundation.NSString)" /> with the correct identifer will cause the table view to instantiate the cell from the nib object if there is not already an instance in the reuse queue.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterNibForHeaderFooterViewReuse">
      <MemberSignature Language="C#" Value="public virtual void RegisterNibForHeaderFooterViewReuse (MonoTouch.UIKit.UINib nib, string identifier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterNibForHeaderFooterViewReuse(class MonoTouch.UIKit.UINib nib, string identifier) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("registerNib:forHeaderFooterViewReuseIdentifier:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nib" Type="MonoTouch.UIKit.UINib" />
        <Parameter Name="identifier" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="nib">A nib object created from a nib file. This value cannot be <see langword="null" />.</param>
        <param name="identifier">A string to use as an identifier for this view. The value cannot be <see langword="null" />.</param>
        <summary>Registers a nib object (containing a <see cref="T:MonoTouch.UIKit.UITableViewHeaderFooterView" />) with the given identifier string.</summary>
        <remarks>
          <para>After a nib object has been registered with a table view, as section header and footer views come into view, the appropriate <see cref="T:MonoTouch.UIKit.UITableViewHeaderFooterView" />s will be instantiated as necessary from the nib object if there is not already an instance in the reuse queue.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReloadData">
      <MemberSignature Language="C#" Value="public virtual void ReloadData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReloadData() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("reloadData")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reloads the rows and sections in the table view.</summary>
        <remarks>
          <para>This method reloads all the data in the table, including cells, headers, footers and the index array. For efficiency, only visible rows are have their cells loaded and displayed.</para>
          <para>A table view's <see cref="P:MonoTouch.UIKit.UITableView.Source" /> calls this method when it wants to completely reload data. This method should not be called inside other methods that insert or delete rows, especially within a <see cref="M:MonoTouch.UIKit.UITableView.BeginUpdates" />-<see cref="M:MonoTouch.UIKit.UITableView.EndUpdates" /> animation block.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReloadRows">
      <MemberSignature Language="C#" Value="public virtual void ReloadRows (MonoTouch.Foundation.NSIndexPath[] atIndexPaths, MonoTouch.UIKit.UITableViewRowAnimation withRowAnimation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReloadRows(class MonoTouch.Foundation.NSIndexPath[] atIndexPaths, valuetype MonoTouch.UIKit.UITableViewRowAnimation withRowAnimation) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("reloadRowsAtIndexPaths:withRowAnimation:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="atIndexPaths" Type="MonoTouch.Foundation.NSIndexPath[]" />
        <Parameter Name="withRowAnimation" Type="MonoTouch.UIKit.UITableViewRowAnimation" />
      </Parameters>
      <Docs>
        <param name="atIndexPaths">An array of <see cref="T:MonoTouch.Foundation.NSIndexPath" /> objects that indicate which rows to reload.</param>
        <param name="withRowAnimation">The type of animation to use. The animation chosen affects both the way the old cell is animated out as well as how the new cell is animated into view.</param>
        <summary>Reloads specific rows with the given animation effect.</summary>
        <remarks>
          <para>Reloading a row means the data source is asked for a new cell for that row, which the table animates into place (animating the old cell off screen). Use this method to alert the user that the value of the cell is changing. If notifying the user is not important simply get the cell for a particular row and update its value.</para>
          <para>When this method is called within a <see cref="M:MonoTouch.UIKit.UITableView.BeginUpdates" />-<see cref="M:MonoTouch.UIKit.UITableView.EndUpdates" /> animation block it behaves like <see cref="M:MonoTouch.UIKit.UITableView.DeleteRows(MonoTouch.Foundation.NSIndexPath[],MonoTouch.UIKit.UITableViewRowAnimation)" /> - the indexes passed to the method are specified in the state of the table view prior to any updates. This happens regardless of the order of the insertion, deletion and reloading method calls within the animation block.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReloadSectionIndexTitles">
      <MemberSignature Language="C#" Value="public virtual void ReloadSectionIndexTitles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReloadSectionIndexTitles() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("reloadSectionIndexTitles")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reloads the index bar long the right edge of a table view.</summary>
        <remarks>Use this method to update the index after inserting or deleting sections, without having to reload the entire table.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReloadSections">
      <MemberSignature Language="C#" Value="public virtual void ReloadSections (MonoTouch.Foundation.NSIndexSet sections, MonoTouch.UIKit.UITableViewRowAnimation withRowAnimation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReloadSections(class MonoTouch.Foundation.NSIndexSet sections, valuetype MonoTouch.UIKit.UITableViewRowAnimation withRowAnimation) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("reloadSections:withRowAnimation:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sections" Type="MonoTouch.Foundation.NSIndexSet" />
        <Parameter Name="withRowAnimation" Type="MonoTouch.UIKit.UITableViewRowAnimation" />
      </Parameters>
      <Docs>
        <param name="sections">The sections to be reloaded.</param>
        <param name="withRowAnimation">Specifies which animation effect to use. This determines how the old sections are animated out as well as how the new sections are animated into view.</param>
        <summary>Reloads specific sections with an animation effect.</summary>
        <remarks>
          <para>Reloading a section means the data source is asked for news cell for the specified sections, which the table animates into place (animating the old cells off screen). Use this method to alert the user that the cells in the given sections are changing. If notifying the user is not important simply get the relevant cells and update their values directly.</para>
          <para>When this method is called within a <see cref="M:MonoTouch.UIKit.UITableView.BeginUpdates" />-<see cref="M:MonoTouch.UIKit.UITableView.EndUpdates" /> animation block it behaves like <see cref="M:MonoTouch.UIKit.UITableView.DeleteRows(MonoTouch.Foundation.NSIndexPath[],MonoTouch.UIKit.UITableViewRowAnimation)" /> - the indexes passed to the method are specified in the state of the table view prior to any updates. This happens regardless of the order of the insertion, deletion and reloading method calls within the animation block.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RowHeight">
      <MemberSignature Language="C#" Value="public virtual float RowHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float32 RowHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("rowHeight")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setRowHeight:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The height of each row in this UITableView.</summary>
        <value>Row height in points.</value>
        <remarks>
          <para>This property can be set if the <see cref="M:MonoTouch.UIKit.UITableViewSource.GetHeightForRow(MonoTouch.UIKit.UITableView,MonoTouch.Foundation.NSIndexPath)" /> has not been implemented. If the row height is not set explicity the table view uses a default value.</para>
          <para>There are performance implications to using <see cref="M:MonoTouch.UIKit.UITableViewSource.GetHeightForRow(MonoTouch.UIKit.UITableView,MonoTouch.Foundation.NSIndexPath)" /> instead of this property: every time a table view is displayed it calls <see cref="M:MonoTouch.UIKit.UITableViewSource.GetHeightForRow(MonoTouch.UIKit.UITableView,MonoTouch.Foundation.NSIndexPath)" /> for each of its rows. This can result in poor performance when the table has a large number of rows (for example, 1000 rows or more).</para>
          <para>If every row in a table has the same height, use this property. If rows have different heights (for example, they are sized around a variable amount of text) then <see cref="M:MonoTouch.UIKit.UITableViewSource.GetHeightForRow(MonoTouch.UIKit.UITableView,MonoTouch.Foundation.NSIndexPath)" /> is more appropriate.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToNearestSelected">
      <MemberSignature Language="C#" Value="public virtual void ScrollToNearestSelected (MonoTouch.UIKit.UITableViewScrollPosition atScrollPosition, bool animated);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ScrollToNearestSelected(valuetype MonoTouch.UIKit.UITableViewScrollPosition atScrollPosition, bool animated) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("scrollToNearestSelectedRowAtScrollPosition:animated:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="atScrollPosition" Type="MonoTouch.UIKit.UITableViewScrollPosition" />
        <Parameter Name="animated" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="atScrollPosition">Position that the target row should appear (e. top, middle, bottom) once the scrolling is complete.</param>
        <param name="animated">
          <paramref name="true" /> to animate the scroll,  <paramref name="false" /> if the table view should just jump immediately to the new position.</param>
        <summary>Automatically scrolls the rows so that the selected row nearest to a given position is moved to that position.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToRow">
      <MemberSignature Language="C#" Value="public virtual void ScrollToRow (MonoTouch.Foundation.NSIndexPath indexPath, MonoTouch.UIKit.UITableViewScrollPosition atScrollPosition, bool animated);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ScrollToRow(class MonoTouch.Foundation.NSIndexPath indexPath, valuetype MonoTouch.UIKit.UITableViewScrollPosition atScrollPosition, bool animated) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("scrollToRowAtIndexPath:atScrollPosition:animated:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indexPath" Type="MonoTouch.Foundation.NSIndexPath" />
        <Parameter Name="atScrollPosition" Type="MonoTouch.UIKit.UITableViewScrollPosition" />
        <Parameter Name="animated" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="indexPath">Identifies which row should appear <paramref name="atScrollPosition" />.</param>
        <param name="atScrollPosition">Position that the target row should appear (e. top, middle, bottom) once the scrolling is complete.</param>
        <param name="animated">
          <paramref name="true" /> to animate the scroll,  <paramref name="false" /> if the table view should just jump immediately to the new position.</param>
        <summary>Automatically scrolls the table view until the specified row appears in the required position.</summary>
        <remarks>Calling this method does not trigger <see cref="M:MonoTouch.UIKit.UITableViewSource.Scrolled()" />, which would normally occur after a programmatically-invoked UI operation.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SectionFooterHeight">
      <MemberSignature Language="C#" Value="public virtual float SectionFooterHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float32 SectionFooterHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("sectionFooterHeight")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setSectionFooterHeight:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The height of section foots in this UITableView.</summary>
        <value>Height in points.</value>
        <remarks>This property is used only in section group tables, and only if <see cref="M:MonoTouch.UIKit.UITableViewSource.GetHeightForFooter(MonoTouch.UIKit.UITableView,System.Int32)" /> has not been implemented.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SectionHeaderHeight">
      <MemberSignature Language="C#" Value="public virtual float SectionHeaderHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float32 SectionHeaderHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("sectionHeaderHeight")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setSectionHeaderHeight:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The height of section headers in this UITableView.</summary>
        <value>Height in points.</value>
        <remarks>This property is used only in section group tables, and only if <see cref="M:MonoTouch.UIKit.UITableViewSource.GetHeightForHeader(MonoTouch.UIKit.UITableView,System.Int32)" /> has not been implemented.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SectionIndexBackgroundColor">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIColor SectionIndexBackgroundColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIColor SectionIndexBackgroundColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("sectionIndexBackgroundColor")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setSectionIndexBackgroundColor:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIColor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The color used for the background of this UITableView's section index when it is not being touched.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SectionIndexColor">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIColor SectionIndexColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIColor SectionIndexColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("sectionIndexColor")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setSectionIndexColor:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIColor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The color used for the index text of this UITableView.</summary>
        <value>This value may be <see langword="null" />.<para tool="nullallowed">This value can be <see langword="null" />.</para></value>
        <remarks>
          <para id="tool-remark">This member participates in the <see cref="T:MonoTouch.UIKit.UIAppearance" /> styling system.  See the <see cref="P:MonoTouch.UIKit.UITableView.Appearance" /> property and the <see cref="M:MonoTouch.UIKit.UITableView.AppearanceWhenContainedIn" /> method.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SectionIndexMinimumDisplayRowCount">
      <MemberSignature Language="C#" Value="public virtual int SectionIndexMinimumDisplayRowCount { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SectionIndexMinimumDisplayRowCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("sectionIndexMinimumDisplayRowCount")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setSectionIndexMinimumDisplayRowCount:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The number of rows required in a table view before the index list is displayed.</summary>
        <value>The default value is 0.</value>
        <remarks>Only <see cref="T:MonoTouch.UIKit.UItableViewStyle" />.Plain styled tables should have an index. </remarks>
      </Docs>
    </Member>
    <Member MemberName="SectionIndexTrackingBackgroundColor">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIColor SectionIndexTrackingBackgroundColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIColor SectionIndexTrackingBackgroundColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("sectionIndexTrackingBackgroundColor")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setSectionIndexTrackingBackgroundColor:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIColor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies the background color of the index as the application user drags.</summary>
        <value>This value may be <see langword="null" />.<para tool="nullallowed">This value can be <see langword="null" />.</para></value>
        <remarks>
          <para id="tool-remark">This member participates in the <see cref="T:MonoTouch.UIKit.UIAppearance" /> styling system.  See the <see cref="P:MonoTouch.UIKit.UITableView.Appearance" /> property and the <see cref="M:MonoTouch.UIKit.UITableView.AppearanceWhenContainedIn" /> method.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionDidChangeNotification">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString SelectionDidChangeNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString SelectionDidChangeNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UITableViewSelectionDidChangeNotification", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for SelectionDidChange</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:MonoTouch.Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UITableView+Notifications" />.<see cref="M:UITableView+Notifications.ObserveSelectionDidChangeNotification" /> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="c#">
//
// Lambda style
//

// listening
notification = UITableView.Notifications.ObserveSelectionDidChange ((sender, args) =&gt; {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, MonoTouch.Foundation.NSNotificationEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UITableView.Notifications.ObserveSelectionDidChange (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}</code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="c#">
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UITableView.SelectionDidChangeNotification, (notification) =&gt; {Console.WriteLine ("Received the notification UITableView", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UITableView", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UITableView.SelectionDidChangeNotification, Callback);
}
</code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectRow">
      <MemberSignature Language="C#" Value="public virtual void SelectRow (MonoTouch.Foundation.NSIndexPath indexPath, bool animated, MonoTouch.UIKit.UITableViewScrollPosition scrollPosition);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SelectRow(class MonoTouch.Foundation.NSIndexPath indexPath, bool animated, valuetype MonoTouch.UIKit.UITableViewScrollPosition scrollPosition) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("selectRowAtIndexPath:animated:scrollPosition:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indexPath" Type="MonoTouch.Foundation.NSIndexPath" />
        <Parameter Name="animated" Type="System.Boolean" />
        <Parameter Name="scrollPosition" Type="MonoTouch.UIKit.UITableViewScrollPosition" />
      </Parameters>
      <Docs>
        <param name="indexPath">Identifies the row to be selected.</param>
        <param name="animated">
          <see langword="true" /> to animate the selection and position change, <see langword="false" /> if the change should occur immediately.</param>
        <param name="scrollPosition">Position that the selected row should be scrolled to (top, middle, bottom).</param>
        <summary>Selects the given row, optionall scrolling the row to a specific location.</summary>
        <remarks>
          <para>Calling this method does not trigger <see cref="M:MonoTouch.UIKit.UITableViewSource.WillSelectRow(MonoTouch.UIKit.UITableView,MonoTouch.Foundation.NSIndexPath)" /> nor will it send <see cref="P:MonoTouch.UIKit.UITableView.SelectionDidChangeNotification" /> notifications.</para>
        </remarks>
        <example>
          <para>Passing <see cref="P:MonoTouch.UIKit.UITableViewScrollPosition.None" />. will result in no scrolling (despite that constant normally causing minimal scrolling). To scroll to the newly selected row with minimum scrolling, select the row using this method with <see cref="P:MonoTouch.UIKit.UITableViewScrollPosition.None" /> then call <see cref="M:MonoTouch.UIKit.UITableView.ScrollToRow(MonoTouch.Foundation.NSIndexPath,MonoTouch.UIKit.UITableViewScrollPosition,System.Boolean)" /> also with <see cref="P:MonoTouch.UIKit.UITableViewScrollPosition.None" />.</para>
          <code lang="c#">
              NSIndexPath rowToSelect; // assume this is valid
              UITableView myTableView; // assume this is valid
              
              myTableView.SelectRow (rowToSelect, true, UITableViewScrollPosition.None);
              myTableView.ScrollToRow (rowToSelect, UITableViewScrollPosition.None, true);
            </code>
        </example>
      </Docs>
    </Member>
    <Member MemberName="SeparatorColor">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIColor SeparatorColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIColor SeparatorColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("separatorColor")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setSeparatorColor:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIColor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The color of the separator between rows in the table view.</summary>
        <value>The default color is grey.</value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SeparatorInset">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIEdgeInsets SeparatorInset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype MonoTouch.UIKit.UIEdgeInsets SeparatorInset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("separatorInset")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setSeparatorInset:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIEdgeInsets</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The default inset of cell separators.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SeparatorStyle">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UITableViewCellSeparatorStyle SeparatorStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype MonoTouch.UIKit.UITableViewCellSeparatorStyle SeparatorStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("separatorStyle")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setSeparatorStyle:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UITableViewCellSeparatorStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The style of the separator between rows in the table view.</summary>
        <value>.</value>
        <remarks>UITableView uses this property to set the separator style on cells returned by <see cref="M:MonoTouch.UIKit.UITableViewSource.GetCell(MonoTouch.UIKit.UITableView,MonoTouch.Foundation.NSIndexPath)" /></remarks>
      </Docs>
    </Member>
    <Member MemberName="SetEditing">
      <MemberSignature Language="C#" Value="public virtual void SetEditing (bool editing, bool animated);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetEditing(bool editing, bool animated) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setEditing:animated:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="editing" Type="System.Boolean" />
        <Parameter Name="animated" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="editing">
          <see langword="true" /> to enter editing mode, <see langword="false" /> to end editing. The default is <see langword="false" />.</param>
        <param name="animated">
          <see langword="true" /> to animate the transition to or from editing mode, or <see langword="false" /> to change modes immediately.</param>
        <summary>Turns editing mode on or off.</summary>
        <remarks>
          <para>Calling this method with  <paramref name="editing" /> == <see langword="true" />, the table view enters editing mode and calls <see cref="M:MonoTouch.UIKit.UITableViewCell.SetEditing(bool,bool)" /> on each visible row's <see cref="T:MonoTouch.UIKit.UITableViewCell" /> object.</para>
          <para>In editing mode the cells might show </para>
          <para>The <see cref="T:MonoTouch.UIKit.UITableViewSource" /> (or <see cref="P:MonoTouch.UIKit.UITableView.DataSource" />) can selectively exclude cells from editing mode by returning <see langword="false" /> from <see cref="M:MonoTouch.UIKit.UITableViewSource.CanEditRow(MonoTouch.UIKit.UITableView,MonoTouch.Foundation.NSIndexPath)" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public MonoTouch.UIKit.UITableViewSource Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UITableViewSource Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UITableViewSource</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A MonoTouch-specific feature that uses a <see cref="T:MonoTouch.UIKit.UITableViewSource" /> subclass to act as both <see cref="P:MonoTouch.UIKit.UITableView.Delegate" /> or <see cref="P:MonoTouch.UIKit.UITableView.DataSource" />.</summary>
        <value>A class that can behave as both <see cref="P:MonoTouch.UIKit.UITableView.Delegate" /> and <see cref="P:MonoTouch.UIKit.UITableView.DataSource" /> for the table view.</value>
        <remarks>
          <para>MonoTouch provides the <see cref="T:MonoTouch.UIKit.UITableViewSource" /> class as an alternative to implementing both <see cref="T:MonoTouch.UIKit.UITableViewDataSource" /> and <see cref="T:MonoTouch.UIKit.UITableViewDelegate" />. If a subclass of <see cref="T:MonoTouch.UIKit.UITableViewSource" /> is created and assigned to this property, the <see cref="P:MonoTouch.UIKit.UITableView.DataSource" /> and <see cref="P:MonoTouch.UIKit.UITableView.Delegate" /> properties should not be set.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Style">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UITableViewStyle Style { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype MonoTouch.UIKit.UITableViewStyle Style" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("style")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UITableViewStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns the style of the table view (read-only).</summary>
        <value>
        </value>
        <remarks>A table view's style is set in the constructor and cannot be changed.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TableFooterView">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIView TableFooterView { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIView TableFooterView" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("tableFooterView")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setTableFooterView:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns a view that is displayed below the table view.</summary>
        <value>The default value is <see langword="null" />.<para tool="nullallowed">This value can be <see langword="null" />.</para></value>
        <remarks>The table footer view is different to a section footer.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TableHeaderView">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIView TableHeaderView { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIView TableHeaderView" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("tableHeaderView")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setTableHeaderView:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns a view that is displayed above the table view.</summary>
        <value>The default value is <see langword="null" />.<para tool="nullallowed">This value can be <see langword="null" />.</para></value>
        <remarks>The table header view is different from a section header.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisibleCells">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UITableViewCell[] VisibleCells { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UITableViewCell[] VisibleCells" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("visibleCells")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UITableViewCell[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns an array of <see cref="T:MonoTouch.UIKit.UITableViewCell" /> that are currently visible in the table view.</summary>
        <value>An array containing <see cref="T:MonoTouch.UIKit.UITableViewCell" /> corresponding to the visible rows in the table view.</value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WeakDataSource">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.Foundation.NSObject WeakDataSource { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.Foundation.NSObject WeakDataSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("dataSource")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setDataSource:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The data source for this UITableView. </summary>
        <value>
          <para>(More documentation for this node is coming)</para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WeakDelegate">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.Foundation.NSObject WeakDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.Foundation.NSObject WeakDelegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("delegate")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setDelegate:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An object that can respond to the delegate protocol for this type</summary>
        <value>
          <para>The instance that will respond to events and data requests.</para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>
          <para>The delegate instance assigned to this object will be used to handle events or provide data on demand to this class.</para>
          <para>When setting the Delegate or WeakDelegate values events will be delivered to the specified instance instead of being delivered to the C#-style events</para>
          <para>   Methods must be decorated with the [Export ("selectorName")] attribute to respond to each method from the protocol.   Alternatively use the Delegate method which is strongly typed and does not require the [Export] attributes on methods.</para>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>