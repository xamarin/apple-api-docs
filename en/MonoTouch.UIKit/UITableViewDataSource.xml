<Type Name="UITableViewDataSource" FullName="UIKit.UITableViewDataSource">
  <TypeSignature Language="C#" Value="public abstract class UITableViewDataSource : Foundation.NSObject, IDisposable, UIKit.IUITableViewDataSource" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit UITableViewDataSource extends Foundation.NSObject implements class ObjCRuntime.INativeObject, class UIKit.IUITableViewDataSource, class System.IDisposable" />
  <AssemblyInfo>
    <AssemblyName>Xamarin.iOS</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Foundation.NSObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>UIKit.IUITableViewDataSource</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>Foundation.Model</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Foundation.Protocol</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Foundation.Register("UITableViewDataSource", false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>The data source for a <see cref="T:UIKit.UITableView" />. Xamarin.iOS developers should prefer to use <see cref="T:UIKit.UITableViewSource" /> instead of this class.</summary>
    <remarks>
      <para>Implementing <see cref="T:UIKit.UITableView" /> often requires subclasses of both <see cref="T:UIKit.UITableViewDataSource" /> and <see cref="T:UIKit.UITableViewDelegate" /> to provide data and behavior for the table view. Xamarin.iOS provides a single class - <see cref="T:UIKit.UITableViewSource" /> - so that only one class needs to be implemented.</para>
      <para>The <see cref="T:UIKit.UITableViewDataSource" /> class methods provide a table view with all the information it requires to display its data - such as informing it of the number of sections and rows, and what cell view to use for each row.</para>
      <para>The universally-important function of <see cref="T:UIKit.UITableViewDataSource" /> is to provide individual <see cref="T:UIKit.UITableViewCell" />s in response to calls to <see cref="M:UIKit.UITableViewDataSource.GetCell" />. That call takes as arguments the <see cref="T:UIKit.UITableView" /> in question and an <see cref="T:Foundation.NSIndexPath" />. That <see cref="T:Foundation.NSIndexPath" /> is based, in turn, on calls to <see cref="M:UIKit.UITableViewDataSource.NumberOfSections" /> and <see cref="M:UIKit.UITableViewDataSource.RowsInSection" />, so the application developer must, at a minimum, override these three functions. (The <see cref="T:UIKit.UITableView" /> additionally calls <see cref="M:UIKit.UITableViewDelegate.GetHeightForRow" /> and other layout-related methods for header and footer views and the application developer must override these as appropriate.)</para>
      <para>Static tables may return references to pre-allocated <see cref="T:UIKit.UITableViewCell" />s from calls to <see cref="M:UIKit.UITableViewDataSource.GetCell" />. Dynamic tables should use the <see cref="T:UIKit.UITableView" />'s built-in cell reuse cache by calling <see cref="M:UIKit.UITableView.DequeueReusableCell" />. In iOS 6 and later, application developers should use <see cref="M:UIKit.UITableView.RegisterClassForCellReuse" /> or <see cref="M:UIKit.UITableView.RegisterNibForCellReuse" /> during initialization, in which case <see cref="M:UIKit.UITableView.DequeueReusableCell" /> will instantiate new <see cref="T:UIKit.UITableViewCell" />s as necessary. If application developers are targeting earlier iOS versions, their override of <see cref="M:UIKit.UITableViewDataSource.GetCell" /> must check for an <see langword="null" /> return from <see cref="M:UIKit.UITableView.DequeueReusableCell" /> and instantiate a <see cref="T:UIKit.UITableViewCell" /> as necessary. </para>
    </remarks>
    <altmember cref="T:UIKit.UITableView" />
    <altmember cref="T:UIKit.UITableViewSource" />
    <altmember cref="T:UIKit.UITableViewCell" />
    <altmember cref="T:UIKit.UITableViewDelegate" />
    <related type="sample" href="http://samples.xamarin.com/Samples/ByGuid?guid=23a2571b-45eb-4889-bb67-d88937cb68c1">monocatalog</related>
    <related type="PlatformDocAPI" href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITableViewDataSource_Protocol/index.html">Apple documentation for <c>UITableViewDataSource</c></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected UITableViewDataSource ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("init")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Default constructor that initializes a new instance of this class with no parameters.</summary>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected UITableViewDataSource (Foundation.NSObjectFlag t);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class Foundation.NSObjectFlag t) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="t" Type="Foundation.NSObjectFlag" />
      </Parameters>
      <Docs>
        <param name="t">Unused sentinel value, pass NSObjectFlag.Empty.</param>
        <summary>Constructor to call on derived classes to skip initialization and merely allocate the object.</summary>
        <remarks>
          <para>This constructor should be called by derived classes when they completely construct the object in managed code and merely want the runtime to allocate and initialize the NSObject.   This is required to implement the two-step initialization process that Objective-C uses, the first step is to perform the object allocation, the second step is to initialize the object.   When developers invoke the constructor that takes the NSObjectFlag.Empty they take advantage of a direct path that goes all the way up to NSObject to merely allocate the object's memory and bind the Objective-C and C# objects together.    The actual initialization of the object is up to the developer.</para>
          <para>This constructor is typically used by the binding generator to allocate the object, but prevent the actual initialization to take place.   Once the allocation has taken place, the constructor has to initialize the object.   With constructors generated by the binding generator this means that it manually invokes one of the "init" methods to initialize the object.</para>
          <para>It is the developer's responsibility to completely initialize the object if they chain up using the NSObjectFlag.Empty path.</para>
          <para>In general, if the developer's constructor invokes the NSObjectFlag.Empty base implementation, then it should be calling an Objective-C init method.   If this is not the case, developers should instead chain to the proper constructor in their class. </para>
          <para>The argument value is ignored and merely ensures that the only code that is executed is the construction phase is the basic NSObject allocation and runtime type registration.  Typically the chaining would look like this:</para>
          <example>
            <code lang="C#"><![CDATA[
//
// The NSObjectFlag merely allocates the object and registers the
// C# class with the Objective-C runtime if necessary, but no actual
// initXxx method is invoked, that is done later in the constructor
//
// This is taken from Xamarin's source code:
//
[Export ("initWithFrame:")]
public UIView (System.Drawing.RectangleF frame) : base (NSObjectFlag.Empty)
{
// Invoke the init method now.
	var initWithFrame = new Selector ("initWithFrame:").Handle;
	if (IsDirectBinding)
		Handle = ObjCRuntime.Messaging.IntPtr_objc_msgSend_RectangleF (this.Handle, initWithFrame, frame);
	else
		Handle = ObjCRuntime.Messaging.IntPtr_objc_msgSendSuper_RectangleF (this.SuperHandle, initWithFrame, frame);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected UITableViewDataSource (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig specialname rtspecialname instance void .ctor(native int handle) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Pointer (handle) to the unmanaged object.</param>
        <summary>A constructor used when creating managed representations of unmanaged objects;  Called by the runtime.</summary>
        <remarks>
          <para>This constructor is invoked by the runtime infrastructure (<see cref="M:ObjCRuntime.Runtime.GetNSObject(System.IntPtr)" />) to create a new managed representation for a pointer to an unmanaged Objective-C object.    Developers should not invoke this method directly, instead they should call the GetNSObject method as it will prevent two instances of a managed object to point to the same native object.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanEditRow">
      <MemberSignature Language="C#" Value="public virtual bool CanEditRow (UIKit.UITableView tableView, Foundation.NSIndexPath indexPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanEditRow(class UIKit.UITableView tableView, class Foundation.NSIndexPath indexPath) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("tableView:canEditRowAtIndexPath:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tableView" Type="UIKit.UITableView" />
        <Parameter Name="indexPath" Type="Foundation.NSIndexPath" />
      </Parameters>
      <Docs>
        <param name="tableView">Table view containing the row.</param>
        <param name="indexPath">Location of the row.</param>
        <summary>Whether the row located at <paramref name="indexPath" /> should be editable.</summary>
        <returns>
          <see langword="true" /> if the row is editable, otherwise <see langword="false" />.</returns>
        <remarks>
          <para>This method allows specific rows to be editable or not. If this method is not implemented, all rows are assumed to be editable. Editable rows display the insertion or deletion control in their cell when the table view is in editing mode.</para>
          <para>Rows that are not editable will ignore the <see cref="P:UIKit.UITableViewCell.EditingStyle" /> property and will not be indented.</para>
          <para>Rows that are editable, but should not display the insertion or deletion control, can return <see cref="F:UIKit.UITableViewCellEditingStyle.None" /> from the <see cref="M:UIKit.UITableViewSource.EditingStyleForRow(UIKit.UITableView,Foundation.NSIndexPath)" /> method on the table view's <see cref="T:UIKit.UITableViewSource" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanMoveRow">
      <MemberSignature Language="C#" Value="public virtual bool CanMoveRow (UIKit.UITableView tableView, Foundation.NSIndexPath indexPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanMoveRow(class UIKit.UITableView tableView, class Foundation.NSIndexPath indexPath) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("tableView:canMoveRowAtIndexPath:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tableView" Type="UIKit.UITableView" />
        <Parameter Name="indexPath" Type="Foundation.NSIndexPath" />
      </Parameters>
      <Docs>
        <param name="tableView">Table view containing the row.</param>
        <param name="indexPath">Location of the row.</param>
        <summary>Whether the row located at <paramref name="indexPath" /> can be moved to another location in the table view.</summary>
        <returns>
          <see langword="true" /> if the row can be moved, otherwise <see langword="false" />.</returns>
        <remarks>
          <para>This method allows specific rows to have the reordering control to be hidden for specific rows. By default, the reordering control is always shown if <see cref="M:UIKit.UITableViewSource.MoveRow(UIKit.UITableView,Foundation.NSIndexPath,Foundation.NSIndexPath)" /> is implemented on the <see cref="T:UIKit.UITableViewSource" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CommitEditingStyle">
      <MemberSignature Language="C#" Value="public virtual void CommitEditingStyle (UIKit.UITableView tableView, UIKit.UITableViewCellEditingStyle editingStyle, Foundation.NSIndexPath indexPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CommitEditingStyle(class UIKit.UITableView tableView, valuetype UIKit.UITableViewCellEditingStyle editingStyle, class Foundation.NSIndexPath indexPath) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("tableView:commitEditingStyle:forRowAtIndexPath:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tableView" Type="UIKit.UITableView" />
        <Parameter Name="editingStyle" Type="UIKit.UITableViewCellEditingStyle" />
        <Parameter Name="indexPath" Type="Foundation.NSIndexPath" />
      </Parameters>
      <Docs>
        <param name="tableView">Table view requesting insertion or deletion.</param>
        <param name="editingStyle">Cell editing style requested for the row at <paramref name="indexPath" />, such as <see cref="F:UIKit.UITableViewEditingStyle.Insert" /> or <see cref="F:UIKit.UITableViewEditingStyle.Delete" />.</param>
        <param name="indexPath">Location of the row.</param>
        <summary>Commits the insertion or deletion of the specified row.</summary>
        <remarks>
          <para>When the user taps the insertion (green plus) or Delete button in a cell, the table view calls this method to commit the change (if the user taps the deletion (red minus) button, that simply reveals the Delete button).</para>
          <para>This method should commit the <paramref name="editingStyle" /> by calling <see cref="T:UIKit.UITableView" /> methods <see cref="M:UIKit.UITableView.InsertRows(Foundation.NSIndexPath[],UIKit.UITableViewRowAnimation)" /> or <see cref="M:UIKit.UITableView.DeleteRows(Foundation.NSIndexPath[],UIKit.UITableViewRowAnimation)" />.</para>
          <para>This method must be implemented to enable the swipe-to-delete feature of the table view control.</para>
          <para>Application developers should not call <see cref="M:UIKit.UITableView.SetEditing(System.Boolean,System.Boolean)" /> in this method. If for some reason this is necessary, developers must invoke it after a delay using <see cref="M:Foundation.PerformSelector(ObjCRuntime.Selector,Foundation.NSObject,System.Double)" />.</para>
          <para>[UITableViewDataSource]</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCell">
      <MemberSignature Language="C#" Value="public abstract UIKit.UITableViewCell GetCell (UIKit.UITableView tableView, Foundation.NSIndexPath indexPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class UIKit.UITableViewCell GetCell(class UIKit.UITableView tableView, class Foundation.NSIndexPath indexPath) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("tableView:cellForRowAtIndexPath:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UITableViewCell</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tableView" Type="UIKit.UITableView" />
        <Parameter Name="indexPath" Type="Foundation.NSIndexPath" />
      </Parameters>
      <Docs>
        <param name="tableView">Table view requesting the cell.</param>
        <param name="indexPath">Location of the row where the cell will be displayed.</param>
        <summary>Called by the table view to get populate the row at <paramref name="indexPath" /> with a cell view.</summary>
        <returns>An object that inherits from <see cref="T:UIKit.UITableViewCell" /> that the table can use for the specified row. Do not return <see langword="null" /> or an assertion will be raised.</returns>
        <remarks>
          <para>This method is called once for each row that is visible on screen. During scrolling, it is called additional times as new rows come into view. Cells that disappear from view are cached by the table view. The implementation of this method should call the table view's <see cref="M:UIKit.UITableView.DequeueReusableCell(Foundation.NSString)" /> method to obtain a cached cell object for reuse. If <see cref="M:UIKit.UITableView.RegisterClassForCellReuse" /> or <see cref="M:UIKit.UITableView.RegisterNibForCellReuse" /> have not been called during initialization, application developers must check the result of <see cref="M:UIKit.UITableView.DequeueReusableCell" /> for <see langword="null" /> and instantiate a new <see cref="T:UIKit.UITableViewCell" /> as necessary).</para>
          <para>Once a cell is retrieved, all of its relevant properties must be set based on the <paramref name="indexPath" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveRow">
      <MemberSignature Language="C#" Value="public virtual void MoveRow (UIKit.UITableView tableView, Foundation.NSIndexPath sourceIndexPath, Foundation.NSIndexPath destinationIndexPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MoveRow(class UIKit.UITableView tableView, class Foundation.NSIndexPath sourceIndexPath, class Foundation.NSIndexPath destinationIndexPath) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("tableView:moveRowAtIndexPath:toIndexPath:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tableView" Type="UIKit.UITableView" />
        <Parameter Name="sourceIndexPath" Type="Foundation.NSIndexPath" />
        <Parameter Name="destinationIndexPath" Type="Foundation.NSIndexPath" />
      </Parameters>
      <Docs>
        <param name="tableView">Table view containing the row being moved.</param>
        <param name="sourceIndexPath">Location of the row to be moved.</param>
        <param name="destinationIndexPath">New location of the row.</param>
        <summary>Called when a row has been moved so that the data source can 'implement' the changed row position that has been performed in the user interface. This ensures the data is kept in-sync with what is being displayed.</summary>
        <remarks>
          <para>When a row is moved (when the table view is in edit mode), the source needs to be updated to reflect that change. Implement this method to persist the updated row position in the data source.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NumberOfSections">
      <MemberSignature Language="C#" Value="public virtual nint NumberOfSections (UIKit.UITableView tableView);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.nint NumberOfSections(class UIKit.UITableView tableView) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("numberOfSectionsInTableView:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.nint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tableView" Type="UIKit.UITableView" />
      </Parameters>
      <Docs>
        <param name="tableView">Table view displaying the sections.</param>
        <summary>Returns the number of sections that are required to display the data.</summary>
        <returns>Number of sections required to display the data. The default is 1 (a table must have at least one section).</returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="RowsInSection">
      <MemberSignature Language="C#" Value="public abstract nint RowsInSection (UIKit.UITableView tableView, nint section);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.nint RowsInSection(class UIKit.UITableView tableView, valuetype System.nint section) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("tableView:numberOfRowsInSection:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.nint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tableView" Type="UIKit.UITableView" />
        <Parameter Name="section" Type="System.nint" />
      </Parameters>
      <Docs>
        <param name="tableView">To be added.</param>
        <param name="section">Index of the section containing the rows.</param>
        <summary>Called by the table view to find out how many rows are to be rendered in the section specified by <paramref name="section" />.</summary>
        <returns>Number of rows in the section at index <paramref name="section" />.</returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="SectionFor">
      <MemberSignature Language="C#" Value="public virtual nint SectionFor (UIKit.UITableView tableView, string title, nint atIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.nint SectionFor(class UIKit.UITableView tableView, string title, valuetype System.nint atIndex) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("tableView:sectionForSectionIndexTitle:atIndex:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 10, 2, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.nint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tableView" Type="UIKit.UITableView" />
        <Parameter Name="title" Type="System.String" />
        <Parameter Name="atIndex" Type="System.nint" />
      </Parameters>
      <Docs>
        <param name="tableView">Table view containing the section.</param>
        <param name="title">The title that's displayed in the table view's index.</param>
        <param name="atIndex">The index of the title in the array returned from the <see cref="M:UIKit.UITableViewSource.SectionIndexTitles" />.</param>
        <summary>Returns the index of the section with the given <paramref name="tableView" /> and <paramref name="atIndex" />.</summary>
        <returns>The index of the section in the table view.</returns>
        <remarks>
          <para>This method is only required for table views that have an index: they must have the <see cref="F:UIKit.UITableViewStyle.Plain" /> style and implement the <see cref="M:UIKit.UITableViewSource.SectionIndexTitles" /> property.</para>
          <para>The index for a table view may contain fewer items than the number of actual sections in the table. This method is passed the text and index of an item in the index, and should return the position of the corresponding section. </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SectionIndexTitles">
      <MemberSignature Language="C#" Value="public virtual string[] SectionIndexTitles (UIKit.UITableView tableView);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] SectionIndexTitles(class UIKit.UITableView tableView) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("sectionIndexTitlesForTableView:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 10, 2, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tableView" Type="UIKit.UITableView" />
      </Parameters>
      <Docs>
        <param name="tableView">Table view that is displaying the index.</param>
        <summary>Returns an array of titles to be displayed as an index on the table view.</summary>
        <returns>Array of titles, for example to display an alphabetized list return an array of strings from "A" to "Z".</returns>
        <remarks>
          <para>The index list appears along the right edge of a table view.</para>
          <para>Only tables with the <see cref="F:UIKit.UITableViewStyle.Plain" /> style should implement this property.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TitleForFooter">
      <MemberSignature Language="C#" Value="public virtual string TitleForFooter (UIKit.UITableView tableView, nint section);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string TitleForFooter(class UIKit.UITableView tableView, valuetype System.nint section) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("tableView:titleForFooterInSection:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tableView" Type="UIKit.UITableView" />
        <Parameter Name="section" Type="System.nint" />
      </Parameters>
      <Docs>
        <param name="tableView">Table view containing the section.</param>
        <param name="section">Index of the section displaying the footer.</param>
        <summary>Called to populate the footer for the specified section.</summary>
        <returns>Text to display in the section footer, or <see langword="null" /> if no title is required.</returns>
        <remarks>
          <para>Table views use a fixed style for the section footer. To customize the appearance of the footer, return a custom view from <see cref="M:UIKit.UITableViewSource.GetViewForFooter(UIKit.UITableView,System.Int32)" /> instead of implementing this method.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TitleForHeader">
      <MemberSignature Language="C#" Value="public virtual string TitleForHeader (UIKit.UITableView tableView, nint section);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string TitleForHeader(class UIKit.UITableView tableView, valuetype System.nint section) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("tableView:titleForHeaderInSection:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tableView" Type="UIKit.UITableView" />
        <Parameter Name="section" Type="System.nint" />
      </Parameters>
      <Docs>
        <param name="tableView">Table view containing the section.</param>
        <param name="section">Index of the section displaying the header.</param>
        <summary>Called to populate the header for the specified section.</summary>
        <returns>Text to display in the section header, or <see langword="null" /> if no title is required.</returns>
        <remarks>
          <para>Table views use a fixed style for the section header. To customize the appearance of the header, return a custom view from <see cref="M:UIKit.UITableViewSource.GetViewForHeader(UIKit.UITableView,System.Int32)" /> instead of implementing this method.</para>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>