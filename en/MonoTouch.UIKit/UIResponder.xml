<Type Name="UIResponder" FullName="MonoTouch.UIKit.UIResponder">
  <TypeSignature Language="C#" Value="public class UIResponder : MonoTouch.Foundation.NSObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit UIResponder extends MonoTouch.Foundation.NSObject" />
  <AssemblyInfo apistyle="old">
    <AssemblyName>monotouch</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo apistyle="new">
    <AssemblyName>Xamarin.iOS</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>MonoTouch.Foundation.NSObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>MonoTouch.Foundation.Register("UIResponder", true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Base class for objects that respond or handle events.</summary>
    <remarks>
      <para>

	This is the base class for <see cref="T:MonoTouch.UIKit.UIView" /> (and by extension, <see cref="T:MonoTouch.UIKit.UIWindow" />), <see cref="T:MonoTouch.UIKit.UIViewController" /> and <see cref="T:MonoTouch.UIKit.UIApplication" />.
      </para>
      <format type="text/html">
        <h4>Responder Chain</h4>
      </format>
      <para>

	iOS implements a responder chain that allows various events
	(Touch events, device motion events, actions and menu editing
	options) to be handled at various levels depending on who is
	interested in handling the event.  
      </para>
      <para>

	When a touch takes place, the operating system packages the
	event and processes it like this:
      <img href="UIResponderChain.png" /></para>
      <list type="number">
        <item>
          <term>
	    The <see cref="T:MonoTouch.UIKit.UIView" /> where the touch took place is determined by using the <see cref="M:MonoTouch.UIKit.UIView.HitTest(System.Drawing.PointF, MonoTouch.UIKit.UIEvent" /> 
	    and the touch is sent to that view.   
	  </term>
        </item>
        <item>
          <term>

	    If the view did not handle the event, the message is sents
	    to its <see cref="T:MonoTouch.UIKit.UIViewController" /> if
	    there is one, or to its <see cref="P:MonoTouch.UIKit.UIView.SuperView" /> if there is no
	    view controller.

	  </term>
        </item>
        <item>
          <term>
	    The process is repeated for each superview, until it reaches the topmost <see cref="T:MonoTouch.UIKit.UIWindow" />.
	  </term>
        </item>
        <item>
          <term>
	    If the topmost UIWindow does not handle the event, the message is sent to the <see cref="T:MonoTouch.UIKit.UIApplication" />.
	  </term>
        </item>
      </list>
      <para>

	To receive messages UIResponders override the <see cref="P:MonoTouch.UIKit.UIResponder.CanBecomeFirstResponder" />
	property to return true and are notified that they became the
	first responder when the <see cref="M:MonoTouch.UIKit.UIResponder.BecomeFirstResponder()" />
	is invoked.  The system calls <see cref="M:MonoTouch.UIKit.UIResponder.ResignFirstResponder()" />
	to notify a the first responder that the first responder is
	changing.  Text input responders will typically override both
	methods to activate and deactivate the virtual keyboard.

      </para>
      <para>

	For action messages, editing menu messages, remote events and
	motion events are sent to the designated first responder.
	These events, if they are not handled are bubbled up the
	responder chain by sending the message to the <see cref="P:MonoTouch.UIKit.UIResponder.NextResponder" />.
	Developers that override any of the UIResponder methods for
	these kinds of events should avoid directly calling the
	NextResponder methods, instead they should just call the base
	implementation which takes care of the proper event bubbling.

      </para>
      <format type="text/html">
        <h4>Touch Events</h4>
      </format>
      <para>
	When an event is delivered to the topmost <see cref="T:MonoTouch.UIKit.UIView" />, if the event is not
	handled, it is sent to its container recursively.  The
	container can be a<see cref="T:MonoTouch.UIKit.UIView" />, a
	<see cref="T:MonoTouch.UIKit.UIWindow" />, a <see cref="T:MonoTouch.UIKit.UIViewController" /> or the <see cref="T:MonoTouch.UIKit.UIApplication" />.  This allows
	developers to override the event handling methods at the level
	that is most convenient for them.   
      </para>
      <para>
	iOS creates a <see cref="T:MonoTouch.UIKit.UIEvent" /> object any time a
	finger touches the screen, moves or is removed from the
	screen.  The touch events are processed by the UIResponder by calling one of <see cref="M:MonoTouch.UIKit.UIResponder.TouchesBegan" />, <see cref="M:MonoTouch.UIKit.UIResponder.TouchesMoved" />, <see cref="M:MonoTouch.UIKit.UIResponder.TouchesEnded" />, and <see cref="M:MonoTouch.UIKit.UIResponder.TouchesCancelled" />.
      </para>
      <para>
	An <see cref="T:MonoTouch.UIKit.UIEvent" /> encapsulates all of the
	touches that are taking place on the screen at this point,
	even those that do not belong to the particular view.  In addition to
	the <see cref="T:MonoTouch.UIKit.UIEvent" />, an <see cref="T:MonoTouch.Foundation.NSSet" /> containing
	<see cref="T:MonoTouch.UIKit.UITouch" /> objects that represent the state of
	each finger on the screen is sent to the various Touch methods.  
      </para>
      <para>
	It is considered a good coding practice to override all of the
	touch event methods.  If your application is tracking state in
	response to a <see cref="M:MonoTouch.UIKit.UIResponder.TouchesBegan(MonoTouch.Foundation.NSSet, MonoTouch.UIKit.UIEvent)" /> or a <see cref="M:MonoTouch.UIKit.UIResponder.TouchesMoved(MonoTouch.Foundation.NSSet , MonoTouch.UIKit.UIEvent)" /> they should reset their state on the <see cref="M:MonoTouch.UIKit.UIResponder.TouchesEnded(MonoTouch.Foundation.NSSet, MonoTouch.UIKit.UIEvent)" /> and <see cref="M:MonoTouch.UIKit.UIResponder.TouchesCancelled(MonoTouch.Foundation.NSSet, MonoTouch.UIKit.UIEvent)" /> methods.
      </para>
      <format type="text/html">
        <h4>Motion Events</h4>
      </format>
      <para>
	Device motion events are also delivered to UIResponders.
	These are generated when the device moves (shakes).  The
	operating system calls the <see cref="M:MonoTouch.UIKit.UIResponder.MotionBegan(MonoTouch.UIKit.UIEventSubtype, MonoTouch.UIKit.UIEvent)" />
	when the motion begins, the <see cref="M:MonoTouch.UIKit.UIResponder.MotionCancelled(MonoTouch.UIKit.UIEventSubtype, MonoTouch.UIKit.UIEvent)" />
	if the motion event is cancelled, and <see cref="M:MonoTouch.UIKit.UIResponder.MotionEnded(MonoTouch.UIKit.UIEventSubtype, MonoTouch.UIKit.UIEvent)" />
	when the shaking stops.   Shakes are aggregated.
      </para>
      <para>
	In particular, <see cref="T:MonoTouch.UIKit.UIView" /> bubbles
	the events up the responder chain.
      </para>
      <para>
	Just like touch events, developers that override these methods
	are encouraged to override them all and ensure that any
	resources allocated during an initial motion event are
	properly disposed either during the MotionENded or
	MotionCancelled methods.
      </para>
      <format type="text/html">
        <h4>Standard Edit Actions</h4>
      </format>
      <para>
	The following methods are part of the standard edit protocol.
	You can implement these in your UIResponder to participate in
	these standard operations: <see cref="M:MonoTouch.UIKit.UIResponder.Copy(MonoTouch.Foundation.NSObject)" />, <see cref="M:MonoTouch.UIKit.UIResponder.Cut(MonoTouch.Foundation.NSObject)" />, <see cref="M:MonoTouch.UIKit.UIResponder.Delete(MonoTouch.Foundation.NSObject)" />, <see cref="M:MonoTouch.UIKit.UIResponder.Select(MonoTouch.Foundation.NSObject)" />, <see cref="M:MonoTouch.UIKit.UIResponder.SelectAll(MonoTouch.Foundation.NSObject)" /> and <see cref="M:MonoTouch.UIKit.UIResponder.Paste(MonoTouch.Foundation.NSObject)" />.
      </para>
      <para>
	The following methods are used to change the styling of text:
	<see cref="M:MonoTouch.UIKit.UIResponder.ToggleBoldface(MonoTouch.Foundation.NSObject)" />,
	<see cref="M:MonoTouch.UIKit.UIResponder.ToggleItalics(MonoTouch.Foundation.NSObject)" /> and
	<see cref="M:MonoTouch.UIKit.UIResponder.ToggleUnderline(MonoTouch.Foundation.NSObject)" />.
      </para>
      <para>

	If you are implementing a UIResponder subclass (like your own
	UIView) and you want it to display the standard editing menu,
	you must: override <see cref="P:MonoTouch.UIKit.UIResponder.CanBecomeFirstResponder" />
	and return true, override the <see cref="M:MonoTouch.UIKit.UIResponder.CanPerform" /> method and
	return true for all actions that you support and override the
	methods that actually carry out the action (the ones listed in
	"Standard Edit Actions" above)

      </para>
      <example>
        <code lang="c#">
//
// Selectable label: a label that shows the "Copy" menu when the user
// long presses
//
public class SelectableLabel : UILabel {

    public SelectableLabel (RectangleF rect) : base (rect)
    {
    	UserInteractionEnabled = true;
    	var gesture = new UILongPressGestureRecognizer (LongPress);
    	AddGestureRecognizer (gesture);
    }
    
    void LongPress (UILongPressGestureRecognizer r)
    {
    	var location = r.LocationInView (r.View);
    	var menu = UIMenuController.SharedMenuController;
    
    	r.View.BecomeFirstResponder ();
    
    	menu.SetTargetRect (r.View.Frame, r.View);
    	menu.SetMenuVisible (true, true);
    }
    			
    
    public override bool CanBecomeFirstResponder { 
    	get { return true; } 
    }

    Selector copyAction = new Selector ("copy");

    public override bool CanPerform (Selector action, NSObject withSender)
    {
    	if (action == copyAction);
    		return true;
    	return false;
    }
    
    public override void Copy (NSObject sender)
    {
    	UIPasteboard.General.String = this.Text;
    }
}
</code>
      </example>
    </remarks>
    <altmember cref="T:MonoTouch.UIKit.UIResponder_NSObjectExtension" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIResponder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("init")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Default constructor that initializes a new instance of this class with no parameters.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIResponder (MonoTouch.Foundation.NSCoder coder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class MonoTouch.Foundation.NSCoder coder) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("initWithCoder:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="coder" Type="MonoTouch.Foundation.NSCoder" />
      </Parameters>
      <Docs>
        <param name="coder">The unarchiver object.</param>
        <summary>A constructor that initializes the object from the data stored in the unarchiver object.</summary>
        <remarks>This constructor is provided to allow the class to be initialized from an unarchiver (for example, during NIB deserialization).</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIResponder (MonoTouch.Foundation.NSObjectFlag t);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class MonoTouch.Foundation.NSObjectFlag t) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="t" Type="MonoTouch.Foundation.NSObjectFlag" />
      </Parameters>
      <Docs>
        <param name="t">Unused sentinel value, pass NSObjectFlag.Empty.</param>
        <summary>Constructor to call on derived classes to skip initialization and merely allocate the object.</summary>
        <remarks>
          <para>This constructor should be called by derived classes when they completely construct the object in managed code and merely want the runtime to allocate and initialize the NSObject.   This is required to implement the two-step initialization process that Objective-C uses, the first step is to perform the object allocation, the second step is to initialize the object.   When you invoke the constructor that takes the NSObjectFlag.Empty you taking advantage of a direct path that goes all the way up to NSObject to merely allocate the object's memory and bind the Objective-C and C# objects together.    The actual initialization of the object is up to you.</para>
          <para>This constructor is typically used by the binding generator to allocate the object, but prevent the actual initialization to take place.   Once the allocation has taken place, the constructor has to initialize the object.   With constructors generated by the binding generator this means that it manually invokes one of the "init" methods to initialize the object.</para>
          <para>It is your responsibility to completely initialize the object if you chain up using the NSObjectFlag.Empty path.</para>
          <para>In general, if your constructors invokes the NSObjectFlag.Empty base implementation, then it should be calling an Objective-C init method.   If this is not the case, you should instead chain to the proper constructor in your class. </para>
          <para>The argument value is ignored and merely ensures that the only code that is executed is the construction phase is the basic NSObject allocation and runtime type registration.  Typically the chaining would look like this:</para>
          <example>
            <code lang="C#">
//
// The NSObjectFlag merely allocates the object and registers the
// C# class with the Objective-C runtime if necessary, but no actual
// initXxx method is invoked, that is done later in the constructor
//
// This is taken from MonoTouch's source code:
//
[Export ("initWithFrame:")]
public UIView (System.Drawing.RectangleF frame) : base (NSObjectFlag.Empty)
{
// Invoke the init method now.
	var initWithFrame = new Selector ("initWithFrame:").Handle;
	if (IsDirectBinding)
		Handle = MonoTouch.ObjCRuntime.Messaging.IntPtr_objc_msgSend_RectangleF (this.Handle, initWithFrame, frame);
	else
		Handle = MonoTouch.ObjCRuntime.Messaging.IntPtr_objc_msgSendSuper_RectangleF (this.SuperHandle, initWithFrame, frame);
}
</code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIResponder (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Pointer (handle) to the unmanaged object.</param>
        <summary>A constructor used when creating managed representations of unmanaged objects;  Called by the runtime.</summary>
        <remarks>
          <para>This constructor is invoked by the runtime infrastructure (<see cref="M:MonoTouch.ObjCRuntime.GetNSObject (System.IntPtr)" />) to create a new managed representation for a pointer to an unmanaged Objective-C object.    You should not invoke this method directly, instead you should call the GetNSObject method as it will prevent two instances of a managed object to point to the same native object.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityCustomActions">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIAccessibilityCustomAction[] AccessibilityCustomActions { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIAccessibilityCustomAction[] AccessibilityCustomActions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(8, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("accessibilityCustomActions")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(8, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setAccessibilityCustomActions:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.ObjCRuntime.Since(8, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIAccessibilityCustomAction[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityDecrement">
      <MemberSignature Language="C#" Value="public virtual void AccessibilityDecrement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AccessibilityDecrement() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("accessibilityDecrement")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tells the accessibility element to decrement the value of its content.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityElementDidBecomeFocused">
      <MemberSignature Language="C#" Value="public virtual void AccessibilityElementDidBecomeFocused ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AccessibilityElementDidBecomeFocused() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("accessibilityElementDidBecomeFocused")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityElementDidLoseFocus">
      <MemberSignature Language="C#" Value="public virtual void AccessibilityElementDidLoseFocus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AccessibilityElementDidLoseFocus() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("accessibilityElementDidLoseFocus")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityElementIsFocused">
      <MemberSignature Language="C#" Value="public virtual bool AccessibilityElementIsFocused ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool AccessibilityElementIsFocused() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("accessibilityElementIsFocused")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityIncrement">
      <MemberSignature Language="C#" Value="public virtual void AccessibilityIncrement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AccessibilityIncrement() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("accessibilityIncrement")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tells the accessibility element to increment the value of its content.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityPerformEscape">
      <MemberSignature Language="C#" Value="public virtual bool AccessibilityPerformEscape ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool AccessibilityPerformEscape() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("accessibilityPerformEscape")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(5, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tells the accessibility system to dismiss a modal popover or hiearchically-displayed element.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityPerformMagicTap">
      <MemberSignature Language="C#" Value="public virtual bool AccessibilityPerformMagicTap ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool AccessibilityPerformMagicTap() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("accessibilityPerformMagicTap")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Toggles the application-defined "most important state" of the app. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityScroll">
      <MemberSignature Language="C#" Value="public virtual bool AccessibilityScroll (MonoTouch.UIKit.UIAccessibilityScrollDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool AccessibilityScroll(valuetype MonoTouch.UIKit.UIAccessibilityScrollDirection direction) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("accessibilityScroll:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(4, 2)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="MonoTouch.UIKit.UIAccessibilityScrollDirection" />
      </Parameters>
      <Docs>
        <param name="direction">To be added.</param>
        <summary>When overridden, allows the accessibility system to perform scrolling.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BecomeFirstResponder">
      <MemberSignature Language="C#" Value="public virtual bool BecomeFirstResponder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool BecomeFirstResponder() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("becomeFirstResponder")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Request the object to become the first responder.</summary>
        <returns>Returns true if the object accepts becoming the first responder, or false if it does not.   The default is to accept.</returns>
        <remarks>
          <para>

	    You can overwrite this method to detect when your
	    UIResponder object becomes the first responder and to
	    either accept or reject the request.

	  </para>
          <para>

	    Typically this method is invoked by application code to
	    request that a specific object become the first responder.
	    Typically to give the focus to a UIView, for example, to
	    focus a <see cref="T:MonoTouch.UIKit.UITextField" /> or a
	    <see cref="T:MonoTouch.UIKit.UITextView" />.

	  </para>
          <para>

	    It is possible for this call to fail if the current first
	    responder refuses to give up control.  This condition can
	    be detected by probing the <see cref="P:MonoTouch.UIKit.UIResponder.CanResignFirstResponder" />.
	    
	  </para>
          <para>

	    This method is only valid if invoked in a UIResponder that
	    is part of the currently active responder chain.  Sending
	    this to a UIView that has not been added to a responder
	    chain does nothing.

	  </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanBecomeFirstResponder">
      <MemberSignature Language="C#" Value="public virtual bool CanBecomeFirstResponder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanBecomeFirstResponder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("canBecomeFirstResponder")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determines whether this UIREsponder is willing to become the first responder.</summary>
        <value>
        </value>
        <remarks>
          <para>

	    Developers that want to write UIResponders that are
	    interested in receiving touch events or action messages
	    must override this method and return true.

	  </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanPerform">
      <MemberSignature Language="C#" Value="public virtual bool CanPerform (MonoTouch.ObjCRuntime.Selector action, MonoTouch.Foundation.NSObject withSender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanPerform(class MonoTouch.ObjCRuntime.Selector action, class MonoTouch.Foundation.NSObject withSender) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("canPerformAction:withSender:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="MonoTouch.ObjCRuntime.Selector" />
        <Parameter Name="withSender" Type="MonoTouch.Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="action">The selector that represents the action that is being probed.  For editing operations, these selectors are "copy:", "cut:", "delete:", "paste:", "select:", "selectAll:", "toggleBoldface:", "toggleItalics:", "toggleUnderline:".</param>
        <param name="withSender">
          <para>The object invoking this method.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Determines if this UIResponder can perform the specified action.  Typically used to probe for editing commands.</summary>
        <returns>True if the specified action can be performed with the specified sender.</returns>
        <remarks>
          <para>
	    This method should return true if the action specified by the selector can be performed by the object.
	  </para>
          <example>
            <code lang="c#">
//
// Selectable label: a label that shows the "Copy" menu when the user
// long presses
//
public class SelectableLabel : UILabel {

    public SelectableLabel (RectangleF rect) : base (rect)
    {
    	UserInteractionEnabled = true;
    	var gesture = new UILongPressGestureRecognizer (LongPress);
    	AddGestureRecognizer (gesture);
    }
    
    void LongPress (UILongPressGestureRecognizer r)
    {
    	var location = r.LocationInView (r.View);
    	var menu = UIMenuController.SharedMenuController;
    
    	r.View.BecomeFirstResponder ();
    
    	menu.SetTargetRect (r.View.Frame, r.View);
    	menu.SetMenuVisible (true, true);
    }
    			
    
    public override bool CanBecomeFirstResponder { 
    	get { return true; } 
    }

    Selector copyAction = new Selector ("copy");

    public override bool CanPerform (Selector action, NSObject withSender)
    {
    	if (action == copyAction);
    		return true;
    	return false;
    }
    
    public override void Copy (NSObject sender)
    {
    	UIPasteboard.General.String = this.Text;
    }
}
	    </code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanResignFirstResponder">
      <MemberSignature Language="C#" Value="public virtual bool CanResignFirstResponder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanResignFirstResponder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("canResignFirstResponder")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determines whether this UIResponder is willing to give up its first responder status.</summary>
        <value>
        </value>
        <remarks>Developers can override this method if they want to prevent their view from relinquishing their first responder status.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClassHandle">
      <MemberSignature Language="C#" Value="public override IntPtr ClassHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ClassHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The handle for this class.</summary>
        <value>The pointer to the Objective-C class.</value>
        <remarks>Each MonoTouch class mirrors an unmanaged Objective-C class.   This value contains the pointer to the Objective-C class, it is similar to calling objc_getClass with the object name.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearTextInputContextIdentifier">
      <MemberSignature Language="C#" Value="public static void ClearTextInputContextIdentifier (MonoTouch.Foundation.NSString identifier);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ClearTextInputContextIdentifier(class MonoTouch.Foundation.NSString identifier) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("clearTextInputContextIdentifier:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identifier" Type="MonoTouch.Foundation.NSString" />
      </Parameters>
      <Docs>
        <param name="identifier">To be added.</param>
        <summary>Clears the text input mode information from the application's user defaults.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public virtual void Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Copy() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Override Copy(NSObject)")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Application developers should not use this obsolete method.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public virtual void Copy (MonoTouch.Foundation.NSObject sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Copy(class MonoTouch.Foundation.NSObject sender) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("copy:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="MonoTouch.Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="sender">Object calling this method.</param>
        <summary>Indicates a "Copy" editing operation.</summary>
        <remarks>
          <para>
	    Applications overriding this method should expose the selected information and pass it to the <see cref="P:MonoTouch.UIKit.UIPasteboard" />. 
	  </para>
          <para>
	    You can invoke the Copy method to retrieve the contents of the object and have them on the pasteboard, for example:
	  </para>
          <example>
            <code lang="c#">
void MakeCopy (UITextField field)
{
	field.Copy (this);
}
</code>
          </example>
          <para>
	    The following example shows how to implement the Copy method on your own subclass of UIResponder.
	  </para>
          <example>
            <code lang="c#">
//
// Selectable label: a label that shows the "Copy" menu when the user
// long presses
//
public class SelectableLabel : UILabel {

    public SelectableLabel (RectangleF rect) : base (rect)
    {
    	UserInteractionEnabled = true;
    	var gesture = new UILongPressGestureRecognizer (LongPress);
    	AddGestureRecognizer (gesture);
    }
    
    void LongPress (UILongPressGestureRecognizer r)
    {
    	var location = r.LocationInView (r.View);
    	var menu = UIMenuController.SharedMenuController;
    
    	r.View.BecomeFirstResponder ();
    
    	menu.SetTargetRect (r.View.Frame, r.View);
    	menu.SetMenuVisible (true, true);
    }
    			
    
    public override bool CanBecomeFirstResponder { 
    	get { return true; } 
    }

    Selector copyAction = new Selector ("copy");

    public override bool CanPerform (Selector action, NSObject withSender)
    {
    	if (action == copyAction);
    		return true;
    	return false;
    }
    
    public override void Copy (NSObject sender)
    {
    	UIPasteboard.General.String = this.Text;
    }
}
</code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cut">
      <MemberSignature Language="C#" Value="public virtual void Cut ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Cut() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Override Cut(NSObject)")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Application developers should not use this obsolete method.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cut">
      <MemberSignature Language="C#" Value="public virtual void Cut (MonoTouch.Foundation.NSObject sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Cut(class MonoTouch.Foundation.NSObject sender) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("cut:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="MonoTouch.Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="sender">Object calling this method.</param>
        <summary>Indicates a "Cut" editing operation.</summary>
        <remarks>To be added.</remarks>
        <para>

	    Applications overriding this method should expose the
	    selected information and pass it to the <see cref="P:MonoTouch.UIKit.UIPasteboard" /> and also remove
	    the selected element from the user interface.

	  </para>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public virtual void Delete ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Delete() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Override Delete(NSObject)")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Application developers should not use this obsolete method.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public virtual void Delete (MonoTouch.Foundation.NSObject sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Delete(class MonoTouch.Foundation.NSObject sender) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("delete:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="MonoTouch.Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="sender">Object calling this method.</param>
        <summary>Indicates a "Delete" editing operation.</summary>
        <remarks>Applications should remove the selected element from the user interface.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <para>If set to <see langword="true" />, the method is invoked directly and will dispose manage and unmanaged resources;   If set to <see langword="false" /> the method is being called by the garbage collector finalizer and should only release unmanaged resources.</para>
        </param>
        <summary>Releases the resources used by the UIResponder object.</summary>
        <remarks>
          <para>This Dispose method releases the resources used by the UIResponder class.</para>
          <para>This method is called by both the Dispose() method and the object finalizer (Finalize).    When invoked by the Dispose method, the parameter disposing <paramref name="disposing" /> is set to <see langword="true" /> and any managed object references that this object holds are also disposed or released;  when invoked by the object finalizer, on the finalizer thread the value is set to <see langword="false" />. </para>
          <para>Calling the Dispose method when you are finished using the UIResponder ensures that all external resources used by this managed object are released as soon as possible.  Once you have invoked the Dispose method, the object is no longer useful and you should no longer make any calls to it.</para>
          <para>  For more information on how to override this method and on the Dispose/IDisposable pattern, read the ``Implementing a Dispose Method'' document at http://msdn.microsoft.com/en-us/library/fs2xkftw.aspx</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTargetForAction">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.Foundation.NSObject GetTargetForAction (MonoTouch.ObjCRuntime.Selector action, MonoTouch.Foundation.NSObject sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class MonoTouch.Foundation.NSObject GetTargetForAction(class MonoTouch.ObjCRuntime.Selector action, class MonoTouch.Foundation.NSObject sender) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("targetForAction:withSender:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="MonoTouch.ObjCRuntime.Selector" />
        <Parameter Name="sender" Type="MonoTouch.Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="action">The selector that represents the action that is being probed.  For editing operations, these selectors are "copy:", "cut:", "delete:", "paste:", "select:", "selectAll:", "toggleBoldface:", "toggleItalics:", "toggleUnderline:".</param>
        <param name="sender">Object calling this method.</param>
        <summary>Returns the object that responds to an action.</summary>
        <returns>The object that can handle the action.</returns>
        <remarks>
          <para> 
	    The default implementation of this method calls the <see cref="T:MonoTouch.UIKit.UIResponder.CanPerform" /> method, and if it returns true, it returns this instance.   
	  </para>
          <para>
	    This method can be overwritten to provide a different behavior than the default.
	  </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputAccessoryView">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIView InputAccessoryView { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIView InputAccessoryView" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(3, 2)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("inputAccessoryView")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(3, 2)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Custom view that can be attached when the object becomes the first responder.</summary>
        <value>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InputAccessoryViewController">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIInputViewController InputAccessoryViewController { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIInputViewController InputAccessoryViewController" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("inputAccessoryViewController")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIInputViewController</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InputView">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIView InputView { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIView InputView" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(3, 2)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("inputView")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(3, 2)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Custom view to display when the object becomes the first responder. Read-only.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InputViewController">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIInputViewController InputViewController { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIInputViewController InputViewController" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("inputViewController")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIInputViewController</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFirstResponder">
      <MemberSignature Language="C#" Value="public virtual bool IsFirstResponder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFirstResponder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("isFirstResponder")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns whether this UIResponder is the First Responder.</summary>
        <value>
        </value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyCommands">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIKeyCommand[] KeyCommands { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIKeyCommand[] KeyCommands" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("keyCommands")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIKeyCommand[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The key commands that should trigger action on this UIResponder. Read-only.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeTextWritingDirectionLeftToRight">
      <MemberSignature Language="C#" Value="public virtual void MakeTextWritingDirectionLeftToRight (MonoTouch.Foundation.NSObject sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MakeTextWritingDirectionLeftToRight(class MonoTouch.Foundation.NSObject sender) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("makeTextWritingDirectionLeftToRight:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(5, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="MonoTouch.Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="sender">Object calling this method.</param>
        <summary>Sets the direction in which text is written to be left-to-right.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeTextWritingDirectionRightToLeft">
      <MemberSignature Language="C#" Value="public virtual void MakeTextWritingDirectionRightToLeft (MonoTouch.Foundation.NSObject sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MakeTextWritingDirectionRightToLeft(class MonoTouch.Foundation.NSObject sender) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("makeTextWritingDirectionRightToLeft:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(5, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="MonoTouch.Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="sender">Object calling this method.</param>
        <summary>Sets the direction in which text is written to be right-to-left.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MotionBegan">
      <MemberSignature Language="C#" Value="public virtual void MotionBegan (MonoTouch.UIKit.UIEventSubtype motion, MonoTouch.UIKit.UIEvent evt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MotionBegan(valuetype MonoTouch.UIKit.UIEventSubtype motion, class MonoTouch.UIKit.UIEvent evt) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("motionBegan:withEvent:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="motion" Type="MonoTouch.UIKit.UIEventSubtype" />
        <Parameter Name="evt" Type="MonoTouch.UIKit.UIEvent" />
      </Parameters>
      <Docs>
        <param name="motion">To be added.</param>
        <param name="evt">To be added.</param>
        <summary>Method invoked when a motion (a shake) has started.</summary>
        <remarks>
          <para>
	    In particular, <see cref="T:MonoTouch.UIKit.UIView" /> bubbles
	    the events up the responder chain.
	  </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MotionCancelled">
      <MemberSignature Language="C#" Value="public virtual void MotionCancelled (MonoTouch.UIKit.UIEventSubtype motion, MonoTouch.UIKit.UIEvent evt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MotionCancelled(valuetype MonoTouch.UIKit.UIEventSubtype motion, class MonoTouch.UIKit.UIEvent evt) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("motionCancelled:withEvent:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="motion" Type="MonoTouch.UIKit.UIEventSubtype" />
        <Parameter Name="evt" Type="MonoTouch.UIKit.UIEvent" />
      </Parameters>
      <Docs>
        <param name="motion">The event subtype.</param>
        <param name="evt">UIEvent describing the motion.</param>
        <summary>Method invoked if the operating system cancels a motion (shake) event.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MotionEnded">
      <MemberSignature Language="C#" Value="public virtual void MotionEnded (MonoTouch.UIKit.UIEventSubtype motion, MonoTouch.UIKit.UIEvent evt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MotionEnded(valuetype MonoTouch.UIKit.UIEventSubtype motion, class MonoTouch.UIKit.UIEvent evt) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("motionEnded:withEvent:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="motion" Type="MonoTouch.UIKit.UIEventSubtype" />
        <Parameter Name="evt" Type="MonoTouch.UIKit.UIEvent" />
      </Parameters>
      <Docs>
        <param name="motion">The event subtype.</param>
        <param name="evt">UIEvent describing the motion.</param>
        <summary>Method invoked when a motion (shake) has finished.</summary>
        <remarks>
          <para>
	    In particular, <see cref="T:MonoTouch.UIKit.UIView" /> bubbles
	    the events up the responder chain.
	  </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NextResponder">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIResponder NextResponder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIResponder NextResponder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("nextResponder")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIResponder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The next responder on the response chain</summary>
        <value>To be added.</value>
        <remarks>
          <para>
	    This property returns the next responder in the chain.   For <see cref="T:MonoTouch.UIKit.UIView" /> objects, this returns the managing <see cref="T:MonoTouch.UIKit.UIViewController" />, or the <see cref="P:MonoTouch.UIKit.UIView.Superview" /> if the controller is not set.   For the <see cref="T:MonoTouch.UIKit.UIViewController" />, this returns its view's <see cref="P:MonoTouch.UIKit.UIView.Superview" />.   For <see cref="T:MonoTouch.UIKit.UIWindow" />s, this returns the <see cref="T:MonoTouch.UIKit.UIApplication" /> object.   <see cref="T:MonoTouch.UIKit.UIApplication" /> objects return null.
	  </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Paste">
      <MemberSignature Language="C#" Value="public virtual void Paste ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Paste() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Override Paste(NSObject)")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Application developer should not use this obsolete method.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Paste">
      <MemberSignature Language="C#" Value="public virtual void Paste (MonoTouch.Foundation.NSObject sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Paste(class MonoTouch.Foundation.NSObject sender) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("paste:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="MonoTouch.Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="sender">Object calling this method.</param>
        <summary>Indicates a "Paste" editing operation.</summary>
        <remarks>
          <para>

	    Applications overriding this method should probe the <see cref="P:MonoTouch.UIKit.UIPasteboard" /> and try to fetch
	    the information available there and insert it.

	  </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReloadInputViews">
      <MemberSignature Language="C#" Value="public virtual void ReloadInputViews ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReloadInputViews() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("reloadInputViews")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(3, 2)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Updates custom input and accessory views when this object is the first responder.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoteControlReceived">
      <MemberSignature Language="C#" Value="public virtual void RemoteControlReceived (MonoTouch.UIKit.UIEvent theEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoteControlReceived(class MonoTouch.UIKit.UIEvent theEvent) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("remoteControlReceivedWithEvent:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(4, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="theEvent" Type="MonoTouch.UIKit.UIEvent" />
      </Parameters>
      <Docs>
        <param name="theEvent">To be added.</param>
        <summary>Indicates that a remote-control event was received.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResignFirstResponder">
      <MemberSignature Language="C#" Value="public virtual bool ResignFirstResponder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ResignFirstResponder() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("resignFirstResponder")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Called when this UIResponder has been asked to resign its first responder status.</summary>
        <returns>
          <see langword="true" /> if the <see cref="T:MonoTouch.UIKit.UIResponder" /> resigned first responder status.</returns>
        <remarks>
          <para>Even if this method returns <see langword="false" />, the resignation can be forced by the application developer calling <see cref="M:MonoTouch.UIKit.UIView.EndEditing" /> with its <c>force</c> parameter set to <see langword="true" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RestoreUserActivityState">
      <MemberSignature Language="C#" Value="public virtual void RestoreUserActivityState (MonoTouch.Foundation.NSUserActivity activity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RestoreUserActivityState(class MonoTouch.Foundation.NSUserActivity activity) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("restoreUserActivityState:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activity" Type="MonoTouch.Foundation.NSUserActivity" />
      </Parameters>
      <Docs>
        <param name="activity">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public virtual void Select ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Select() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Override Select(NSObject)")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Application developers should not use this obsolete method.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public virtual void Select (MonoTouch.Foundation.NSObject sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Select(class MonoTouch.Foundation.NSObject sender) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("select:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="MonoTouch.Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="sender">Object calling this method.</param>
        <summary>Indicates a "Select" editing operation.|b</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectAll">
      <MemberSignature Language="C#" Value="public virtual void SelectAll ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SelectAll() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Override SelectAll(NSObject)")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Application developers should not use this obsolete method.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectAll">
      <MemberSignature Language="C#" Value="public virtual void SelectAll (MonoTouch.Foundation.NSObject sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SelectAll(class MonoTouch.Foundation.NSObject sender) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("selectAll:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="MonoTouch.Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="sender">Object calling this method.</param>
        <summary>Indicates a "Select All" editing operation.</summary>
        <remarks>
          <para>
	    Clases overriding this method should select all of the information available in the current object.
	  </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextInputContextIdentifier">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.Foundation.NSString TextInputContextIdentifier { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.Foundation.NSString TextInputContextIdentifier" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("textInputContextIdentifier")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An identifier indicating that this UIResponder should preserve its text input mode information. Read-only.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TextInputMode">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UITextInputMode TextInputMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UITextInputMode TextInputMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("textInputMode")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UITextInputMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The text input mode for this UIResponder. Read-only.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToggleBoldface">
      <MemberSignature Language="C#" Value="public virtual void ToggleBoldface (MonoTouch.Foundation.NSObject sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ToggleBoldface(class MonoTouch.Foundation.NSObject sender) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("toggleBoldface:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="MonoTouch.Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="sender">Object calling this method.</param>
        <summary>Toggles the use of a bold font.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToggleItalics">
      <MemberSignature Language="C#" Value="public virtual void ToggleItalics (MonoTouch.Foundation.NSObject sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ToggleItalics(class MonoTouch.Foundation.NSObject sender) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("toggleItalics:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="MonoTouch.Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="sender">Object calling this method.</param>
        <summary>Toggles the use of an italic font.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToggleUnderline">
      <MemberSignature Language="C#" Value="public virtual void ToggleUnderline (MonoTouch.Foundation.NSObject sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ToggleUnderline(class MonoTouch.Foundation.NSObject sender) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("toggleUnderline:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="MonoTouch.Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="sender">Object calling this method.</param>
        <summary>Toggles the use of underlining.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesBegan">
      <MemberSignature Language="C#" Value="public virtual void TouchesBegan (MonoTouch.Foundation.NSSet touches, MonoTouch.UIKit.UIEvent evt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void TouchesBegan(class MonoTouch.Foundation.NSSet touches, class MonoTouch.UIKit.UIEvent evt) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("touchesBegan:withEvent:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="touches" Type="MonoTouch.Foundation.NSSet" />
        <Parameter Name="evt" Type="MonoTouch.UIKit.UIEvent" />
      </Parameters>
      <Docs>
        <param name="touches">Set containing the touches as objects of type <see cref="T:MonoTouch.UIKit.UITouch" />.</param>
        <param name="evt">The UIEvent that encapsulates all of the touches and the event information.</param>
        <summary>Sent when one or more fingers touches the screen.</summary>
        <remarks>
          <para>
	    The <paramref name="touches" /> set containing all of the touch events.
	  </para>
          <para>

	    If your application tracks the touches starting with this
	    method, it should also override both the <see cref="M:MonoTouch.UIKit.UIResponder.TouchesEnded(MonoTouch.Foundation.NSSet,&#xA;     MonoTouch.UIKit.UIEvent)" /> and <see cref="M:MonoTouch.UIKit.UIResponder.TouchesCancelled(MonoTouch.Foundation.NSSet,&#xA;     MonoTouch.UIKit.UIEvent)" /> methods to track the end of
	    the touch processing.

	  </para>
          <para>
	    UIViews by default only receive a single touch event at
	    once, if you want to receive multiple touches at the same
	    time, set the <see cref="P:MonoTouch.UIView.MultipleTouchEnabled" /> property
	    to true.
	  </para>
          <para>
	    If you only want to handle a single touch, the following idiom can be used:
	  </para>
          <example>
            <code lang="C#"><![CDATA[
public override void TouchesBegan (NSSet touches, UIEvent evt)
{
    var touch = touches.AnyObject as UITouch;

    Console.WriteLine (touch);
}
]]></code>
          </example>
          <para>
	    If you want to handle multiple touches, you can use this idiom:
	  </para>
          <example>
            <code lang="C#"><![CDATA[
public override void TouchesBegan (NSSet touches, UIEvent evt)
{
    foreach (UITouch touch in touches.ToArray<UITouch> ()){
        Console.WriteLine (touch);
    }
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesCancelled">
      <MemberSignature Language="C#" Value="public virtual void TouchesCancelled (MonoTouch.Foundation.NSSet touches, MonoTouch.UIKit.UIEvent evt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void TouchesCancelled(class MonoTouch.Foundation.NSSet touches, class MonoTouch.UIKit.UIEvent evt) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("touchesCancelled:withEvent:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="touches" Type="MonoTouch.Foundation.NSSet" />
        <Parameter Name="evt" Type="MonoTouch.UIKit.UIEvent" />
      </Parameters>
      <Docs>
        <param name="touches">Set containing the touches as objects of type <see cref="T:MonoTouch.UIKit.UITouch" />.</param>
        <param name="evt">The UIEvent that encapsulates all of the touches and the event information.</param>
        <summary>Sent when the touch processing has been cancelled.</summary>
        <remarks>
          <para>
	    This method is typically involved because the application
	    was interrupted by an external source, like for example,
	    an incoming phone call.
	  </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesEnded">
      <MemberSignature Language="C#" Value="public virtual void TouchesEnded (MonoTouch.Foundation.NSSet touches, MonoTouch.UIKit.UIEvent evt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void TouchesEnded(class MonoTouch.Foundation.NSSet touches, class MonoTouch.UIKit.UIEvent evt) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("touchesEnded:withEvent:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="touches" Type="MonoTouch.Foundation.NSSet" />
        <Parameter Name="evt" Type="MonoTouch.UIKit.UIEvent" />
      </Parameters>
      <Docs>
        <param name="touches">Set containing the touches as objects of type <see cref="T:MonoTouch.UIKit.UITouch" />.</param>
        <param name="evt">The UIEvent that encapsulates all of the touches and the event information.</param>
        <summary>Sent when one or more fingers are lifted from the screen.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesMoved">
      <MemberSignature Language="C#" Value="public virtual void TouchesMoved (MonoTouch.Foundation.NSSet touches, MonoTouch.UIKit.UIEvent evt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void TouchesMoved(class MonoTouch.Foundation.NSSet touches, class MonoTouch.UIKit.UIEvent evt) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("touchesMoved:withEvent:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="touches" Type="MonoTouch.Foundation.NSSet" />
        <Parameter Name="evt" Type="MonoTouch.UIKit.UIEvent" />
      </Parameters>
      <Docs>
        <param name="touches">Set containing the touches as objects of type <see cref="T:MonoTouch.UIKit.UITouch" />.</param>
        <param name="evt">The UIEvent that encapsulates all of the touches and the event information.</param>
        <summary>Sent when one or more fingers move on the screen.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UndoManager">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.Foundation.NSUndoManager UndoManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.Foundation.NSUndoManager UndoManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("undoManager")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSUndoManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The nearest shared NSUndoManager in the responder chain. Read-only.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateUserActivityState">
      <MemberSignature Language="C#" Value="public virtual void UpdateUserActivityState (MonoTouch.Foundation.NSUserActivity activity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UpdateUserActivityState(class MonoTouch.Foundation.NSUserActivity activity) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("updateUserActivityState:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activity" Type="MonoTouch.Foundation.NSUserActivity" />
      </Parameters>
      <Docs>
        <param name="activity">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UserActivity">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.Foundation.NSUserActivity UserActivity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.Foundation.NSUserActivity UserActivity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="old">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="new">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("userActivity")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setUserActivity:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSUserActivity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>
          <para>(More documentation for this node is coming)</para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
