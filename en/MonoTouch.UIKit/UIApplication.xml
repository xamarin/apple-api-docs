<Type Name="UIApplication" FullName="MonoTouch.UIKit.UIApplication">
  <TypeSignature Language="C#" Value="public class UIApplication : MonoTouch.UIKit.UIResponder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit UIApplication extends MonoTouch.UIKit.UIResponder" />
  <AssemblyInfo>
    <AssemblyName>monotouch</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>MonoTouch.UIKit.UIResponder</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>MonoTouch.Foundation.Register("UIApplication", true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Encapsulates the main processing loop for a MonoTouch application.</summary>
    <remarks>
      <para> 
	The <see cref="T:MonoTouch.UIKit.UIApplication" />
	encapsulates the central administrative properties of an
	application running on iOS. Application developers must not
	instantiate new <see cref="T:MonoTouch.UIKit.UIApplication" />s using constructors, but instead must use the static <see cref="P:MonoTouch.UIKit.UIApplication.SharedApplication" />
        singleton property. Application developers may subclass <see cref="T:MonoTouch.UIKit.UIApplication" /> and use the <c>principalClassName</c> argument to the <see cref="M:MonoTouch.UIKit.UIApplication.Main(string[],string,string)" /> method to specify their subclass. In that situation, developers must create a public constructor for their subclass that the runtime will call appropriately. Subsequently, the <see cref="P:MonoTouch.UIKit.UIApplication.SharedApplication" /> singleton will refer to the instance of their subclass.</para>
      <para> 
	Unlike with most classes in the <see cref="N:MonoTouch.UIKit" /> namespace, events relating to the
        <see cref="T:MonoTouch.UIKit.UIApplication" /> cannot be
        handled using C#-style events but rather only by the
        Objective-C style <see cref="T:MonoTouch.UIKit.UIApplicationDelegate" /> delegate
        style.  </para>
      <para> 
	The <see cref="T:MonoTouch.UIKit.UIApplication" /> object
        is responsible for maintaining the highest-level context of
        the application, such as the <see cref="P:MonoTouch.UIKit.UIApplication.ApplicationState" />,
        the set of open windows (<see cref="P:MonoTouch.UIKit.UIApplication.Windows" />), and
        functions relating to notifications (see also <see cref="T:MonoTouch.UIKit.UIAppearance+Notifications.xml" />). Additionally, the <see cref="M:MonoTouch.UIKit.UIApplication.OpenUrl" /> method may
        be used to launch another application.  </para>
      <para> 
	The <see cref="T:MonoTouch.UIKit.UIApplication" /> class
        contains methods relating to background processing, such as
        <see cref="M:MonoTouch.UIKit.UIApplication.EnsureUIThread" />,
        <see cref="M:MonoTouch.UIKit.UIApplication.BeginBackgroundTask" />,
        and <see cref="M:MonoTouch.UIKit.UIApplication.EndBackgroundTask" />.
        </para>
      <format type="text/html">
        <h2>Background Fetch</h2>
      </format>
      <para> 

	Starting with iOS 7, applications can request that they be
	woken up to download data from the server in the background.
	When this feature is enabled, the operating system will resume
	your application or launch your application at some point to
	allow your application to download any new contents it needs
	from the server.

      </para>
      <para>

	To use this, applications need to have the "fetch" background
	operation requested on their requested Entitlements as well as
	calling the <see cref="T:MonoTouch.UIKit.UIApplication.SetMinimumBackgroundFetchInterval" />
	method with the desired wake up interval at launch.   

      </para>
      <para>

	When the operating system determines that your application
	should be resumed to download data, the <see cref="T:MonoTouch.UIKit.UIApplicationDelegate.PerformFetch" />
	method will be invoked.  This method should perform any
	downloads and then notify the operating system of the result
	of the operation.

      </para>
      <para>

	Applications do not really have control of when the
	application will be launched.  The actual launch time is
	determined by a set of heuristics based that the operating
	system tracks based on how the user users your application, as
	well as tracking the status of previous download operations
	that your application has done.

      </para>
      <format type="text/html">
        <h2>Remote Notifications</h2>
      </format>
      <para> 

	Starting with iOS 7, applications can request that they be
	woken up when a remote notification is received.  When this
	feature is enabled, the operating system will resume your
	application and invoke the <see cref="T:MonoTouch.UIKit.UIApplicationDelegate.DidReceiveRemotNotification" />
	overload that takes a completion handler parameter and let it
	run.

      </para>
      <para>

	To use this, applications need to have the "remote-notification" background
	operation requested on their requested Entitlements as.

      </para>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIApplication ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("init")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Default constructor that initializes a new instance of this class with no parameters.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIApplication (MonoTouch.Foundation.NSCoder coder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class MonoTouch.Foundation.NSCoder coder) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("initWithCoder:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="coder" Type="MonoTouch.Foundation.NSCoder" />
      </Parameters>
      <Docs>
        <param name="coder">The unarchiver object.</param>
        <summary>A constructor that initializes the object from the data stored in the unarchiver object.</summary>
        <remarks>This constructor is provided to allow the class to be initialized from an unarchiver (for example, during NIB deserialization).</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIApplication (MonoTouch.Foundation.NSObjectFlag t);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class MonoTouch.Foundation.NSObjectFlag t) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="t" Type="MonoTouch.Foundation.NSObjectFlag" />
      </Parameters>
      <Docs>
        <param name="t">Unused sentinel value, pass NSObjectFlag.Empty.</param>
        <summary>Constructor to call on derived classes to skip initialization and merely allocate the object.</summary>
        <remarks>
          <para>This constructor should be called by derived classes when they completely construct the object in managed code and merely want the runtime to allocate and initialize the NSObject.   This is required to implement the two-step initialization process that Objective-C uses, the first step is to perform the object allocation, the second step is to initialize the object.   When you invoke the constructor that takes the NSObjectFlag.Empty you taking advantage of a direct path that goes all the way up to NSObject to merely allocate the object's memory and bind the Objective-C and C# objects together.    The actual initialization of the object is up to you.</para>
          <para>This constructor is typically used by the binding generator to allocate the object, but prevent the actual initialization to take place.   Once the allocation has taken place, the constructor has to initialize the object.   With constructors generated by the binding generator this means that it manually invokes one of the "init" methods to initialize the object.</para>
          <para>It is your responsibility to completely initialize the object if you chain up using the NSObjectFlag.Empty path.</para>
          <para>In general, if your constructors invokes the NSObjectFlag.Empty base implementation, then it should be calling an Objective-C init method.   If this is not the case, you should instead chain to the proper constructor in your class. </para>
          <para>The argument value is ignored and merely ensures that the only code that is executed is the construction phase is the basic NSObject allocation and runtime type registration.  Typically the chaining would look like this:</para>
          <example>
            <code lang="C#">
//
// The NSObjectFlag merely allocates the object and registers the
// C# class with the Objective-C runtime if necessary, but no actual
// initXxx method is invoked, that is done later in the constructor
//
// This is taken from MonoTouch's source code:
//
[Export ("initWithFrame:")]
public UIView (System.Drawing.RectangleF frame) : base (NSObjectFlag.Empty)
{
// Invoke the init method now.
	var initWithFrame = new Selector ("initWithFrame:").Handle;
	if (IsDirectBinding)
		Handle = MonoTouch.ObjCRuntime.Messaging.IntPtr_objc_msgSend_RectangleF (this.Handle, initWithFrame, frame);
	else
		Handle = MonoTouch.ObjCRuntime.Messaging.IntPtr_objc_msgSendSuper_RectangleF (this.SuperHandle, initWithFrame, frame);
}
</code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIApplication (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Pointer (handle) to the unmanaged object.</param>
        <summary>A constructor used when creating managed representations of unmanaged objects;  Called by the runtime.</summary>
        <remarks>
          <para>This constructor is invoked by the runtime infrastructure (<see cref="M:MonoTouch.ObjCRuntime.GetNSObject (System.IntPtr)" />) to create a new managed representation for a pointer to an unmanaged Objective-C object.    You should not invoke this method directly, instead you should call the GetNSObject method as it will prevent two instances of a managed object to point to the same native object.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationIconBadgeNumber">
      <MemberSignature Language="C#" Value="public virtual int ApplicationIconBadgeNumber { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ApplicationIconBadgeNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("applicationIconBadgeNumber")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setApplicationIconBadgeNumber:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Numeric value to display as the application badge number.</summary>
        <value>
        </value>
        <remarks>
          When this value is zero, no badge is displayed.  When this
          value is different than zero, the value is displayed as a
          badge on the application's icon by the operating system.
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationState">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIApplicationState ApplicationState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype MonoTouch.UIKit.UIApplicationState ApplicationState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(4, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("applicationState")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(4, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIApplicationState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reflects the current application state.</summary>
        <value>
        </value>
        <remarks>
          <para> 
            When the user taps on the app icon, the app briefly
            goes through a transitional state of
            UIApplicationState.Inactive on its way to becoming
            UIApplicationState.Active. This is where the app gets
            itself ready to display to the user.
          </para>
          <para>
            When the app is open, the application state is UIApplicationState.Active.
          </para>
          <para>
            If the user presses the home button, and is returned to
            the springboard (home screen), or the application is
            interrupted by something, such as a phone call, the
            application state transitions back to
            UIApplicationState.Inactive.
          </para>
          <para> 
            For the application state of your app to become
            UIApplicationState.Background, your application would have
            to register for a background process. 
          </para>
          <para>
            Reference: http://stackoverflow.com/questions/7937400/need-clarification-about-uiapplicationstate
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationSupportsShakeToEdit">
      <MemberSignature Language="C#" Value="public virtual bool ApplicationSupportsShakeToEdit { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ApplicationSupportsShakeToEdit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("applicationSupportsShakeToEdit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setApplicationSupportsShakeToEdit:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Controls whether shaking the device will bring up the undo/redo buttons.</summary>
        <value>It defaults to true, so all applications by default support undo/redo by shaking.</value>
        <remarks>
          Set this value to false if you want to disable the default behavior that shows an undo/redo dialog box on shake.
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundFetchIntervalMinimum">
      <MemberSignature Language="C#" Value="public static double BackgroundFetchIntervalMinimum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property float64 BackgroundFetchIntervalMinimum" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIApplicationBackgroundFetchIntervalMinimum", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UIApplicationBackgroundFetchIntervalMinimum</summary>
        <value>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundFetchIntervalNever">
      <MemberSignature Language="C#" Value="public static double BackgroundFetchIntervalNever { get; }" />
      <MemberSignature Language="ILAsm" Value=".property float64 BackgroundFetchIntervalNever" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIApplicationBackgroundFetchIntervalNever", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UIApplicationBackgroundFetchIntervalNever</summary>
        <value>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundRefreshStatus">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIBackgroundRefreshStatus BackgroundRefreshStatus { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype MonoTouch.UIKit.UIBackgroundRefreshStatus BackgroundRefreshStatus" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("backgroundRefreshStatus")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIBackgroundRefreshStatus</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether background processing is allowed, denied, or restricted.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundRefreshStatusDidChangeNotification">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString BackgroundRefreshStatusDidChangeNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString BackgroundRefreshStatusDidChangeNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIApplicationBackgroundRefreshStatusDidChangeNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for BackgroundRefreshStatusDidChange</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:MonoTouch.Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIApplication+Notifications" />.<see cref="M:UIApplication+Notifications.ObserveBackgroundRefreshStatusDidChangeNotification" /> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="c#">
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveBackgroundRefreshStatusDidChange ((sender, args) =&gt; {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, MonoTouch.Foundation.NSNotificationEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveBackgroundRefreshStatusDidChange (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}</code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="c#">
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.BackgroundRefreshStatusDidChangeNotification, (notification) =&gt; {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.BackgroundRefreshStatusDidChangeNotification, Callback);
}
</code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundTaskInvalid">
      <MemberSignature Language="C#" Value="public static int BackgroundTaskInvalid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 BackgroundTaskInvalid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIBackgroundTaskInvalid", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(4, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(4, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UIBackgroundTaskInvalid</summary>
        <value>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundTimeRemaining">
      <MemberSignature Language="C#" Value="public virtual double BackgroundTimeRemaining { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 BackgroundTimeRemaining" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(4, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("backgroundTimeRemaining")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(4, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The number of seconds that the application has left to run in the background.</summary>
        <value>
        </value>
        <remarks>
          <para>
          </para>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginBackgroundTask">
      <MemberSignature Language="C#" Value="public virtual int BeginBackgroundTask (MonoTouch.Foundation.NSAction backgroundTimeExpired);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 BeginBackgroundTask(class MonoTouch.Foundation.NSAction backgroundTimeExpired) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("beginBackgroundTaskWithExpirationHandler:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(4, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backgroundTimeExpired" Type="MonoTouch.Foundation.NSAction">
          <Attributes>
            <Attribute>
              <AttributeName>MonoTouch.ObjCRuntime.BlockProxy(typeof(MonoTouch.ObjCRuntime.Trampolines/NIDNSAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="backgroundTimeExpired">
          <para>The method that will be invoked shortly before your application's remaining background quota reaches zero.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Requests that the app be allowed to process in the background.</summary>
        <returns>An id that, when passed to <see cref="M:MonoTouch.UIKit.UIApplication.EndBackgroundTask" />, indicates that background processing has ended.</returns>
        <remarks>
          <para>This method, with <see cref="M:MonoTouch.UIKit.UIApplication.EndBackgroundTask" />, bookends code that should be allowed to continue running in the background when another app is in the foreground. The returned <see langword="int" /> should be passed to <see cref="M:MonoTouch.UIKit.UIApplication.EndBackgroundTask" /> at the appropriate time. </para>
          <para>This method does not cause the app to enter a background state or launch asynchronous code, despite its name. Rather, it requests that the system make background processing available.</para>
          <para>This method may be called multiple times and may be called from background threads. Background processing will continue either until the allowed background time (generally 3 or 10 minutes total) expires or until <see cref="M:MonoTouch.UIKit.UIApplication.EndBackgroundtask" /> has been called for all started tasks.</para>
          <para>The <paramref name="expirationHandler" /> is only called if allowed background time is close to expiring (3-4 seconds).</para>
          <example>
            <code lang="C#"><![CDATA[
Task.Factory.StartNew( () => {
    //expirationHandler only called if background time allowed exceeded
    var taskId = UIApplication.SharedApplication.BeginBackgroundTask(() => Console.WriteLine("Exhausted time"));
    while(myFlag == true)
    {
        Console.WriteLine(UIApplication.SharedApplication.TimeRemaining);
        myFlag = SomeCalculationNeedsMoreTime();
    }
    //Only called if loop terminated due to myFlag and not expiration of time
    UIApplication.SharedApplication.EndBackgroundTask(taskId);
});              
              ]]></code>
          </example>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginBackgroundTask">
      <MemberSignature Language="C#" Value="public virtual int BeginBackgroundTask (string taskName, MonoTouch.Foundation.NSAction expirationHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 BeginBackgroundTask(string taskName, class MonoTouch.Foundation.NSAction expirationHandler) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("beginBackgroundTaskWithName:expirationHandler:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="taskName" Type="System.String" />
        <Parameter Name="expirationHandler" Type="MonoTouch.Foundation.NSAction">
          <Attributes>
            <Attribute>
              <AttributeName>MonoTouch.ObjCRuntime.BlockProxy(typeof(MonoTouch.ObjCRuntime.Trampolines/NIDNSAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="taskName">A name for the task (useful for debugging).</param>
        <param name="expirationHandler">Called shortly before the allowed background time for the app expires.</param>
        <summary>Requests that the app be allowed to process in the background.</summary>
        <returns>An id that, when passed to <see cref="M:MonoTouch.UIKit.UIApplication.EndBackgroundTask" />, indicates that background processing has ended.</returns>
        <remarks>
          <para>This method, with <see cref="M:MonoTouch.UIKit.UIApplication.EndBackgroundTask" />, bookends code that should be allowed to continue running in the background when another app is in the foreground. The returned <see langword="int" /> should be passed to <see cref="M:MonoTouch.UIKit.UIApplication.EndBackgroundTask" /> at the appropriate time. </para>
          <para>This method does not cause the app to enter a background state or launch asynchronous code, despite its name. Rather, it requests that the system make background processing available.</para>
          <para>This method may be called multiple times and may be called from background threads. Background processing will continue either until the allowed background time (generally 3 or 10 minutes total) expires or until <see cref="M:MonoTouch.UIKit.UIApplication.EndBackgroundtask" /> has been called for all started tasks.</para>
          <para>The <paramref name="expirationHandler" /> is only called if allowed background time is close to expiring (3-4 seconds).</para>
          <example>
            <code lang="C#"><![CDATA[
Task.Factory.StartNew( () => {
    //expirationHandler only called if background time allowed exceeded
    var taskId = UIApplication.SharedApplication.BeginBackgroundTask("bgTask", () => Console.WriteLine("Exhausted time"));
    while(myFlag == true)
    {
        Console.WriteLine(UIApplication.SharedApplication.TimeRemaining);
        myFlag = SomeCalculationNeedsMoreTime();
    }
    //Only called if loop terminated due to myFlag and not expiration of time
    UIApplication.SharedApplication.EndBackgroundTask(taskId);
});              
              ]]></code>
          </example>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginIgnoringInteractionEvents">
      <MemberSignature Language="C#" Value="public virtual void BeginIgnoringInteractionEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginIgnoringInteractionEvents() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("beginIgnoringInteractionEvents")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stops the application from receiving touch events.</summary>
        <remarks>
          <para>
            
            This method is sometimes used by developers that want to
            prevent touch events to be delivered during an animation.
            
          </para>
          <para>
            To resume receiving touch events, call the <see cref="M:MonoTouch.UIKit.UIApplication.EndIgnoringInteractionEvents()" />.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginReceivingRemoteControlEvents">
      <MemberSignature Language="C#" Value="public virtual void BeginReceivingRemoteControlEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginReceivingRemoteControlEvents() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("beginReceivingRemoteControlEvents")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(4, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indicates that the application should start listening for remote-control events.</summary>
        <remarks>
          <para>Remote-control events are generated by external devices such as headsets intended to control multimedia playback.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CancelAllLocalNotifications">
      <MemberSignature Language="C#" Value="public virtual void CancelAllLocalNotifications ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CancelAllLocalNotifications() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("cancelAllLocalNotifications")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(4, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cancels the delivery of scheduled local notifications.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CancelLocalNotification">
      <MemberSignature Language="C#" Value="public virtual void CancelLocalNotification (MonoTouch.UIKit.UILocalNotification notification);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CancelLocalNotification(class MonoTouch.UIKit.UILocalNotification notification) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("cancelLocalNotification:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(4, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="notification" Type="MonoTouch.UIKit.UILocalNotification" />
      </Parameters>
      <Docs>
        <param name="notification">To be added.</param>
        <summary>Cancels a local notification.</summary>
        <remarks>If the notification is currently displayed, it is removed;   If it is not displayed, the queued notification is dropped.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanOpenUrl">
      <MemberSignature Language="C#" Value="public virtual bool CanOpenUrl (MonoTouch.Foundation.NSUrl url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanOpenUrl(class MonoTouch.Foundation.NSUrl url) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("canOpenURL:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="MonoTouch.Foundation.NSUrl" />
      </Parameters>
      <Docs>
        <param name="url">
          <para>The URL to probe.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Determines whether the given URL can be opened by OpenUrl.</summary>
        <returns>true if there is an application registered to open the URL, false if not.</returns>
        <remarks>
          <para>
            This function probes whether there is a handler for the
            provided URL on the system.  For example, if you call this
            function with "tel://555-123-1234" on an iPhone, this will
            return true, but will return false on an iPod Touch.
          </para>
          <para>
            
            This function does not validate the URL, it merely checks
            whether a handler for this URL has been installed on the system.
            
          </para>
          <para>
            
            If you want to define your own URL handlers, edit your
            Info.plist file and define a new URL type, you then must
            update your <see cref="M:MonoTouch.UIKit.UIApplicationDelegate.FinishedLaunching(MonoTouch.UIKit.UIApplication,MonoTouch.Foundation.NSDictionary)" />
            method (to handle launching the application if it is not
            already running) and override the <see cref="M:MonoTouch.UIKit.UIApplicationDelegate.OpenUrl" />
            method to handle the request to open the URL.
            
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckForIllegalCrossThreadCalls">
      <MemberSignature Language="C#" Value="public static bool CheckForIllegalCrossThreadCalls;" />
      <MemberSignature Language="ILAsm" Value=".field public static bool CheckForIllegalCrossThreadCalls" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determines whether the debug builds of MonoTouch will enforce that calls done to UIKit are only issued from the UI thread.</summary>
        <remarks>
          <para>
            On debug builds, MonoTouch will enforce that calls made to
            UIKit APIs are only done from the UIKit thread.  This is
            useful to spot code that could inadvertently use UIKit from
            a non-UI thread which can corrupt the UIKit state and could
            lead to very hard to debug problems.
          </para>
          <para>
            
            But sometimes it might be useful to disable this check,
            either because you can ensure that UIKit is not in use at
            this point or because MonoTouch might be enforcing the
            checks in APIs that might have later been relaxed or made
            thread safe by iOS.
            
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClassHandle">
      <MemberSignature Language="C#" Value="public override IntPtr ClassHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ClassHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The handle for this class.</summary>
        <value>The pointer to the Objective-C class.</value>
        <remarks>Each MonoTouch class mirrors an unmanaged Objective-C class.   This value contains the pointer to the Objective-C class, it is similar to calling objc_getClass with the object name.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearKeepAliveTimeout">
      <MemberSignature Language="C#" Value="public virtual void ClearKeepAliveTimeout ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearKeepAliveTimeout() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("clearKeepAliveTimeout")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stops invoking the KeepAlive method defined previously with SetKeepAliveTimeout.</summary>
        <remarks>This method is used by Voice over IP applications when they no longer need the keep-alive timeout method handler to be executed.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CompleteStateRestoration">
      <MemberSignature Language="C#" Value="public virtual void CompleteStateRestoration ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CompleteStateRestoration() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("completeStateRestoration")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indicates to the system that state restoration is complete.</summary>
        <remarks>
          <para>Application developers should call this method after they have finished state restoration.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentSizeCategoryChangedNotification">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString ContentSizeCategoryChangedNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString ContentSizeCategoryChangedNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIContentSizeCategoryDidChangeNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for ContentSizeCategoryChanged</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:MonoTouch.Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIApplication+Notifications" />.<see cref="M:UIApplication+Notifications.ObserveContentSizeCategoryChangedNotification" /> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="c#">
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveContentSizeCategoryChanged ((sender, args) =&gt; {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("WeakNewValue", args.WeakNewValue);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, MonoTouch.UIKit.UIContentSizeCategoryChangedEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("WeakNewValue", args.WeakNewValue);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveContentSizeCategoryChanged (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}</code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="c#">
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.ContentSizeCategoryChangedNotification, (notification) =&gt; {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.ContentSizeCategoryChangedNotification, Callback);
}
</code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentUserNotificationSettings">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIUserNotificationSettings CurrentUserNotificationSettings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIUserNotificationSettings CurrentUserNotificationSettings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("currentUserNotificationSettings")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIUserNotificationSettings</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Delegate">
      <MemberSignature Language="C#" Value="public MonoTouch.UIKit.UIApplicationDelegate Delegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIApplicationDelegate Delegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIApplicationDelegate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An instance of the MonoTouch.UIKit.UIApplicationDelegate model class which acts as the class delegate.</summary>
        <value>
          <para>The instance of the MonoTouch.UIKit.UIApplicationDelegate model class</para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>
          <para>The delegate instance assigned to this object will be used to handle events or provide data on demand to this class.</para>
          <para>When setting the Delegate or WeakDelegate values events will be delivered to the specified instance instead of being delivered to the C#-style events</para>
          <para>This is the strongly typed version of the object, use the WeakDelegate property instead if you want to merely assign a class derived from NSObject that has been decorated with [Export] attributes.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DidBecomeActiveNotification">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString DidBecomeActiveNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString DidBecomeActiveNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIApplicationDidBecomeActiveNotification", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for DidBecomeActive</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:MonoTouch.Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIApplication+Notifications" />.<see cref="M:UIApplication+Notifications.ObserveDidBecomeActiveNotification" /> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="c#">
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveDidBecomeActive ((sender, args) =&gt; {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, MonoTouch.Foundation.NSNotificationEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveDidBecomeActive (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}</code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="c#">
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.DidBecomeActiveNotification, (notification) =&gt; {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.DidBecomeActiveNotification, Callback);
}
</code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DidChangeStatusBarFrameNotification">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString DidChangeStatusBarFrameNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString DidChangeStatusBarFrameNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIApplicationDidChangeStatusBarFrameNotification", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for DidChangeStatusBarFrame</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:MonoTouch.Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIApplication+Notifications" />.<see cref="M:UIApplication+Notifications.ObserveDidChangeStatusBarFrameNotification" /> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="c#">
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveDidChangeStatusBarFrame ((sender, args) =&gt; {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("StatusBarFrame", args.StatusBarFrame);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, MonoTouch.UIKit.UIStatusBarFrameChangeEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("StatusBarFrame", args.StatusBarFrame);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveDidChangeStatusBarFrame (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}</code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="c#">
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.DidChangeStatusBarFrameNotification, (notification) =&gt; {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.DidChangeStatusBarFrameNotification, Callback);
}
</code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DidChangeStatusBarOrientationNotification">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString DidChangeStatusBarOrientationNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString DidChangeStatusBarOrientationNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIApplicationDidChangeStatusBarOrientationNotification", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for DidChangeStatusBarOrientation</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:MonoTouch.Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIApplication+Notifications" />.<see cref="M:UIApplication+Notifications.ObserveDidChangeStatusBarOrientationNotification" /> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="c#">
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveDidChangeStatusBarOrientation ((sender, args) =&gt; {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("StatusBarOrientation", args.StatusBarOrientation);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, MonoTouch.UIKit.UIStatusBarOrientationChangeEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("StatusBarOrientation", args.StatusBarOrientation);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveDidChangeStatusBarOrientation (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}</code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="c#">
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.DidChangeStatusBarOrientationNotification, (notification) =&gt; {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.DidChangeStatusBarOrientationNotification, Callback);
}
</code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DidEnterBackgroundNotification">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString DidEnterBackgroundNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString DidEnterBackgroundNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIApplicationDidEnterBackgroundNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(4, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(4, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for DidEnterBackground</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:MonoTouch.Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIApplication+Notifications" />.<see cref="M:UIApplication+Notifications.ObserveDidEnterBackgroundNotification" /> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="c#">
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveDidEnterBackground ((sender, args) =&gt; {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, MonoTouch.Foundation.NSNotificationEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveDidEnterBackground (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}</code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="c#">
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.DidEnterBackgroundNotification, (notification) =&gt; {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.DidEnterBackgroundNotification, Callback);
}
</code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DidFinishLaunchingNotification">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString DidFinishLaunchingNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString DidFinishLaunchingNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIApplicationDidFinishLaunchingNotification", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for DidFinishLaunching</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:MonoTouch.Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIApplication+Notifications" />.<see cref="M:UIApplication+Notifications.ObserveDidFinishLaunchingNotification" /> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="c#">
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveDidFinishLaunching ((sender, args) =&gt; {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("Url", args.Url);
    Console.WriteLine ("SourceApplication", args.SourceApplication);
    Console.WriteLine ("RemoteNotifications", args.RemoteNotifications);
    Console.WriteLine ("LocationLaunch", args.LocationLaunch);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, MonoTouch.UIKit.UIApplicationLaunchEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("Url", args.Url);
    Console.WriteLine ("SourceApplication", args.SourceApplication);
    Console.WriteLine ("RemoteNotifications", args.RemoteNotifications);
    Console.WriteLine ("LocationLaunch", args.LocationLaunch);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveDidFinishLaunching (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}</code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="c#">
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.DidFinishLaunchingNotification, (notification) =&gt; {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.DidFinishLaunchingNotification, Callback);
}
</code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DidReceiveMemoryWarningNotification">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString DidReceiveMemoryWarningNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString DidReceiveMemoryWarningNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIApplicationDidReceiveMemoryWarningNotification", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for DidReceiveMemoryWarning</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:MonoTouch.Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIApplication+Notifications" />.<see cref="M:UIApplication+Notifications.ObserveDidReceiveMemoryWarningNotification" /> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="c#">
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveDidReceiveMemoryWarning ((sender, args) =&gt; {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, MonoTouch.Foundation.NSNotificationEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveDidReceiveMemoryWarning (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}</code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="c#">
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.DidReceiveMemoryWarningNotification, (notification) =&gt; {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.DidReceiveMemoryWarningNotification, Callback);
}
</code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <para>If set to <see langword="true" />, the method is invoked directly and will dispose manage and unmanaged resources;   If set to <see langword="false" /> the method is being called by the garbage collector finalizer and should only release unmanaged resources.</para>
        </param>
        <summary>Releases the resources used by the UIApplication object.</summary>
        <remarks>
          <para>This Dispose method releases the resources used by the UIApplication class.</para>
          <para>This method is called by both the Dispose() method and the object finalizer (Finalize).    When invoked by the Dispose method, the parameter disposing <paramref name="disposing" /> is set to <see langword="true" /> and any managed object references that this object holds are also disposed or released;  when invoked by the object finalizer, on the finalizer thread the value is set to <see langword="false" />. </para>
          <para>Calling the Dispose method when you are finished using the UIApplication ensures that all external resources used by this managed object are released as soon as possible.  Once you have invoked the Dispose method, the object is no longer useful and you should no longer make any calls to it.</para>
          <para>  For more information on how to override this method and on the Dispose/IDisposable pattern, read the ``Implementing a Dispose Method'' document at http://msdn.microsoft.com/en-us/library/fs2xkftw.aspx</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnabledRemoteNotificationTypes">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIRemoteNotificationType EnabledRemoteNotificationTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype MonoTouch.UIKit.UIRemoteNotificationType EnabledRemoteNotificationTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Availability(Deprecated=MonoTouch.ObjCRuntime.Platform.iOS_8_0, Message="Use CurrentUserNotificationSettings instead")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("enabledRemoteNotificationTypes")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Availability(Deprecated=MonoTouch.ObjCRuntime.Platform.iOS_8_0, Message="Use CurrentUserNotificationSettings instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIRemoteNotificationType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns a bit-masked <see cref="T:MonoTouch.UIKit.UIRemoteNotificationType" /> indicating which types of notifications the app accepts.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <altmember cref="M:MonoTouch.UIKit.UIApplication.RegisterForRemoteNotificationTypes" />
      </Docs>
    </Member>
    <Member MemberName="EndBackgroundTask">
      <MemberSignature Language="C#" Value="public virtual void EndBackgroundTask (int taskId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndBackgroundTask(int32 taskId) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("endBackgroundTask:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(4, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="taskId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="taskId">The value returned by the matching <see cref="M:MonoTouch.UIKit.UIApplication.BeginBackgroundTask" /> method.</param>
        <summary>Indicates to the system that background processing has ended for the <paramref name="taskId" />.</summary>
        <remarks>
          <para>This method, with <see cref="M:MonoTouch.UIKit.UIApplication.BeginBackgroundTask" />, bookends code that should be allowed to run in the background. It does not affect the actual state of any threads. (See <see cref="M:MonoTouch.UIKit.UIApplication.BeginBackgroundTask" /> for discussion.)</para>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndIgnoringInteractionEvents">
      <MemberSignature Language="C#" Value="public virtual void EndIgnoringInteractionEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndIgnoringInteractionEvents() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("endIgnoringInteractionEvents")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resumes receiving touch events for the application.</summary>
        <remarks>This should be called if you previously disabled receiving events by calling the <see cref="M:MonoTouch.UIKit.UIApplication.BeginIgnoringInteractionEvents()" />.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndReceivingRemoteControlEvents">
      <MemberSignature Language="C#" Value="public virtual void EndReceivingRemoteControlEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndReceivingRemoteControlEvents() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("endReceivingRemoteControlEvents")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(4, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indicates that the application should nto receive further remote-control events.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:MonoTouch.UIKit.UIApplication.BeginReceivingRemoteControlEvents" />
      </Docs>
    </Member>
    <Member MemberName="EnsureUIThread">
      <MemberSignature Language="C#" Value="public static void EnsureUIThread ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnsureUIThread() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Assertion to ensure that this call is being done from the UIKit thread.</summary>
        <remarks>
          <para>
            This method is used internally by MonoTouch to ensure that
            accesses done to UIKit classes and methods are only
            performed from the UIKit thread.  This is necessary because
            the UIKit API is not thread-safe and accessing it from
            multiple threads will corrupt the application state and will
            likely lead to a crash that is hard to identify.
          </para>
          <para>
            
            MonoTouch only performs the thread checks in debug builds.
            Release builds have this feature disabled.
            
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExtendStateRestoration">
      <MemberSignature Language="C#" Value="public virtual void ExtendStateRestoration ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ExtendStateRestoration() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("extendStateRestoration")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indicates that the application is restoring state asynchronously.</summary>
        <remarks>
          <para>State restoration occurs on the main thread. Application developers who wish to do state restoration asynchronously should call this method and pair it with calls to <see cref="M:MonoTouch.UIKit.UIApplication.CompleteStateRestoration" /> to indicate to the system that state restoration is occurring asynchronously.</para>
          <para>If this method is called and the application crashes before the matching <see cref="M:MonoTouch.UIKit.UIApplication.CompleteStateRestoration" /> is called, all retained state will be discarded on next startup. This behavior prevents the crash from re-occurring.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IdleTimerDisabled">
      <MemberSignature Language="C#" Value="public virtual bool IdleTimerDisabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IdleTimerDisabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("isIdleTimerDisabled")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setIdleTimerDisabled:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>If <see langword="true" />, indicates that the screen should not dim even when no input is occurring.</summary>
        <value>The default value is <see langword="false" />.</value>
        <remarks>
          <para>The idle timer dims the screen after some amount of time has passed without user interaction. Application developers who wish to keep the screen fully powered can set this property to <see langword="true" />. For instance, games whose input is restricted to the accelerometer may set this value to <see langword="true" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IgnoreSnapshotOnNextApplicationLaunch">
      <MemberSignature Language="C#" Value="public virtual void IgnoreSnapshotOnNextApplicationLaunch ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void IgnoreSnapshotOnNextApplicationLaunch() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("ignoreSnapshotOnNextApplicationLaunch")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Instructs the system not to use a UI snapshot during relaunch.</summary>
        <remarks>
          <para>This method method be called from within the state-preservation process.</para>
          <para>Normally, the system takes a snapshot of the UI during state-preservation and presents this during state-restoration. Generally, this makes the application user feel that the system is relaunching quickly. App developers can call this method during state-preservation if the UI would not be appropriate during relaunch.</para>
          <para>If this method is called, during state-restoration the app's default launch image will be displayed.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsIgnoringInteractionEvents">
      <MemberSignature Language="C#" Value="public virtual bool IsIgnoringInteractionEvents { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsIgnoringInteractionEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("isIgnoringInteractionEvents")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether the receiver is ignoring touch events.</summary>
        <value>
          <see langword="true" /> if there have been more calls to <see cref="M:MonoTouch.UIKit.UIApplication.BeginIgnoringInteractionEvents" /> than calls to <see cref="M:MonoTouch.UIKit.UIApplication.EndIgnoringInteractionEvents" />.</value>
        <remarks>
        </remarks>
        <altmember cref="M:MonoTouch.UIKit.UIApplication.BeginIgnoringInteractionEvents" />
        <altmember cref="M:MonoTouch.UIKit.UIApplication.EndIgnoringInteractionEvents" />
      </Docs>
    </Member>
    <Member MemberName="IsRegisteredForRemoteNotifications">
      <MemberSignature Language="C#" Value="public virtual bool IsRegisteredForRemoteNotifications { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsRegisteredForRemoteNotifications" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("isRegisteredForRemoteNotifications")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyWindow">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIWindow KeyWindow { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIWindow KeyWindow" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("keyWindow")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIWindow</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns the application's key window - the window that is currently displayed and receives user input </summary>
        <value>
        </value>
        <remarks>
          
          The key window is the currently visible window that is also
          the one that receives user input.  The key window in turn
          will route input events to the <see cref="T:MonoTouch.UIKit.UIViewController" /> that is defined
          in set in the  <see cref="P:MonoTouch.UIKit.UIWindows.RootViewController" /> property.
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LaunchOptionsAnnotationKey">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString LaunchOptionsAnnotationKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString LaunchOptionsAnnotationKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIApplicationLaunchOptionsAnnotationKey", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(3, 2)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(3, 2)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Launch Options Key: Use this key to find out if custom data was passed to the program by the opening application.   The value of this key will be a property list. </summary>
        <value>
          Represents the value associated with the constant UIApplicationLaunchOptionsAnnotationKey
        </value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LaunchOptionsBluetoothCentralsKey">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString LaunchOptionsBluetoothCentralsKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString LaunchOptionsBluetoothCentralsKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIApplicationLaunchOptionsBluetoothCentralsKey", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UIApplicationLaunchOptionsBluetoothCentralsKey</summary>
        <value>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LaunchOptionsBluetoothPeripheralsKey">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString LaunchOptionsBluetoothPeripheralsKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString LaunchOptionsBluetoothPeripheralsKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIApplicationLaunchOptionsBluetoothPeripheralsKey", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UIApplicationLaunchOptionsBluetoothPeripheralsKey</summary>
        <value>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LaunchOptionsLocalNotificationKey">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString LaunchOptionsLocalNotificationKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString LaunchOptionsLocalNotificationKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIApplicationLaunchOptionsLocalNotificationKey", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(4, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(4, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for LaunchOptionsLocalNot</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para>
            The value of this key will be a <see cref="T:MonoTouch.UIKit.UILocalNotification" /> instance.
          </para>
          <para>
            This key will be present on the launch options if a local notification was delivered and the application was not running.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LaunchOptionsLocationKey">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString LaunchOptionsLocationKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString LaunchOptionsLocationKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIApplicationLaunchOptionsLocationKey", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(4, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(4, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Launch Options Key: Application was started up in response to a location event.</summary>
        <value>Represents the value associated with the constant UIApplicationLaunchOptionsLocationKey</value>
        <remarks>The value of this key will be an NSNumber.   The application should respond by creating a <see cref="T:MonoTouch.CoreLocation.CLLocationManager" /> instance to and get the information from that object.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LaunchOptionsNewsstandDownloadsKey">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString LaunchOptionsNewsstandDownloadsKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString LaunchOptionsNewsstandDownloadsKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIApplicationLaunchOptionsNewsstandDownloadsKey", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(5, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(5, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Launch Options Key: This key indicates that Newsstand has completed downloading the requested data. </summary>
        <value>Represents the value associated with the constant UIApplicationLaunchOptionsNewsstandDownloadsKey
        </value>
        <remarks>
          The value in the dictionary for this key, contains an array of strings that represent <see cref="T:MonoTouch.Newsstand.NKAssetDownload" /> objects.
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LaunchOptionsRemoteNotificationKey">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString LaunchOptionsRemoteNotificationKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString LaunchOptionsRemoteNotificationKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIApplicationLaunchOptionsRemoteNotificationKey", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for LaunchOptionsRemoteNot</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          The value associated with this key will be an NSDictionary with the payload from the remote notification that was received. 
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LaunchOptionsSourceApplicationKey">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString LaunchOptionsSourceApplicationKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString LaunchOptionsSourceApplicationKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIApplicationLaunchOptionsSourceApplicationKey", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Launch Options Key: the value associated with the key is the bundle-id of the application that launched this application.</summary>
        <value>Represents the value associated with the constant UIApplicationLaunchOptionsSourceApplicationKey
        </value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LaunchOptionsUrlKey">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString LaunchOptionsUrlKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString LaunchOptionsUrlKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIApplicationLaunchOptionsURLKey", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Launch Options Key: the application was launched in response to open a URL.  the value associated with the key contains the URL to open.</summary>
        <value>Represents the value associated with the constant UIApplicationLaunchOptionsURLKey.
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Main">
      <MemberSignature Language="C#" Value="public static void Main (string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Main(string[] args) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="args">Command line parameters from the Main program.</param>
        <summary>Launches the main application loop with the given command line parameters.</summary>
        <remarks>This launches the main application loop, assumes that the main application class is UIApplication, and uses the UIApplicationDelegate instance specified in the main NIB file for this program.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Main">
      <MemberSignature Language="C#" Value="public static void Main (string[] args, string principalClassName, string delegateClassName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Main(string[] args, string principalClassName, string delegateClassName) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.String[]" />
        <Parameter Name="principalClassName" Type="System.String" />
        <Parameter Name="delegateClassName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="args">Command line parameters from the Main program.</param>
        <param name="principalClassName">The name of the main application class, if you specify null, this uses UIApplication.</param>
        <param name="delegateClassName">The name of the UIApplicationDelegate class, if null, it uses the UIApplicationDelegate instance specified in the main NIB file for this program..</param>
        <summary>Launches the main application loop with the given command line parameters.</summary>
        <remarks>
          <para>The <paramref name="principalClassName" /> is typically only specified if the application developer subclasses <see cref="T:MonoTouch.UIKit.UIApplication" />, as shown in the following example:</para>
          <example>
            <code lang="C#"><![CDATA[
public class Application
{
	static void Main(string[] args)
	{
		UIApplication.Main(args, "MyApp", "MyAppDelegate");
	}
}

[Register("MyApp")]
public class MyApp : UIApplication
{
//...etc...
}          

[Register("MyAppDelegate")]
public  class AppDelegate : UIApplicationDelegate
{
//..etc...
}
              ]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Main">
      <MemberSignature Language="C#" Value="public static void Main (string[] args, Type principalClass, Type delegateClass);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Main(string[] args, class System.Type principalClass, class System.Type delegateClass) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.String[]" />
        <Parameter Name="principalClass" Type="System.Type" />
        <Parameter Name="delegateClass" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="args">Command line parameters from the Main program.</param>
        <param name="principalClass">The type of the main application class, if you specify null, this uses UIApplication.</param>
        <param name="delegateClass">The type of the UIApplicationDelegate class, if null, it uses the UIApplicationDelegate instance specified in the main NIB file for this program..</param>
        <summary>Launches the main application loop with the given command line parameters.</summary>
        <remarks>
          <para>The <paramref name="principalClassName" /> is typically only specified if the application developer subclasses <see cref="T:MonoTouch.UIKit.UIApplication" />, as shown in the following example:</para>
          <example>
            <code lang="C#"><![CDATA[
public class Application
{
  static void Main(string[] args)
  {
    UIApplication.Main(args, typeof (MyApp), typeof (MyAppDelegate));
  }
}

public class MyApp : UIApplication
{
//...etc...
}          

public class MyAppDelegate : UIApplicationDelegate
{
//..etc...
}
              ]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinimumKeepAliveTimeout">
      <MemberSignature Language="C#" Value="public static double MinimumKeepAliveTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property float64 MinimumKeepAliveTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIMinimumKeepAliveTimeout", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(4, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(4, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UIMinimumKeepAliveTimeout</summary>
        <value>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NetworkActivityIndicatorVisible">
      <MemberSignature Language="C#" Value="public virtual bool NetworkActivityIndicatorVisible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NetworkActivityIndicatorVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("isNetworkActivityIndicatorVisible")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setNetworkActivityIndicatorVisible:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Controls the status of the network activity indicator on the device.</summary>
        <value>To be added.</value>
        <remarks>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenSettingsUrlString">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString OpenSettingsUrlString { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString OpenSettingsUrlString" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIApplicationOpenSettingsURLString", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UIApplicationOpenSettingsURLString</summary>
        <value>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenUrl">
      <MemberSignature Language="C#" Value="public virtual bool OpenUrl (MonoTouch.Foundation.NSUrl url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool OpenUrl(class MonoTouch.Foundation.NSUrl url) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("openURL:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="MonoTouch.Foundation.NSUrl" />
      </Parameters>
      <Docs>
        <param name="url">To be added.</param>
        <summary>Opens the specified URL, launching the app that's registered to handle the scheme.</summary>
        <returns>
          <see langword="true" /> if the URL was successfully opened.</returns>
        <remarks>
          <para>If another app is registered to handle the URL scheme, calling this method will launch the other application, which may cause the current application to quit or at least be sent to the background.</para>
        </remarks>
        <altmember cref="M:MonoTouch.UIKit.UIApplication.CanOpenUrl" />
        <altmember cref="M:MonoTouch.UIKit.UIApplicationDelegate.HandleOpenUrl" />
      </Docs>
    </Member>
    <Member MemberName="PreferredContentSizeCategory">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.Foundation.NSString PreferredContentSizeCategory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.Foundation.NSString PreferredContentSizeCategory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("preferredContentSizeCategory")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The font size preferred by the application user.</summary>
        <value>One of the values defined in <see cref="T:MonoTouch.UIKit.UIContentSizeCategory" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PresentLocationNotificationNow">
      <MemberSignature Language="C#" Value="public virtual void PresentLocationNotificationNow (MonoTouch.UIKit.UILocalNotification notification);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PresentLocationNotificationNow(class MonoTouch.UIKit.UILocalNotification notification) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("presentLocalNotificationNow:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(4, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="notification" Type="MonoTouch.UIKit.UILocalNotification" />
      </Parameters>
      <Docs>
        <param name="notification">To be added.</param>
        <summary>Immediately presents a local notification.</summary>
        <remarks>
          <para>The notification is presented immediately, ignoring the <see cref="P:MonoTouch.UIKit.UILocalNotification.FireDate" /> property of the <paramref name="notification" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectedDataAvailable">
      <MemberSignature Language="C#" Value="public virtual bool ProtectedDataAvailable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ProtectedDataAvailable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(4, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("isProtectedDataAvailable")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(4, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether content protection is available.</summary>
        <value>
          <see langword="true" /> if data protection is enabled and the device is locked. Otherwise, <see langword="false" />.</value>
        <remarks>
          <para>If this method returns <see langword="false" />, the application will not be allowed to read or write files whose <see cref="P:MonoTouch.NSFoundation.NSFileManager.FileProtectionKey" /> is <see cref="P:MonoTouch.NSFoundation.NSFileManager.FileProtectionComplete" /> or <see cref="P:MonoTouch.NSFoundation.NSFileManager.FileProtectionCompleteUnlessOpen" />.</para>
        </remarks>
        <altmember cref="P:MonoTouch.UIKit.UIApplication.ProtectedDataDidBecomeAvailable" />
      </Docs>
    </Member>
    <Member MemberName="ProtectedDataDidBecomeAvailable">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString ProtectedDataDidBecomeAvailable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString ProtectedDataDidBecomeAvailable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIApplicationProtectedDataDidBecomeAvailable", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(4, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(4, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indicates that the state of protected data has changed.</summary>
        <value>To be added.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:MonoTouch.Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIApplication+Notifications" />.<see cref="M:UIApplication+Notifications.ObserveProtectedDataDidBecomeAvailable" /> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="c#">
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveProtectedDataDidBecomeAvailable ((sender, args) =&gt; {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, MonoTouch.Foundation.NSNotificationEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveProtectedDataDidBecomeAvailable (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}</code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="c#">
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.ProtectedDataDidBecomeAvailable, (notification) =&gt; {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.ProtectedDataDidBecomeAvailable, Callback);
}
</code>
          </example>
        </remarks>
        <altmember cref="P:MonoTouch.UIKit.UIApplication.ProtectedDataAvailable" />
      </Docs>
    </Member>
    <Member MemberName="ProtectedDataWillBecomeUnavailable">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString ProtectedDataWillBecomeUnavailable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString ProtectedDataWillBecomeUnavailable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIApplicationProtectedDataWillBecomeUnavailable", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(4, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(4, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indicates that the state of protected data has changed.</summary>
        <value>To be added.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:MonoTouch.Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIApplication+Notifications" />.<see cref="M:UIApplication+Notifications.ObserveProtectedDataWillBecomeUnavailable" /> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="c#">
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveProtectedDataWillBecomeUnavailable ((sender, args) =&gt; {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, MonoTouch.Foundation.NSNotificationEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveProtectedDataWillBecomeUnavailable (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}</code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="c#">
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.ProtectedDataWillBecomeUnavailable, (notification) =&gt; {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.ProtectedDataWillBecomeUnavailable, Callback);
}
</code>
          </example>
        </remarks>
        <altmember cref="P:MonoTouch.UIKit.UIApplication.ProtectedDataAvailable" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForRemoteNotifications">
      <MemberSignature Language="C#" Value="public virtual void RegisterForRemoteNotifications ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterForRemoteNotifications() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("registerForRemoteNotifications")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterForRemoteNotificationTypes">
      <MemberSignature Language="C#" Value="public virtual void RegisterForRemoteNotificationTypes (MonoTouch.UIKit.UIRemoteNotificationType types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterForRemoteNotificationTypes(valuetype MonoTouch.UIKit.UIRemoteNotificationType types) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("registerForRemoteNotificationTypes:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Availability(Deprecated=MonoTouch.ObjCRuntime.Platform.iOS_8_0, Message="Use RegisterUserNotifications and RegisterForNotifications instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="MonoTouch.UIKit.UIRemoteNotificationType" />
      </Parameters>
      <Docs>
        <param name="types">To be added.</param>
        <summary>Begins the registration of the application to receive the specified types of notification from Apple Push Service.</summary>
        <remarks>
          <para>Only notifications of the types registered by this method will display, even if different types (e.g., an alert) is specified in the notification's payload.</para>
        </remarks>
        <altmember cref="M:MonoTouch.UIKit.UIApplicationDelegate.RegisteredForRemoteNotifications" />
        <altmember cref="M:MonoTouch.UIKit.UIApplicationDelegate.FailedToRegisterForRemoteNotifications" />
        <altmember cref="P:MonoTouch.UIKit.UIApplication.EnabledRemoteNotificationTypes" />
      </Docs>
    </Member>
    <Member MemberName="RegisterObjectForStateRestoration">
      <MemberSignature Language="C#" Value="public static void RegisterObjectForStateRestoration (MonoTouch.UIKit.IUIStateRestoring uistateRestoringObject, string restorationIdentifier);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterObjectForStateRestoration(class MonoTouch.UIKit.IUIStateRestoring uistateRestoringObject, string restorationIdentifier) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("registerObjectForStateRestoration:restorationIdentifier:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uistateRestoringObject" Type="MonoTouch.UIKit.IUIStateRestoring" />
        <Parameter Name="restorationIdentifier" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uistateRestoringObject">To be added.</param>
        <param name="restorationIdentifier">To be added.</param>
        <summary>Registers the <paramref name="uistateRestoringObject" /> as eligible for state restoration.</summary>
        <remarks>
          <para>Calling this method allows the object to be saved and restored but does not automatically trigger preservation/restoration. Application developers must write the object at the appropriate time, for instance <see cref="M:MonoTouch.UIKit.UIViewController.EncodeRestorableState" />. </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterUserNotificationSettings">
      <MemberSignature Language="C#" Value="public virtual void RegisterUserNotificationSettings (MonoTouch.UIKit.UIUserNotificationSettings notificationSettings);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterUserNotificationSettings(class MonoTouch.UIKit.UIUserNotificationSettings notificationSettings) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("registerUserNotificationSettings:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="notificationSettings" Type="MonoTouch.UIKit.UIUserNotificationSettings" />
      </Parameters>
      <Docs>
        <param name="notificationSettings">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScheduledLocalNotifications">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UILocalNotification[] ScheduledLocalNotifications { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UILocalNotification[] ScheduledLocalNotifications" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(4, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("scheduledLocalNotifications")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(4, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setScheduledLocalNotifications:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.ObjCRuntime.Since(4, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UILocalNotification[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An array of <see cref="T:MonoTouch.UIKit.UILocalNotification" />s that are currently scheduled.</summary>
        <value>To be added.</value>
        <remarks>
          <para>If application developers set this property, the local notifications are replaced via a series of calls to <see cref="M:MonoTouch.UIKit.UIApplication.CancelLocalNotification" /> and <see cref="M:MonoTouch.UIKit.UIApplication.ScheduleLocalNotification" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScheduleLocalNotification">
      <MemberSignature Language="C#" Value="public virtual void ScheduleLocalNotification (MonoTouch.UIKit.UILocalNotification notification);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ScheduleLocalNotification(class MonoTouch.UIKit.UILocalNotification notification) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("scheduleLocalNotification:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(4, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="notification" Type="MonoTouch.UIKit.UILocalNotification" />
      </Parameters>
      <Docs>
        <param name="notification">To be added.</param>
        <summary>Schedules the <paramref name="notification" /> for delivery.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SendAction">
      <MemberSignature Language="C#" Value="public virtual bool SendAction (MonoTouch.ObjCRuntime.Selector action, MonoTouch.Foundation.NSObject target, MonoTouch.Foundation.NSObject sender, MonoTouch.UIKit.UIEvent forEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool SendAction(class MonoTouch.ObjCRuntime.Selector action, class MonoTouch.Foundation.NSObject target, class MonoTouch.Foundation.NSObject sender, class MonoTouch.UIKit.UIEvent forEvent) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("sendAction:to:from:forEvent:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="MonoTouch.ObjCRuntime.Selector" />
        <Parameter Name="target" Type="MonoTouch.Foundation.NSObject" />
        <Parameter Name="sender" Type="MonoTouch.Foundation.NSObject" />
        <Parameter Name="forEvent" Type="MonoTouch.UIKit.UIEvent" />
      </Parameters>
      <Docs>
        <param name="action">To be added.</param>
        <param name="target">
          <para>To be added.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <param name="sender">
          <para>To be added.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <param name="forEvent">
          <para>To be added.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Send an action message to the specified <paramref name="target" />.</summary>
        <returns>
          <see langword="true" /> if the responder handled the message.</returns>
        <remarks>
          <para>This method allows application developers to trigger native action methods. </para>
        </remarks>
        <altmember cref="M:MonoTouch.UIKit.UIApplication.SendEvent" />
      </Docs>
    </Member>
    <Member MemberName="SendEvent">
      <MemberSignature Language="C#" Value="public virtual void SendEvent (MonoTouch.UIKit.UIEvent uievent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SendEvent(class MonoTouch.UIKit.UIEvent uievent) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("sendEvent:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uievent" Type="MonoTouch.UIKit.UIEvent" />
      </Parameters>
      <Docs>
        <param name="uievent">To be added.</param>
        <summary>Sends an event to the application.</summary>
        <remarks>
          <para>This method allows application developers to create native <see cref="T:MonoTouch.UIKit.UIEvent" />s that are then handled normally.</para>
        </remarks>
        <altmember cref="M:MonoTouch.UIKit.UIApplication.SendAction" />
      </Docs>
    </Member>
    <Member MemberName="SetKeepAliveTimeout">
      <MemberSignature Language="C#" Value="public virtual bool SetKeepAliveTimeout (double timeout, MonoTouch.Foundation.NSAction handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool SetKeepAliveTimeout(float64 timeout, class MonoTouch.Foundation.NSAction handler) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setKeepAliveTimeout:handler:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(4, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Double" />
        <Parameter Name="handler" Type="MonoTouch.Foundation.NSAction">
          <Attributes>
            <Attribute>
              <AttributeName>MonoTouch.ObjCRuntime.BlockProxy(typeof(MonoTouch.ObjCRuntime.Trampolines/NIDNSAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="timeout">Time at which the application should be woken up to keep the VoIP connection going, must be at least 600 seconds.</param>
        <param name="handler">
          <para>The method that is invoked to keep your network connection open, the method has 10 seconds to run.   Use null to cancel the keep alive timeout. </para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Sets the specified handler as the VoIP keep alive method.</summary>
        <returns>True if the handler was installed, false if not.</returns>
        <remarks>
          <para> This method installs the handler to be executed by
            the operating system to keep voice-over-ip connections
            alive.  The handler will be invoked at least every 600
            seconds (the minimum required value) and should perform
            any handshakes required with the VoIP application before
            returning control to the operating system.  
          </para>
          <para>
            
            When the keep alive handler is called, the handler has 10
            seconds of foreground execution time, in which remaining
            background time is infinite (as returned by <see cref="P:MonoTouch.UIKit.UIApplication.BackgroundTimeRemaining" />).
            If you initiate a background task with <see cref="M:MonoTouch.UIKit.UIApplication.BeginBackgroundTask" />
            the task will get about 60 seconds to run.   
            
          </para>
          <para> Setting the keepAlive time to something significantly
            larger than 600 seconds will typically result in the
            handler being fired with a frequency of every time/2
            interval. Bonus fact: This is consistent with the SIP
            REGISTER request, in which the recommended re-registration
            interval is (re-register time/2).
          </para>
          <para>
            The BackgroundModes key in the application Info.plist file should list "voip".
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetMinimumBackgroundFetchInterval">
      <MemberSignature Language="C#" Value="public virtual void SetMinimumBackgroundFetchInterval (double minimumBackgroundFetchInterval);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetMinimumBackgroundFetchInterval(float64 minimumBackgroundFetchInterval) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setMinimumBackgroundFetchInterval:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="minimumBackgroundFetchInterval" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="minimumBackgroundFetchInterval">The desired minimum background fetch interval.  You can use the constant <see cref="P:MonoTouch.UIKit.UIApplication.BackgroundFetchIntervalMinimum" /> to set the minimum update interval or <see cref="P:MonoTouch.UIKit.UIApplication.BackgroundFetchIntervalNever" />) to disable background fetching.</param>
        <summary>Activates backgound fetching.</summary>
        <remarks>
          <para>

	    This method can be used to enable or disable background
	    fetching.  When you enable this, the operating system will
	    call your application's delegate <see cref="M:MonoTouch.UIKit.UIApplicationDelegate.PerformFetch" />
	    method at the discretion of the operating system to allow
	    your application to download and request data from a
	    server.
	  </para>
          <para>
	    This requires that your application has the background fetch entitlement activated.   
	  </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetNewsstandIconImage">
      <MemberSignature Language="C#" Value="public virtual void SetNewsstandIconImage (MonoTouch.UIKit.UIImage image);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetNewsstandIconImage(class MonoTouch.UIKit.UIImage image) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setNewsstandIconImage:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(5, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="MonoTouch.UIKit.UIImage" />
      </Parameters>
      <Docs>
        <param name="image">The image to be used, or <see langword="null" /> to set the icon stored in the app bundle.</param>
        <summary>Sets the icon to be used in Newsstand.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetStatusBarHidden">
      <MemberSignature Language="C#" Value="public virtual void SetStatusBarHidden (bool state, MonoTouch.UIKit.UIStatusBarAnimation animation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetStatusBarHidden(bool state, valuetype MonoTouch.UIKit.UIStatusBarAnimation animation) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setStatusBarHidden:withAnimation:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(3, 2)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Boolean" />
        <Parameter Name="animation" Type="MonoTouch.UIKit.UIStatusBarAnimation" />
      </Parameters>
      <Docs>
        <param name="state">
          <see langword="true" /> to hide the status bar, <see langword="false" /> to reveal it.</param>
        <param name="animation">The animation to use.</param>
        <summary>Hides or shows the status bar.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetStatusBarHidden">
      <MemberSignature Language="C#" Value="public virtual void SetStatusBarHidden (bool hidden, bool animated);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetStatusBarHidden(bool hidden, bool animated) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setStatusBarHidden:animated:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hidden" Type="System.Boolean" />
        <Parameter Name="animated" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="hidden">
          <see langword="true" /> to hide the status bar, <see langword="false" /> to reveal it.</param>
        <param name="animated">To be added.</param>
        <summary>Hides or shows the animation bar, and whether it should be animated.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetStatusBarOrientation">
      <MemberSignature Language="C#" Value="public virtual void SetStatusBarOrientation (MonoTouch.UIKit.UIInterfaceOrientation orientation, bool animated);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetStatusBarOrientation(valuetype MonoTouch.UIKit.UIInterfaceOrientation orientation, bool animated) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setStatusBarOrientation:animated:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="orientation" Type="MonoTouch.UIKit.UIInterfaceOrientation" />
        <Parameter Name="animated" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="orientation">To be added.</param>
        <param name="animated">To be added.</param>
        <summary>Sets the status bar to <paramref name="orientation" />.</summary>
        <remarks>
          <para>This method should not be used if the application is expected to handle rotation automatically. Once this method is called, the status bar will not change automatically in response to rotation.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetStatusBarStyle">
      <MemberSignature Language="C#" Value="public virtual void SetStatusBarStyle (MonoTouch.UIKit.UIStatusBarStyle statusBarStyle, bool animated);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetStatusBarStyle(valuetype MonoTouch.UIKit.UIStatusBarStyle statusBarStyle, bool animated) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setStatusBarStyle:animated:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="statusBarStyle" Type="MonoTouch.UIKit.UIStatusBarStyle" />
        <Parameter Name="animated" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="statusBarStyle">To be added.</param>
        <param name="animated">To be added.</param>
        <summary>Sets the style of the status bar, optionally animating the change.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SharedApplication">
      <MemberSignature Language="C#" Value="public static MonoTouch.UIKit.UIApplication SharedApplication { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.UIKit.UIApplication SharedApplication" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("sharedApplication")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIApplication</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Points to the main application class.</summary>
        <value>To be added.</value>
        <remarks>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SignificantTimeChangeNotification">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString SignificantTimeChangeNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString SignificantTimeChangeNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIApplicationSignificantTimeChangeNotification", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for SignificantTimeChange</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:MonoTouch.Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIApplication+Notifications" />.<see cref="M:UIApplication+Notifications.ObserveSignificantTimeChangeNotification" /> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="c#">
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveSignificantTimeChange ((sender, args) =&gt; {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, MonoTouch.Foundation.NSNotificationEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveSignificantTimeChange (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}</code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="c#">
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.SignificantTimeChangeNotification, (notification) =&gt; {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.SignificantTimeChangeNotification, Callback);
}
</code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StateRestorationBundleVersionKey">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString StateRestorationBundleVersionKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString StateRestorationBundleVersionKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIApplicationStateRestorationBundleVersionKey", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UIApplicationStateRestorationBundleVersionKey</summary>
        <value>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StateRestorationSystemVersionKey">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString StateRestorationSystemVersionKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString StateRestorationSystemVersionKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIApplicationStateRestorationSystemVersionKey", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UIApplicationStateRestorationSystemVersionKey</summary>
        <value>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StateRestorationTimestampKey">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString StateRestorationTimestampKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString StateRestorationTimestampKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIApplicationStateRestorationTimestampKey", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UIApplicationStateRestorationTimestampKey</summary>
        <value>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StateRestorationUserInterfaceIdiomKey">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString StateRestorationUserInterfaceIdiomKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString StateRestorationUserInterfaceIdiomKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIApplicationStateRestorationUserInterfaceIdiomKey", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UIApplicationStateRestorationUserInterfaceIdiomKey</summary>
        <value>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StatusBarFrame">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.RectangleF StatusBarFrame { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.RectangleF StatusBarFrame" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("statusBarFrame")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The Frame of the status bar.</summary>
        <value>Will be <see cref="P:System.Drawing.RectangleF.Zero" /> if the status bar is hidden.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StatusBarFrameUserInfoKey">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString StatusBarFrameUserInfoKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString StatusBarFrameUserInfoKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIApplicationStatusBarFrameUserInfoKey", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UIApplicationStatusBarFrameUserInfoKey</summary>
        <value>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StatusBarHidden">
      <MemberSignature Language="C#" Value="public virtual bool StatusBarHidden { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool StatusBarHidden" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("isStatusBarHidden")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setStatusBarHidden:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether the status bar is visible.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StatusBarOrientation">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIInterfaceOrientation StatusBarOrientation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype MonoTouch.UIKit.UIInterfaceOrientation StatusBarOrientation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("statusBarOrientation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setStatusBarOrientation:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIInterfaceOrientation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The orientation of the status bar.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <altmember cref="M:MonoTouch.UIKit.UIApplication.SetStatusBarOrientation" />
      </Docs>
    </Member>
    <Member MemberName="StatusBarOrientationAnimationDuration">
      <MemberSignature Language="C#" Value="public virtual double StatusBarOrientationAnimationDuration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 StatusBarOrientationAnimationDuration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("statusBarOrientationAnimationDuration")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The length of the animation used when the status bar rotates.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StatusBarOrientationUserInfoKey">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString StatusBarOrientationUserInfoKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString StatusBarOrientationUserInfoKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIApplicationStatusBarOrientationUserInfoKey", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UIApplicationStatusBarOrientationUserInfoKey</summary>
        <value>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StatusBarStyle">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIStatusBarStyle StatusBarStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype MonoTouch.UIKit.UIStatusBarStyle StatusBarStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("statusBarStyle")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setStatusBarStyle:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIStatusBarStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The current <see cref="T:MonoTouch.UIKit.UIStatusBarStyle" />.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportedInterfaceOrientationsForWindow">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIInterfaceOrientationMask SupportedInterfaceOrientationsForWindow (MonoTouch.UIKit.UIWindow window);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype MonoTouch.UIKit.UIInterfaceOrientationMask SupportedInterfaceOrientationsForWindow(class MonoTouch.UIKit.UIWindow window) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("supportedInterfaceOrientationsForWindow:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIInterfaceOrientationMask</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="window" Type="MonoTouch.UIKit.UIWindow">
          <Attributes>
            <Attribute>
              <AttributeName>MonoTouch.ObjCRuntime.Transient</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="window">To be added.</param>
        <summary>A bitmask indicating which orientations are supported.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UITrackingRunLoopMode">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString UITrackingRunLoopMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString UITrackingRunLoopMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UITrackingRunLoopMode", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UITrackingRunLoopMode</summary>
        <value>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterForRemoteNotifications">
      <MemberSignature Language="C#" Value="public virtual void UnregisterForRemoteNotifications ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UnregisterForRemoteNotifications() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("unregisterForRemoteNotifications")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>The application will no longer receive notifications from Apple Push Service.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UserDidTakeScreenshotNotification">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString UserDidTakeScreenshotNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString UserDidTakeScreenshotNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIApplicationUserDidTakeScreenshotNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for UserDidTakeScreenshot</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:MonoTouch.Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIApplication+Notifications" />.<see cref="M:UIApplication+Notifications.ObserveUserDidTakeScreenshotNotification" /> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="c#">
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveUserDidTakeScreenshot ((sender, args) =&gt; {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, MonoTouch.Foundation.NSNotificationEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveUserDidTakeScreenshot (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}</code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="c#">
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.UserDidTakeScreenshotNotification, (notification) =&gt; {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.UserDidTakeScreenshotNotification, Callback);
}
</code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserInterfaceLayoutDirection">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIUserInterfaceLayoutDirection UserInterfaceLayoutDirection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype MonoTouch.UIKit.UIUserInterfaceLayoutDirection UserInterfaceLayoutDirection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(5, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("userInterfaceLayoutDirection")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(5, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIUserInterfaceLayoutDirection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The layout direction (right-to-left or left-to-right) of the UI.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WeakDelegate">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.Foundation.NSObject WeakDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.Foundation.NSObject WeakDelegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("delegate")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setDelegate:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An object that can respond to the delegate protocol for this type</summary>
        <value>
          <para>The instance that will respond to events and data requests.</para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>
          <para>The delegate instance assigned to this object will be used to handle events or provide data on demand to this class.</para>
          <para>When setting the Delegate or WeakDelegate values events will be delivered to the specified instance instead of being delivered to the C#-style events</para>
          <para>   Methods must be decorated with the [Export ("selectorName")] attribute to respond to each method from the protocol.   Alternatively use the Delegate method which is strongly typed and does not require the [Export] attributes on methods.</para>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WillChangeStatusBarFrameNotification">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString WillChangeStatusBarFrameNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString WillChangeStatusBarFrameNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIApplicationWillChangeStatusBarFrameNotification", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for WillChangeStatusBarFrame</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:MonoTouch.Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIApplication+Notifications" />.<see cref="M:UIApplication+Notifications.ObserveWillChangeStatusBarFrameNotification" /> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="c#">
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveWillChangeStatusBarFrame ((sender, args) =&gt; {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("StatusBarFrame", args.StatusBarFrame);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, MonoTouch.UIKit.UIStatusBarFrameChangeEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("StatusBarFrame", args.StatusBarFrame);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveWillChangeStatusBarFrame (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}</code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="c#">
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.WillChangeStatusBarFrameNotification, (notification) =&gt; {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.WillChangeStatusBarFrameNotification, Callback);
}
</code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WillChangeStatusBarOrientationNotification">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString WillChangeStatusBarOrientationNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString WillChangeStatusBarOrientationNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIApplicationWillChangeStatusBarOrientationNotification", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for WillChangeStatusBarOrientation</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:MonoTouch.Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIApplication+Notifications" />.<see cref="M:UIApplication+Notifications.ObserveWillChangeStatusBarOrientationNotification" /> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="c#">
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveWillChangeStatusBarOrientation ((sender, args) =&gt; {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("StatusBarOrientation", args.StatusBarOrientation);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, MonoTouch.UIKit.UIStatusBarOrientationChangeEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("StatusBarOrientation", args.StatusBarOrientation);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveWillChangeStatusBarOrientation (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}</code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="c#">
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.WillChangeStatusBarOrientationNotification, (notification) =&gt; {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.WillChangeStatusBarOrientationNotification, Callback);
}
</code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WillEnterForegroundNotification">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString WillEnterForegroundNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString WillEnterForegroundNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIApplicationWillEnterForegroundNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(4, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(4, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for WillEnterForeground</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:MonoTouch.Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIApplication+Notifications" />.<see cref="M:UIApplication+Notifications.ObserveWillEnterForegroundNotification" /> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="c#">
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveWillEnterForeground ((sender, args) =&gt; {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, MonoTouch.Foundation.NSNotificationEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveWillEnterForeground (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}</code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="c#">
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.WillEnterForegroundNotification, (notification) =&gt; {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.WillEnterForegroundNotification, Callback);
}
</code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WillResignActiveNotification">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString WillResignActiveNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString WillResignActiveNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIApplicationWillResignActiveNotification", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for WillResignActive</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:MonoTouch.Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIApplication+Notifications" />.<see cref="M:UIApplication+Notifications.ObserveWillResignActiveNotification" /> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="c#">
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveWillResignActive ((sender, args) =&gt; {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, MonoTouch.Foundation.NSNotificationEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveWillResignActive (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}</code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="c#">
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.WillResignActiveNotification, (notification) =&gt; {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.WillResignActiveNotification, Callback);
}
</code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WillTerminateNotification">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString WillTerminateNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString WillTerminateNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIApplicationWillTerminateNotification", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for WillTerminate</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:MonoTouch.Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIApplication+Notifications" />.<see cref="M:UIApplication+Notifications.ObserveWillTerminateNotification" /> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="c#">
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveWillTerminate ((sender, args) =&gt; {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, MonoTouch.Foundation.NSNotificationEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveWillTerminate (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}</code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="c#">
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.WillTerminateNotification, (notification) =&gt; {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.WillTerminateNotification, Callback);
}
</code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Windows">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIWindow[] Windows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIWindow[] Windows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("windows")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIWindow[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>All of the application windows.</summary>
        <value>
        </value>
        <remarks>
          Invoking this property will return a list of all the windows created by this application.
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
