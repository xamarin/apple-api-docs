<?xml version="1.0"?>
<Type Name="UIView" FullName="MonoTouch.UIKit.UIView">
  <TypeSignature Language="C#" Value="public class UIView : MonoTouch.UIKit.UIResponder, System.Collections.IEnumerable"/>
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit UIView extends MonoTouch.UIKit.UIResponder implements class System.Collections.IEnumerable"/>
  <AssemblyInfo>
    <AssemblyName>monotouch</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>MonoTouch.UIKit.UIResponder</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>MonoTouch.Foundation.Register("UIView", true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Base class used for components that want to render themselves and respond to events.</summary>
    <remarks>
      <para>
        The UIView class is a rectangular area on the screen that is
        responsible for displaying content and handling user interactions
        with that content. It can also contain other views, allowing you to
        create complex interactive controls.  UIView can thus be used as
        either a standalone control, or a full screen of content built from
        many other independent UIViews. 
      </para>
      <para>Views have three major responsibilities:</para>
      <list type="bullet">
        <item>
          <term>
            Visualization: UIView instances are responsible for displaying
            their content, typically this is done by implementing a draw
            method using either <see cref="N:MonoTouch.CoreGraphics"/>,
            OpenGL or customizing some of their visual properties.  Views 
            also have built-in support for animating elements of the view.  
          </term>
        </item>
        <item>
          <term>
            Managing Layout and Subviews: UIViews are responsible for
            managing their layout in response to changes in size and
            orientation. This includes re-drawing any content they manage,
            as well as repositioning children views. This is most often in
            response to size of the UIView. For instance, if a view
            represents a button, the location of corners would change
            according to size. Or, if the device was rotated, the view might
            get resized (or it might resize it's child views).
          </term>
        </item>
        <item>
          <term>
            
            Event Handling: UIViews are a natural place to handle touch
            events since they are self-contained user interface elements.
            UIViews subclass the <see cref="T:MonoTouch.UIKit.UIResponder"/>
            class, so they participate both on system events (like motion
            and actions) as well as being able to process touch events.
            
          </term>
        </item>
      </list>
      <format type="text/html">
        <h2>Event Handling</h2>
      </format>
      <para>
        UIViews can handle touch events in two ways.  You can use the
        high-level gesture recognizer API to detect and handle gestures, or
        you can roll your own event handling by using the low-level
        interface that provides detailed touch events as they happen: every
        time a finger touches the screen or is lifted as well as motion of
        those fingers.  Both are covered below
      </para>
      <para>
        When your UIView wants to respond to user input by updating its
        display, it should call the
        <see cref="M:MonoTouch.UIKit.UIView.SetNeedsDisplay()"/> or
        <see cref="M:MonoTouch.UIKit.UIView.SetNeedsDisplayInRect(System.Drawing.RectangleF)"/> which will queue a call to your
        <see cref="M:MonoTouch.UIKit.UIView.Draw(System.Drawing.RectangleF)"/> method
        where you would re-render your control with the new state.
      </para>
      <para>
        Event delivery can be turned off either by setting the
        <see cref="P:MonoTouch.UIKit.UIView.UserInteractionEnabled"/> to false or you can
        disable them temporarily at the application level by calling
        <see cref="M:MonoTouch.UIKit.UIApplication.BeginIgnoringInteractionEvents"/>.  In
        both cases, events destined for the view are dropped and are not
        delivered to the views.
      </para>
      <para>
        Events are disabled while animation are playing back.  You can
        change this behavior when using explicit animations by using the
        <see cref="T:MonoTouch.UIKit.UIViewAnimationOptions"/>'s AllowUserInteraction
        flag in your animation.
      </para>
      <format type="text/html">
        <h3>Event Handling with Gesture Recognizers</h3>
      </format>
      <para>
        Interacting with touch interfaces has lead to a series of common
        gesture idioms that are used everywhere.  Gestures like swiping,
        panning, long-presses, pinching rotating and tapping.  iOS makes the
        process of detecting these common gesture idioms very easy by
        providing Gesture Recognizers.  These are objects that inherit from
        the UIGestureRecognizer class and can detect various standard
        gesture idioms.  The built-in recognizers include:
      </para>
      <list type="bullet">
        <item>
          <term>
            <see cref="T:MonoTouch.UIKit.UILongPressGestureRecognizer"/>
          </term>
        </item>
        <item>
          <term>
            <see cref="T:MonoTouch.UIKit.UIPanGestureRecognizer"/>
          </term>
        </item>
        <item>
          <term>
            <see cref="T:MonoTouch.UIKit.UIPinchGestureRecognizer"/>
          </term>
        </item>
        <item>
          <term>
            <see cref="T:MonoTouch.UIKit.UIRotationGestureRecognizer"/>
          </term>
        </item>
        <item>
          <term>
            <see cref="T:MonoTouch.UIKit.UISwipeGestureRecognizer"/>
          </term>
        </item>
        <item>
          <term>
            <see cref="T:MonoTouch.UIKit.UITapGestureRecognizer"/>
          </term>
        </item>
      </list>
      <para>
        In addition, you can create your own custom gesture recognizer by
        subclassing <see cref="T:MonoTouch.UIKit.UIGestureRecognizer"/>.
      </para>
      <para>
        To use the recognizer, you need to create an instance of the
        specific kind of recognizer that you need, optionally set some
        parameters and then you add it to the view by calling
        AddGestureRecognizer.  It is possible to attach multiple gesture
        recognizers to a single view.
      </para>
      <para>
        For example, the following code create a gesture recognizer that
        detects a panning gesture and assigns it to myView:
        
      </para>
      <example>
        <code lang="c#">
          var recognizer = new UIPanGestureRecognizer ((g) =&gt; {
          Console.WriteLine ("Panning detected");
          Console.WriteLine ("Gesture recognizer state: {0}", g.State);
          });
          
          myView.AddGestureRecognizer (recognizer);
        </code>
      </example>
      <para>
        The parameter passed to your lambda (in this case the "g" parameter)
        is an instance of the gesture recognizer that detected the gesture.
        You can query the parameters of the recognized query by looking at
        the properties in the recognizer, the
        <see cref="P:MonoTouch.UIKit.UIGestureRecognizer.State"/> property contains the
        recognizer state.
        
      </para>
      <format type="text/html">
        <h3>Event Handling with method Overrides</h3>
      </format>
      <para>
        Although Gesture Recognizers provide a high-level and convenient way
        of capturing many touch events, they do not cover every
        possibility. For those cases, developers should subclass UIView and
        override one or more of the following methods inherited from
        UIResponder:
      </para>
      <list type="bullet">
        <item>
          <term><see cref="M:MonoTouch.UIKit.UIResponder.TouchesBegan(MonoTouch.Foundation.NSSet,MonoTouch.UIKit.UIEvent)"/>:
            sent when one or more fingers touch the screen.
          </term>
        </item>
        <item>
          <term><see cref="M:MonoTouch.UIKit.UIResponder.TouchesMoved(MonoTouch.Foundation.NSSet,MonoTouch.UIKit.UIEvent)"/>:
            sent when one or more fingers move.
          </term>
        </item>
        <item>
          <term><see cref="M:MonoTouch.UIKit.UIResponder.TouchesEnded(MonoTouch.Foundation.NSSet,MonoTouch.UIKit.UIEvent)"/>:
            sent when one or more fingers are lifted from the screen.
          </term>
        </item>
        <item>
          <term><see cref="M:MonoTouch.UIKit.UIResponder.TouchesCancelled(MonoTouch.Foundation.NSSet,MonoTouch.UIKit.UIEvent)"/>:
            sent when the touch is cancelled by the system (for example if
            the phone interrupts your application).
          </term>
        </item>
      </list>
      <para>
        UIViews by default only handle a single touch event at once.  If you
        want your view to handle multiple touches, you must set the
        <see cref="P:MonoTouch.UIKit.UIView.MultipleTouchEnabled"/> to true.
      </para>
      <para>
        
        iOS creates a T:MonoTouch.UIKit.UIEvent object any time a finger
        touches the screen, moves or is removed from the screen.  The <see cref="T:MonoTouch.UIKit.UIEvent"/> encapsulates all of the touches
        that are taking place on the screen at this point, even those that
        do not belong to this view.  In addition to the <see cref="T:MonoTouch.UIKit.UIEvent"/>, there is an <see cref="T:MonoTouch.Foundation.NSSet"/> containing <see cref="T:MonoTouch.UIKit.UITouch"/> objects that represent the state
        of each finger on the screen for this particular view.
      </para>
      <para>
        
        If your application handles touches directly, you might want to
        override the <see cref="M:MonoTouch.UIKit.UIView.GestureRecognizerShouldBegin(MonoTouch.UIKit.UIGestureRecognizer)"/>
        method to control whether an associated
        <see cref="T:MonoTouch.UIKit.UIGestureRecognizer"/> should execute or not.
        
      </para>
      <format type="text/html">
        <h2>Creating Views</h2>
      </format>
      <para>
        UIViews are typically created by invoking the constructor that takes
        a frame as its parameter (the frame is of type
        <see cref="T:System.Drawing.RectangleF"/>), for example:
      </para>
      <example>
        <code lang="c#">
          var myView = new UIView (new RectangleF (0, 0, 100, 100));
        </code>
      </example>
      <para>
        Most subclasses of UIView will provide a constructor that takes the
        initial frame, just like UIView.  For more information on how to do
        this for your own subclasses, see the section below on subclassing
        UIView.
      </para>
      <para>
        You will want to configure your view at this point.  One of the most
        important properties to configure is the
        <see cref="P:MonoTouch.UIKit.UIView.AutoresizingMask"/> which determines how the
        view will be resized if you invoke
        <see cref="M:MonoTouch.UIKit.UIView.SetNeedsLayout()"/> or if the geometry of the
        view container changes (for example, in response to a device
        rotation).
      </para>
      <para>
        Once you have created a view, you will add it to a container view.
        For your main screen this could be a UIWindow or it could be the
        <see cref="P:MonoTouch.UIKit.UIViewController.View"/> property of your current
        <see cref="T:MonoTouch.UIKit.UIViewController"/>, this is done using one of the
        following methods:
      </para>
      <list type="bullet">
        <item>
          <term>
            <see cref="M:MonoTouch.UIKit.UIView.AddSubview(MonoTouch.UIKit.UIView)"/>
          </term>
        </item>
        <item>
          <term>
            <see cref="M:MonoTouch.UIKit.UIView.InsertSubview(MonoTouch.UIKit.UIView, int)"/>
          </term>
        </item>
        <item>
          <term>
            <see cref="M:MonoTouch.UIKit.UIView.InsertSubviewAbove(MonoTouch.UIKit.UIView, MonoTouch.UIKit.UIView)"/>
          </term>
        </item>
        <item>
          <term>
            <see cref="M:MonoTouch.UIKit.UIView.InsertSubviewBelow(MonoTouch.UIKit.UIView, MonoTouch.UIKit.UIView)"/>
          </term>
        </item>
      </list>
      <para>
        Although you can use the above APIs to add subviews to any
        UIView, Apple advises developers against extending
        existing high-level views by adding subviews to them behind their
        back.  Instead developers should use the public API those high-level
        views expose.
      </para>
      <format type="text/html">
        <h2>Bounds and Sizes</h2>
      </format>
      <para>
        Each view is created with an initial <see cref="P:MonoTouch.UIKit.UIView.Frame"/>.  The Frame is a
        <see cref="T:System.Drawing.RectangleF"/> structure that represents both the size and the initial
        position for the view.  The coordinates for the Frame are used to
        specify the position relative to its superview.
      </para>
      <para>
        You can resize and move views around using the frame.  Every time
        you set the frame the view will layout its subviews. If you are
        purely moving the view, using frame can cause performance issues, as
        it relays out the view and all its subviews.
      </para>
      <para>
        The <see cref="P:MonoTouch.UIKit.UIView.Bounds"/> is the usable
        frame of the view.  Unlike the <see cref="P:MonoTouch.UIKit.UIView.Frame"/>, the <see cref="P:MonoTouch.UIKit.UIView.Bounds"/> do not use the container's
        coordinate space, but instead represent the size in the view's own
        coordinate space.  By default the <see cref="P:MonoTouch.UIKit.UIView.Bounds"/> location is (0,0).
      </para>
      <para>
        
        When you update the <see cref="P:MonoTouch.UIKit.UIView.Bounds"/>
        property, it will modify the <see cref="P:MonoTouch.UIKit.UIView.Frame"/> based on the value of the
        <see cref="P:MonoTouch.UIKit.UIView.Center"/>.  You can also change
        the position of your view by updating the <see cref="P:MonoTouch.UIKit.UIView.Center"/> property.
        
      </para>
      <para>
        When the <see cref="P:MonoTouch.UIKit.UIView.Bound"/> property is changed, the size of the view is affected
        relative to the <see cref="P:MonoTouch.UIKit.UIView.Center"/> property.
      </para>
      <format type="text/html">
        <h2>Animation</h2>
      </format>
      <para>
        There are two styles of animations supported by UIViews, implicit
        animations and explicit animations.
      </para>
      <para>
        Implicit animations happen automatically when you modify the <see cref="P:MonoTouch.UIKit.UIView.Frame"/>, <see cref="P:MonoTouch.UIKit.UIView.Bounds"/>, <see cref="P:MonoTouch.UIKit.UIView.Center"/>, <see cref="P:MonoTouch.UIKit.UIView.Transform"/>, <see cref="P:MonoTouch.UIKit.UIView.Alpha"/>, <see cref="P:MonoTouch.UIKit.UIView.BackgroundColor"/> or <see cref="P:MonoTouch.UIKit.UIView.ContentStretch"/> properties in a
        view.  The system will automatically animate the change using the
        system defaults.  When you modify any of these animatable properties
        in the view, iOS automatically creates an animation transaction
        which starts as soon as control returns to the main loop.
      </para>
      <para>
        For example, the following code will animate a view's <see cref="P:MonoTouch.UIKit.UIView.Bounds"/> and
        <see cref="P:MonoTouch.UIKit.UIView.Center"/></para>
      <example>
        <code lang="c#">
          
          view.Bounds = new RectangleF (0, 0, 100, 100);
          view.Center = new PointF (200, 200);
        </code>
      </example>
      <para>
        Alternatively, you can create animations explicitly by calling the
        <see cref="M:MonoTouch.UIKit.UIView..BeginAnimations(string)"/> method, configuring the animation, making the
        changes to the animatable properties and then completing the
        transaction by calling <see cref="M:MonoTouch.UIKit.UIView.CommitAnimations()"/>.
      </para>
      <para>
        Once you call <see cref="M:MonoTouch.UIKit.UIView.BeginAnimations(string)"/>, you can
        call these methods to configure the animation:
      </para>
      <list type="bullet">
        <item>
          <term>
            <see cref="M:MonoTouch.UIKit.UIView.SetAnimationDuration(double)"/>
          </term>
        </item>
        <item>
          <term>
            <see cref="M:MonoTouch.UIKit.UIView.SetAnimationCurve(MonoTouch.UIKit.UIViewAnimationCurve)"/>
          </term>
        </item>
        <item>
          <term>
            <see cref="M:MonoTouch.UIKit.UIView.SetAnimationDelay(double)"/>
          </term>
        </item>
        <item>
          <term>
            <see cref="M:MonoTouch.UIKit.UIView.SetAnimationDelegate(MonoTouch.Foundation.NSObject)"/>
          </term>
        </item>
        <item>
          <term>
            <see cref="M:MonoTouch.UIKit.UIView.SetAnimationRepeatAutoReverses(bool)"/>
          </term>
        </item>
        <item>
          <term>
            <see cref="M:MonoTouch.UIKit.UIView.SetAnimationRepeatCount(float)"/>
          </term>
        </item>
        <item>
          <term>
            <see cref="M:MonoTouch.UIKit.UIView.SetAnimationDidStopSelector(MonoTouch.ObjCRuntime.Selector)"/>
          </term>
        </item>
      </list>
      <para>
        The following example shows how to use these methods in a
        transaction:
      </para>
      <example>
        <code lang="c#">
          UIView.BeginAnimations (null);
          UIView.SetAnimationDuration (5);
          UIView.SetAnimationCurve (UIViewAnimationCurve.EaseOut);
          view.Bounds = new RectangleF (0, 0, 100, 100);
          view.Position = new PointF (200, 200);
          UIView.CommitAnimations ();
        </code>
      </example>
      <para>
        An alternative to create the transactions and set the configuration
        options is to use the new <see cref="M:MonoTouch.UIKit.UIView.Animate"/> collection of methods that
        allow you to specify in a single call the delay, the duration, the
        animation block and an action to be invoked when the animation
        completes:
      </para>
      <example>
        <code lang="c#">
          UIView.Animate (duration, delay, UIViewAnimationOption.Autoreverse,
          delegate {
          view.Bounds = new RectangleF (0, 0, 100, 100);
          view.Position = new PointF (200, 200);
          },
          delegate {
          Console.WriteLine ("Animation completed");
          }
          );
        </code>
      </example>
      <para>
        The above is the basic set of animations supported by UIViews.  If
        you want finer control over animations you can resort to animations
        done directly using <see cref="N:MonoTouch.CoreAnimation"/>.  <see cref="N:MonoTouch.CoreAnimation"/> allows you to
        animate layers and properties of your C# objects.
      </para>
      <format type="text/html">
        <h2>Threading</h2>
      </format>
      <para>
        UIView methods are not thread safe, so you should avoid configuring
        or invoking any of the UIView static methods from any thread that is
        not the main thread.  Newer versions of MonoTouch catch these
        mistakes in Debug builds by throwing an exception.  See the
        <see cref="F:MonoTouch.UIKit.UIApplication.CheckForIllegalCrossThreadCalls"/> for
        more information.
      </para>
      <para>
        If you want to perform some work in a background thread that must
        update any of the UIView properties or you want to invoke any of the
        UIView static methods, you should use either the
        <see cref="M:MonoTouch.Foundation.NSObject.BeginInvokeOnMainThread()"/> or
        <see cref="M:MonoTouch.Foundation.NSObject.InvokeOnMainThread()"/> methods.  Both
        methods take a C# delegate or lambda that is invoked on the main
        thread.
      </para>
      <para>
        The <see cref="M:MonoTouch.Foundation.NSObject.InvokeOnMainThread()"/> method will
        invoke the specified delegate method synchronously on the main
        thread. The
        <see cref="M:MonoTouch.Foundation.NSObject.BeginInvokeOnMainThread()"/> will queue
        the action to be executed on the main thread.
      </para>
      <para>
        Example:
      </para>
      <example>
        <code lang="c#">
          //
          // This performs an expensive computation in the background, and then
          // updates the main UI when done.
          //
          void DoSomeWork (UIView view)
          {
          double sum = 0;
          for (int i = 0; i &lt; Int32.MaxValue; i++)
          sum += i * i;
          
          // Now invoke the update on the main UI.
          view.BeginInvokeOnMainThread (delegate {
          view.BackgroundColor = UIColor.Green;
          statusLabel.Text = "Sum is: " + sum;
          });
          }
        </code>
      </example>
      <para>
        The following example shows a helper method that can be used to run
        the provided action on the main thread.  It optimizes for the case
        where you are calling this from the main thread already, and avoids
        a trip to the main loop pump:
      </para>
      <example>
        <code lang="c#">
          static NSObject Invoker = new NSObject();
          public static void EnsureInvokedOnMainThread (Action action)
          {
          if (NSThread.Current.IsMainThread) {
          action ();
          return;
          }
          Invoker.BeginInvokeOnMainThread (() =&gt; action());
          }
        </code>
      </example>
      <format type="text/html">
        <h2>How to Subclass UIView</h2>
      </format>
      <para>
        Developers will often subclass UIView to provide their own custom
        views to use.  This section discusses the different classes of
        members that developers would overwrite to create their custom
        classes.
      </para>
      <format type="text/html">
        <h3>Initialization</h3>
      </format>
      <para>
        Your subclass of UIView should chain into either the UIView
        constructor that is initialized with an initial frame (<see cref="C:MonoTouch.UIKit.UIView(System.Drawing.RectangleF)"/>).  You
        would typically do this like this:
      </para>
      <example>
        <code lang="c#">
          public class MyView : UIView {
          public MyView (RectangleF frame) : base (frame)
          {
          // Your initialization code goes here
          }
          }
        </code>
      </example>
      <para>
        If your object will be deserialized from an archive produced by the
        UI designer, you would need to chain to the <see cref="C:MonoTouch.UIKit.UIView(MonoTouch.Foundation.NSCoder)"/>
        constructor and also flag the constructor as being the one
        implementing the selector "initWithCoder:", like this:
      </para>
      <example>
        <code lang="c#">
          public class MyView : UIView {
          [Export ("initWithCoder:")]
          public MyView (NSCoder coder) : base (coder)
          {
          // Your initialization code goes here
          }
          }
        </code>
      </example>
      <para>
        By default UIViews will use a <see cref="T:MonoTouch.CoreAnimation.CALayer"/> instance for their
        backing store.  The section on "Changing the CALayer" below has both
        information on how to make this change and a sample.
      </para>
      <para>
        If your view will contains any other subviews, you should initialize
        those values in your constructor.
      </para>
      <format type="text/html">
        <h3>Custom Drawing</h3>
      </format>
      <para>
        To implement custom drawing code in a view, you can subclass the
        UIView and override the <see cref="M:MonoTouch.UIKit.UIView.Draw(System.Drawing.RectangleF)"/>
        method. The drawing code placed in the Draw method can use <see cref="N:MonoTouch.CoreGraphics"/> to draw with. The steps to draw
        with Core Graphics are:
      </para>
      <list type="bullet">
        <item>
          <term>Obtain a reference to the current graphics context.</term>
        </item>
        <item>
          <term>Set up any desired drawing attributes, such as fill and stroke colors for instance.</term>
        </item>
        <item>
          <term>Create geometry from Core Graphics primitives.</term>
        </item>
        <item>
          <term>Draw the geometry.</term>
        </item>
      </list>
      <para>
        For example, the following code shows an implementation of an
        overridden Draw method that draws a triangle:
      </para>
      <example>
        <code lang="c#">
          public override void Draw (RectangleF rect)
          {
          base.Draw (rect);
          
          var context = UIGraphics.GetCurrentContext ();
          
          context.SetLineWidth(4);
          UIColor.Red.SetFill ();
          UIColor.Blue.SetStroke ();
          
          var path = new CGPath ();
          
          path.AddLines(new PointF[]{
          new PointF(100,200),
          new PointF(160,100), 
          new PointF(220,200)});
          
          path.CloseSubpath();
          
          context.AddPath(path);		
          context.DrawPath(CGPathDrawingMode.FillStroke);
          }
        </code>
      </example>
      <para>
        The <see cref="M:MonoTouch.UIKit.UIView.Draw"/> method should never be called directly. It is called by iOS
        during run loop processing. The first time through the run loop, it
        is called. After that, it will be called on demand whenever the view
        has been marked as needing display by calling <see cref="M:MonoTouch.UIKit.UIView.SetNeedsDisplay()"/> or
        <see cref="M:MonoTouch.UIKit.UIView.SetNeedsDisplayInRect(System.Drawing.RectangleF)"/>.
      </para>
      <para>
        Core Graphics uses device independent points rather than
        pixels. This allows drawing code to scale between different
        resolutions. For example, on a Retina display, 1 point is equivalent
        to 2 pixels, while on non-Retina displays, 1 point corresponds to 1
        pixel.
      </para>
      <format type="text/html">
        <h3>Printing</h3>
      </format>
      <para>
        UIViews can be printed.  The default behavior is for the contents of
        the UIView as rendered by the <see cref="M:MonoTouch.UIKit.UIView.Draw(System.Drawing.RectangleF)"/>
        method to be printed.
      </para>
      <para>
        If you need to provide a different rendering for the view when
        printed, you should override the <see cref="M:MonoTouch.UIKit.UIView.DrawRect(System.Drawing.RectangleF,MonoTouch.UIKit.UIView.UIViewPrintFormatter)"/>
        method.
      </para>
      <format type="text/html">
        <h3>Constraints</h3>
      </format>
      <para>
        If you want your view subclass to use the new constraint-based
        layout system introduced with iOS 6.0, your subclass needs to
        respond to the requiresConstraintBasedLayout selector, like this:
      </para>
      <example>
        <code lang="c#">
          class MyView : UIView {
          [Export ("requiresConstraintBasedLayout")]
          bool UseNewLayout ()
          {
          return true;
          }
          }
        </code>
      </example>
      <para>
        If your view will use constraints among its own subviews to lay them
        out, you should override the <see cref="M:P:MonoTouch.UIKit.UIView.UpdateConstraints"/> which is
        called before the constraints-based layout is performed.
      </para>
      <para>
        
        Constraints-based layout is performed on the alignment rectangle
        instead of the view's <see cref="P:MonoTouch.UIKit.UIView.Frame"/>.
        The alignment rectangle by default is computed as the <see cref="P:MonoTouch.UIKit.UIView.Frame"/> modified by the <see cref="P:MonoTouch.UIKit.UIView.AlignmentRectInsets"/>.  You can
        change that behavior and provide your own alignment rectangle by
        overriding the <see cref="M:MonoTouch.UIKit.UIView.AlignmentRectForFrame(System.Drawing.RectangleF)"/>
        and <see cref="M:MonoTouch.UIKit.UIView.FrameForAlignmentRect(System.Drawing.RectangleF)"/>
        methods.
      </para>
      <format type="text/html">
        <h3>Layout</h3>
      </format>
      <para>
        The default layout system for UIViews is very simple.  UIViews are
        created with an initial <see cref="P:MonoTouch.UIKit.UIView.Frame"/>
        and an <see cref="P:MonoTouch.UIKit.UIView.AutoresizingMask"/> that
        determines how the view will be resized in response to changes in
        the container's boundaries.
      </para>
      <para>
        You should set the default <see cref="P:MonoTouch.UIKit.UIView.AutoresizingMask"/> property after
        initialization.
      </para>
      <para>
        If your view will be a container for other views, you should
        configure their <see cref="P:MonoTouch.UIKit.UIView.AutoresizingMask"/> property.  If the
        layout behavior provided is not sufficient, you should override the
        <see cref="M:MonoTouch.UIKit.UIView.LayoutSubviews()"/> method.
        This method is responsible for updating the <see cref="P:MonoTouch.UIKit.UIView.Frame"/> property of each of the
        subviews.
      </para>
      <para>
        If the state of your view changes in response to some API calls,
        instead of changing the layout manually in response to the change,
        you should invoke the <see cref="M:MonoTouch.UIKit.UIView.SetNeedsLayout()"/> method which will
        flag the view for a layout.  The layout event will then be processed
        the next time the main loop runs.  By using this approach, you can
        coalesce multiple changes to the layout in a single pass.
      </para>
      <para>
        UIViews can implement the <see cref="M:MonoTouch.UIKit.UIView.SizeThatFits(System.Drawing.SizeF)"/>
        method to report back what is their desired size based on the
        contents of the view.
      </para>
      <para>
        You can override the <see cref="M:MonoTouch.UIKit.UIView.SubviewAdded(MonoTouch.UIKit.UIView)"/>
        and the <see cref="M:MonoTouch.UIKit.UIView.WillRemoveSubview(MonoTouch.UIKit.UIView)"/>
        to track when subviews are added or removed to your UIView.
      </para>
      <para>
        You can override the <see cref="M:MonoTouch.UIKit.UIView.WillMoveToWindow(MonoTouch.UIKit.UIWindow)"/>
        and the <see cref="M:MonoTouch.UIKit.UIView.MovedToWindow()"/> to
        track when your view is moved from one <see cref="T:MonoTouch.UIKit.UIWindow"/> to another.
      </para>
      <para>
        You can override the <see cref="M:MonoTouch.UIKit.UIView.WillMoveToSuperview(MonoTouch.UIKit.UIView)"/>
        and the <see cref="M:MonoTouch.UIKit.UIView.MovedToSuperview()"/> to
        track when your view is added or removed from a superview.
      </para>
      <format type="text/html">
        <h2>Constraints Based Layout</h2>
      </format>
      <para>
        Starting with iOS 6.0 there is a new layout system available to
        developers, the constraints-based layout system.  This system
        differs from the traditional layout system in that it uses rules
        (constraints) that describe the relationships between subviews that
        should be preserved.  When views change in size (for example a label
        is updated) or the size of the container changes (for example, after
        a rotation), the new positions and sizes for the subviews are
        computed based on these constraints.
      </para>
      <para>
        To opt into this system, a subclass of UIView should expose a static
        method that is exported as "requiresConstraintBasedLayout" and
        returns true, like this:
      </para>
      <example>
        <code lang="c#">
          class MyView : UIView {
          [Export ("requiresConstraintBasedLayout")]
          static bool RequiresConstraintBasedLayout ()
          {
          return true;
          }
          }
        </code>
      </example>
      <format type="text/html">
        <h3>Event Handling</h3>
      </format>
      <para>
        If you are using gesture recognizers, you can add those directly to
        your constructor at initialization time.
      </para>
      <para>
        For the low-level touch event handling, you should override the <see cref="M:MonoTouch.UIKit.UIResponder.TouchesBegan(MonoTouch.Foundation.NSSet,MonoTouch.UIKit.UIEvent)"/>, <see cref="M:MonoTouch.UIKit.UIResponder.TouchesMoved(MonoTouch.Foundation.NSSet,MonoTouch.UIKit.UIEvent)"/>, <see cref="M:MonoTouch.UIKit.UIResponder.TouchesEnded(MonoTouch.Foundation.NSSet,MonoTouch.UIKit.UIEvent)"/> and <see cref="M:MonoTouch.UIKit.UIResponder.TouchesCancelled(MonoTouch.Foundation.NSSet,MonoTouch.UIKit.UIEvent)"/> methods.
      </para>
      <para>
        You do not need to call the base methods for any of the above
        methods if you are overriding UIView directly.  But you might want
        to call base if you are deriving from another UIView subclass.
      </para>
      <para>
        You can control whether a gesture recognizer is activated by
        overriding the <see cref="M:MonoTouch.UIKit.UIViewGestureRecognizerShouldBegin(MonoTouch.UIKit.UIGestureRecognizer)"/>
        method.
      </para>
      <format type="text/html">
        <h2>Views and CALayers</h2>
      </format>
      <para>
        Each UIView is backed by a <see cref="N:MonoTouch.CoreAnimation"/> Layer (<see cref="MonoTouch.CoreAnimation.CALayer"/>).  A CALayer
        represents the GPU-backed bitmap that is used to render your view
        into the screen.  When you paint into a UIView, you are actually
        painting into the CALayer.
      </para>
      <para>
        While the appearance of a UIView can be controlled by setting its
        <see cref="P:MonoTouch.UIKit.UIView.Frame"/>, <see cref="P:MonoTouch.UIKit.UIView.Alpha"/>, <see cref="P:MonoTouch.UIKit.UIView.BackgroundColor"/>, or by overriding its <see cref="M:MonoTouch.UIKit.UIView.Draw"/> method, all
        those properties and functions are in fact modifying the <see cref="P:MonoTouch.CoreAnimation.CALayer"/>
        owned by the view.
      </para>
      <para>
        The <see cref="MonoTouch.UIKit.UIView.Layer"/> property is a reference to the
        CALayer owned by the view. You can change the appearance of the view
        by modifying the properties of that layer.
      </para>
      <para>
        For example, you can add rounded corners to the UIView by modifying
        the <see cref="P:MonoTouch.CoreAnimation.CALayer.CornerRadius"/> of its layer:
      </para>
      <example>
        <code lang="c#">
          view.Layer.CornerRadius = 4;
        </code>
      </example>
      <para>
        You can add drop shadows by modifying a variety of properties:
      </para>
      <example>
        <code lang="c#">
          view.Layer.ShadowColor = new CGColor (1, 0, 0);
          view.Layer.ShadowOpacity = 1.0f;
          view.Layer.ShadowOffset = new SizeF (0, 4);
        </code>
      </example>
      <para>
        You can even apply a 3D transformation to the layer:
      </para>
      <example>
        <code lang="c#">
          view.Layer.Transform = CATransform3D.MakeRotation (
          (float)(Math.PI / 2), 1, 1, 1);
        </code>
      </example>
      <para>
        Note that this transformation is a full 3D transform, with a
        perspective element, that is more versatile than UIView's 2D
        Transform property.   If you apply 3D transforms, you should no longer use the Frame property
      </para>
      <format type="text/html">
        <h3>Changing the CALayer</h3>
      </format>
      <para>
        The <see cref="P:MonoTouch.UIKit.UIView.Layer"/> owned by a view is automatically
        created and assigned to the view by UIKit and it defaults to be a
        <see cref="T:MonoTouch.CoreAnimation.CALayer"/> instance.   You can control the type
        of layer that is created for a view by responding to the "layerClass" 
        selector in a static method.
      </para>
      <para>
        Here is an example of a UIView subclass that uses a custom <see cref="T:MonoTouch.CoreAnimation.CALayer"/> to do its drawing. This
        layer, and therefore the view, always displays the color blue:
      </para>
      <example>
        <code lang="c#">
          public class BlueView : UIView
          {
          [Export ("layerClass")]
          public static Class GetLayerClass ()
          {
          return new Class (typeof (BlueLayer));
          }
          
          public override void Draw (RectangleF rect)
          {
          // Do nothing, the Layer will do all the drawing
          }
          }
          
          public class BlueLayer : CALayer
          {
          public override void DrawInContext (CGContext ctx)
          {
          ctx.SetFillColor (0, 0, 1, 1);
          ctx.FillRect (Bounds);
          }
          }
        </code>
      </example>
      <para>
        In this example, a new UIView class called "BlueView" is created. It
        exports a static method called "GetLayerClass" that tells UIKit the
        type of layer that this view wishes to own. In this example, the
        BlueView wishes to own a BlueLayer.
      </para>
      <para>
        It is now up to the BlueLayer to provide the visual representation
        of the view. It does this by executing CoreGraphics drawing code in
        its <see cref="M:MonoTouch.CoreAnimation.CALayer.DrawInContext(MonoTouch.CoreGraphics.CGContext)"/>
        method. This method is very similar to a UIView's Draw method but is used to fill the layer.
        
      </para>
      <para>
        Even though the BlueLayer will do all drawing for the BlueView, the
        view must still override its Draw method. This override should do
        nothing and is just a signal to UIKit that the Layer will do all the
        work.
      </para>
    </remarks>
    <related type="recipe" href="http://docs.xamarin.com/ios/Recipes/Animation/CoreAnimation/Animate_a_UIView_using_UIKit">Animate a UIView using UIKit</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIView ();"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed"/>
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("init")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters/>
      <Docs>
        <summary>Default constructor that initializes a new instance of this class with no parameters.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIView (MonoTouch.Foundation.NSCoder coder);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class MonoTouch.Foundation.NSCoder coder) cil managed"/>
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("initWithCoder:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="coder" Type="MonoTouch.Foundation.NSCoder"/>
      </Parameters>
      <Docs>
        <param name="coder">The unarchiver object.</param>
        <summary>A constructor that initializes the object from the data stored in the unarchiver object.</summary>
        <remarks>This constructor is provided to allow the class to be initialized from an unarchiver (for example, during NIB deserialization).</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIView (MonoTouch.Foundation.NSObjectFlag t);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class MonoTouch.Foundation.NSObjectFlag t) cil managed"/>
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="t" Type="MonoTouch.Foundation.NSObjectFlag"/>
      </Parameters>
      <Docs>
        <param name="t">Unused sentinel value, pass NSObjectFlag.Empty.</param>
        <summary>Constructor to call on derived classes to skip initialization and merely allocate the object.</summary>
        <remarks>
          <para>This constructor should be called by derived classes when they completely construct the object in managed code and merely want the runtime to allocate and initialize the NSObject.   This is required to implement the two-step initialization process that Objective-C uses, the first step is to perform the object allocation, the second step is to initialize the object.   When you invoke the constructor that takes the NSObjectFlag.Empty you taking advantage of a direct path that goes all the way up to NSObject to merely allocate the object's memory and bind the Objective-C and C# objects together.    The actual initialization of the object is up to you.</para>
          <para>This constructor is typically used by the binding generator to allocate the object, but prevent the actual initialization to take place.   Once the allocation has taken place, the constructor has to initialize the object.   With constructors generated by the binding generator this means that it manually invokes one of the "init" methods to initialize the object.</para>
          <para>It is your responsibility to completely initialize the object if you chain up using the NSObjectFlag.Empty path.</para>
          <para>In general, if your constructors invokes the NSObjectFlag.Empty base implementation, then it should be calling an Objective-C init method.   If this is not the case, you should instead chain to the proper constructor in your class. </para>
          <para>The argument value is ignored and merely ensures that the only code that is executed is the construction phase is the basic NSObject allocation and runtime type registration.  Typically the chaining would look like this:</para>
          <example>
            <code lang="C#">
              //
              // The NSObjectFlag merely allocates the object and registers the
              // C# class with the Objective-C runtime if necessary, but no actual
              // initXxx method is invoked, that is done later in the constructor
              //
              // This is taken from MonoTouch's source code:
              //
              [Export ("initWithFrame:")]
              public UIView (System.Drawing.RectangleF frame) : base (NSObjectFlag.Empty)
              {
              // Invoke the init method now.
              var initWithFrame = new Selector ("initWithFrame:").Handle;
              if (IsDirectBinding)
              Handle = MonoTouch.ObjCRuntime.Messaging.IntPtr_objc_msgSend_RectangleF (this.Handle, initWithFrame, frame);
              else
              Handle = MonoTouch.ObjCRuntime.Messaging.IntPtr_objc_msgSendSuper_RectangleF (this.SuperHandle, initWithFrame, frame);
              }
            </code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIView (System.Drawing.RectangleF frame);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Drawing.RectangleF frame) cil managed"/>
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("initWithFrame:")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="frame" Type="System.Drawing.RectangleF"/>
      </Parameters>
      <Docs>
        <param name="frame">Frame used by the view, expressed in iOS points.</param>
        <summary>Initializes the UIView with the specified frame.</summary>
        <remarks>
          <para>This constructor is used to programmatically create a new instance of UIView with the specified dimension in the frame.   The object will only be displayed once it has been added to a view hierarchy by calling AddSubview in a containing view.</para>
          <para>This constructor is not invoked when deserializing objects from storyboards or XIB filesinstead the constructor that takes an NSCoder parameter is invoked.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIView (IntPtr handle);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle) cil managed"/>
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr"/>
      </Parameters>
      <Docs>
        <param name="handle">Pointer (handle) to the unmanaged object.</param>
        <summary>A constructor used when creating managed representations of unmanaged objects;  Called by the runtime.</summary>
        <remarks>
          <para>This constructor is invoked by the runtime infrastructure (<see cref="M:MonoTouch.ObjCRuntime.GetNSObject (System.IntPtr)"/>) to create a new managed representation for a pointer to an unmanaged Objective-C object.    You should not invoke this method directly, instead you should call the GetNSObject method as it will prevent two instances of a managed object to point to the same native object.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (MonoTouch.UIKit.UIView view);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(class MonoTouch.UIKit.UIView view) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="view" Type="MonoTouch.UIKit.UIView"/>
      </Parameters>
      <Docs>
        <param name="view">The subview to add.</param>
        <summary>This is an alias for <see cref="M:MonoTouch.UIKit.UIView.AddSubview"/>, but uses the Add pattern as it allows C# 3.0 constructs to add subviews after creating the object.</summary>
        <remarks>
          <para>
            This method is equivalent to <see cref="M:MonoTouch.UIKit.UIView.AddSubview"/> and is present to enable C# 3.0 to add subviews at creation time.
          </para>
          <example>
            <code lang="c#">
              var myView = new MyView (new RectangleF (0, 0, 320, 320)){
              &#xA0;&#xA0;new ImageGallery (region [0]),
              &#xA0;&#xA0;new ImageGallery (region [1]),
              &#xA0;&#xA0;new UILabel (new RectangleF (10, 10, 200, 200)){
              &#xA0;&#xA0;&#xA0;&#xA0;Text = "Images from our Trip"
              &#xA0;&#xA0;}
              };
            </code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddConstraint">
      <MemberSignature Language="C#" Value="public virtual void AddConstraint (MonoTouch.UIKit.NSLayoutConstraint constraint);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddConstraint(class MonoTouch.UIKit.NSLayoutConstraint constraint) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("addConstraint:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constraint" Type="MonoTouch.UIKit.NSLayoutConstraint"/>
      </Parameters>
      <Docs>
        <param name="constraint">An <see cref="T:MonoTouch.UIKit.NSLayoutConstraint"/> to add. The <paramref name="constraint"/> must refer only to the receiving view or its subviews.</param>
        <summary>Adds a constraint to the layout of the receiving view or its subviews.</summary>
        <remarks>
          <para>The <paramref name="constraint"/> must refer only to the receiving view or its subviews.</para>
        </remarks>
        <altmember cref="P:MonoTouch.UIKit.UIView.Constraints"/>
        <altmember cref="M:MonoTouch.UIKit.UIView.AddConstraints"/>
        <altmember cref="M:MonoTouch.UIKit.UIView.RemoveConstraint"/>
        <altmember cref="M:MonoTouch.UIKit.UIView.RemoveConstraints"/>
        <altmember cref="P:MonoTouch.UIKit.UIView.TranslatesAutoresizingMaskIntoConstraints"/>
      </Docs>
    </Member>
    <Member MemberName="AddConstraints">
      <MemberSignature Language="C#" Value="public virtual void AddConstraints (MonoTouch.UIKit.NSLayoutConstraint[] constraints);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddConstraints(class MonoTouch.UIKit.NSLayoutConstraint[] constraints) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("addConstraints:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constraints" Type="MonoTouch.UIKit.NSLayoutConstraint[]"/>
      </Parameters>
      <Docs>
        <param name="constraints">An array of <see cref="T:MonoTouch.UIKit.NSLayoutConstraint"/>s to add. The <paramref name="constraints"/> must refer only to the receiving view or its subviews.</param>
        <summary>Adds multiple constraints to the layout of the receiving view or its subviews.</summary>
        <remarks>
          <para>The <paramref name="constraints"/> must refer only to the receiving view or its subviews.</para>
          <para>In the following example, <format type="text/html"><a href="https://developer.apple.com/library/mac/#documentation/UserExperience/Conceptual/AutolayoutPG/Articles/formatLanguage.html#//apple_ref/doc/uid/TP40010853-CH3-SW1">Visual Format Language</a></format> specifies that the <c>blueView</c> be horizontally attched to the leading and trailing edge (sides), that the <c>blueView</c> and <c>greenView</c> be vertically attached to the leading and trailing edges (top and bottom) and separated by 30 pixels, and that the <c>greenView</c> be the same width as the <c>blueView</c> and attached to both the leading and trailing edges. The result is shown in the following image.</para>
          <example>
            <code lang="C#">
              mainView.AddSubview(blueView);
              mainView.AddSubview(greenView);
              
              greenView.TranslatesAutoresizingMaskIntoConstraints = false;
              blueView.TranslatesAutoresizingMaskIntoConstraints = false;
              
              var viewsDictionary = NSDictionary.FromObjectsAndKeys(new NSObject[] { greenView, blueView}, new NSObject[] { new NSString("green"), new NSString("blue")});
              var metrics = new NSDictionary();
              
              mainView.AddConstraints(NSLayoutConstraint.FromVisualFormat("H:|-[blue]-|",0, new NSDictionary(), viewsDictionary));
              mainView.AddConstraints(NSLayoutConstraint.FromVisualFormat("V:|-[blue]-(==30)-[green(==blue)]-|",0, new NSDictionary(), viewsDictionary));
              mainView.AddConstraints(NSLayoutConstraint.FromVisualFormat("|-[green(==blue)]-|",0, new NSDictionary(), viewsDictionary));
              
            </code>
          </example>
          <para>
            <img href="MonoTouch.UIKit.UIView.AddConstraints.png"/>
          </para>
        </remarks>
        <altmember cref="P:MonoTouch.UIKit.UIView.Constraints"/>
        <altmember cref="M:MonoTouch.UIKit.UIView.AddConstraint"/>
        <altmember cref="M:MonoTouch.UIKit.UIView.RemoveConstraint"/>
        <altmember cref="M:MonoTouch.UIKit.UIView.RemoveConstraints"/>
        <altmember cref="P:MonoTouch.UIKit.UIView.TranslatesAutoresizingMaskIntoConstraints"/>
      </Docs>
    </Member>
    <Member MemberName="AddGestureRecognizer">
      <MemberSignature Language="C#" Value="public virtual void AddGestureRecognizer (MonoTouch.UIKit.UIGestureRecognizer gestureRecognizer);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddGestureRecognizer(class MonoTouch.UIKit.UIGestureRecognizer gestureRecognizer) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("addGestureRecognizer:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="gestureRecognizer" Type="MonoTouch.UIKit.UIGestureRecognizer"/>
      </Parameters>
      <Docs>
        <param name="gestureRecognizer">The configured gesture recognizer to add to this view.</param>
        <summary>Adds a gesture recognizer to this view.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddSubview">
      <MemberSignature Language="C#" Value="public virtual void AddSubview (MonoTouch.UIKit.UIView view);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddSubview(class MonoTouch.UIKit.UIView view) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("addSubview:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="view" Type="MonoTouch.UIKit.UIView"/>
      </Parameters>
      <Docs>
        <param name="view">
          <para>The <see cref="T:MonoTouch.UIKit.UIView"/> to add as a nested view of this view.</para>
        </param>
        <summary>Adds the specified view as a subview of this view.</summary>
        <remarks>
          <para>Since <see cref="T:MonoTouch.UIKit.UIView"/>s can only have direct ancestore, this will overwrite the existing <see cref="P:MonoTouch.UIKit.UIView.Superview"/> of the <paramref name="view"/>.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddSubviews">
      <MemberSignature Language="C#" Value="public void AddSubviews (MonoTouch.UIKit.UIView[] views);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddSubviews(class MonoTouch.UIKit.UIView[] views) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="views" Type="MonoTouch.UIKit.UIView[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="views">An array of zero or more <see cref="T:MonoTouch.UIKit.UIView"/>s.</param>
        <summary>Convenience routine to add various views to a UIView.</summary>
        <remarks>
          <para>
            This is merely a convenience routine that allows the application developer to add a number of views in a single call.
          </para>
          <example>
            <code lang="c#">
              myView.AddSubviews (label, button, entry, image1, image2);
            </code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AlignmentRectForFrame">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.RectangleF AlignmentRectForFrame (System.Drawing.RectangleF frame);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Drawing.RectangleF AlignmentRectForFrame(valuetype System.Drawing.RectangleF frame) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("alignmentRectForFrame:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="frame" Type="System.Drawing.RectangleF"/>
      </Parameters>
      <Docs>
        <param name="frame">A <see cref="T:System.Drawing.RectangleF"/> for which the alignment rectangle should be calculated.</param>
        <summary>Returns a customized alignment rectangle for Auto Layout.</summary>
        <returns>The alignment rectangle appropriate to the <paramref name="frame"/>.</returns>
        <remarks>
          <para>By overriding this method, application developers can fully customize the alignment rectangle of the <see cref="T:MonoTouch.UIKit.UIView"/>.Application developers who override this method must also override the complementary method <see cref="M:MonoTouch.UIKit.UIView.FrameForAlignmentRect"/>. The two methods must provide complementary values.</para>
          <para>Auto Layout uses "alignment rectangles" to layout subviews rather than the subviews' <see cref="P:MonoTouch.UIKit.UIView.Frame"/>. The <see cref="P:MonoTouch.UIKit.UIView.Frame"/> of a <see cref="T:MonoTouch.UIKit.UIView"/> may include visual elements, such as drop-shadows, that are not symmetrical around the <see cref="T:MonoTouch.UIKit.UIView"/>'s logical center. The "alignment rectangle" for a <see cref="T:MonoTouch.UIKit.UIView"/> should be related to its logical content.</para>
          <para> By default, the "alignment rectangle" of a <see cref="T:MonoTouch.UIKit.UIView"/> is the <see cref="P:MonoTouch.UIKit.UIView.Frame"/> plus the <see cref="P:MonoTouch.UIKit.UIView.AlignmentRectInsets"/>. The <see cref="M:MonoTouch.UIKit.UIView.AlignmentRectForFrame"/> and <see cref="M:MonoTouch.UIKit.UIView.FrameForAlignmentRect"/> methods can be used to fully customize the alignment rectangle.</para>
        </remarks>
        <altmember cref="M:MonoTouch.UIKit.UIView.FrameForAlignmentRect"/>
        <altmember cref="M:MonoTouch.UIKit.UIView.AlignmentRectInsets"/>
        <altmember cref="M:MonoTouch.UIKit.UIView.ViewForBaselineLayout"/>
      </Docs>
    </Member>
    <Member MemberName="AlignmentRectInsets">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIEdgeInsets AlignmentRectInsets { get; }"/>
      <MemberSignature Language="ILAsm" Value=".property instance valuetype MonoTouch.UIKit.UIEdgeInsets AlignmentRectInsets"/>
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("alignmentRectInsets")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIEdgeInsets</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Adjustments to the <see cref="P:MonoTouch.UIKit.UIView.Frame"/> for use with Auto Layout.</summary>
        <value>The default value is an <see cref="T:MonoTouch.UIKit.UIEdgeInsets"/> whose values are all zero.</value>
        <remarks>
          <para>Application developers can use this property to modify the rectangle that is used by Auto Layout to control the <see cref="T:MonoTouch.UIKit.UIView"/>'s ultimate alignment.</para>
          <para>Auto Layout uses "alignment rectangles" to layout subviews rather than the subviews' <see cref="P:MonoTouch.UIKit.UIView.Frame"/>. The <see cref="P:MonoTouch.UIKit.UIView.Frame"/> of a <see cref="T:MonoTouch.UIKit.UIView"/> may include visual elements, such as drop-shadows, that are not symmetrical around the <see cref="T:MonoTouch.UIKit.UIView"/>'s logical center. The "alignment rectangle" for a <see cref="T:MonoTouch.UIKit.UIView"/> should be related to its logical content.</para>
          <para> By default, the "alignment rectangle" of a <see cref="T:MonoTouch.UIKit.UIView"/> is the <see cref="P:MonoTouch.UIKit.UIView.Frame"/> plus the <see cref="P:MonoTouch.UIKit.UIView.AlignmentRectInsets"/>. The <see cref="M:MonoTouch.UIKit.UIView.AlignmentRectForFrame"/> and <see cref="M:MonoTouch.UIKit.UIView.FrameForAlignmentRect"/> methods can be used to fully customize the alignment rectangle.</para>
        </remarks>
        <altmember cref="M:MonoTouch.UIKit.UIView.AlignmentRectForFrame"/>
        <altmember cref="M:MonoTouch.UIKit.UIView.FrameForAlignmentRect"/>
        <altmember cref="M:MonoTouch.UIKit.UIView.ViewForBaselineLayout"/>
      </Docs>
    </Member>
    <Member MemberName="Alpha">
      <MemberSignature Language="C#" Value="public virtual float Alpha { get; set; }"/>
      <MemberSignature Language="ILAsm" Value=".property instance float32 Alpha"/>
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("alpha")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setAlpha:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Controls the transparency (alpha) value for the view.</summary>
        <value>0 to 1.</value>
        <remarks>
          <para>
            
            This controls the transparency for the view.  If the value
            is 1.0, the view is completely opaque, if the value is 0.0
            the view is completely transparent.    
          </para>
          <para>
            
            When the value of the view is in between 0 and 1, the
            contents of the view are composited with views that are
            lower in the view hierarchy or the superview.
            
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Animate">
      <MemberSignature Language="C#" Value="public static void Animate (double duration, MonoTouch.Foundation.NSAction animation);"/>
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Animate(float64 duration, class MonoTouch.Foundation.NSAction animation) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("animateWithDuration:animations:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Double"/>
        <Parameter Name="animation" Type="MonoTouch.Foundation.NSAction"/>
      </Parameters>
      <Docs>
        <param name="duration">Duration in seconds for the animation.</param>
        <param name="animation">Code containing the changes that you will apply to your view.</param>
        <summary>Animates the property changes that take place in the specified block.</summary>
        <remarks>
          <para>
            This uses the CurveEaseOut and TransitionNone flags for the animation.
          </para>
          <example>
            <code lang="C#">
              // Animates hiding the label by setting the alpha to zero over three seconds.
              UIView.Animate (3, () =&gt; { label.Alpha = 0 });
            </code>
          </example>
        </remarks>
        <related type="recipe" href="http://docs.xamarin.com/ios/recipes/Animation/CoreAnimation/Animate_Using_Blocks"/>
      </Docs>
    </Member>
    <Member MemberName="Animate">
      <MemberSignature Language="C#" Value="public static void Animate (double duration, MonoTouch.Foundation.NSAction animation, MonoTouch.Foundation.NSAction completion);"/>
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Animate(float64 duration, class MonoTouch.Foundation.NSAction animation, class MonoTouch.Foundation.NSAction completion) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Double"/>
        <Parameter Name="animation" Type="MonoTouch.Foundation.NSAction"/>
        <Parameter Name="completion" Type="MonoTouch.Foundation.NSAction"/>
      </Parameters>
      <Docs>
        <param name="duration">Duration in seconds for the animation.</param>
        <param name="animation">Code containing the changes that you will apply to your view.</param>
        <param name="completion">Code that is invoke when the animation completes.</param>
        <summary>Animates the property changes that take place in the specificied block and invokes a completion callback when the animation completes.</summary>
        <remarks>
          <para>
            This uses The CurveEaseOut and TransitionNone flags for the animation.
          </para>
          <example>
            <code lang="c#">
              // Animates hiding the label by setting the alpha to zero over three seconds.
              UIView.Animate (
              duration: 3, 
              animation: () =&gt; { view.Alpha = 0 },
              completion: () =&gt; { view.RemoveFromSuperview (); });
            </code>
          </example>
          <para>This method's <paramref name="completion"/> parameter is of type <see cref="T:MonoTouch.Foundation.NSAction"/>, which does not receive a <c>Boolean finished</c> indicating whether the animation completed successfully. Application developers who rely on that value should instead use the <see cref="M:MonoTouch.UIKit.UIView.AnimateNotify"/> method.</para>
        </remarks>
        <related type="recipe" href="http://docs.xamarin.com/ios/recipes/Animation/CoreAnimation/Animate_Using_Blocks"/>
        <altmember cref="M:MonoTouch.UIKit.UIView.AnimateNotify"/>
      </Docs>
    </Member>
    <Member MemberName="Animate">
      <MemberSignature Language="C#" Value="public static void Animate (double duration, double delay, MonoTouch.UIKit.UIViewAnimationOptions options, MonoTouch.Foundation.NSAction animation, MonoTouch.Foundation.NSAction completion);"/>
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Animate(float64 duration, float64 delay, valuetype MonoTouch.UIKit.UIViewAnimationOptions options, class MonoTouch.Foundation.NSAction animation, class MonoTouch.Foundation.NSAction completion) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Double"/>
        <Parameter Name="delay" Type="System.Double"/>
        <Parameter Name="options" Type="MonoTouch.UIKit.UIViewAnimationOptions"/>
        <Parameter Name="animation" Type="MonoTouch.Foundation.NSAction"/>
        <Parameter Name="completion" Type="MonoTouch.Foundation.NSAction"/>
      </Parameters>
      <Docs>
        <param name="duration">Duration in seconds for the animation.</param>
        <param name="delay">Delay before the animation begins.</param>
        <param name="options">Animation options</param>
        <param name="animation">Code containing the changes that you will apply to your view.</param>
        <param name="completion">Code that is invoke when the animation completes.</param>
        <summary>Animates the property changes that take place in the specificied block and invokes a completion callback when the animation completes.</summary>
        <remarks>
          <example>
            <code lang="c#">
              // Animates hiding the label by setting the alpha to zero over three seconds.
              UIView.Animate (
              duration: 3, 
              delay: 0,
              options: UIViewAnimationOptions.AllowUserInteraction,
              animation: () =&gt; { view.Alpha = 0 },
              completion: () =&gt; { view.RemoveFromSuperview (); });
            </code>
          </example>
          <para>This method's <paramref name="completion"/> parameter is of type <see cref="T:MonoTouch.Foundation.NSAction"/>, which does not receive a <c>Boolean finished</c> indicating whether the animation completed successfully. Application developers who rely on that value should instead use the <see cref="M:MonoTouch.UIKit.UIView.AnimateNotify"/> method.</para>
        </remarks>
        <related type="recipe" href="http://docs.xamarin.com/ios/recipes/Animation/CoreAnimation/Animate_Using_Blocks"/>
        <altmember cref="M:MonoTouch.UIKit.UIView.AnimateNotify"/>
      </Docs>
    </Member>
    <Member MemberName="AnimateNotify">
      <MemberSignature Language="C#" Value="public static void AnimateNotify (double duration, MonoTouch.Foundation.NSAction animation, MonoTouch.UIKit.UICompletionHandler completion);"/>
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AnimateNotify(float64 duration, class MonoTouch.Foundation.NSAction animation, class MonoTouch.UIKit.UICompletionHandler completion) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("animateWithDuration:animations:completion:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Double"/>
        <Parameter Name="animation" Type="MonoTouch.Foundation.NSAction"/>
        <Parameter Name="completion" Type="MonoTouch.UIKit.UICompletionHandler"/>
      </Parameters>
      <Docs>
        <param name="duration">Duration in seconds for the animation.</param>
        <param name="animation">Code containing the changes that you will apply to your view.</param>
        <param name="completion">
          <para>The method to invoke when the animation has completed.</para>
          <para tool="nullallowed">This parameter can be <see langword="null"/>.</para>
        </param>
        <summary>Animates the property changes that take place in the specified block.</summary>
        <remarks>
          <para>This method is similar to the <see cref="M:MonoTouch.UIKit.UIView.Animate"/> method except that the <paramref name="completion"/> handler is of type <see cref="T:MonoTouch.UIKit.UICompletionHandler"/> and thus has a <c>Boolean finished</c> parameter indicating whether the animation completed successfully or was interrupted.</para>
        </remarks>
        <related type="recipe" href="http://docs.xamarin.com/ios/recipes/Animation/CoreAnimation/Animate_Using_Blocks"/>
        <altmember cref="M:MonoTouch.UIKit.UIView.Animate"/>
      </Docs>
    </Member>
    <Member MemberName="AnimateNotify">
      <MemberSignature Language="C#" Value="public static void AnimateNotify (double duration, double delay, MonoTouch.UIKit.UIViewAnimationOptions options, MonoTouch.Foundation.NSAction animation, MonoTouch.UIKit.UICompletionHandler completion);"/>
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AnimateNotify(float64 duration, float64 delay, valuetype MonoTouch.UIKit.UIViewAnimationOptions options, class MonoTouch.Foundation.NSAction animation, class MonoTouch.UIKit.UICompletionHandler completion) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("animateWithDuration:delay:options:animations:completion:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Double"/>
        <Parameter Name="delay" Type="System.Double"/>
        <Parameter Name="options" Type="MonoTouch.UIKit.UIViewAnimationOptions"/>
        <Parameter Name="animation" Type="MonoTouch.Foundation.NSAction"/>
        <Parameter Name="completion" Type="MonoTouch.UIKit.UICompletionHandler"/>
      </Parameters>
      <Docs>
        <param name="duration">Duration in seconds for the animation.</param>
        <param name="delay">Delay before the animation begins.</param>
        <param name="options">Animation options</param>
        <param name="animation">Code containing the changes that you will apply to your view.</param>
        <param name="completion">
          <para>The method to invoke when the animation has completed.</para>
          <para tool="nullallowed">This parameter can be <see langword="null"/>.</para>
        </param>
        <summary>Animates the property changes that take place in the specificied block and invokes a completion callback when the animation completes.</summary>
        <remarks>
          <para>This method is similar to the <see cref="M:MonoTouch.UIKit.UIView.Animate"/> method except that the <paramref name="completion"/> handler is of type <see cref="T:MonoTouch.UIKit.UICompletionHandler"/> and thus has a <c>Boolean finished</c> parameter indicating whether the animation completed successfully or was interrupted.</para>
        </remarks>
        <related type="recipe" href="http://docs.xamarin.com/ios/recipes/Animation/CoreAnimation/Animate_Using_Blocks"/>
        <altmember cref="M:UIKit.UIView.Animate"/>
      </Docs>
    </Member>
    <Member MemberName="AnimationsEnabled">
      <MemberSignature Language="C#" Value="public static bool AnimationsEnabled { get; set; }"/>
      <MemberSignature Language="ILAsm" Value=".property bool AnimationsEnabled"/>
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("areAnimationsEnabled")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setAnimationsEnabled:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies whether animations are displayed or not.</summary>
        <value>The default value is <see langword="true"/>.</value>
        <remarks>
          <para>Whether this is <see langword="true"/> or <see langword="false"/>, the code inside animation blocks will execute. A <see langword="false"/> value simply means the animation does not display.</para>
          <para>Setting this value during an existing animation will not modify that animation's display.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AnimationWillEnd">
      <MemberSignature Language="C#" Value="public static event MonoTouch.Foundation.NSAction AnimationWillEnd;"/>
      <MemberSignature Language="ILAsm" Value=".event class MonoTouch.Foundation.NSAction AnimationWillEnd"/>
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSAction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>This event is raised when the animations will end.</summary>
        <remarks>
          Notice that these events are only fired as long as the application does not install its own animation delegate by calling <see cref="M:MonoTouch.UIKit.UIView.SetAnimationDelegate(MonoTouch.Foundation.NSObject)"/>. 
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AnimationWillStart">
      <MemberSignature Language="C#" Value="public static event MonoTouch.Foundation.NSAction AnimationWillStart;"/>
      <MemberSignature Language="ILAsm" Value=".event class MonoTouch.Foundation.NSAction AnimationWillStart"/>
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSAction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>This event is raised when the animations will start.</summary>
        <remarks>
          Notice that these events are only fired as long as the application does not install its own animation delegate by calling <see cref="M:MonoTouch.UIKit.UIView.SetAnimationDelegate(MonoTouch.Foundation.NSObject)"/>. 
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Appearance">
      <MemberSignature Language="C#" Value="public static MonoTouch.UIKit.UIView.UIViewAppearance Appearance { get; }"/>
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.UIKit.UIView/UIViewAppearance Appearance"/>
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIView+UIViewAppearance</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Strongly-typed property that returns the UIAppearance class for this class.</summary>
        <value>
        </value>
        <remarks>Setting any appearance properties on this instance will affect the appearance of all instances of UIView.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppearanceWhenContainedIn">
      <MemberSignature Language="C#" Value="public static MonoTouch.UIKit.UIView.UIViewAppearance AppearanceWhenContainedIn (Type[] containers);"/>
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class MonoTouch.UIKit.UIView/UIViewAppearance AppearanceWhenContainedIn(class System.Type[] containers) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIView+UIViewAppearance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containers" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="containers">List of types that you want to have as the containers to apply this particular appearance</param>
        <summary>Returns a strongly typed UIAppearance for instances of this class when the view is hosted in the specified hierarchy.</summary>
        <returns>The appearance proxy object that you can use to set properties when the given container hierarchy is active</returns>
        <remarks>
          <para>The returned object represents the UIAppearance proxy where you can set appearance properties for instances of UIView when those instances are contained in the hierarchy specified by the <paramref name="containers"/> parameter.</para>
          <para>The following example shows how the AppearanceWhenContainedIn method works</para>
          <example>
            <code lang="C#">
              var mySliders = UISlider.AppearanceWhenContainedIn (typeof (UINavigationBar), typeof (UIPopoverController));
              mySliders.TintColor = UIColor.Red;
            </code>
          </example>
          <para>For more information, see the documentation for the <see cref="T:MonoTouch.UIKit.UIAppearance"/> class.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoresizingMask">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIViewAutoresizing AutoresizingMask { get; set; }"/>
      <MemberSignature Language="ILAsm" Value=".property instance valuetype MonoTouch.UIKit.UIViewAutoresizing AutoresizingMask"/>
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("autoresizingMask")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setAutoresizingMask:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIViewAutoresizing</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A bitmask that specifies how the receiver should resize itself when it's super-view's bounds change.</summary>
        <value>The default value is <see cref="UIViewAutoResizing.None"/>.</value>
        <remarks>
          <para>Application developers may wish to use the more powerful Auto Layout capability rather than the older Autoresizing Mask capability.</para>
          <para>The <see cref="M:MonoTouch.UIKit.AutoResizingMask"/> is a powerful feature that handles a good deal of the complexity of resizing views, such as occurs during device rotation. However, it is not necessarily a complete solution. For instance, when using a <see cref="T:MonoTouch.UIKit.UIScrollView"/>,  logic may require the <see cref="P:MonoTouch.UIKit.UIScrollView.ContentSize"/> to be resized. In such situations, application developers may subscribe to the <c>UIDeviceOrientationDidChangeNotification</c> and implement a custom method with additional resizing logic:</para>
          <example>
            <code>
              //During initialization, subscribe to orientation changes              
              NSNotificationCenter.DefaultCenter.AddObserver ("UIDeviceOrientationDidChangeNotification", DeviceRotated);
              
              protected void DeviceRotated (NSNotification notification)
              {
              //Code to resize UIScrollView.ContentSize and other custom on-rotation logic
              }
            </code>
          </example>
        </remarks>
        <altmember cref="M:MonoTouch.UIKit.UIView.AutoResizingMask"/>
      </Docs>
    </Member>
    <Member MemberName="AutosizesSubviews">
      <MemberSignature Language="C#" Value="public virtual bool AutosizesSubviews { get; set; }"/>
      <MemberSignature Language="ILAsm" Value=".property instance bool AutosizesSubviews"/>
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("autoresizesSubviews")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setAutoresizesSubviews:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies whether the receiver should automatically resize its <see cref="P:MonoTouch.UIKit.UIView.Subviews"/> when the receiver's <see cref="P:MonoTouch.UIKit.UIView.Bounds"/> change.</summary>
        <value>The default value is <see langword="true"/>.</value>
        <remarks>
          <para>If this value is <see langword="true"/>, this <see cref="T:MonoTouch.UIKit.UIView"/> will resize its <see cref="P:MonoTouch.UIKit.UIView.Subviews"/> when this <see cref="T:MonoTouch.UIKit.UIView"/>'s <see cref="P:MonoTouch.UIKit.UIView.Bounds"/> change.</para>
          <para>Application developers may wish to use the more powerful Auto Layout capability rather than the older Autoresizing Mask capability.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundColor">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIColor BackgroundColor { get; set; }"/>
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIColor BackgroundColor"/>
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("backgroundColor", MonoTouch.ObjCRuntime.ArgumentSemantic.Retain)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setBackgroundColor:", MonoTouch.ObjCRuntime.ArgumentSemantic.Retain)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIColor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sets the background color of the <see cref="T:MonoTouch.UIKit.UIView"/>.</summary>
        <value>
          <para>The default value is <see langword="null"/>.</para>
          <para tool="nullallowed">This value can be <see langword="null"/>.</para>
        </value>
        <remarks>
          <para id="tool-remark">This member participates in the <see cref="T:MonoTouch.UIKit.UIAppearance"/> styling system.  See the <see cref="P:MonoTouch.UIKit.UIView.Appearance"/> property and the <see cref="M:MonoTouch.UIKit.UIView.AppearanceWhenContainedIn"/> method.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginAnimations">
      <MemberSignature Language="C#" Value="public static void BeginAnimations (string animation);"/>
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginAnimations(string animation) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="animation" Type="System.String"/>
      </Parameters>
      <Docs>
        <param name="animation">The animation identifier.</param>
        <summary>Indicates the beginning of an animation block.</summary>
        <remarks>
          <para>Application developers should prefer to use the more compact syntax of the <see cref="M:MonoTouch.UIKit.UIView.Animate"/> method.</para>
          <para>Older versions of iOS used a matched set of <see cref="M:MonoTouch.UIKit.UIView.BeginAnimations"/> and <see cref="M:MonoTouch.UIKit.UIView.CommitAnimations"/> to specify an animation block. The following code, taken from the "Animate a UIView using UIKit" recipe, shows the technique:</para>
          <example>
            <code lang="C#">
              UIView.BeginAnimations ("slideAnimation");
              
              UIView.SetAnimationDuration (2);
              UIView.SetAnimationCurve (UIViewAnimationCurve.EaseInOut);
              UIView.SetAnimationRepeatCount (2);
              UIView.SetAnimationRepeatAutoreverses (true);
              UIView.SetAnimationDelegate (this);
              UIView.SetAnimationDidStopSelector (
              &#xA0;&#xA0;new Selector ("slideAnimationFinished:"));
              _imageView.Center = new PointF (UIScreen.MainScreen.Bounds.Right -
              &#xA0;&#xA0;_imageView.Frame.Width / 2, _imageView.Center.Y);
              UIView.CommitAnimations ();
            </code>
          </example>
        </remarks>
        <altmember cref="M:MonoTouch.UIKit.UIView.CommitAnimations"/>
        <related type="recipe" href="http://docs.xamarin.com/iOS/Recipes/Animation/CoreAnimation/Animate_a_UIView_using_UIKit"/>
        <!-- TODO: Switch to UUID-based URL -->
      </Docs>
    </Member>
    <Member MemberName="BeginAnimations">
      <MemberSignature Language="C#" Value="public static void BeginAnimations (string animationID, IntPtr context);"/>
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginAnimations(string animationID, native int context) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("beginAnimations:context:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="animationID" Type="System.String"/>
        <Parameter Name="context" Type="System.IntPtr"/>
      </Parameters>
      <Docs>
        <param name="animationID">
          <para>The animation identifier.</para>
          <para tool="nullallowed">This parameter can be <see langword="null"/>.</para>
        </param>
        <param name="context">A handle to custom data that provides context for the animation.</param>
        <summary>Indicates the beginning of an animation block</summary>
        <remarks>
          <para>Application developers should prefer to use the more compact syntax of the <see cref="M:MonoTouch.UIKit.UIView.Animate"/> method.</para>
          <para>If no native data is being used for <paramref name="context"/>, application developers should specify <paramref name="context"/> as <see cref="F:System.IntPtr.Zero"/>.        </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bounds">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.RectangleF Bounds { get; set; }"/>
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.RectangleF Bounds"/>
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("bounds")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setBounds:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The usable frame of the view</summary>
        <value>
        </value>
        <remarks>
          <para>
            This property represents the usable
            frame of the view.  Unlike the <see cref="P:MonoTouch.UIKit.UIView.Frame"/>, the <see cref="P:MonoTouch.UIKit.UIView.Bounds"/> do not use the container's
            coordinate space, but instead represent the size in the view's own
            coordinate space.  By default the <see cref="P:MonoTouch.UIKit.UIView.Bounds"/> location is
            (0,0).
          </para>
          <para>
            
            When you update this property, it will modify the <see cref="P:MonoTouch.UIKit.UIView.Frame"/> based on the value
            of the <see cref="P:MonoTouch.UIKit.UIView.Center"/>.  You
            can also change the position of your view by updating the
            <see cref="P:MonoTouch.UIKit.UIView.Center"/> property.
            
          </para>
          <para>
            When the Bound property is changed, the size of the view is affected
            relative to the <see cref="P:MonoTouch.UIKit.UIView.Center"/> property.
          </para>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BringSubviewToFront">
      <MemberSignature Language="C#" Value="public virtual void BringSubviewToFront (MonoTouch.UIKit.UIView view);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BringSubviewToFront(class MonoTouch.UIKit.UIView view) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("bringSubviewToFront:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="view" Type="MonoTouch.UIKit.UIView"/>
      </Parameters>
      <Docs>
        <param name="view">
          <para>The subview to move to the front.</para>
        </param>
        <summary>Moves the specified subview so that it appears in front of other <see cref="P:MonoTouch.UIKit.UIView.Subviews"/>.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Center">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.PointF Center { get; set; }"/>
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.PointF Center"/>
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("center")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setCenter:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.PointF</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Center of the view, in the container coordinate space.</summary>
        <value>This value is measured in points, not pixels.</value>
        <remarks>
          <para>
            When you update this property, this will automatically
            adjust corresponding  <see cref="P:MonoTouch.UIKit.UIView.Frame"/>.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClassHandle">
      <MemberSignature Language="C#" Value="public override IntPtr ClassHandle { get; }"/>
      <MemberSignature Language="ILAsm" Value=".property instance native int ClassHandle"/>
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The handle for this class.</summary>
        <value>The pointer to the Objective-C class.</value>
        <remarks>Each MonoTouch class mirrors an unmanaged Objective-C class.   This value contains the pointer to the Objective-C class, it is similar to calling objc_getClass with the object name.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearsContextBeforeDrawing">
      <MemberSignature Language="C#" Value="public virtual bool ClearsContextBeforeDrawing { get; set; }"/>
      <MemberSignature Language="ILAsm" Value=".property instance bool ClearsContextBeforeDrawing"/>
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("clearsContextBeforeDrawing")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setClearsContextBeforeDrawing:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies that the drawing buffer be erased prior to calling <see cref="M:MonoTouch.UIKit.UIView.DrawRect"/></summary>
        <value>The default value is <see langword="true"/>.</value>
        <remarks>
          <para>If this value is <see langword="true"/>, the receiver's <see cref="P:MonoTouch.UIKit.UIView.Bounds"/> are erased and set to transparent black before the receiver's <see cref="M:MonoTouch.UIKit.UIView.DrawRect"/> method is called.</para>
          <para>If the application developer has written a highly optimized <see cref="M:MonoTouch.UIKit.UIView.DrawRect"/>, this property can be set to <see langword="false"/> which may lead to a performance improvement.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClipsToBounds">
      <MemberSignature Language="C#" Value="public virtual bool ClipsToBounds { get; set; }"/>
      <MemberSignature Language="ILAsm" Value=".property instance bool ClipsToBounds"/>
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("clipsToBounds")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setClipsToBounds:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies whether the <see cref="P:MonoTouch.UIKit.UIView.Subviews"/> are confined to the <see cref="P:MonoTouch.UIKit.UIView.Bounds"/> of the receiver.</summary>
        <value>The default value is <see langword="false"/>.</value>
        <remarks>
          <para>If this property is <see langword="false"/>, subviews whose <see cref="P:MonoTouch.UIKit.UIView.Frame"/> extends beyond their <see cref="P:MonoTouch.UIKit.UIView.Superview"/>'s <see cref="P:MonoTouch.UIKit.UIView.Bounds"/> will be fully displayed. If this property is <see langword="true"/>, only that portion that lies within their <see cref="P:MonoTouch.UIKit.UIView.Superview"/>'s <see cref="P:MonoTouch.UIKit.UIView.Bounds"/> will be displayed. </para>
          <para>In the following image, the green rectangles are subviews of the blue rectangles (<c>var innerView = new UIView(new RectangleF(-10, 10, 175, 25));</c>). The top blue rectangle has its <see cref="P:MonoTouch.UIKit.UIView.ClipsToBounds"/> left at the default <see langword="false"/> value while the lower rectangle shows the clipping that occurs when <see cref="P:MonoTouch.UIKit.UIView.ClipsToBounds"/> is set to <see langword="true"/>.</para>
          <para>
            <img href="MonoTouch.UIKit.UIView.ClipsToBounds.png"/>
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CommitAnimations">
      <MemberSignature Language="C#" Value="public static void CommitAnimations ();"/>
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CommitAnimations() cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("commitAnimations")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters/>
      <Docs>
        <summary>Indicates the end of an animation block.</summary>
        <remarks>
          <para>Application developers should prefer to use the more compact syntax of the <see cref="M:MonoTouch.UIKit.UIView.Animate"/> method.</para>
          <para>Older versions of iOS used a matched set of <see cref="M:MonoTouch.UIKit.UIView.BeginAnimations"/> and <see cref="M:MonoTouch.UIKit.UIView.CommitAnimations"/> to specify an animation block. The following code, taken from the "Animate a UIView using UIKit" recipe, shows the technique:</para>
          <example>
            <code lang="C#">
              UIView.BeginAnimations ("slideAnimation");
              
              UIView.SetAnimationDuration (2);
              UIView.SetAnimationCurve (UIViewAnimationCurve.EaseInOut);
              UIView.SetAnimationRepeatCount (2);
              UIView.SetAnimationRepeatAutoreverses (true);
              UIView.SetAnimationDelegate (this);
              UIView.SetAnimationDidStopSelector (
              &#xA0;&#xA0;new Selector ("slideAnimationFinished:"));
              _imageView.Center = new PointF (UIScreen.MainScreen.Bounds.Right -
              &#xA0;&#xA0;_imageView.Frame.Width / 2, _imageView.Center.Y);
              UIView.CommitAnimations ();
            </code>
          </example>
        </remarks>
        <altmember cref="M:MonoTouch.UIKit.UIView.BeginAnimations"/>
        <related type="recipe" href="http://docs.xamarin.com/iOS/Recipes/Animation/CoreAnimation/Animate_a_UIView_using_UIKit"/>
        <!-- TODO: Switch to UUID-based URL -->
      </Docs>
    </Member>
    <Member MemberName="Constraints">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.NSLayoutConstraint[] Constraints { get; }"/>
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.NSLayoutConstraint[] Constraints"/>
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("constraints")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.NSLayoutConstraint[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The constraints used by Auto Layout on this <see cref="T:MonoTouch.UIKit.UIView"/>.</summary>
        <value>The default value is an empty array.</value>
        <remarks>
          <para>
            Auto Layout uses the <see cref="P:MonoTouch.UIKit.UIView.Constraints"/> of a <see cref="T:MonoTouch.UIKit.UIView"/> to lay out its <see cref="P:MonoTouch.UIKit.UIView.Subviews"/>. These constraints are set with <see cref="M:MonoTouch.UIKit.UIView.AddConstraint"/> or <see cref="M:MonoTouch.UIKit.UIView.AddConstraints"/>. 
          </para>
          <para>
            The <see cref="P:MonoTouch.UIKit.NSLayoutConstraint.DebugDescription"/> property can be helpful in debugging Auto Layout issues. 
          </para>
          <example>
            <code lang="C#">
              foreach(var c in mainView.Constraints)
              {
              Console.WriteLine(c.DebugDescription);
              }              
            </code>
          </example>
        </remarks>
        <altmember cref="M:MonoTouch.UIKit.UIView.AddConstraint"/>
        <altmember cref="M:MonoTouch.UIKit.UIView.AddConstraints"/>
        <altmember cref="M:MonoTouch.UIKit.UIView.RemoveConstraint"/>
        <altmember cref="M:MonoTouch.UIKit.UIView.RemoveConstraints"/>
        <altmember cref="P:MonoTouch.UIKit.UIView.TranslatesAutoresizingMaskIntoConstraints"/>
      </Docs>
    </Member>
    <Member MemberName="ContentCompressionResistancePriority">
      <MemberSignature Language="C#" Value="public virtual float ContentCompressionResistancePriority (MonoTouch.UIKit.UILayoutConstraintAxis axis);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float32 ContentCompressionResistancePriority(valuetype MonoTouch.UIKit.UILayoutConstraintAxis axis) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("contentCompressionResistancePriorityForAxis:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="axis" Type="MonoTouch.UIKit.UILayoutConstraintAxis"/>
      </Parameters>
      <Docs>
        <param name="axis">The axis whose resistance is being queried.</param>
        <summary>Returns the resistance of an axis to compression belows its intrinsic size.</summary>
        <returns>A <see cref="T:MonoTouch.UIKit.UILayoutPriority"/> that specifies how resistant the view is along the <paramref name="axis"/> to compression below its intrinsic size.</returns>
        <remarks>Application developers should not override this method. Instead, they should manipulate the result by using <see cref="M:MonoTouch.UIKit.UIView.SetContentCompressionResistancePriority"/>.</remarks>
        <altmember cref="M:MonoTouch.UIKit.UIView.SetContentCompressionResistancePriority"/>
      </Docs>
    </Member>
    <Member MemberName="ContentHuggingPriority">
      <MemberSignature Language="C#" Value="public virtual float ContentHuggingPriority (MonoTouch.UIKit.UILayoutConstraintAxis axis);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float32 ContentHuggingPriority(valuetype MonoTouch.UIKit.UILayoutConstraintAxis axis) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("contentHuggingPriorityForAxis:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="axis" Type="MonoTouch.UIKit.UILayoutConstraintAxis"/>
      </Parameters>
      <Docs>
        <param name="axis">The axis whose resistance is being queried.</param>
        <summary>Returns the resistance of an axis to expansion larger than its intrinsic size.</summary>
        <returns>A <see cref="T:MonoTouch.UIKit.UILayoutPriority"/> that specifies how resistant the view is along the <paramref name="axis"/> to expansion beyond its intrinsic size.</returns>
        <remarks>Application developers should not override this method. Instead, they should manipulate the result by using <see cref="M:MonoTouch.UIKit.SetContentHuggingPriority"/>.</remarks>
        <altmember cref="M:MonoTouch.UIKit.UIView.SetContentHuggingPriority"/>
      </Docs>
    </Member>
    <Member MemberName="ContentMode">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIViewContentMode ContentMode { get; set; }"/>
      <MemberSignature Language="ILAsm" Value=".property instance valuetype MonoTouch.UIKit.UIViewContentMode ContentMode"/>
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("contentMode")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setContentMode:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIViewContentMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Controls how the cached bitmap of a view must be rendered when the view's bounds change.</summary>
        <value>
        </value>
        <remarks>
          <para>
            This property is used to control how the cached bitmap of the UIView changes when the <see cref="P:MonoTouch.UIKit.UIView.Frame"/> or <see cref="P:MonoTouch.UIKit.UIView.Bounds"/> properties are updated.   
          </para>
          <para>
            This property works in conjunction with the <see cref="P:MonoTouch.UIKit.UIView.ContentStretch"/> property.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentScaleFactor">
      <MemberSignature Language="C#" Value="public virtual float ContentScaleFactor { get; set; }"/>
      <MemberSignature Language="ILAsm" Value=".property instance float32 ContentScaleFactor"/>
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(4, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("contentScaleFactor")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setContentScaleFactor:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The number of device pixels per logical coordinate point.</summary>
        <value>The default value depends on the underlying hardware and the backing view type. The value is typically either 2.0 or 1.0.</value>
        <remarks>
          <para>The coordinate space used by application developers is measured in logical points. High-resolution (Retina) displays will have more than a single physical pixel per logical point and this property specifies the scale factor.</para>
          <para><see cref="T:MonoTouch.UIKit.UIView"/>s that are backed by a <see cref="T:MonoTouch.CoreAnimation.CAEAGLLayer"/> may return 1.0 even if they are being displayed on a high-resolution screen.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentStretch">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.RectangleF ContentStretch { get; set; }"/>
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.RectangleF ContentStretch"/>
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Deprecated in iOS 6.0", false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("contentStretch")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setContentStretch:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Defines an area of the view that is intended to be stretchable.</summary>
        <value>
        </value>
        <remarks>This property was deprecated in iOS 6.0.   Developers are advised to use UIImageView with a stretchable UIImage instead.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertPointFromView">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.PointF ConvertPointFromView (System.Drawing.PointF point, MonoTouch.UIKit.UIView fromView);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Drawing.PointF ConvertPointFromView(valuetype System.Drawing.PointF point, class MonoTouch.UIKit.UIView fromView) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("convertPoint:fromView:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.PointF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.PointF"/>
        <Parameter Name="fromView" Type="MonoTouch.UIKit.UIView"/>
      </Parameters>
      <Docs>
        <param name="point">
          <para>A point whose location is in the coordinate system of the <paramref name="fromView"/>.</para>
        </param>
        <param name="fromView">
          <para>The <see cref="T:MonoTouch.UIKit.UIView"/> in whose coordinate system the <paramref name="point"/> is expressed.</para>
          <para tool="nullallowed">This parameter can be <see langword="null"/>.</para>
        </param>
        <summary>
          <para>Returns the point, in the receiver's coordinate system, of the <paramref name="point"/> in the <paramref name="fromView"/>'s coordinate space.</para>
        </summary>
        <returns>
          <para>The point, translated between coordinate systems.</para>
        </returns>
        <remarks>
          <para>
            The <see cref="P:MonoTouch.UIKit.UIView.Bounds"/> property specifies a local coordinate system. This method returns the location, in <c>this</c><see cref="T:MonoTouch.UIKit.UIView"/>'s <see cref="P:MonoTouch.UIKit.UIView.Bounds"/> coordinate system of the <paramref name="point"/> in <paramref name="fromView"/>'s <see cref="P:MonoTouch.UIKit.UIView.Bounds"/>' coordinate system.
          </para>
        </remarks>
        <altmember cref="M:MonoTouch.UIKit.ConvertPointToView"/>
        <altmember cref="M:MonoTouch.UIKit.ConvertRectFromView"/>
        <altmember cref="M:MonoTouch.UIKit.ConvertRectToView"/>
      </Docs>
    </Member>
    <Member MemberName="ConvertPointToView">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.PointF ConvertPointToView (System.Drawing.PointF point, MonoTouch.UIKit.UIView toView);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Drawing.PointF ConvertPointToView(valuetype System.Drawing.PointF point, class MonoTouch.UIKit.UIView toView) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("convertPoint:toView:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.PointF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.PointF"/>
        <Parameter Name="toView" Type="MonoTouch.UIKit.UIView"/>
      </Parameters>
      <Docs>
        <param name="point">
          <para>A point whose location is in the coordinate system of <c>this</c><see cref="T:MonoTouch.UIKit.UIView"/>.</para>
        </param>
        <param name="toView">
          <para>The <see cref="T:MonoTouch.UIKit.UIView"/> to whose local coordinate system the point should be translated.</para>
          <para tool="nullallowed">This parameter can be <see langword="null"/>.</para>
        </param>
        <summary>Returns the point, in the <paramref name="toView"/>'s coordinate system, of the <paramref name="point"/> in <c>this</c><see cref="T:MonoTouch.UIKit.UIView"/>'s local coordinate system.</summary>
        <returns>
          <para>The point, translated between coordinated systems.</para>
        </returns>
        <remarks>
          <para>
            The <see cref="P:MonoTouch.UIKit.UIView.Bounds"/> property specifies a local coordinate system. This method returns the location, in <paramref name="toView"/>'s <see cref="P:MonoTouch.UIKit.UIView.Bounds"/>' coordinate system of the <paramref name="point"/> in <c>this</c><see cref="T:MonoTouch.UIKit.UIView"/>'s <see cref="P:MonoTouch.UIKit.UIView.Bounds"/>' coordinate system.
          </para>
        </remarks>
        <altmember cref="M:MonoTouch.UIKit.ConvertPointFromView"/>
        <altmember cref="M:MonoTouch.UIKit.ConvertRectFromView"/>
        <altmember cref="M:MonoTouch.UIKit.ConvertRectToView"/>
      </Docs>
    </Member>
    <Member MemberName="ConvertRectFromView">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.RectangleF ConvertRectFromView (System.Drawing.RectangleF rect, MonoTouch.UIKit.UIView fromView);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Drawing.RectangleF ConvertRectFromView(valuetype System.Drawing.RectangleF rect, class MonoTouch.UIKit.UIView fromView) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("convertRect:fromView:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF"/>
        <Parameter Name="fromView" Type="MonoTouch.UIKit.UIView"/>
      </Parameters>
      <Docs>
        <param name="rect">
          <para>The <see cref="T:System.Drawing.RectangleF"/> expressed in the <paramref name="fromView"/>'s local coordinate system.</para>
        </param>
        <param name="fromView">
          <para>The <see cref="T:MonoTouch.UIKit.UIView"/> in whose coordinate system the <paramref name="rect"/> is expressed.</para>
          <para tool="nullallowed">This parameter can be <see langword="null"/>.</para>
        </param>
        <summary>
          <para>Returns the <see cref="T:System.Drawing.RectangleF"/>, in the receiver's coordinate system, of the <paramref name="rect"/> in the <paramref name="fromView"/>'s coordinate space.</para>
        </summary>
        <returns>
          <para>The rectangle, translated between coordinate systems.</para>
        </returns>
        <remarks>
          <para>
            The <see cref="P:MonoTouch.UIKit.UIView.Bounds"/> property specifies a local coordinate system. This method returns the location, in <c>this</c><see cref="T:MonoTouch.UIKit.UIView"/>'s <see cref="P:MonoTouch.UIKit.UIView.Bounds"/> coordinate system of the <paramref name="rect"/> in <paramref name="fromView"/>'s <see cref="P:MonoTouch.UIKit.UIView.Bounds"/>' coordinate system.
          </para>
        </remarks>
        <altmember cref="M:MonoTouch.UIKit.ConvertPointFromView"/>
        <altmember cref="M:MonoTouch.UIKit.ConvertPointToView"/>
        <altmember cref="M:MonoTouch.UIKit.ConvertRectToView"/>
      </Docs>
    </Member>
    <Member MemberName="ConvertRectToView">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.RectangleF ConvertRectToView (System.Drawing.RectangleF rect, MonoTouch.UIKit.UIView toView);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Drawing.RectangleF ConvertRectToView(valuetype System.Drawing.RectangleF rect, class MonoTouch.UIKit.UIView toView) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("convertRect:toView:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF"/>
        <Parameter Name="toView" Type="MonoTouch.UIKit.UIView"/>
      </Parameters>
      <Docs>
        <param name="rect">
          <para>The <see cref="T:System.Drawing.RectangleF"/> expressed in this <see cref="T:MonoTouch.UIKit.UIView"/> local coordinate system.</para>
        </param>
        <param name="toView">
          <para>The <see cref="T:MonoTouch.UIKit.UIView"/> to whose local coordinate system the <paramref name="rect"/> should be translated.</para>
          <para tool="nullallowed">This parameter can be <see langword="null"/>.</para>
        </param>
        <summary>Returns the <see cref="T:System.Drawing.RectangleF"/>, in the <paramref name="toView"/>'s coordinate system, of the <paramref name="rect"/> in <c>this</c><see cref="T:MonoTouch.UIKit.UIView"/>'s local coordinate system.</summary>
        <returns>
          <para>The rectangle, translated between coordinated systems.</para>
        </returns>
        <remarks>
          <para>
            The <see cref="P:MonoTouch.UIKit.UIView.Bounds"/> property specifies a local coordinate system. This method returns the rectangle, in <paramref name="toView"/>'s <see cref="P:MonoTouch.UIKit.UIView.Bounds"/>' coordinate system of the <paramref name="rect"/> in <c>this</c><see cref="T:MonoTouch.UIKit.UIView"/>'s <see cref="P:MonoTouch.UIKit.UIView.Bounds"/>' coordinate system.
          </para>
        </remarks>
        <altmember cref="M:MonoTouch.UIKit.ConvertPointFromView"/>
        <altmember cref="M:MonoTouch.UIKit.ConvertPointToView"/>
        <altmember cref="M:MonoTouch.UIKit.ConvertRectFromView"/>
      </Docs>
    </Member>
    <Member MemberName="DecodeRestorableState">
      <MemberSignature Language="C#" Value="public virtual void DecodeRestorableState (MonoTouch.Foundation.NSCoder coder);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DecodeRestorableState(class MonoTouch.Foundation.NSCoder coder) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("decodeRestorableStateWithCoder:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="coder" Type="MonoTouch.Foundation.NSCoder"/>
      </Parameters>
      <Docs>
        <param name="coder">The <see cref="T:MonoTouch.Foundation.NSCoder"/> used to decode the state.</param>
        <summary>Application developers can override this method to support state restoration.</summary>
        <remarks/>
        <altmember cref="M:Monotouch.UIKit.UIView.EncodeRestorableState"/>
        <altmember cref="M:MonoTouch.UIKit.UIApplicationDelegate.ShouldRestoreApplicationState"/>
        <altmember cref="M:MonoTouch.UIKit.UIApplicationDelegate.ShouldSaveApplicationState"/>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);"/>
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean"/>
      </Parameters>
      <Docs>
        <param name="disposing">
          <para>If set to <see langword="true"/>, the method is invoked directly and will dispose manage and unmanaged resources;   If set to <see langword="false"/> the method is being called by the garbage collector finalizer and should only release unmanaged resources.</para>
        </param>
        <summary>Releases the resourced used by the UIView object.</summary>
        <remarks>
          <para>This Dispose method releases the resources used by the UIView class.</para>
          <para>This method is called by both the Dispose() method and the object finalizer (Finalize).    When invoked by the Dispose method, the parameter disposing <paramref name="disposing"/> is set to <see langword="true"/> and any managed object references that this object holds are also disposed or released;  when invoked by the object finalizer, on the finalizer thread the value is set to <see langword="false"/>. </para>
          <para>Calling the Dispose method when you are finished using the UIView ensures that all external resources used by this managed object are released as soon as possible.  Once you have invoked the Dispose method, the object is no longer useful and you should no longer make any calls to it.</para>
          <para>  For more information on how to override this method and on the Dispose/IDisposable pattern, read the ``Implementing a Dispose Method'' document at http://msdn.microsoft.com/en-us/library/fs2xkftw.aspx</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Draw">
      <MemberSignature Language="C#" Value="public virtual void Draw (System.Drawing.RectangleF rect);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Draw(valuetype System.Drawing.RectangleF rect) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("drawRect:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF"/>
      </Parameters>
      <Docs>
        <param name="rect">
          <para>The <see cref="T:System.Drawing.RectangleF"/> to draw.</para>
        </param>
        <summary>Draws the view within the passed-in rectangle.</summary>
        <remarks>
          <para>
            The <see cref="M:MonoTouch.UIKit.UIView.Draw"/> method should never be called directly. It is called by iOS
            during run loop processing. The first time through the run loop, it
            is called. After that, it will be called on demand whenever the view
            has been marked as needing display by calling <see cref="M:MonoTouch.UIKit.UIView.SetNeedsDisplay()"/> or
            <see cref="M:MonoTouch.UIKit.UIView.SetNeedsDisplayInRect(System.Drawing.RectangleF)"/>.
          </para>
          <para>
            Core Graphics uses device independent points rather than
            pixels. This allows drawing code to scale between different
            resolutions. For example, on a Retina display, 1 point is equivalent
            to 2 pixels, while on non-Retina displays, 1 point corresponds to 1
            pixel.
          </para>
          <example>
            <code lang="c#">
              public override void Draw (RectangleF rect)
              {
              base.Draw (rect);
              
              var context = UIGraphics.GetCurrentContext ();
              
              context.SetLineWidth(4);
              UIColor.Red.SetFill ();
              UIColor.Blue.SetStroke ();
              
              var path = new CGPath ();
              
              path.AddLines(new PointF[]{
              new PointF(100,200),
              new PointF(160,100), 
              new PointF(220,200)});
              
              path.CloseSubpath();
              
              context.AddPath(path);		
              context.DrawPath(CGPathDrawingMode.FillStroke);
              }
            </code>
          </example>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawRect">
      <MemberSignature Language="C#" Value="public virtual void DrawRect (System.Drawing.RectangleF area, MonoTouch.UIKit.UIViewPrintFormatter formatter);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawRect(valuetype System.Drawing.RectangleF area, class MonoTouch.UIKit.UIViewPrintFormatter formatter) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("drawRect:forViewPrintFormatter:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="area" Type="System.Drawing.RectangleF"/>
        <Parameter Name="formatter" Type="MonoTouch.UIKit.UIViewPrintFormatter"/>
      </Parameters>
      <Docs>
        <param name="area">The region to be printed</param>
        <param name="formatter">The configured UIViewPrintFormatter,
          which is obtained by accessing the <see cref="P:MonoTouch.UIKit.UIView.PrintFormatter"/> property.</param>
        <summary>Draws a region for printing.</summary>
        <remarks>
          <para>
            UIViews can be printed.  The default behavior is for the contents of
            the UIView as rendered by the <see cref="M:MonoTouch.UIKit.UIView.Draw(System.Drawing.RectangleF)"/>
            method to be printed.
          </para>
          <para>
            You should override the <see cref="M:MonoTouch.UIKit.UIView.DrawRect(System.Drawing.RectangleF,MonoTouch.UIKit.UIView.UIViewPrintFormatter)"/>
            method if you want to provide a different implementation
            while printing.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF DrawString (string str, System.Drawing.PointF point, MonoTouch.UIKit.UIFont font);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF DrawString(string str, valuetype System.Drawing.PointF point, class MonoTouch.UIKit.UIFont font) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String"/>
        <Parameter Name="point" Type="System.Drawing.PointF"/>
        <Parameter Name="font" Type="MonoTouch.UIKit.UIFont"/>
      </Parameters>
      <Docs>
        <param name="str">The string to draw.</param>
        <param name="point">The origin of the text drawing rectangle.</param>
        <param name="font">The font to use in drawing.</param>
        <summary>Draws the specified text at the specified location with the specified font.</summary>
        <returns>The actual size of the font with which the text was rendered.</returns>
        <remarks>
          <para>The <paramref name="point"/> specifies the origin (not the text baseline) of the drawing rectangle. In other words, the text will render below and to the right of the <paramref name="point"/>.</para>
          <para>This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF DrawString (string str, System.Drawing.RectangleF rect, MonoTouch.UIKit.UIFont font);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF DrawString(string str, valuetype System.Drawing.RectangleF rect, class MonoTouch.UIKit.UIFont font) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String"/>
        <Parameter Name="rect" Type="System.Drawing.RectangleF"/>
        <Parameter Name="font" Type="MonoTouch.UIKit.UIFont"/>
      </Parameters>
      <Docs>
        <param name="str">String to draw.</param>
        <param name="rect">Bounding rectangle.</param>
        <param name="font">Font to use to draw the string.</param>
        <summary>Draws the string in the specified rectangle with the specified font.</summary>
        <returns>The actual size used by the rendering.</returns>
        <remarks>
          <para>This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF DrawString (string str, System.Drawing.RectangleF rect, MonoTouch.UIKit.UIFont font, MonoTouch.UIKit.UILineBreakMode mode);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF DrawString(string str, valuetype System.Drawing.RectangleF rect, class MonoTouch.UIKit.UIFont font, valuetype MonoTouch.UIKit.UILineBreakMode mode) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String"/>
        <Parameter Name="rect" Type="System.Drawing.RectangleF"/>
        <Parameter Name="font" Type="MonoTouch.UIKit.UIFont"/>
        <Parameter Name="mode" Type="MonoTouch.UIKit.UILineBreakMode"/>
      </Parameters>
      <Docs>
        <param name="str">String to draw.</param>
        <param name="rect">Bounding rectangle.</param>
        <param name="font">Font to use to draw the string.</param>
        <param name="mode">The linebreak mode to use to draw the string.</param>
        <summary>Draws the string in the specified rectangle with the specified font.</summary>
        <returns>The actual size used by the rendering.</returns>
        <remarks>
          <para>This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF DrawString (string str, System.Drawing.PointF point, float width, MonoTouch.UIKit.UIFont font, MonoTouch.UIKit.UILineBreakMode breakMode);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF DrawString(string str, valuetype System.Drawing.PointF point, float32 width, class MonoTouch.UIKit.UIFont font, valuetype MonoTouch.UIKit.UILineBreakMode breakMode) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String"/>
        <Parameter Name="point" Type="System.Drawing.PointF"/>
        <Parameter Name="width" Type="System.Single"/>
        <Parameter Name="font" Type="MonoTouch.UIKit.UIFont"/>
        <Parameter Name="breakMode" Type="MonoTouch.UIKit.UILineBreakMode"/>
      </Parameters>
      <Docs>
        <param name="str">String to draw.</param>
        <param name="point">The position where the string should be drawn.</param>
        <param name="width">The maximum width to use when drawing.</param>
        <param name="font">Font to use to draw the string.</param>
        <param name="breakMode">The linebreak mode to use to draw the string.</param>
        <summary>Draws the string in the specified rectangle with the specified font.</summary>
        <returns>The actual size used by the rendering.</returns>
        <remarks>
          <para>This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF DrawString (string str, System.Drawing.RectangleF rect, MonoTouch.UIKit.UIFont font, MonoTouch.UIKit.UILineBreakMode mode, MonoTouch.UIKit.UITextAlignment alignment);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF DrawString(string str, valuetype System.Drawing.RectangleF rect, class MonoTouch.UIKit.UIFont font, valuetype MonoTouch.UIKit.UILineBreakMode mode, valuetype MonoTouch.UIKit.UITextAlignment alignment) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String"/>
        <Parameter Name="rect" Type="System.Drawing.RectangleF"/>
        <Parameter Name="font" Type="MonoTouch.UIKit.UIFont"/>
        <Parameter Name="mode" Type="MonoTouch.UIKit.UILineBreakMode"/>
        <Parameter Name="alignment" Type="MonoTouch.UIKit.UITextAlignment"/>
      </Parameters>
      <Docs>
        <param name="str">String to draw.</param>
        <param name="rect">Bounding rectangle.</param>
        <param name="font">Font to use to draw the string.</param>
        <param name="mode">The linebreak mode to use to draw the string.</param>
        <param name="alignment">The text alignment to use when drawing the string.</param>
        <summary>Draws the string in the specified rectangle with the specified font.</summary>
        <returns>The actual size used by the rendering.</returns>
        <remarks>
          <para>This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF DrawString (string str, System.Drawing.PointF point, float width, MonoTouch.UIKit.UIFont font, float fontSize, MonoTouch.UIKit.UILineBreakMode breakMode, MonoTouch.UIKit.UIBaselineAdjustment adjustment);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF DrawString(string str, valuetype System.Drawing.PointF point, float32 width, class MonoTouch.UIKit.UIFont font, float32 fontSize, valuetype MonoTouch.UIKit.UILineBreakMode breakMode, valuetype MonoTouch.UIKit.UIBaselineAdjustment adjustment) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String"/>
        <Parameter Name="point" Type="System.Drawing.PointF"/>
        <Parameter Name="width" Type="System.Single"/>
        <Parameter Name="font" Type="MonoTouch.UIKit.UIFont"/>
        <Parameter Name="fontSize" Type="System.Single"/>
        <Parameter Name="breakMode" Type="MonoTouch.UIKit.UILineBreakMode"/>
        <Parameter Name="adjustment" Type="MonoTouch.UIKit.UIBaselineAdjustment"/>
      </Parameters>
      <Docs>
        <param name="str">String to draw.</param>
        <param name="point">The position where the string should be drawn.</param>
        <param name="width">The maximum width to use when drawing.</param>
        <param name="font">Font to use to draw the string.</param>
        <param name="fontSize">The font size to use</param>
        <param name="breakMode">The linebreak mode to use to draw the string.</param>
        <param name="adjustment">Baseline adjustment to use.</param>
        <summary>Draws the string in the specified rectangle with the specified font.</summary>
        <returns>The actual size used by the rendering.</returns>
        <remarks>
          <para>This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF DrawString (string str, System.Drawing.PointF point, float width, MonoTouch.UIKit.UIFont font, float minFontSize, float actualFontSize, MonoTouch.UIKit.UILineBreakMode breakMode, MonoTouch.UIKit.UIBaselineAdjustment adjustment);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF DrawString(string str, valuetype System.Drawing.PointF point, float32 width, class MonoTouch.UIKit.UIFont font, float32 minFontSize, float32 actualFontSize, valuetype MonoTouch.UIKit.UILineBreakMode breakMode, valuetype MonoTouch.UIKit.UIBaselineAdjustment adjustment) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Advice("Use the version with a `ref float actualFontSize`")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String"/>
        <Parameter Name="point" Type="System.Drawing.PointF"/>
        <Parameter Name="width" Type="System.Single"/>
        <Parameter Name="font" Type="MonoTouch.UIKit.UIFont"/>
        <Parameter Name="minFontSize" Type="System.Single"/>
        <Parameter Name="actualFontSize" Type="System.Single"/>
        <Parameter Name="breakMode" Type="MonoTouch.UIKit.UILineBreakMode"/>
        <Parameter Name="adjustment" Type="MonoTouch.UIKit.UIBaselineAdjustment"/>
      </Parameters>
      <Docs>
        <param name="str">String to draw.</param>
        <param name="point">The position where the string should be drawn.</param>
        <param name="width">The maximum width to use when drawing.</param>
        <param name="font">Font to use to draw the string.</param>
        <param name="minFontSize">To be added.</param>
        <param name="actualFontSize">
        </param>
        <param name="breakMode">The linebreak mode to use to draw the string.</param>
        <param name="adjustment">Baseline adjustment to use.</param>
        <summary>Obsolete version of this method, use the version with a `ref float actualizeFontSize' parameter instead</summary>
        <returns>The actual size used by the rendering.</returns>
        <remarks>
          <para>This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF DrawString (string str, System.Drawing.PointF point, float width, MonoTouch.UIKit.UIFont font, float minFontSize, ref float actualFontSize, MonoTouch.UIKit.UILineBreakMode breakMode, MonoTouch.UIKit.UIBaselineAdjustment adjustment);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF DrawString(string str, valuetype System.Drawing.PointF point, float32 width, class MonoTouch.UIKit.UIFont font, float32 minFontSize, float32 actualFontSize, valuetype MonoTouch.UIKit.UILineBreakMode breakMode, valuetype MonoTouch.UIKit.UIBaselineAdjustment adjustment) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String"/>
        <Parameter Name="point" Type="System.Drawing.PointF"/>
        <Parameter Name="width" Type="System.Single"/>
        <Parameter Name="font" Type="MonoTouch.UIKit.UIFont"/>
        <Parameter Name="minFontSize" Type="System.Single"/>
        <Parameter Name="actualFontSize" Type="System.Single&amp;" RefType="ref"/>
        <Parameter Name="breakMode" Type="MonoTouch.UIKit.UILineBreakMode"/>
        <Parameter Name="adjustment" Type="MonoTouch.UIKit.UIBaselineAdjustment"/>
      </Parameters>
      <Docs>
        <param name="str">String to draw.</param>
        <param name="point">The position where the string should be drawn.</param>
        <param name="width">The maximum width to use when drawing.</param>
        <param name="font">Font to use to draw the string.</param>
        <param name="minFontSize">Minimum font size that can be used.</param>
        <param name="actualFontSize">On return, this will contain the font size used.</param>
        <param name="breakMode">The linebreak mode to use to draw the string.</param>
        <param name="adjustment">Baseline adjustment to use.</param>
        <summary>Obsolete version of this method, use the version with a `ref float actualizeFontSize' parameter instead</summary>
        <returns>The actual size used by the rendering.</returns>
        <remarks>
          <para>
            
            This drawing routine will try to draw the string at the
            specified position with the specified width.  If the text
            does not fit in the specified width, the font sized will
            be reduced until it reaches the size specified by
            <paramref name="minFontSize"/>.  Any text that does not
            fit will at that point be truncated according to the
            <paramref name="breakMode"/> rule.
          </para>
          <para>This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableInputClicksWhenVisible">
      <MemberSignature Language="C#" Value="public virtual bool EnableInputClicksWhenVisible { get; }"/>
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableInputClicksWhenVisible"/>
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(4, 2)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("enableInputClicksWhenVisible")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies whether input "clicks" should play.</summary>
        <value>The default value is <see langword="false"/>.</value>
        <remarks>For input clicks to be heard, the application user must have enabled keyboard clicks in Settings &gt; Sounds.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EncodeRestorableState">
      <MemberSignature Language="C#" Value="public virtual void EncodeRestorableState (MonoTouch.Foundation.NSCoder coder);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EncodeRestorableState(class MonoTouch.Foundation.NSCoder coder) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("encodeRestorableStateWithCoder:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="coder" Type="MonoTouch.Foundation.NSCoder"/>
      </Parameters>
      <Docs>
        <param name="coder">The <see cref="T:MonoTouch.Foundation.NSCoder"/> to encode the state.</param>
        <summary>Application developers can override this method to store state associated with the view.</summary>
        <remarks/>
        <altmember cref="M:Monotouch.UIKit.UIView.DecodeRestorableState"/>
        <altmember cref="M:MonoTouch.UIKit.UIApplicationDelegate.ShouldRestoreApplicationState"/>
        <altmember cref="M:MonoTouch.UIKit.UIApplicationDelegate.ShouldSaveApplicationState"/>
      </Docs>
    </Member>
    <Member MemberName="EndEditing">
      <MemberSignature Language="C#" Value="public bool EndEditing (bool force);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndEditing(bool force) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="force" Type="System.Boolean"/>
      </Parameters>
      <Docs>
        <param name="force">If <see langword="true"/>, overrides the subview's resignation choice.</param>
        <summary>Causes the view (or an appropriate subview) to resign first responder status.</summary>
        <returns><see langword="true"/> if the view resigned first responder status.</returns>
        <remarks>
          <para>This method causes the view or one of its <see cref="P:MonoTouch.UIKit.UIView.Subviews"/> to resign first responder status. If <paramref name="force"/> is <see langword="true"/>, the field is not even asked to resign: it is forced.</para>
          <para>This method returns <see langword="true"/> if the view or subview resigned first responder status. It will return <see langword="false"/> if:</para>
          <list type="bullet">
            <item>
              <term>Neither the <see cref="T:MonoTouch.UIKit.UIView"/> nor any of its <see cref="P:MonoTouch.UIKit.UIView.Subviews"/> was first responder; or
              </term>
            </item>
            <item>
              <term>The <paramref name="force"/> parameter was <see langword="false"/> and the first responder refused to resign (i.e., returned <see langword="false"/> from <see cref="M:MonoTouch.UIKit.UIResponder.ResignFirstResponder"/>.)
              </term>
            </item>
          </list>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExchangeSubview">
      <MemberSignature Language="C#" Value="public virtual void ExchangeSubview (int atIndex, int withSubviewAtIndex);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ExchangeSubview(int32 atIndex, int32 withSubviewAtIndex) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("exchangeSubviewAtIndex:withSubviewAtIndex:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="atIndex" Type="System.Int32"/>
        <Parameter Name="withSubviewAtIndex" Type="System.Int32"/>
      </Parameters>
      <Docs>
        <param name="atIndex">
          <para>An index within the zero-based <see cref="P:MonoTouch.UIKit.UIView.Subviews"/> array.</para>
        </param>
        <param name="withSubviewAtIndex">
          <para>Another index within the zero-based <see cref="P:MonoTouch.UIKit.UIView.Subviews"/> array.</para>
        </param>
        <summary>
          <para>This method exchanges the indices of two <see cref="T:MonoTouch.UIKit.UIView"/>s within the <see cref="P:MonoTouch.UIKit.UIView.Subviews"/> array. </para>
        </summary>
        <remarks>
        </remarks>
        <altmember cref="M:MonoTouch.UIKit.UIView.AddSubview"/>
        <altmember cref="M:MonoTouch.UIKit.UIView.InsertSubview"/>
        <altmember cref="M:MonoTouch.UIKit.UIView.InsertSubviewAbove"/>
        <altmember cref="M:MonoTouch.UIKit.UIView.InsertSubviewBelow"/>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveTouch">
      <MemberSignature Language="C#" Value="public virtual bool ExclusiveTouch { get; set; }"/>
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveTouch"/>
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("isExclusiveTouch")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setExclusiveTouch:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Restricts the event delivery to this view.</summary>
        <value>The default value is false.</value>
        <remarks>
          <para>
            
            When this property is set, if this view starts tracking a
            touch, no other views in the window will receive these
            events.  Additionally, a view that has set this property
            to true wont receive any events that are associated with
            other views in the window.
          </para>
          <para>
            
            If a finger touches a view that hast this property set,
            the event is only delivered if no other view in the window
            is tracking a finger.  If a finger touches a non-exclusive
            window, the event is only delivered if there are no
            exclusive views tracking a finger.
            
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExerciseAmbiguityInLayout">
      <MemberSignature Language="C#" Value="public virtual void ExerciseAmbiguityInLayout ();"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ExerciseAmbiguityInLayout() cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("exerciseAmbiguityInLayout")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters/>
      <Docs>
        <summary>Randomly changes the <see cref="P:MonoTouch.UIKit.UIView.Frame"/> within an ambiguous set of Auto Layout constraints.</summary>
        <remarks>
          <para>This is a debugging method that should not be used in production applications.</para>
          <para>This method should be used with an under-constrained (ambiguous) Auto Layout. When called, it varies the <see cref="P:MonoTouch.UIKit.UIView.Frame"/> among its valid values, providing visual cues to assist the application developer in determining needed constraints.</para>
        </remarks>
        <altmember cref="P:MonoTouch.UIKit.UIView.HasAmbiguousLayout"/>
      </Docs>
    </Member>
    <Member MemberName="Frame">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.RectangleF Frame { get; set; }"/>
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.RectangleF Frame"/>
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("frame")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setFrame:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Coordinates of the view relative to its container.</summary>
        <value>The value of this property is in points, not pixels.</value>
        <remarks>
          <para>
            
            When changes are done to this property, the <see cref="P:MonoTouch.UIKit.UIView.Center"/> is updated with
            the new location and the <see cref="P:MonoTouch.UIKit.UIView.Bounds"/> is updated with
            the new dimensions and a re-layout of the subviews is
            performed.
            
          </para>
          <para>
            
            Changing this property will not trigger a call to <see cref="M:MonoTouch.UIKit.UIView.Draw&#xA;     (System.Drawing.RectangleF)"/> unless you set the <see cref="P:MonoTouch.UIKit.UIView.ContentMode"/> property to
            <see cref="E:MonoTouch.UIKit.UIViewContentMode.Redraw"/>.
            
          </para>
          <para>
            
            At least on iOS 6, changing this property causes the a
            re-layout of the subviews, even if the dimensions are the
            same.  This can cause performance problems as some views
            (like UITableView) can perform some very expensive
            computations when they are laid out.  
            
          </para>
          <para>
            
            If your <see cref="P:MonoTouch.UIKit.UIView.ContentMode"/>
            property is set to <see cref="E:MonoTouch.UIKit.UIViewContentMode.Redraw"/>, you
            can avoid a redraw of your view if you update the <see cref="P:MonoTouch.UIKit.UIView.Center"/> property instead
            of updating the Frame as that one will merely move the
            view without triggering a call to <see cref="M:MonoTouch.UIKit.UIView.LayoutSubviews()"/>.
            
          </para>
          <para id="animatable">
            This property participates in the implicit animation
            protocol, changing it outside of a transaction will trigger
            an implicit animation for its values.
          </para>
          <para>
            
            If you change the <see cref="P:MonoTouch.UIKit.UIView.Transform"/> property to a
            matrix that does not represent the identity matrix,
            changing this property can have unintended consequences.   In those cases, you should instead update <see cref="P:MonoTouch.UIKit.UIView.Center"/> and <see cref="P:MonoTouch.UIKit.UIView.Bounds"/> directly.
            
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FrameForAlignmentRect">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.RectangleF FrameForAlignmentRect (System.Drawing.RectangleF alignmentRect);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Drawing.RectangleF FrameForAlignmentRect(valuetype System.Drawing.RectangleF alignmentRect) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("frameForAlignmentRect:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="alignmentRect" Type="System.Drawing.RectangleF"/>
      </Parameters>
      <Docs>
        <param name="alignmentRect">A <see cref="T:System.Drawing.RectangleF"/> for which the frame rectangle should be calculated.</param>
        <summary>Returns the frame resulting from applying the <paramref name="alignmentRect"/> to the current Auto Layout constraints.</summary>
        <returns>
          <para>The frame rectangle appropriate to the <paramref name="alignmentRect"/>/</para>
        </returns>
        <remarks>
          <para>By overriding this method, application developers can fully customize the alignment rectangle of the <see cref="T:MonoTouch.UIKit.UIView"/>.Application developers who override this method must also override the complementary method <see cref="M:MonoTouch.UIKit.UIView.AlignmentRectForFrame"/>. The two methods must provide complementary values.</para>
          <para>Auto Layout uses "alignment rectangles" to layout subviews rather than the subviews' <see cref="P:MonoTouch.UIKit.UIView.Frame"/>. The <see cref="P:MonoTouch.UIKit.UIView.Frame"/> of a <see cref="T:MonoTouch.UIKit.UIView"/> may include visual elements, such as drop-shadows, that are not symmetrical around the <see cref="T:MonoTouch.UIKit.UIView"/>'s logical center. The "alignment rectangle" for a <see cref="T:MonoTouch.UIKit.UIView"/> should be related to its logical content.</para>
          <para> By default, the "alignment rectangle" of a <see cref="T:MonoTouch.UIKit.UIView"/> is the <see cref="P:MonoTouch.UIKit.UIView.Frame"/> plus the <see cref="P:MonoTouch.UIKit.UIView.AlignmentRectInsets"/>. The <see cref="M:MonoTouch.UIKit.UIView.AlignmentRectForFrame"/> and <see cref="M:MonoTouch.UIKit.UIView.FrameForAlignmentRect"/> methods can be used to fully customize the alignment rectangle.</para>
        </remarks>
        <altmember cref="M:MonoTouch.UIKit.UIView.AlignmentRectForFrame"/>
        <altmember cref="M:MonoTouch.UIKit.UIView.AlignmentRectInsets"/>
        <altmember cref="M:MonoTouch.UIKit.UIView.ViewForBaselineLayout"/>
      </Docs>
    </Member>
    <Member MemberName="GestureRecognizers">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIGestureRecognizer[] GestureRecognizers { get; set; }"/>
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIGestureRecognizer[] GestureRecognizers"/>
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(3, 2)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("gestureRecognizers", MonoTouch.ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setGestureRecognizers:", MonoTouch.ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIGestureRecognizer[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The array of <see cref="T:MonoTouch.UIKit.UIGestureRecognizer"/>s for this <see cref="T:MonoTouch.UIKit.UIView"/>.</summary>
        <value>The default value is <see langword="null"/>.</value>
        <remarks/>
      </Docs>
    </Member>
    <Member MemberName="GestureRecognizerShouldBegin">
      <MemberSignature Language="C#" Value="public virtual bool GestureRecognizerShouldBegin (MonoTouch.UIKit.UIGestureRecognizer gestureRecognizer);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GestureRecognizerShouldBegin(class MonoTouch.UIKit.UIGestureRecognizer gestureRecognizer) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("gestureRecognizerShouldBegin:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="gestureRecognizer" Type="MonoTouch.UIKit.UIGestureRecognizer"/>
      </Parameters>
      <Docs>
        <param name="gestureRecognizer">The gesture recognizer that is
          trying to transitioning out of the <see cref="T:MonoTouch.UIKit.UIGestureRecognizerState"/>'s Possible state.</param>
        <summary>Determines if the specified gesture recognizers
          should be allowed to track touch events.</summary>
        <returns>
        </returns>
        <remarks>
          Override this method if your application handles touches
          directly, it controls whether an associated
          <see cref="T:MonoTouch.UIKit.UIGestureRecognizer"/> should execute or not.
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConstraintsAffectingLayout">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.NSLayoutConstraint[] GetConstraintsAffectingLayout (MonoTouch.UIKit.UILayoutConstraintAxis axis);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class MonoTouch.UIKit.NSLayoutConstraint[] GetConstraintsAffectingLayout(valuetype MonoTouch.UIKit.UILayoutConstraintAxis axis) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("constraintsAffectingLayoutForAxis:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.NSLayoutConstraint[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="axis" Type="MonoTouch.UIKit.UILayoutConstraintAxis"/>
      </Parameters>
      <Docs>
        <param name="axis">The direction of interest.</param>
        <summary>Returns the array of <see cref="T:MonoTouch.UIKit.NSLayoutConstraint"/> that are affecting the layout of the <see cref="T:MonoTouch.UIKit.UIView"/> along the specified <paramref name="axis"/>.</summary>
        <returns>The default value is an empty array.</returns>
        <remarks>
          <para>This is a debugging method that should not be used in production applications.</para>
          <para>
            The returned array may contain <see cref="T:MonoTouch.UIKit.NSLayoutConstraint"/>s that do not explicitly reference <c>this</c><see cref="T:MonoTouch.UIKit.UIView"/> but which nonetheless affect the <see cref="P:MonoTouch.UIKit.UIView.Frame"/>. For instance, if <c>this</c> is pinned to <c>anotherView</c> and <c>anotherView</c> is pinned to it's <see cref="P:MonoTouch.UIKit.UIView.Superview"/>, the method may return both constraints. 
          </para>
          <para>This method is a debugging oriented helper method and is not guaranteed to return the complete set (or any) <see cref="T:MonoTouch.UIKit.NSLayoutConstraint"/>s. </para>
          <para>If this method is called directly from within <see cref="M:MonoTouch.UIKit.UIView.ViewDidLoad"/>, it will generally return an empty array. If it is invoked as shown in the following example, it appears to be more likely to provide a comprehensive answer.</para>
          <example>
            <code lang="C#">
              mainView.AddConstraints(NSLayoutConstraint.FromVisualFormat("H:|-[blue]-|", 0, new NSDictionary(), viewsDictionary));
              mainView.AddConstraints(NSLayoutConstraint.FromVisualFormat("V:|-[blue]-(==30)-[green(==blue)]-|", 0, new NSDictionary(), viewsDictionary));
              mainView.AddConstraints(NSLayoutConstraint.FromVisualFormat("|-[green(==blue)]-|", 0, new NSDictionary(), viewsDictionary));
              
              System.Threading.ThreadPool.QueueUserWorkItem(delegate {
              &#xA0;&#xA0;InvokeOnMainThread(delegate {
              &#xA0;&#xA0;&#xA0;&#xA0;foreach(var c2 in blueView.GetConstraintsAffectingLayout(UILayoutConstraintAxis.Horizontal))
              &#xA0;&#xA0;&#xA0;&#xA0;{
              &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;Console.WriteLine(c2);
              &#xA0;&#xA0;&#xA0;&#xA0;}
              &#xA0;&#xA0;});
              });
            </code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters/>
      <Docs>
        <summary>Returns an enumerator that lists all of the subviews in this view</summary>
        <returns>
        </returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasAmbiguousLayout">
      <MemberSignature Language="C#" Value="public virtual bool HasAmbiguousLayout { get; }"/>
      <MemberSignature Language="ILAsm" Value=".property instance bool HasAmbiguousLayout"/>
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("hasAmbiguousLayout")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns <see langword="true"/> if the Auto Layout for this <see cref="T:MonoTouch.UIKit.UIView"/> is ambiguous.</summary>
        <value>Returns <see langword="false"/> if the <see cref="T:MonoTouch.UIKit.UIView"/>'s constraints are sufficient to accurately specify its alignment rectangle.</value>
        <remarks>
          <para>This is a debugging method that should not be used in production applications.</para>
          <para>This method can be used to determine if the set of <see cref="T:MonoTouch.UIKit.NSLayoutConstraint"/>s for a <see cref="T:MonoTouch.UIKit.UIView"/> are sufficient to fully determine the alignment rectangle or if they are ambiguous. </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Hidden">
      <MemberSignature Language="C#" Value="public virtual bool Hidden { get; set; }"/>
      <MemberSignature Language="ILAsm" Value=".property instance bool Hidden"/>
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("isHidden")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setHidden:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies whether the <see cref="T:MonoTouch.UIKit.UIView"/> displays or not.</summary>
        <value>The default value is <see langword="false"/>.</value>
        <remarks>
          <para>A hidden <see cref="T:MonoTouch.UIKit.UIView"/> does not display and does not receive input events. It does, however, participate in resizing and layout events and remains in its <see cref="P:MonoTouch.UIKit.UIView.Superview"/>'s list of <see cref="P:MonoTouch.UIKit.UIView.Subviews"/>s.</para>
          <para>A hidden <see cref="T:MonoTouch.UIKit.UIView"/> hides its descendant views in addition to hiding itself. This does not affect the <see cref="P:MonoTouch.UIKit.UIView.Hidden"/> property of the descendant views. Thus, a <see cref="T:MonoTouch.UIKit.UIView"/> may be hidden even though its <see cref="P:MonoTouch.UIKit.UIView.Hidden"/> property is <see langword="false"/>.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HitTest">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIView HitTest (System.Drawing.PointF point, MonoTouch.UIKit.UIEvent uievent);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class MonoTouch.UIKit.UIView HitTest(valuetype System.Drawing.PointF point, class MonoTouch.UIKit.UIEvent uievent) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("hitTest:withEvent:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIView</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.PointF"/>
        <Parameter Name="uievent" Type="MonoTouch.UIKit.UIEvent"/>
      </Parameters>
      <Docs>
        <param name="point">
          <para>The location to test.</para>
        </param>
        <param name="uievent">
          <para>The event that triggered this call.</para>
          <para tool="nullallowed">This parameter can be <see langword="null"/>.</para>
        </param>
        <summary>Determines the most nested view that contains the point.</summary>
        <returns>
          <para>The most nested view that contains the point, or null if the point falls outside of the boundaris of the view.</para>
        </returns>
        <remarks>
          <para>
            
            This method iterates over all of the visible subviews that
            have user interaction enabled and that are not entirely
            transparent to find the most nested view that contains the
            point.  For each of those views, the method <see cref="M:MonoTouch.UIKit.UIView.PointInside(System.Drawing.PointF,&#xA;     MonoTouch.UIKit.UIEvent)"/> is invoked to determine if
            there is a match.     
            
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertSubview">
      <MemberSignature Language="C#" Value="public virtual void InsertSubview (MonoTouch.UIKit.UIView view, int atIndex);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void InsertSubview(class MonoTouch.UIKit.UIView view, int32 atIndex) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("insertSubview:atIndex:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="view" Type="MonoTouch.UIKit.UIView"/>
        <Parameter Name="atIndex" Type="System.Int32"/>
      </Parameters>
      <Docs>
        <param name="view">
          <para>The view to add as a nested view of this view.</para>
        </param>
        <param name="atIndex">
          <para>The index in the stack of subviews where this view
            will be inserted.</para>
        </param>
        <summary>Inserts the specified subview at the specified
          location as a subview of this view.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertSubviewAbove">
      <MemberSignature Language="C#" Value="public virtual void InsertSubviewAbove (MonoTouch.UIKit.UIView view, MonoTouch.UIKit.UIView siblingSubview);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void InsertSubviewAbove(class MonoTouch.UIKit.UIView view, class MonoTouch.UIKit.UIView siblingSubview) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("insertSubview:aboveSubview:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="view" Type="MonoTouch.UIKit.UIView"/>
        <Parameter Name="siblingSubview" Type="MonoTouch.UIKit.UIView"/>
      </Parameters>
      <Docs>
        <param name="view">
          <para>The view to add as a nested view of this view.</para>
        </param>
        <param name="siblingSubview">
          <para>The subview of this view that will be below the view.</para>
        </param>
        <summary>Inserts the specified view above the siblingSubvie in
          the view hierarchy</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertSubviewBelow">
      <MemberSignature Language="C#" Value="public virtual void InsertSubviewBelow (MonoTouch.UIKit.UIView view, MonoTouch.UIKit.UIView siblingSubview);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void InsertSubviewBelow(class MonoTouch.UIKit.UIView view, class MonoTouch.UIKit.UIView siblingSubview) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("insertSubview:belowSubview:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="view" Type="MonoTouch.UIKit.UIView"/>
        <Parameter Name="siblingSubview" Type="MonoTouch.UIKit.UIView"/>
      </Parameters>
      <Docs>
        <param name="view">
          <para>The view to add as a nested view of this view.</para>
        </param>
        <param name="siblingSubview">
          <para>The subview of this view that will be below the view.</para>
        </param>
        <summary>Inserts the specified view below the siblingSubvie in
          the view hierarchy.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IntrinsicContentSize">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.SizeF IntrinsicContentSize { get; }"/>
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.SizeF IntrinsicContentSize"/>
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("intrinsicContentSize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Docs>
        <!-- tk tk tk -->
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvalidateIntrinsicContentSize">
      <MemberSignature Language="C#" Value="public virtual void InvalidateIntrinsicContentSize ();"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void InvalidateIntrinsicContentSize() cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("invalidateIntrinsicContentSize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters/>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDescendantOfView">
      <MemberSignature Language="C#" Value="public virtual bool IsDescendantOfView (MonoTouch.UIKit.UIView view);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsDescendantOfView(class MonoTouch.UIKit.UIView view) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("isDescendantOfView:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="view" Type="MonoTouch.UIKit.UIView"/>
      </Parameters>
      <Docs>
        <param name="view">
          <para>To be added.</para>
        </param>
        <summary>To be added.</summary>
        <returns>
          <para>To be added.</para>
        </returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Layer">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.CoreAnimation.CALayer Layer { get; }"/>
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.CoreAnimation.CALayer Layer"/>
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("layer", MonoTouch.ObjCRuntime.ArgumentSemantic.Retain)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.CoreAnimation.CALayer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>
          <para>(More documentation for this node is coming)</para>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LayoutIfNeeded">
      <MemberSignature Language="C#" Value="public virtual void LayoutIfNeeded ();"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void LayoutIfNeeded() cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("layoutIfNeeded")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters/>
      <Docs>
        <summary>Lays out the subviews if needed.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LayoutSubviews">
      <MemberSignature Language="C#" Value="public virtual void LayoutSubviews ();"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void LayoutSubviews() cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("layoutSubviews")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters/>
      <Docs>
        <summary>Lays out subviews.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MovedToSuperview">
      <MemberSignature Language="C#" Value="public virtual void MovedToSuperview ();"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MovedToSuperview() cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("didMoveToSuperview")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters/>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MovedToWindow">
      <MemberSignature Language="C#" Value="public virtual void MovedToWindow ();"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MovedToWindow() cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("didMoveToWindow")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters/>
      <Docs>
        <summary>To be added.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MultipleTouchEnabled">
      <MemberSignature Language="C#" Value="public virtual bool MultipleTouchEnabled { get; set; }"/>
      <MemberSignature Language="ILAsm" Value=".property instance bool MultipleTouchEnabled"/>
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("isMultipleTouchEnabled")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setMultipleTouchEnabled:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Controls whether the UIView can handle multitouch events.</summary>
        <value>State of multiple touch recotgnition.</value>
        <remarks>
          UIViews by default only handle a single touch event at once.  If you
          want your view to handle multiple touches, you must set this property
          to true.
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NeedsUpdateConstraints">
      <MemberSignature Language="C#" Value="public virtual bool NeedsUpdateConstraints ();"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool NeedsUpdateConstraints() cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("needsUpdateConstraints")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters/>
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NoIntrinsicMetric">
      <MemberSignature Language="C#" Value="public static float NoIntrinsicMetric { get; }"/>
      <MemberSignature Language="ILAsm" Value=".property float32 NoIntrinsicMetric"/>
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UIViewNoIntrinsicMetric</summary>
        <value>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Opaque">
      <MemberSignature Language="C#" Value="public virtual bool Opaque { get; set; }"/>
      <MemberSignature Language="ILAsm" Value=".property instance bool Opaque"/>
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("isOpaque")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setOpaque:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determines whether the view is opaque or not.</summary>
        <value>
        </value>
        <remarks>
          <para>
            
            If you set this value to true, you should make sure that
            the entire area is painted, if you do not, the behavior is
            undefined.  You should also set the <see cref="T:MonoTouch.UIKit.UIView.Alpha"/> property to 1.0.
            
          </para>
          <para>
            Whenever possible, you should try to set the view as
            opaque, as that informs UIKit that the view does not need
            to be composited and blended with underlying views.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PointInside">
      <MemberSignature Language="C#" Value="public virtual bool PointInside (System.Drawing.PointF point, MonoTouch.UIKit.UIEvent uievent);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool PointInside(valuetype System.Drawing.PointF point, class MonoTouch.UIKit.UIEvent uievent) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("pointInside:withEvent:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.PointF"/>
        <Parameter Name="uievent" Type="MonoTouch.UIKit.UIEvent"/>
      </Parameters>
      <Docs>
        <param name="point">
          <para>To be added.</para>
        </param>
        <param name="uievent">
          <para>
          </para>
          <para tool="nullallowed">This parameter can be <see langword="null"/>.</para>
        </param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveConstraint">
      <MemberSignature Language="C#" Value="public virtual void RemoveConstraint (MonoTouch.UIKit.NSLayoutConstraint constraint);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveConstraint(class MonoTouch.UIKit.NSLayoutConstraint constraint) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("removeConstraint:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constraint" Type="MonoTouch.UIKit.NSLayoutConstraint"/>
      </Parameters>
      <Docs>
        <param name="constraint">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:MonoTouch.UIKit.UIView.Constraints"/>
        <altmember cref="M:MonoTouch.UIKit.UIView.AddConstraint"/>
        <altmember cref="M:MonoTouch.UIKit.UIView.AddConstraints"/>
        <altmember cref="M:MonoTouch.UIKit.UIView.RemoveConstraints"/>
        <altmember cref="P:MonoTouch.UIKit.UIView.TranslatesAutoresizingMaskIntoConstraints"/>
      </Docs>
    </Member>
    <Member MemberName="RemoveConstraints">
      <MemberSignature Language="C#" Value="public virtual void RemoveConstraints (MonoTouch.UIKit.NSLayoutConstraint[] constraints);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveConstraints(class MonoTouch.UIKit.NSLayoutConstraint[] constraints) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("removeConstraints:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constraints" Type="MonoTouch.UIKit.NSLayoutConstraint[]"/>
      </Parameters>
      <Docs>
        <param name="constraints">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:MonoTouch.UIKit.UIView.Constraints"/>
        <altmember cref="M:MonoTouch.UIKit.UIView.AddConstraint"/>
        <altmember cref="M:MonoTouch.UIKit.UIView.AddConstraints"/>
        <altmember cref="M:MonoTouch.UIKit.UIView.RemoveConstraint"/>
        <altmember cref="P:MonoTouch.UIKit.UIView.TranslatesAutoresizingMaskIntoConstraints"/>
      </Docs>
    </Member>
    <Member MemberName="RemoveFromSuperview">
      <MemberSignature Language="C#" Value="public virtual void RemoveFromSuperview ();"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveFromSuperview() cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("removeFromSuperview")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters/>
      <Docs>
        <summary>To be added.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveGestureRecognizer">
      <MemberSignature Language="C#" Value="public virtual void RemoveGestureRecognizer (MonoTouch.UIKit.UIGestureRecognizer gestureRecognizer);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveGestureRecognizer(class MonoTouch.UIKit.UIGestureRecognizer gestureRecognizer) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("removeGestureRecognizer:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="gestureRecognizer" Type="MonoTouch.UIKit.UIGestureRecognizer"/>
      </Parameters>
      <Docs>
        <param name="gestureRecognizer">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RequiresConstraintBasedLayout">
      <MemberSignature Language="C#" Value="public static bool RequiresConstraintBasedLayout ();"/>
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool RequiresConstraintBasedLayout() cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("requiresConstraintBasedLayout")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters/>
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RestorationIdentifier">
      <MemberSignature Language="C#" Value="public virtual string RestorationIdentifier { get; set; }"/>
      <MemberSignature Language="ILAsm" Value=".property instance string RestorationIdentifier"/>
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("restorationIdentifier")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setRestorationIdentifier:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SendSubviewToBack">
      <MemberSignature Language="C#" Value="public virtual void SendSubviewToBack (MonoTouch.UIKit.UIView view);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SendSubviewToBack(class MonoTouch.UIKit.UIView view) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("sendSubviewToBack:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="view" Type="MonoTouch.UIKit.UIView"/>
      </Parameters>
      <Docs>
        <param name="view">
          <para>To be added.</para>
        </param>
        <summary>To be added.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAnimationBeginsFromCurrentState">
      <MemberSignature Language="C#" Value="public static void SetAnimationBeginsFromCurrentState (bool fromCurrentState);"/>
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAnimationBeginsFromCurrentState(bool fromCurrentState) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setAnimationBeginsFromCurrentState:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromCurrentState" Type="System.Boolean"/>
      </Parameters>
      <Docs>
        <param name="fromCurrentState">true if you want to start the
          animation from the current state, false otherwise.</param>
        <summary>Sets whether the animation transaction will animate
          from the current view state.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAnimationCurve">
      <MemberSignature Language="C#" Value="public static void SetAnimationCurve (MonoTouch.UIKit.UIViewAnimationCurve curve);"/>
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAnimationCurve(valuetype MonoTouch.UIKit.UIViewAnimationCurve curve) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setAnimationCurve:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="curve" Type="MonoTouch.UIKit.UIViewAnimationCurve"/>
      </Parameters>
      <Docs>
        <param name="curve">Curve used to animate the property changes.</param>
        <summary>Sets the animation curve for this animation transaction.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAnimationDelay">
      <MemberSignature Language="C#" Value="public static void SetAnimationDelay (double delay);"/>
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAnimationDelay(float64 delay) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setAnimationDelay:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delay" Type="System.Double"/>
      </Parameters>
      <Docs>
        <param name="delay">Delay in seconds.</param>
        <summary>Sets the animation delay for this animation transaction.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAnimationDelegate">
      <MemberSignature Language="C#" Value="public static void SetAnimationDelegate (MonoTouch.Foundation.NSObject del);"/>
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAnimationDelegate(class MonoTouch.Foundation.NSObject del) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setAnimationDelegate:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="del" Type="MonoTouch.Foundation.NSObject"/>
      </Parameters>
      <Docs>
        <param name="del">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAnimationDidStopSelector">
      <MemberSignature Language="C#" Value="public static void SetAnimationDidStopSelector (MonoTouch.ObjCRuntime.Selector sel);"/>
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAnimationDidStopSelector(class MonoTouch.ObjCRuntime.Selector sel) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setAnimationDidStopSelector:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sel" Type="MonoTouch.ObjCRuntime.Selector"/>
      </Parameters>
      <Docs>
        <param name="sel">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAnimationDuration">
      <MemberSignature Language="C#" Value="public static void SetAnimationDuration (double duration);"/>
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAnimationDuration(float64 duration) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setAnimationDuration:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Double"/>
      </Parameters>
      <Docs>
        <param name="duration">Duration in seconds.</param>
        <summary>Sets the duration for this animation transaction.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAnimationRepeatAutoreverses">
      <MemberSignature Language="C#" Value="public static void SetAnimationRepeatAutoreverses (bool repeatAutoreverses);"/>
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAnimationRepeatAutoreverses(bool repeatAutoreverses) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setAnimationRepeatAutoreverses:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="repeatAutoreverses" Type="System.Boolean"/>
      </Parameters>
      <Docs>
        <param name="repeatAutoreverses">True if this animation should autoreverse when it completes.</param>
        <summary>Sets whether this animation transaction will automatically reverse when it completes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAnimationRepeatCount">
      <MemberSignature Language="C#" Value="public static void SetAnimationRepeatCount (float repeatCount);"/>
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAnimationRepeatCount(float32 repeatCount) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setAnimationRepeatCount:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="repeatCount" Type="System.Single"/>
      </Parameters>
      <Docs>
        <param name="repeatCount">Count</param>
        <summary>Sets the repeat count for this animation transaction.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAnimationStartDate">
      <MemberSignature Language="C#" Value="public static void SetAnimationStartDate (MonoTouch.Foundation.NSDate startDate);"/>
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAnimationStartDate(class MonoTouch.Foundation.NSDate startDate) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setAnimationStartDate:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startDate" Type="MonoTouch.Foundation.NSDate"/>
      </Parameters>
      <Docs>
        <param name="startDate">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAnimationTransition">
      <MemberSignature Language="C#" Value="public static void SetAnimationTransition (MonoTouch.UIKit.UIViewAnimationTransition transition, MonoTouch.UIKit.UIView forView, bool cache);"/>
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAnimationTransition(valuetype MonoTouch.UIKit.UIViewAnimationTransition transition, class MonoTouch.UIKit.UIView forView, bool cache) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setAnimationTransition:forView:cache:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transition" Type="MonoTouch.UIKit.UIViewAnimationTransition"/>
        <Parameter Name="forView" Type="MonoTouch.UIKit.UIView"/>
        <Parameter Name="cache" Type="System.Boolean"/>
      </Parameters>
      <Docs>
        <param name="transition">To be added.</param>
        <param name="forView">To be added.</param>
        <param name="cache">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAnimationWillStartSelector">
      <MemberSignature Language="C#" Value="public static void SetAnimationWillStartSelector (MonoTouch.ObjCRuntime.Selector sel);"/>
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAnimationWillStartSelector(class MonoTouch.ObjCRuntime.Selector sel) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setAnimationWillStartSelector:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sel" Type="MonoTouch.ObjCRuntime.Selector"/>
      </Parameters>
      <Docs>
        <param name="sel">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetContentCompressionResistancePriority">
      <MemberSignature Language="C#" Value="public virtual void SetContentCompressionResistancePriority (float priority, MonoTouch.UIKit.UILayoutConstraintAxis axis);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetContentCompressionResistancePriority(float32 priority, valuetype MonoTouch.UIKit.UILayoutConstraintAxis axis) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setContentCompressionResistancePriority:forAxis:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Single"/>
        <Parameter Name="axis" Type="MonoTouch.UIKit.UILayoutConstraintAxis"/>
      </Parameters>
      <Docs>
        <param name="priority">To be added.</param>
        <param name="axis">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:MonoTouch.UIKit.UIView.ContentCompressionResistancePriority"/>
      </Docs>
    </Member>
    <Member MemberName="SetContentHuggingPriority">
      <MemberSignature Language="C#" Value="public virtual void SetContentHuggingPriority (float priority, MonoTouch.UIKit.UILayoutConstraintAxis axis);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetContentHuggingPriority(float32 priority, valuetype MonoTouch.UIKit.UILayoutConstraintAxis axis) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setContentHuggingPriority:forAxis:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Single"/>
        <Parameter Name="axis" Type="MonoTouch.UIKit.UILayoutConstraintAxis"/>
      </Parameters>
      <Docs>
        <param name="priority">To be added.</param>
        <param name="axis">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:MonoTouch.UIKit.UIView.ContentHuggingPriority"/>
      </Docs>
    </Member>
    <Member MemberName="SetNeedsDisplay">
      <MemberSignature Language="C#" Value="public virtual void SetNeedsDisplay ();"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetNeedsDisplay() cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setNeedsDisplay")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters/>
      <Docs>
        <summary>Marks the view dirty and queues a redraw operation on it.</summary>
        <remarks>
          <para>
            This method is invoked if the contents of the view need to
            be refreshed due to a change of state or geometry.  Invoking
            this method will cause the <see cref="M:MonoTouch.UIKit.UIView.Draw(System.Drawing.RectangleF)"/>
            method to be invoked.
          </para>
          <para>
            Alternatively you can use the <see cref="M:MonoTouch.UIKit.UIView.SetNeedsDisplayInRect(System.Drawing.RectangleF)"/>
            method to only mark a specific region of the view to be repainted.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetNeedsDisplayInRect">
      <MemberSignature Language="C#" Value="public virtual void SetNeedsDisplayInRect (System.Drawing.RectangleF rect);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetNeedsDisplayInRect(valuetype System.Drawing.RectangleF rect) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setNeedsDisplayInRect:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF"/>
      </Parameters>
      <Docs>
        <param name="rect">
          <para>The region that will be marked as dirty.</para>
        </param>
        <summary>Marks a region of the view as dirty and queues a redraw operation on that region.</summary>
        <remarks>
          <para>
            This method is invoked if a region of the contents of the view need to
            be refreshed due to a change of state or geometry.  Invoking
            this method will cause the <see cref="M:MonoTouch.UIKit.UIView.Draw(System.Drawing.RectangleF)"/>
            method to be invoked.
          </para>
          <para>
            Alternatively you can use the <see cref="M:MonoTouch.UIKit.UIView.SetNeedsDisplay()"/>
            method if you want to repaing the entire view.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetNeedsLayout">
      <MemberSignature Language="C#" Value="public virtual void SetNeedsLayout ();"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetNeedsLayout() cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setNeedsLayout")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters/>
      <Docs>
        <summary>Sets whether subviews need to be rearranged before displaying.</summary>
        <remarks>
          If the state of your view changes in response to some API calls,
          instead of changing the layout manually in response to the change,
          you should invoke this method which will
          flag the view for a layout.  The layout event will then be processed
          the next time the main loop runs.  By using this approach, you can
          coalesce multiple changes to the layout in a single pass.
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetNeedsUpdateConstraints">
      <MemberSignature Language="C#" Value="public virtual void SetNeedsUpdateConstraints ();"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetNeedsUpdateConstraints() cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setNeedsUpdateConstraints")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters/>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeThatFits">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.SizeF SizeThatFits (System.Drawing.SizeF size);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Drawing.SizeF SizeThatFits(valuetype System.Drawing.SizeF size) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("sizeThatFits:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Drawing.SizeF"/>
      </Parameters>
      <Docs>
        <param name="size">
          <para>To be added.</para>
        </param>
        <summary>Returns the <see cref="T:System.Drawing.SizeF"/> that best fits <c>this</c> <see cref="T:MonoTouch.UIKit.UIView"/>.</summary>
        <returns>
          <para>To be added.</para>
        </returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeToFit">
      <MemberSignature Language="C#" Value="public virtual void SizeToFit ();"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SizeToFit() cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("sizeToFit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters/>
      <Docs>
        <summary>To be added.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StringSize">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF StringSize (string str, MonoTouch.UIKit.UIFont font);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF StringSize(string str, class MonoTouch.UIKit.UIFont font) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String"/>
        <Parameter Name="font" Type="MonoTouch.UIKit.UIFont"/>
      </Parameters>
      <Docs>
        <param name="str">The string whose size is being calculated.</param>
        <param name="font">The font to be used in the size calculation.</param>
        <summary>Calculates the <see cref="T:System.Drawing.SizeF"/> of the specified string if it were rendered with the specified font.</summary>
        <returns>Returns the <see cref="T:System.Drawing.SizeF"/> of the specified string if it were rendered with the specified font.</returns>
        <remarks>
          <para>Application developers can use this method to calculate text metrics. It does not render or otherwise change state in the <see cref="T:MonoTouch.UIKit.UIView"/>.</para>
          <para>In iOS 6 and later, this method calculates the size using the <see cref="M:MonoTouch.UIKit.UILineBreakMode.WordWrap"/> line-break mode. In earlier versions, this method returns the calculation without any line breaks.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StringSize">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF StringSize (string str, MonoTouch.UIKit.UIFont font, System.Drawing.SizeF constrainedToSize);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF StringSize(string str, class MonoTouch.UIKit.UIFont font, valuetype System.Drawing.SizeF constrainedToSize) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String"/>
        <Parameter Name="font" Type="MonoTouch.UIKit.UIFont"/>
        <Parameter Name="constrainedToSize" Type="System.Drawing.SizeF"/>
      </Parameters>
      <Docs>
        <param name="str">The string whose size is being calculated.</param>
        <param name="font">The font to be used in the size calculation.</param>
        <param name="constrainedToSize">The maximum <see cref="T:System.Drawing.SizeF"/> allowed for the string.</param>
        <summary>Calculates the <see cref="T:System.Drawing.SizeF"/> of the specified string if it were rendered with the specified font and constrained to the specified size.</summary>
        <returns>Returns the <see cref="T:System.Drawing.SizeF"/> of the specified string if it were rendered with the specified font and constrained to the specified size.</returns>
        <remarks>
          <para>Application developers can use this method to calculate text metrics. It does not render or otherwise change state in the <see cref="T:MonoTouch.UIKit.UIView"/>.</para>
          <para>This method calculates the size that the <paramref name="str"/> would require if rendered with the <paramref name="font"/>, but if it the rendering were not allowed to exceed the dimensions of the <paramref name="constrainedToSize"/> <see cref="T:System.Drawing.SizeF"/>. This method calculates the size using <see cref="M:MonoTouch.UIKit.UILineBreakMode.WordWrap"/> line-break mode. If the calculated size exceeds the available dimensions, the method will attempt to truncate the string internally and return a <see cref="T:System.Drawing.SizeF"/> based on that truncated text. If the <see cref="P:System.Drawing.SizeF.Height"/> of the <paramref name="constrainedToSize"/> argument is less than that of a single line of text in the specfied font, the method may return a <see cref="T:System.Drawing.SizeF"/> whose <see cref="P:System.Drawing.SizeF.Height"/> is greater than that in <paramref name="constrainedToSize"/>.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StringSize">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF StringSize (string str, MonoTouch.UIKit.UIFont font, System.Drawing.SizeF constrainedToSize, MonoTouch.UIKit.UILineBreakMode lineBreakMode);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF StringSize(string str, class MonoTouch.UIKit.UIFont font, valuetype System.Drawing.SizeF constrainedToSize, valuetype MonoTouch.UIKit.UILineBreakMode lineBreakMode) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String"/>
        <Parameter Name="font" Type="MonoTouch.UIKit.UIFont"/>
        <Parameter Name="constrainedToSize" Type="System.Drawing.SizeF"/>
        <Parameter Name="lineBreakMode" Type="MonoTouch.UIKit.UILineBreakMode"/>
      </Parameters>
      <Docs>
        <param name="str">The string whose size is being calculated.</param>
        <param name="font">The font to be used in the size calculation.</param>
        <param name="constrainedToSize">The maximum <see cref="T:System.Drawing.SizeF"/> allowed for the string.</param>
        <param name="lineBreakMode">The line-break mode to be used in the calculation.</param>
        <summary>Calculates the <see cref="T:System.Drawing.SizeF"/> of the specified string if it were rendered with the specified: font, size constraint, and line-break mode.</summary>
        <returns>Returns the <see cref="T:System.Drawing.SizeF"/> of the specified string if it were rendered with the specified: font, size constraint, and line-break mode.</returns>
        <remarks>
          <para>Application developers can use this method to calculate text metrics. It does not render or otherwise change state in the <see cref="T:MonoTouch.UIKit.UIView"/>.</para>
          <para>This method calculates the size that the <paramref name="str"/> would require if rendered with the <paramref name="font"/>, but if it the rendering were not allowed to exceed the dimensions of the <paramref name="constrainedToSize"/> <see cref="T:System.Drawing.SizeF"/>. This method calculates the size using the specified <paramref name="lineBreakMode"/> line-break mode. If the calculated size exceeds the available dimensions, the method will attempt to truncate the string internally and return a <see cref="T:System.Drawing.SizeF"/> based on that truncated text. If the <see cref="P:System.Drawing.SizeF.Height"/> of the <paramref name="constrainedToSize"/> argument is less than that of a single line of text in the specfied font, the method may return a <see cref="T:System.Drawing.SizeF"/> whose <see cref="P:System.Drawing.SizeF.Height"/> is greater than that in <paramref name="constrainedToSize"/>.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StringSize">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF StringSize (string str, MonoTouch.UIKit.UIFont font, float forWidth, MonoTouch.UIKit.UILineBreakMode breakMode);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF StringSize(string str, class MonoTouch.UIKit.UIFont font, float32 forWidth, valuetype MonoTouch.UIKit.UILineBreakMode breakMode) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String"/>
        <Parameter Name="font" Type="MonoTouch.UIKit.UIFont"/>
        <Parameter Name="forWidth" Type="System.Single"/>
        <Parameter Name="breakMode" Type="MonoTouch.UIKit.UILineBreakMode"/>
      </Parameters>
      <Docs>
        <param name="str">The string whose size is being calculated.</param>
        <param name="font">The font to be used in the size calculation.</param>
        <param name="forWidth">The maximum width to be used in the calculation.</param>
        <param name="lineBreakMode">The line-break mode to be used in the calculation.</param>
        <summary>Calculates the <see cref="T:System.Drawing.SizeF"/> of a single line of the specified string if it were rendered with the specified: font, width constraint, and line-break mode.</summary>
        <returns>Returns the <see cref="T:System.Drawing.SizeF"/> of the first line of the specified string if it were rendered with the specified: font, width constraint, and line-break mode.</returns>
        <remarks>
          <para>Application developers can use this method to calculate text metrics. It does not render or otherwise change state in the <see cref="T:MonoTouch.UIKit.UIView"/>.</para>
          <para>This method calculates the size that the first line of the <paramref name="str"/> would require if rendered with the <paramref name="font"/>, if the rendering were not allowed to exceed the width of  <paramref name="forWidth"/>. This method uses the specified <paramref name="lineBreakMode"/> line-break mode to truncate the string when it exceeds <paramref name="forWidth"/>. If the <see cref="P:System.Drawing.SizeF.Height"/> of the <paramref name="constrainedToSize"/> argument is less than that of a single line of text in the specfied font, the method may return a <see cref="T:System.Drawing.SizeF"/> whose <see cref="P:System.Drawing.SizeF.Height"/> is greater than that in <paramref name="constrainedToSize"/>.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StringSize">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF StringSize (string str, MonoTouch.UIKit.UIFont font, float minFontSize, ref float actualFontSize, float forWidth, MonoTouch.UIKit.UILineBreakMode lineBreakMode);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF StringSize(string str, class MonoTouch.UIKit.UIFont font, float32 minFontSize, float32 actualFontSize, float32 forWidth, valuetype MonoTouch.UIKit.UILineBreakMode lineBreakMode) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String"/>
        <Parameter Name="font" Type="MonoTouch.UIKit.UIFont"/>
        <Parameter Name="minFontSize" Type="System.Single"/>
        <Parameter Name="actualFontSize" Type="System.Single&amp;" RefType="ref"/>
        <Parameter Name="forWidth" Type="System.Single"/>
        <Parameter Name="lineBreakMode" Type="MonoTouch.UIKit.UILineBreakMode"/>
      </Parameters>
      <Docs>
        <param name="str">The string whose size is being calculated.</param>
        <param name="font">The font to be used in the size calculation.</param>
        <param name="forWidth">The maximum width to be used in the calculation.</param>
        <param name="lineBreakMode">The line-break mode to be used in the calculation.</param>
        <param name="minFontSize">The minimum size to which the font can be shrunk before resorting to text-truncation.</param>
        <param name="actualFontSize">An output reference parameter that holds the calculate font size.</param>
        <summary>Calculates the <see cref="T:System.Drawing.SizeF"/>  and size of the font of the first line of the specified string if it were rendered with the specified constraints.</summary>
        <returns>Returns the <see cref="T:System.Drawing.SizeF"/> of the first line of the specified string if it were rendered with the specified constraints. Assigns the calculated font size to <paramref name="actualFontSize"/>.</returns>
        <remarks>
          <para>Application developers can use this method to calculate text metrics. It does not render or otherwise change state in the <see cref="T:MonoTouch.UIKit.UIView"/>.</para>
          <para>This method calculates the size that the first line of the <paramref name="str"/> would require if rendered with the <paramref name="font"/>, if the font were allowed to shrink as necessary to fit in the width of  <paramref name="forWidth"/>. This method tries to use smaller font sizes to fit the entire text in a single line of width less than or equal to <paramref name="forWidth"/>. If, even with a font of <paramref name="minFontSize"/> size, the entire string cannot fit, the string is truncated using the <paramref name="lineBreakMode"/> line-break mode until it's rendered width is less than or equal to <paramref name="forWidth"/>. </para>
          <para>The reference parameter <paramref name="actualFontSize"/> is assigned the font size that is ultimately used by the calculation.</para>
          <para>The following example code shows the use of this method. The output is "Metrics are {Width=100, Height=15} with required font size of: 7.5."</para>
          <example>
            <code lang="C#">
              var v = new UIView();
              var str = "Hark! I hear the cannons roar!";
              var font = UIFont.FromName("Helvetica", 12);
              var minFontSize = 6;
              Single actualFontSize = 0;
              var forWidth = 100;
              var lineBreakMode = UILineBreakMode.WordWrap;
              var textSize = v.StringSize(str, font, minFontSize, ref actualFontSize, forWidth, lineBreakMode);
              Console.WriteLine("Metrics are {0} with required font size of: {1}", textSize, actualFontSize);
            </code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SubviewAdded">
      <MemberSignature Language="C#" Value="public virtual void SubviewAdded (MonoTouch.UIKit.UIView uiview);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SubviewAdded(class MonoTouch.UIKit.UIView uiview) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("didAddSubview:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uiview" Type="MonoTouch.UIKit.UIView"/>
      </Parameters>
      <Docs>
        <param name="uiview">
          <para>The view that was added as a subview.</para>
        </param>
        <summary>Tells the view when subviews are added.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Subviews">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIView[] Subviews { get; }"/>
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIView[] Subviews"/>
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("subviews", MonoTouch.ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIView[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An array of <see cref="T:MonoTouch.UIKit.UIView"/>s that are contained within <c>this</c> <see cref="T:MonoTouch.UIKit.UIView"/>.</summary>
        <value>The default value is an empty array.</value>
        <remarks>
          <para>
            This property defines the view hierarchy of a <see cref="T:MonoTouch.UIKit.UIView"/>. The complete view hierarchy includes the <see cref="T:MonoTouch.UIKit.UIView"/>'s <see cref="P:MonoTouch.UIKit.UIView.Superview"/> and the descendent <see cref="T:MonoTouch.UIKit.UIView"/>s that are <see cref="P:MonoTouch.UIKit.UIView.Subview"/>s of <see cref="P:MonoTouch.UIKit.UIView.Subview"/>s, but the methods for manipulating the hierarchy are focused on manipulating subviews (e.g., <see cref="M:MonoTouch.UIKit.UIView.AddSubview"/>, <see cref="M:MonoTouch.UIKit.UIView.InsertSubview"/>, etc.).
          </para>
          <para>The position of a <see cref="T:MonoTouch.UIKit.UIView"/> in the <see cref="P:MonoTouch.UIKit.UIView.Subviews"/> array determines that <see cref="T:MonoTouch.UIKit.UIView"/>'s z-order among the subviews. The <see cref="T:MonoTouch.UIKit.UIView"/> at index 0 is the rear-most view. <see cref="T:MonoTouch.UIKit.UIView"/>s can be initialized in a desired z-order by using <see cref="M:MonoTouch.UIKit.UIView.InsertSubviewAbove"/> and <see cref="M:MonoTouch.UIKit.UIView.InsertSubviewBelow"/>. <see cref="T:MonoTouch.UIKit.UIView"/>s can be brought forward or sent backward in z-order by using <see cref="M:MonoTouch.UIKit.UIView.ExchangeSubview"/>.</para>
          <para>Application developers should not manipulate or modify <see cref="P:MonoTouch.UIKit.UIView.Subviews"/> of framework-supplied <see cref="T:MonoTouch.UIKit.UIView"/>s, as they may change without notice in system updates.</para>
        </remarks>
        <altmember cref="P:Monotouch.UIKit.UIView.Superview"/>
      </Docs>
    </Member>
    <Member MemberName="Superview">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIView Superview { get; }"/>
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIView Superview"/>
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("superview")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The <see cref="T:MonoTouch.UIKit.UIView"/>, if any, that contains <c>this</c> <see cref="T:MonoTouch.UIKit.UIView"/> in its <see cref="P:MonoTouch.UIKit.UIView.Subviews"/>.</summary>
        <value>The default value is <see langword="null"/>.</value>
        <remarks>
          <para>This value may be <see langword="null"/>, indicating that the <see cref="T:MonoTouch.UIKit.UIView"/> is not contained within another <see cref="T:MonoTouch.UIKit.UIView"/>'s view hierarchy.</para>
        </remarks>
        <altmember cref="P:MonoTouch.UIKit.UIView.Subviews"/>
      </Docs>
    </Member>
    <Member MemberName="SystemLayoutSizeFittingSize">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.SizeF SystemLayoutSizeFittingSize (System.Drawing.SizeF size);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Drawing.SizeF SystemLayoutSizeFittingSize(valuetype System.Drawing.SizeF size) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("systemLayoutSizeFittingSize:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Drawing.SizeF"/>
      </Parameters>
      <Docs>
        <param name="size">This parameter should be <see cref="P:MonoTouch.UIKit.UIView.UILayoutFittingCompressedSize"/> to retrieve the smallest possible size or <see cref="P:MonoTouch.UIKit.UIView.UILayoutFittingExpandedSize"/> to retrieve the largest possible size</param>
        <summary>Calculates the smallest or largest size that this <see cref="T:MonoTouch.UIKit.UIView"/> can have that satisfies its Auto Layout constraints.</summary>
        <returns>Returns the smallest (if <paramref name="size"/> == <see cref="P:MonoTouch.UIKit.UIView.UILayoutFittingCompressedSize"/>) or largest (if <paramref name="size"/> == <see cref="P:MonoTouch.UIKit.UIView.UILayoutFittingExpandedSize"/>)<see cref="T:System.Drawing.SizeF"/> that satisfies the constraints that relate to this <see cref="T:MonoTouch.UIKit.UIView"/>.</returns>
        <remarks>
          <para>
            This method can calculate either the largest or the smallest size consistent with the Auto Layout constraints of <c>this</c> <see cref="T:MonoTouch.UIKit.UIView"/> and the constraints of its <see cref="P:MonoTouch.UIKit.UIView.Subviews"/>. This method may only be called with <paramref name="size"/> equal to one of the predefined <see cref="T:System.Drawing.SizeF"/>s <see cref="P:MonoTouch.UIKit.UIView.UILayoutFittingCompressedSize"/> or <see cref="P:MonoTouch.UIKit.UIView.UILayoutFittingExpandedSize"/>.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public virtual int Tag { get; set; }"/>
      <MemberSignature Language="ILAsm" Value=".property instance int32 Tag"/>
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("tag")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setTag:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An integer that can be used to identify a specific <see cref="T:MonoTouch.UIKit.UIView"/> instance.</summary>
        <value>The default value is 0.</value>
        <remarks>
          <para>The stability and uniqueness of this property is entirely the responsibility of the application developer.</para>
        </remarks>
        <altmember cref="M:MonoTouch.UIKit.UIView.ViewWithTag"/>
      </Docs>
    </Member>
    <Member MemberName="Transform">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.CoreGraphics.CGAffineTransform Transform { get; set; }"/>
      <MemberSignature Language="ILAsm" Value=".property instance valuetype MonoTouch.CoreGraphics.CGAffineTransform Transform"/>
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("transform")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setTransform:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.CoreGraphics.CGAffineTransform</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The transform of the <see cref="T:MonoTouch.UIKit.UIView"/>, relative to the center of its bounds.</summary>
        <value>The default value is the identity transform.</value>
        <remarks>
          <para>
            This property can be used to manipulate the <see cref="T:MonoTouch.CoreGraphics.CGAffineTransform"/> that is applied to the <see cref="T:MonoTouch.UIKit.UIView"/> prior to rendering. The <see cref="P:MonoTouch.UIKit.UIView.Transform"/> is applied to the center of the <see cref="T:MonoTouch.UIKit.UIView"/>'s <see cref="P:MonoTouch.UIKit.UIView.Bounds"/>. 
          </para>
          <para>
            The transform is applied prior to Auto Layout constraints being applied. For instance, the following code shows constraints that, with default transforms, lay out three equally sized subviews with 30-pixel vertical spacing. A scaling transform is applied to the green view and a rotational transform to the yellow. The following image shows the result: the transforms are applied and then the Auto Layout constraints are resolved. The result is that the views are resized such that their width and height match the constraints. This effectively overrides the scaling transform on the green view while rotating and scaling the yellow view such that it's alignment rectangle satisfies the constraints.
          </para>
          <example>
            <code lang="C#">
              mainView.AddConstraints(NSLayoutConstraint.FromVisualFormat("H:|-[blue]-|", 0, new NSDictionary(), viewsDictionary));
              mainView.AddConstraints(NSLayoutConstraint.FromVisualFormat("V:|-[blue]-(==30)-[green(==blue)]-(==30)-[yellow(==blue)]-|", 0, new NSDictionary(), viewsDictionary));
              mainView.AddConstraints(NSLayoutConstraint.FromVisualFormat("|-[green(==blue)]-|", 0, new NSDictionary(), viewsDictionary));
              mainView.AddConstraints(NSLayoutConstraint.FromVisualFormat("|-[yellow(==blue)]-|", 0, new NSDictionary(), viewsDictionary));
              
              greenView.Transform = CGAffineTransform.MakeScale(2F, 2F);
              yellowView.Transform = CGAffineTransform.MakeRotation((float)(Math.PI / 10));		
            </code>
          </example>
          <para>
            <img href="MonoTouch.UIKit.View.Transform.png"/>
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transition">
      <MemberSignature Language="C#" Value="public static void Transition (MonoTouch.UIKit.UIView fromView, MonoTouch.UIKit.UIView toView, double duration, MonoTouch.UIKit.UIViewAnimationOptions options, MonoTouch.Foundation.NSAction completion);"/>
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Transition(class MonoTouch.UIKit.UIView fromView, class MonoTouch.UIKit.UIView toView, float64 duration, valuetype MonoTouch.UIKit.UIViewAnimationOptions options, class MonoTouch.Foundation.NSAction completion) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromView" Type="MonoTouch.UIKit.UIView"/>
        <Parameter Name="toView" Type="MonoTouch.UIKit.UIView"/>
        <Parameter Name="duration" Type="System.Double"/>
        <Parameter Name="options" Type="MonoTouch.UIKit.UIViewAnimationOptions"/>
        <Parameter Name="completion" Type="MonoTouch.Foundation.NSAction"/>
      </Parameters>
      <Docs>
        <param name="fromView">The initial view.</param>
        <param name="toView">The final view.</param>
        <param name="duration">The duration, in seconds, of the animation.</param>
        <param name="options">A mask of options to be used with the animation.</param>
        <param name="completion">An <see cref="T:MonoTouch.Foundation.NSAction"/> to be executed at the end of the animation. This parameter may be <see langword="null"/>.</param>
        <summary>Specifies a transition animation to be used between the specified <see cref="T:MonoTouch.UIKit.UIView"/>s.</summary>
        <remarks>
          <para>Application developers should prefer to use the method <see cref="M:MonoTouch.UIKit.UIView.TransitionNotify"/>, whose behavior is identical, but which has a <see cref="T:MonoTouch.UIKit.UICompletionHandler"/> instead of an <see cref="T:MonoTouch.Foundation.NSAction"/> for its completion hander. The <see cref="T:MonoTouch.UIKit.UIKit.UICompletionHandler"/> receives a parameter indicating whether the animation completed successfully or not.</para>
          <para>This static method provides an animation that shows the transition from <paramref name="fromView"/> to <paramref name="toView"/>.</para>
          <para>If <paramref name="duration"/> is less than or equal to 0, no animation is displayed, but <paramref name="completion"/> is executed.</para>
          <para> If <paramref name="options"/> does not include <see cref="P:MonoTouch.UIKit.UIViewAnimationOptions.ShowHideTransitionViews"/>, <paramref name="fromView"/> is removed from it's <see cref="P:MonoTouch.UIKit.UIView.Superview"/>'s view hierarchy and <paramref name="toView"/> is inserted into that <see cref="T:MonoTouch.UIKit.UIView"/>'s <see cref="P:MonoTouch.UIKit.UIView.Subviews"/>. If <paramref name="options"/> includes <see cref="P:MonoTouch.UIKit.UIViewAnimationOptions.ShowHideTransitionViews"/>, <paramref name="toView"/> and <paramref name="fromView"/> are not removed and added to the view hierarchy of <paramref name="toView"/>'s <see cref="P:MonoTouch.UIKit.UIView.Superview"/>, but instead <paramref name="fromView"/> is hidden and <paramref name="toView"/> is shown (both must have the same <see cref="P:MonoTouch.UIKit.UIView.Superview"/>.)</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transition">
      <MemberSignature Language="C#" Value="public static void Transition (MonoTouch.UIKit.UIView withView, double duration, MonoTouch.UIKit.UIViewAnimationOptions options, MonoTouch.Foundation.NSAction animation, MonoTouch.Foundation.NSAction completion);"/>
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Transition(class MonoTouch.UIKit.UIView withView, float64 duration, valuetype MonoTouch.UIKit.UIViewAnimationOptions options, class MonoTouch.Foundation.NSAction animation, class MonoTouch.Foundation.NSAction completion) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="withView" Type="MonoTouch.UIKit.UIView"/>
        <Parameter Name="duration" Type="System.Double"/>
        <Parameter Name="options" Type="MonoTouch.UIKit.UIViewAnimationOptions"/>
        <Parameter Name="animation" Type="MonoTouch.Foundation.NSAction"/>
        <Parameter Name="completion" Type="MonoTouch.Foundation.NSAction"/>
      </Parameters>
      <Docs>
        <param name="withView">The <see cref="T:MonoTouch.UIKit.UIView"/> whose state is being manipulated and in which the animation should occur.</param>
        <param name="duration">The duration of the animation in seconds.</param>
        <param name="options">A mask of options to be used with the animation.</param>
        <param name="animation">An <see cref="T:MonoTouch.Foundation.NSAction"/> containing the animation and state manipulation of the <paramref name="withView"/>.</param>
        <param name="completion">An <see cref="T:MonoTouch.Foundation.NSAction"/> to be executed at the end of the animation. This parameter may be <see langword="null"/>.</param>
        <summary>Specifies a transition animation on the specified collection view.</summary>
        <remarks>
          <para>Application developers should prefer to use the method <see cref="M:MonoTouch.UIKit.UIView.TransitionNotify"/>, whose behavior is identical, but which has a <see cref="T:MonoTouch.UIKit.UICompletionHandler"/> instead of an <see cref="T:MonoTouch.Foundation.NSAction"/> for its completion hander. The <see cref="T:MonoTouch.UIKit.UIKit.UICompletionHandler"/> receives a parameter indicating whether the animation completed successfully or not.</para>
          <para>This static method specifies an animation within the <paramref name="withView"/> container <see cref="T:MonoTouch.UIKit.UIView"/>.</para>
          <para>If duration is less than or equal to 0, no animation is displayed, but both <paramref name="animation"/> and <paramref name="completion"/> are executed.</para>
          <para>The <paramref name="animation"/> action may animate addition, removal, showing, or hiding subviews. If other animations are desired, the application developer must include <see cref="P:MonoTouch.UIKit.UIViewAnimationOptions.AllowAnimatedContent"/> in the <paramref name="options"/>.</para>
          <para>During animation, user interactions are disabled for the animated <see cref="T:MonoTouch.UIKit.UIView"/>s. To enable interaction during the animation, the application developer must set <see cref="P:MonoTouchUIKit.UIViewANimationAoptions.AllowUserInteraction"/> in <paramref name="options"/>.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TransitionNotify">
      <MemberSignature Language="C#" Value="public static void TransitionNotify (MonoTouch.UIKit.UIView fromView, MonoTouch.UIKit.UIView toView, double duration, MonoTouch.UIKit.UIViewAnimationOptions options, MonoTouch.UIKit.UICompletionHandler completion);"/>
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TransitionNotify(class MonoTouch.UIKit.UIView fromView, class MonoTouch.UIKit.UIView toView, float64 duration, valuetype MonoTouch.UIKit.UIViewAnimationOptions options, class MonoTouch.UIKit.UICompletionHandler completion) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("transitionFromView:toView:duration:options:completion:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromView" Type="MonoTouch.UIKit.UIView"/>
        <Parameter Name="toView" Type="MonoTouch.UIKit.UIView"/>
        <Parameter Name="duration" Type="System.Double"/>
        <Parameter Name="options" Type="MonoTouch.UIKit.UIViewAnimationOptions"/>
        <Parameter Name="completion" Type="MonoTouch.UIKit.UICompletionHandler"/>
      </Parameters>
      <Docs>
        <param name="fromView">The initial view.</param>
        <param name="toView">The final view.</param>
        <param name="duration">The duration, in seconds, of the animation.</param>
        <param name="options">A mask of options to be used with the animation.</param>
        <param name="completion">
          <para>An <see cref="T:MonoTouch.UIKit.UICompletionHandler"/> to be executed at the end of the animation. This parameter may be <see langword="null"/>.</para>
          <para tool="nullallowed">This parameter can be <see langword="null"/>.</para>
        </param>
        <summary>Specifies a transition animation to be used between the specified <see cref="T:MonoTouch.UIKit.UIView"/>s.</summary>
        <remarks>
          <para>This static method provides an animation that shows the transition from <paramref name="fromView"/> to <paramref name="toView"/>.</para>
          <para>If <paramref name="duration"/> is less than or equal to 0, no animation is displayed, but <paramref name="completion"/> is executed.</para>
          <para> If <paramref name="options"/> does not include <see cref="P:MonoTouch.UIKit.UIViewAnimationOptions.ShowHideTransitionViews"/>, <paramref name="fromView"/> is removed from it's <see cref="P:MonoTouch.UIKit.UIView.Superview"/>'s view hierarchy and <paramref name="toView"/> is inserted into that <see cref="T:MonoTouch.UIKit.UIView"/>'s <see cref="P:MonoTouch.UIKit.UIView.Subviews"/>. If <paramref name="options"/> includes <see cref="P:MonoTouch.UIKit.UIViewAnimationOptions.ShowHideTransitionViews"/>, <paramref name="toView"/> and <paramref name="fromView"/> are not removed and added to the view hierarchy of <paramref name="toView"/>'s <see cref="P:MonoTouch.UIKit.UIView.Superview"/>, but instead <paramref name="fromView"/> is hidden and <paramref name="toView"/> is shown (both must have the same <see cref="P:MonoTouch.UIKit.UIView.Superview"/>.)</para>
          <para>The <paramref name="completion"/> <see cref="T:MonoTouch.UIKit.UICompletionHandler"/> receives a <see langword="bool"/> parameter that is <see langword="true"/> if the animation completed successfully and <see langword="false"/> otherwise.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TransitionNotify">
      <MemberSignature Language="C#" Value="public static void TransitionNotify (MonoTouch.UIKit.UIView withView, double duration, MonoTouch.UIKit.UIViewAnimationOptions options, MonoTouch.Foundation.NSAction animation, MonoTouch.UIKit.UICompletionHandler completion);"/>
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TransitionNotify(class MonoTouch.UIKit.UIView withView, float64 duration, valuetype MonoTouch.UIKit.UIViewAnimationOptions options, class MonoTouch.Foundation.NSAction animation, class MonoTouch.UIKit.UICompletionHandler completion) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("transitionWithView:duration:options:animations:completion:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="withView" Type="MonoTouch.UIKit.UIView"/>
        <Parameter Name="duration" Type="System.Double"/>
        <Parameter Name="options" Type="MonoTouch.UIKit.UIViewAnimationOptions"/>
        <Parameter Name="animation" Type="MonoTouch.Foundation.NSAction"/>
        <Parameter Name="completion" Type="MonoTouch.UIKit.UICompletionHandler"/>
      </Parameters>
      <Docs>
        <param name="withView">The <see cref="T:MonoTouch.UIKit.UIView"/> whose state is being manipulated and in which the animation should occur.</param>
        <param name="duration">The duration of the animation in seconds.</param>
        <param name="options">A mask of options to be used with the animation.</param>
        <param name="animation">An <see cref="T:MonoTouch.Foundation.NSAction"/> containing the animation and state manipulation of the <paramref name="withView"/>.</param>
        <param name="completion">
          <para>The method to invoke when the transition completes.</para>
          <para tool="nullallowed">This parameter can be <see langword="null"/>.</para>
        </param>
        <summary>Specifies a transition animation on the specified collection view.</summary>
        <remarks>
          <para>This static method specifies an animation within the <paramref name="withView"/> container <see cref="T:MonoTouch.UIKit.UIView"/>.</para>
          <para>If duration is less than or equal to 0, no animation is displayed, but both <paramref name="animation"/> and <paramref name="completion"/> are executed.</para>
          <para>The <paramref name="animation"/> action may animate addition, removal, showing, or hiding subviews. If other animations are desired, the application developer must include <see cref="P:MonoTouch.UIKit.UIViewAnimationOptions.AllowAnimatedContent"/> in the <paramref name="options"/>.</para>
          <para>During animation, user interactions are disabled for the animated <see cref="T:MonoTouch.UIKit.UIView"/>s. To enable interaction during the animation, the application developer must set <see cref="P:MonoTouchUIKit.UIViewANimationAoptions.AllowUserInteraction"/> in <paramref name="options"/>.</para>
          <para>The <paramref name="completion"/> <see cref="T:MonoTouch.UIKit.UICompletionHandler"/> receives a <see langword="bool"/> parameter that is <see langword="true"/> if the animation completed successfully and <see langword="false"/> otherwise.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TranslatesAutoresizingMaskIntoConstraints">
      <MemberSignature Language="C#" Value="public virtual bool TranslatesAutoresizingMaskIntoConstraints { get; set; }"/>
      <MemberSignature Language="ILAsm" Value=".property instance bool TranslatesAutoresizingMaskIntoConstraints"/>
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("translatesAutoresizingMaskIntoConstraints")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setTranslatesAutoresizingMaskIntoConstraints:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies whether the autoresizing mask should be translated into constraints for Auto Layout.</summary>
        <value>The default value is <see langword="true"/>.</value>
        <remarks>
          <para>If this property is <see langword="true"/>, this <see cref="T:MonoTouch.UIKit.UIView"/>'s <see cref="P:MonoTouch.UIKit.UIView.Superview"/> will convert this <see cref="T:MonoTouch.UIKit.UIView"/>'s <see cref="P:MonoTouch.UIKit.UIView.AutoresizingMask"/> into <see cref="T:MonoTouch.UIKit.NSLayoutConstraint"/>s and include them in the <see cref="P:MonoTouch.UIKit.UIView.Superview"/>'s <see cref="P:MonoTouch.UIKit.UIView.Constraints"/>.</para>
          <para>If the application developer is using Auto Layout, setting this property to <see langword="false"/> will often provide a clearer starting point for programmatically specifying constraints.</para>
          <para>In an over-constrained Auto Layout, the appearance of <c>NSAutoresizingMaskLayoutConstraint</c> in the Auto Layout debugging information is often an indication that the Application Developer has inappropriately left this property as <see langword="true"/> somewhere.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UILayoutFittingCompressedSize">
      <MemberSignature Language="C#" Value="public static System.Drawing.SizeF UILayoutFittingCompressedSize { get; }"/>
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Drawing.SizeF UILayoutFittingCompressedSize"/>
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UILayoutFittingCompressedSize</summary>
        <value>
        </value>
        <remarks>Indicates that <see cref="M:MonoTouch.UIKit.UIView.SystemLayoutFittingSize"/> should calculate the smallest possible size.</remarks>
        <altmember cref="M:MonoTouch.UIKit.UIView.SystemLayoutFittingSize"/>
      </Docs>
    </Member>
    <Member MemberName="UILayoutFittingExpandedSize">
      <MemberSignature Language="C#" Value="public static System.Drawing.SizeF UILayoutFittingExpandedSize { get; }"/>
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Drawing.SizeF UILayoutFittingExpandedSize"/>
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UILayoutFittingExpandedSize</summary>
        <value>
        </value>
        <remarks>Indicates that <see cref="M:MonoTouch.UIKit.UIView.SystemLayoutFittingSize"/> should calculate the largest possible size.</remarks>
        <altmember cref="M:MonoTouch.UIKit.UIView.SystemLayoutFittingSize"/>
      </Docs>
    </Member>
    <Member MemberName="UpdateConstraints">
      <MemberSignature Language="C#" Value="public virtual void UpdateConstraints ();"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UpdateConstraints() cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("updateConstraints")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters/>
      <Docs>
        <summary>Updates the Auto Layout constraints for the <see cref="T:MonoTouch.UIKit.UIView"/>.</summary>
        <remarks>
          <para>Application developers may override this method in order to create and update custom constraints for use with Auto Layout.</para>
          <para>The Auto Layout system calls this method prior to layout. The <see cref="T:MonoTouch.UIKit.UIView"/>'s properties will be in a stable state when this method is called and application developers should be able to establish valid constraints.</para>
          <para>Application developers may add or remove constraints in this method. If they do so, they must call <see cref="M:MonoTouch.UIKit.UIView.SetNeedsUpdateConstraints"/> to notify the Auto Layout system that further updating is required.</para>
          <para>Application developers must not invalidate existing <see cref="T:MonoTouch.UIKit.NSLayoutConstraint"/>s during this method. Applications developers must not perform drawing actions or invoke layout recalculation during this method.</para>
          <para>Application developers must call <c>base.UpdateConstraints()</c> in their implementations of this method.</para>
        </remarks>
        <altmember cref="M:MonoTouch.UIKit.UIView.UpdateConstraintsIfNeeded"/>
      </Docs>
    </Member>
    <Member MemberName="UpdateConstraintsIfNeeded">
      <MemberSignature Language="C#" Value="public virtual void UpdateConstraintsIfNeeded ();"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UpdateConstraintsIfNeeded() cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("updateConstraintsIfNeeded")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters/>
      <Docs>
        <summary>Updates the constraints of the <see cref="T:MonoTouch.UIKit.UIView"/> and its <see cref="P:MonoTouch.UIKit.UIView.Subviews"/>.</summary>
        <remarks>
          <para>Application developers should not overide this method.</para>
          <para>This method is called by the Auto Layout system during layout. Application developers may invoke it to ensure that constraints are current.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserInteractionEnabled">
      <MemberSignature Language="C#" Value="public virtual bool UserInteractionEnabled { get; set; }"/>
      <MemberSignature Language="ILAsm" Value=".property instance bool UserInteractionEnabled"/>
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("isUserInteractionEnabled")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setUserInteractionEnabled:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determines whether input events are processed by this view.</summary>
        <value>
        </value>
        <remarks>
          <para>
            
            This property is used to control whether input events are
            delivered to the view.  By default all views receive
            events.  
            
          </para>
          <para>
            
            During animations, UIKit will disable event delivery to
            your view unless you pass the <see cref="E:MonoTouch.UIKit.UIViewAnimationOptions"/>.AllowUserInteraction
            flag to your animation function.
            
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewForBaselineLayout">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIView ViewForBaselineLayout { get; }"/>
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIView ViewForBaselineLayout"/>
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("viewForBaselineLayout")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns the <see cref="T:MonoTouch.UIKit.UIView"/> upon which baseline constraints should be applied.</summary>
        <value>The default value is <c>this</c> <see cref="T:MonoTouch.UIKit.UIView"/>.</value>
        <remarks>
          <para>Returns the <see cref="T:MonoTouch.UIKit.UIView"/> for which constraints relating to <see cref="F:MonoTouch.UIKit.NSLayoutAttribute.Baseline"/> should apply. The baseline for many <see cref="T:MonoTouch.UIKit.UIView"/>s is the bottom of the view but in a <see cref="T:MonoTouch.UIKit.UILabel"/>, for instance, the baseline should be the position of the text baseline.</para>
          <para>The returned value must be either <c>this</c> or a view in <c>this</c>'s subview hierarchy.</para>
        </remarks>
        <altmember cref="M:MonoTouch.UIKit.UIView.AlignmentRectForFrame"/>
        <altmember cref="M:MonoTouch.UIKit.UIView.FrameForAlignmentRect"/>
        <altmember cref="M:MonoTouch.UIKit.UIView.AlignmentRectInsets"/>
      </Docs>
    </Member>
    <Member MemberName="ViewPrintFormatter">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIViewPrintFormatter ViewPrintFormatter { get; }"/>
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIViewPrintFormatter ViewPrintFormatter"/>
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(4, 2)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("viewPrintFormatter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIViewPrintFormatter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns a <see cref="T:MonoTouch.UIKit.UIViewPrintFormatter"/> appropriate for the <see cref="T:MonoTouch.UIKit.UIView"/>.</summary>
        <value>This method may return <see langword="null"/> if an appropriate <see cref="T:MonoTouch.UIKit.UIViewPrintFormatter"/> could not be created.</value>
        <remarks>
          <para>This method produces a t<see cref="T:MonoTouch.UIKit.UIViewPrintFormatter"/> that can be configured with the page layout options desired by the application.</para>
          <para>Every time this method is called, it creates a new <see cref="T:MonoTouch.UIKit.UIViewPrintFormatter"/>.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewWithTag">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIView ViewWithTag (int tag);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class MonoTouch.UIKit.UIView ViewWithTag(int32 tag) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("viewWithTag:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIView</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tag" Type="System.Int32"/>
      </Parameters>
      <Docs>
        <param name="tag">
          <para>The identifier being searched for.</para>
        </param>
        <summary>Returns the <see cref="T:MonoTouch.UIKit.UIView"/> identified by the <paramref name="tag"/>. May return <see langword="null"/>.</summary>
        <returns>
          <para>The view in the view hierarchy whose <see cref="P:MonoTouch.UIKit.UIView.Tag"/> is equal to <paramref name="tag"/>.</para>
        </returns>
        <remarks>
          <para>This method searches the current <see cref="T:MonoTouch.UIKit.UIView"/>'s view hierarchy (i.e., <c>this</c>, it's <see cref="P:MonoTouch.UIKit.UIView.Subviews"/> and their descendants) and returns the <see cref="T:MonoTouch.UIKit.UIView"/>, if any, whose <see cref="P:MonoTouch.UIKit.UIView.Tag"/> property is equal to the <paramref name="tag"/> parameter. If no such <see cref="T:MonoTouch.UIKit.UIView"/> exists, this method returns <see langword="null"/>.</para>
        </remarks>
        <altmember cref="P:MonoTouch.UIKit.UIView.Tag"/>
      </Docs>
    </Member>
    <Member MemberName="WillMoveToSuperview">
      <MemberSignature Language="C#" Value="public virtual void WillMoveToSuperview (MonoTouch.UIKit.UIView newsuper);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WillMoveToSuperview(class MonoTouch.UIKit.UIView newsuper) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("willMoveToSuperview:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newsuper" Type="MonoTouch.UIKit.UIView"/>
      </Parameters>
      <Docs>
        <param name="newsuper">
          <para>The <see cref="T:MonoTouch.UIKit.UIView"/> to which <c>this</c> <see cref="T:MonoTouch.UIKit.UIView"/> is being moved.</para>
          <para tool="nullallowed">This parameter can be <see langword="null"/>.</para>
        </param>
        <summary>Called before the <see cref="P:MonoTouch.UIKit.UIView.Superview"/> changes.</summary>
        <remarks>
          <para>This method is called by the runtime when assigning the <see cref="P:MonoTouch.UIKit.UIView.Superview"/> property and is invoked shortly before the change is made.</para>
          <para>By default, this method does nothing. Application developers can override the method in order to perform additional processing.</para>
        </remarks>
        <altmember cref="M:MonoTouch.UIKit.UIView.MovedToSuperview"/>
      </Docs>
    </Member>
    <Member MemberName="WillMoveToWindow">
      <MemberSignature Language="C#" Value="public virtual void WillMoveToWindow (MonoTouch.UIKit.UIWindow window);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WillMoveToWindow(class MonoTouch.UIKit.UIWindow window) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("willMoveToWindow:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="window" Type="MonoTouch.UIKit.UIWindow"/>
      </Parameters>
      <Docs>
        <param name="window">
          <para>Called before the window at the root of the <see cref="T:MonoTouch.UIKit.UIView"/>'s view hierarchy changes.</para>
          <para tool="nullallowed">This parameter can be <see langword="null"/>.</para>
        </param>
        <summary>
          <para>This method is called by the runtime when assigning a new <see cref="T:MonoTouch.UIKit.UIWindow"/> to the <see cref="T:MonoTouch.UIKit.UIView"/>'s view hierarcy. This method will be called on all <see cref="T:MonoTouch.UIKit.UIView"/>s in the hierarchy, not just the top-level <see cref="T:MonoTouch.UIKit.UIView"/>. </para>
          <para>By default, this method does nothing. Application developers can override the method in order to perform additional processing.</para>
        </summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WillRemoveSubview">
      <MemberSignature Language="C#" Value="public virtual void WillRemoveSubview (MonoTouch.UIKit.UIView uiview);"/>
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WillRemoveSubview(class MonoTouch.UIKit.UIView uiview) cil managed"/>
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("willRemoveSubview:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uiview" Type="MonoTouch.UIKit.UIView"/>
      </Parameters>
      <Docs>
        <param name="uiview">
          <para>The subview that will be removed.</para>
        </param>
        <summary>Called prior to the removal of a subview.</summary>
        <remarks>
          <para>This method is called by the runtime when a <see cref="T:MonoTouch.UIKit.UIView"/> is removed from the <see cref="P:MonoTouch.UIKit.UIView.Subviews"/> array. </para>
          <para>By default, this method does nothing. Application developers can override the method in order to perform additional processing.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Window">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIWindow Window { get; }"/>
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIWindow Window"/>
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("window")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIWindow</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The <see cref="T:MonoTouch.UIKit.UIWindow"/> of the <see cref="T:MonoTouch.UIKit.UIView"/>.</summary>
        <value>The default value is <see langword="null"/>.</value>
        <remarks/>
      </Docs>
    </Member>
  </Members>
</Type>
