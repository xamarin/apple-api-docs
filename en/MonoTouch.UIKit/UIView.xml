<Type Name="UIView" FullName="MonoTouch.UIKit.UIView">
  <TypeSignature Language="C#" Value="public class UIView : MonoTouch.UIKit.UIResponder, IDisposable, MonoTouch.Foundation.INSCoding, MonoTouch.UIKit.IUIAccessibilityIdentification, MonoTouch.UIKit.IUICoordinateSpace, MonoTouch.UIKit.IUIDynamicItem, MonoTouch.UIKit.IUITraitEnvironment, System.Collections.IEnumerable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit UIView extends MonoTouch.UIKit.UIResponder implements class MonoTouch.Foundation.INSCoding, class MonoTouch.ObjCRuntime.INativeObject, class MonoTouch.UIKit.IUIAccessibilityIdentification, class MonoTouch.UIKit.IUICoordinateSpace, class MonoTouch.UIKit.IUIDynamicItem, class MonoTouch.UIKit.IUITraitEnvironment, class System.Collections.IEnumerable, class System.IDisposable" />
  <AssemblyInfo apistyle="classic">
    <AssemblyName>monotouch</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo apistyle="unified">
    <AssemblyName>Xamarin.iOS</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>MonoTouch.UIKit.UIResponder</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>MonoTouch.Foundation.INSCoding</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>MonoTouch.UIKit.IUIAccessibilityIdentification</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>MonoTouch.UIKit.IUICoordinateSpace</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>MonoTouch.UIKit.IUIDynamicItem</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>MonoTouch.UIKit.IUITraitEnvironment</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>MonoTouch.Foundation.Register("UIView", true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Base class used for components that want to render themselves and respond to events.</summary>
    <remarks>
      <para>
        The UIView class is a rectangular area on the screen that is
        responsible for displaying content and handling user interactions
        with that content. It can also contain other views, allowing you to
        create complex interactive controls.  UIView can thus be used as
        either a standalone control, or a full screen of content built from
        many other independent UIViews. 
      </para>
      <para>Views have three major responsibilities:</para>
      <list type="bullet">
        <item>
          <term>
            Visualization: UIView instances are responsible for displaying
            their content, typically this is done by implementing a draw
            method using either <see cref="N:MonoTouch.CoreGraphics" />,
            OpenGL or customizing some of their visual properties.  Views 
            also have built-in support for animating elements of the view.  
          </term>
        </item>
        <item>
          <term>
            Managing Layout and Subviews: UIViews are responsible for
            managing their layout in response to changes in size and
            orientation. This includes re-drawing any content they manage,
            as well as repositioning children views. This is most often in
            response to size of the UIView. For instance, if a view
            represents a button, the location of corners would change
            according to size. Or, if the device was rotated, the view might
            get resized (or it might resize it's child views).
          </term>
        </item>
        <item>
          <term>
            
            Event Handling: UIViews are a natural place to handle touch
            events since they are self-contained user interface elements.
            UIViews subclass the <see cref="T:MonoTouch.UIKit.UIResponder" />
            class, so they participate both on system events (like motion
            and actions) as well as being able to process touch events.
            
          </term>
        </item>
      </list>
      <format type="text/html">
        <h2>Event Handling</h2>
      </format>
      <para>
        UIViews can handle touch events in two ways.  You can use the
        high-level gesture recognizer API to detect and handle gestures, or
        you can roll your own event handling by using the low-level
        interface that provides detailed touch events as they happen: every
        time a finger touches the screen or is lifted as well as motion of
        those fingers.  Both are covered below
      </para>
      <para>
        When your UIView wants to respond to user input by updating its
        display, it should call the
        <see cref="M:MonoTouch.UIKit.UIView.SetNeedsDisplay" /> or
        <see cref="M:MonoTouch.UIKit.UIView.SetNeedsDisplayInRect(System.Drawing.RectangleF)" /> which will queue a call to your
        <see cref="M:MonoTouch.UIKit.UIView.Draw(System.Drawing.RectangleF)" /> method
        where you would re-render your control with the new state.
      </para>
      <para>
        Event delivery can be turned off either by setting the
        <see cref="P:MonoTouch.UIKit.UIView.UserInteractionEnabled" /> to false or you can
        disable them temporarily at the application level by calling
        <see cref="M:MonoTouch.UIKit.UIApplication.BeginIgnoringInteractionEvents" />.  In
        both cases, events destined for the view are dropped and are not
        delivered to the views.
      </para>
      <para>
        Events are disabled while animation are playing back.  You can
        change this behavior when using explicit animations by using the
        <see cref="T:MonoTouch.UIKit.UIViewAnimationOptions" />'s AllowUserInteraction
        flag in your animation.
      </para>
      <format type="text/html">
        <h3>Event Handling with Gesture Recognizers</h3>
      </format>
      <para>
        Interacting with touch interfaces has lead to a series of common
        gesture idioms that are used everywhere.  Gestures like swiping,
        panning, long-presses, pinching rotating and tapping.  iOS makes the
        process of detecting these common gesture idioms very easy by
        providing Gesture Recognizers.  These are objects that inherit from
        the UIGestureRecognizer class and can detect various standard
        gesture idioms.  The built-in recognizers include:
      </para>
      <list type="bullet">
        <item>
          <term>
            <see cref="T:MonoTouch.UIKit.UILongPressGestureRecognizer" />
          </term>
        </item>
        <item>
          <term>
            <see cref="T:MonoTouch.UIKit.UIPanGestureRecognizer" />
          </term>
        </item>
        <item>
          <term>
            <see cref="T:MonoTouch.UIKit.UIPinchGestureRecognizer" />
          </term>
        </item>
        <item>
          <term>
            <see cref="T:MonoTouch.UIKit.UIRotationGestureRecognizer" />
          </term>
        </item>
        <item>
          <term>
            <see cref="T:MonoTouch.UIKit.UISwipeGestureRecognizer" />
          </term>
        </item>
        <item>
          <term>
            <see cref="T:MonoTouch.UIKit.UITapGestureRecognizer" />
          </term>
        </item>
      </list>
      <para>
        In addition, you can create your own custom gesture recognizer by
        subclassing <see cref="T:MonoTouch.UIKit.UIGestureRecognizer" />.
      </para>
      <para>
        To use the recognizer, you need to create an instance of the
        specific kind of recognizer that you need, optionally set some
        parameters and then you add it to the view by calling
        AddGestureRecognizer.  It is possible to attach multiple gesture
        recognizers to a single view.
      </para>
      <para>
        For example, the following code create a gesture recognizer that
        detects a panning gesture and assigns it to myView:
        
      </para>
      <example>
        <code lang="C#"><![CDATA[
var recognizer = new UIPanGestureRecognizer ((g) => {
  Console.WriteLine ("Panning detected");
  Console.WriteLine ("Gesture recognizer state: {0}", g.State);
});

myView.AddGestureRecognizer (recognizer);
        ]]></code>
      </example>
      <para>
        The parameter passed to your lambda (in this case the "g" parameter)
        is an instance of the gesture recognizer that detected the gesture.
        You can query the parameters of the recognized query by looking at
        the properties in the recognizer, the
        <see cref="P:MonoTouch.UIKit.UIGestureRecognizer.State" /> property contains the
        recognizer state.
        
      </para>
      <format type="text/html">
        <h3>Event Handling with method Overrides</h3>
      </format>
      <para>
        Although Gesture Recognizers provide a high-level and convenient way
        of capturing many touch events, they do not cover every
        possibility. For those cases, developers should subclass UIView and
        override one or more of the following methods inherited from
        UIResponder:
      </para>
      <list type="bullet">
        <item>
          <term>
            <see cref="M:MonoTouch.UIKit.UIResponder.TouchesBegan(MonoTouch.Foundation.NSSet,MonoTouch.UIKit.UIEvent)" />:
            sent when one or more fingers touch the screen.
          </term>
        </item>
        <item>
          <term>
            <see cref="M:MonoTouch.UIKit.UIResponder.TouchesMoved(MonoTouch.Foundation.NSSet,MonoTouch.UIKit.UIEvent)" />:
            sent when one or more fingers move.
          </term>
        </item>
        <item>
          <term>
            <see cref="M:MonoTouch.UIKit.UIResponder.TouchesEnded(MonoTouch.Foundation.NSSet,MonoTouch.UIKit.UIEvent)" />:
            sent when one or more fingers are lifted from the screen.
          </term>
        </item>
        <item>
          <term>
            <see cref="M:MonoTouch.UIKit.UIResponder.TouchesCancelled(MonoTouch.Foundation.NSSet,MonoTouch.UIKit.UIEvent)" />:
            sent when the touch is cancelled by the system (for example if
            the phone interrupts your application).
          </term>
        </item>
      </list>
      <para>
        UIViews by default only handle a single touch event at once.  If you
        want your view to handle multiple touches, you must set the
        <see cref="P:MonoTouch.UIKit.UIView.MultipleTouchEnabled" /> to true.
      </para>
      <para>
        
        iOS creates a T:MonoTouch.UIKit.UIEvent object any time a finger
        touches the screen, moves or is removed from the screen.  The <see cref="T:MonoTouch.UIKit.UIEvent" /> encapsulates all of the touches
        that are taking place on the screen at this point, even those that
        do not belong to this view.  In addition to the <see cref="T:MonoTouch.UIKit.UIEvent" />, there is an <see cref="T:MonoTouch.Foundation.NSSet" /> containing <see cref="T:MonoTouch.UIKit.UITouch" /> objects that represent the state
        of each finger on the screen for this particular view.
      </para>
      <para>
        
        If your application handles touches directly, you might want to
        override the <see cref="M:MonoTouch.UIKit.UIView.GestureRecognizerShouldBegin(MonoTouch.UIKit.UIGestureRecognizer)" />
        method to control whether an associated
        <see cref="T:MonoTouch.UIKit.UIGestureRecognizer" /> should execute or not.
        
      </para>
      <format type="text/html">
        <h2>Creating Views</h2>
      </format>
      <para>
        UIViews are typically created by invoking the constructor that takes
        a frame as its parameter (the frame is of type
        <see cref="T:System.Drawing.RectangleF" />), for example:
      </para>
      <example>
        <code lang="C#"><![CDATA[
var myView = new UIView (new RectangleF (0, 0, 100, 100));
]]></code>
      </example>
      <para>
        Most subclasses of UIView will provide a constructor that takes the
        initial frame, just like UIView.  For more information on how to do
        this for your own subclasses, see the section below on subclassing
        UIView.
      </para>
      <para>
        You will want to configure your view at this point.  One of the most
        important properties to configure is the
        <see cref="P:MonoTouch.UIKit.UIView.AutoresizingMask" /> which determines how the
        view will be resized if you invoke
        <see cref="M:MonoTouch.UIKit.UIView.SetNeedsLayout()" /> or if the geometry of the
        view container changes (for example, in response to a device
        rotation).
      </para>
      <para>
        Once you have created a view, you will add it to a container view.
        For your main screen this could be a UIWindow or it could be the
        <see cref="P:MonoTouch.UIKit.UIViewController.View" /> property of your current
        <see cref="T:MonoTouch.UIKit.UIViewController" />, this is done using one of the
        following methods:
      </para>
      <list type="bullet">
        <item>
          <term>
            <see cref="M:MonoTouch.UIKit.UIView.AddSubview(MonoTouch.UIKit.UIView)" />
          </term>
        </item>
        <item>
          <term>
            <see cref="M:MonoTouch.UIKit.UIView.InsertSubview(MonoTouch.UIKit.UIView, int)" />
          </term>
        </item>
        <item>
          <term>
            <see cref="M:MonoTouch.UIKit.UIView.InsertSubviewAbove(MonoTouch.UIKit.UIView, MonoTouch.UIKit.UIView)" />
          </term>
        </item>
        <item>
          <term>
            <see cref="M:MonoTouch.UIKit.UIView.InsertSubviewBelow(MonoTouch.UIKit.UIView, MonoTouch.UIKit.UIView)" />
          </term>
        </item>
      </list>
      <para>
        Although you can use the above APIs to add subviews to any
        UIView, Apple advises developers against extending
        existing high-level views by adding subviews to them behind their
        back.  Instead developers should use the public API those high-level
        views expose.
      </para>
      <format type="text/html">
        <h2>Bounds and Sizes</h2>
      </format>
      <para>
        Each view is created with an initial <see cref="P:MonoTouch.UIKit.UIView.Frame" />.  The Frame is a
        <see cref="T:System.Drawing.RectangleF" /> structure that represents both the size and the initial
        position for the view.  The coordinates for the Frame are used to
        specify the position relative to its superview.
      </para>
      <para>
        You can resize and move views around using the frame.  Every time
        you set the frame the view will layout its subviews. If you are
        purely moving the view, using frame can cause performance issues, as
        it relays out the view and all its subviews.
      </para>
      <para>
        The <see cref="P:MonoTouch.UIKit.UIView.Bounds" /> is the usable
        frame of the view.  Unlike the <see cref="P:MonoTouch.UIKit.UIView.Frame" />, the <see cref="P:MonoTouch.UIKit.UIView.Bounds" /> do not use the container's
        coordinate space, but instead represent the size in the view's own
        coordinate space.  By default the <see cref="P:MonoTouch.UIKit.UIView.Bounds" /> location is (0,0).
      </para>
      <para>
        
        When you update the <see cref="P:MonoTouch.UIKit.UIView.Bounds" />
        property, it will modify the <see cref="P:MonoTouch.UIKit.UIView.Frame" /> based on the value of the
        <see cref="P:MonoTouch.UIKit.UIView.Center" />.  You can also change
        the position of your view by updating the <see cref="P:MonoTouch.UIKit.UIView.Center" /> property.
        
      </para>
      <para>
        When the <see cref="P:MonoTouch.UIKit.UIView.Bound" /> property is changed, the size of the view is affected
        relative to the <see cref="P:MonoTouch.UIKit.UIView.Center" /> property.
      </para>
      <format type="text/html">
        <h2>Animation</h2>
      </format>
      <para>
        There are two styles of animations supported by UIViews, implicit
        animations and explicit animations.
      </para>
      <para>
        Implicit animations happen automatically when you modify the <see cref="P:MonoTouch.UIKit.UIView.Frame" />, <see cref="P:MonoTouch.UIKit.UIView.Bounds" />, <see cref="P:MonoTouch.UIKit.UIView.Center" />, <see cref="P:MonoTouch.UIKit.UIView.Transform" />, <see cref="P:MonoTouch.UIKit.UIView.Alpha" />, <see cref="P:MonoTouch.UIKit.UIView.BackgroundColor" /> or <see cref="P:MonoTouch.UIKit.UIView.ContentStretch" /> properties in a
        view.  The system will automatically animate the change using the
        system defaults.  When you modify any of these animatable properties
        in the view, iOS automatically creates an animation transaction
        which starts as soon as control returns to the main loop.
      </para>
      <para>
        For example, the following code will animate a view's <see cref="P:MonoTouch.UIKit.UIView.Bounds" /> and
        <see cref="P:MonoTouch.UIKit.UIView.Center" /></para>
      <example>
        <code lang="C#"><![CDATA[
view.Bounds = new RectangleF (0, 0, 100, 100);
view.Center = new PointF (200, 200);
]]></code>
      </example>
      <para>
        Alternatively, you can create animations explicitly by calling the
        <see cref="M:MonoTouch.UIKit.UIView.BeginAnimations(string)" /> method, configuring the animation, making the
        changes to the animatable properties and then completing the
        transaction by calling <see cref="M:MonoTouch.UIKit.UIView.CommitAnimations()" />.
      </para>
      <para>
        Once you call <see cref="M:MonoTouch.UIKit.UIView.BeginAnimations(string)" />, you can
        call these methods to configure the animation:
      </para>
      <list type="bullet">
        <item>
          <term>
            <see cref="M:MonoTouch.UIKit.UIView.SetAnimationDuration(double)" />
          </term>
        </item>
        <item>
          <term>
            <see cref="M:MonoTouch.UIKit.UIView.SetAnimationCurve(MonoTouch.UIKit.UIViewAnimationCurve)" />
          </term>
        </item>
        <item>
          <term>
            <see cref="M:MonoTouch.UIKit.UIView.SetAnimationDelay(double)" />
          </term>
        </item>
        <item>
          <term>
            <see cref="M:MonoTouch.UIKit.UIView.SetAnimationDelegate(MonoTouch.Foundation.NSObject)" />
          </term>
        </item>
        <item>
          <term>
            <see cref="M:MonoTouch.UIKit.UIView.SetAnimationRepeatAutoreverses(bool)" />
          </term>
        </item>
        <item>
          <term>
            <see cref="M:MonoTouch.UIKit.UIView.SetAnimationRepeatCount(float)" />
          </term>
        </item>
        <item>
          <term>
            <see cref="M:MonoTouch.UIKit.UIView.SetAnimationDidStopSelector(MonoTouch.ObjCRuntime.Selector)" />
          </term>
        </item>
      </list>
      <para>
        The following example shows how to use these methods in a
        transaction:
      </para>
      <example>
        <code lang="C#"><![CDATA[
UIView.BeginAnimations (null);
UIView.SetAnimationDuration (5);
UIView.SetAnimationCurve (UIViewAnimationCurve.EaseOut);
view.Bounds = new RectangleF (0, 0, 100, 100);
view.Position = new PointF (200, 200);
UIView.CommitAnimations ();
]]></code>
      </example>
      <para>
        An alternative to create the transactions and set the configuration
        options is to use the new <see cref="M:MonoTouch.UIKit.UIView.Animate" /> collection of methods that
        allow you to specify in a single call the delay, the duration, the
        animation block and an action to be invoked when the animation
        completes:
      </para>
      <example>
        <code lang="C#"><![CDATA[
UIView.Animate (duration, delay, UIViewAnimationOption.Autoreverse,
  delegate {
      view.Bounds = new RectangleF (0, 0, 100, 100);
      view.Position = new PointF (200, 200);
   },
   delegate {
       Console.WriteLine ("Animation completed");
   }
);
          ]]></code>
      </example>
      <para>
        The above is the basic set of animations supported by UIViews.  If
        you want finer control over animations you can resort to animations
        done directly using <see cref="N:MonoTouch.CoreAnimation" />.  <see cref="N:MonoTouch.CoreAnimation" /> allows you to
        animate layers and properties of your C# objects.
      </para>
      <format type="text/html">
        <h2>Threading</h2>
      </format>
      <para>
        UIView methods are not thread safe, so you should avoid configuring
        or invoking any of the UIView static methods from any thread that is
        not the main thread.  Newer versions of MonoTouch catch these
        mistakes in Debug builds by throwing an exception.  See the
        <see cref="F:MonoTouch.UIKit.UIApplication.CheckForIllegalCrossThreadCalls" /> for
        more information.
      </para>
      <para>
        If you want to perform some work in a background thread that must
        update any of the UIView properties or you want to invoke any of the
        UIView static methods, you should use either the
        <see cref="M:MonoTouch.Foundation.NSObject.BeginInvokeOnMainThread()" /> or
        <see cref="M:MonoTouch.Foundation.NSObject.InvokeOnMainThread()" /> methods.  Both
        methods take a C# delegate or lambda that is invoked on the main
        thread.
      </para>
      <para>
        The <see cref="M:MonoTouch.Foundation.NSObject.InvokeOnMainThread()" /> method will
        invoke the specified delegate method synchronously on the main
        thread. The
        <see cref="M:MonoTouch.Foundation.NSObject.BeginInvokeOnMainThread()" /> will queue
        the action to be executed on the main thread.
      </para>
      <para>
        Example:
      </para>
      <example>
        <code lang="C#"><![CDATA[
//
// This performs an expensive computation in the background, and then
// updates the main UI when done.
//
void DoSomeWork (UIView view)
{
  double sum = 0;
  for (int i = 0; i &lt; Int32.MaxValue; i++)
      sum += i * i;

  // Now invoke the update on the main UI.
  view.BeginInvokeOnMainThread (delegate {
      view.BackgroundColor = UIColor.Green;
      statusLabel.Text = "Sum is: " + sum;
  });
}
          ]]></code>
      </example>
      <para>
        The following example shows a helper method that can be used to run
        the provided action on the main thread.  It optimizes for the case
        where you are calling this from the main thread already, and avoids
        a trip to the main loop pump:
      </para>
      <example>
        <code lang="C#"><![CDATA[
static NSObject Invoker = new NSObject();
public static void EnsureInvokedOnMainThread (Action action)
{
    if (NSThread.Current.IsMainThread) {
        action ();
        return;
    }
    Invoker.BeginInvokeOnMainThread (() => action());
}
        ]]></code>
      </example>
      <format type="text/html">
        <h2>How to Subclass UIView</h2>
      </format>
      <para>
        Developers will often subclass UIView to provide their own custom
        views to use.  This section discusses the different classes of
        members that developers would overwrite to create their custom
        classes.
      </para>
      <format type="text/html">
        <h3>Initialization</h3>
      </format>
      <para>
        Your subclass of UIView should chain into either the UIView
        constructor that is initialized with an initial frame (<see cref="C:MonoTouch.UIKit.UIView(System.Drawing.RectangleF)" />).  You
        would typically do this like this:
      </para>
      <example>
        <code lang="C#"><![CDATA[
public class MyView : UIView {
    public MyView (RectangleF frame) : base (frame)
    {
        // Your initialization code goes here
    }
}
          ]]></code>
      </example>
      <para>
        If your object will be deserialized from an archive produced by the
        UI designer, you would need to chain to the <see cref="C:MonoTouch.UIKit.UIView(MonoTouch.Foundation.NSCoder)" />
        constructor and also flag the constructor as being the one
        implementing the selector "initWithCoder:", like this:
      </para>
      <example>
        <code lang="C#"><![CDATA[
public class MyView : UIView {
    [Export ("initWithCoder:")]
    public MyView (NSCoder coder) : base (coder)
    {
        // Your initialization code goes here
    }
}
          ]]></code>
      </example>
      <para>
        By default UIViews will use a <see cref="T:MonoTouch.CoreAnimation.CALayer" /> instance for their
        backing store.  The section on "Changing the CALayer" below has both
        information on how to make this change and a sample.
      </para>
      <para>
        If your view will contains any other subviews, you should initialize
        those values in your constructor.
      </para>
      <format type="text/html">
        <h3>Custom Drawing</h3>
      </format>
      <para>
        To implement custom drawing code in a view, you can subclass the
        UIView and override the <see cref="M:MonoTouch.UIKit.UIView.Draw(System.Drawing.RectangleF)" />
        method. The drawing code placed in the Draw method can use <see cref="N:MonoTouch.CoreGraphics" /> to draw with. The steps to draw
        with Core Graphics are:
      </para>
      <list type="bullet">
        <item>
          <term>Obtain a reference to the current graphics context.</term>
        </item>
        <item>
          <term>Set up any desired drawing attributes, such as fill and stroke colors for instance.</term>
        </item>
        <item>
          <term>Create geometry from Core Graphics primitives.</term>
        </item>
        <item>
          <term>Draw the geometry.</term>
        </item>
      </list>
      <para>
        For example, the following code shows an implementation of an
        overridden Draw method that draws a triangle:
      </para>
      <example>
        <code lang="C#"><![CDATA[
public override void Draw (RectangleF rect)
{
    base.Draw (rect);

    var context = UIGraphics.GetCurrentContext ();

    context.SetLineWidth(4);
    UIColor.Red.SetFill ();
    UIColor.Blue.SetStroke ();

    var path = new CGPath ();

    path.AddLines(new PointF[]{
        new PointF(100,200),
        new PointF(160,100), 
        new PointF(220,200)
    });

    path.CloseSubpath();

    context.AddPath(path);		
    context.DrawPath(CGPathDrawingMode.FillStroke);
}
          ]]></code>
      </example>
      <para>
        The <see cref="M:MonoTouch.UIKit.UIView.Draw" /> method should never be called directly. It is called by iOS
        during run loop processing. The first time through the run loop, it
        is called. After that, it will be called on demand whenever the view
        has been marked as needing display by calling <see cref="M:MonoTouch.UIKit.UIView.SetNeedsDisplay" /> or
        <see cref="M:MonoTouch.UIKit.UIView.SetNeedsDisplayInRect(System.Drawing.RectangleF)" />.
      </para>
      <para>
        Core Graphics uses device independent points rather than
        pixels. This allows drawing code to scale between different
        resolutions. For example, on a Retina display, 1 point is equivalent
        to 2 pixels, while on non-Retina displays, 1 point corresponds to 1
        pixel.
      </para>
      <format type="text/html">
        <h3>Printing</h3>
      </format>
      <para>
        UIViews can be printed.  The default behavior is for the contents of
        the UIView as rendered by the <see cref="M:MonoTouch.UIKit.UIView.Draw(System.Drawing.RectangleF)" />
        method to be printed.
      </para>
      <para>
        If you need to provide a different rendering for the view when
        printed, you should override the <see cref="M:MonoTouch.UIKit.UIView.DrawRect(System.Drawing.RectangleF,MonoTouch.UIKit.UIView.UIViewPrintFormatter)" />
        method.
      </para>
      <format type="text/html">
        <h3>Constraints</h3>
      </format>
      <para>
        If you want your view subclass to use the new constraint-based
        layout system introduced with iOS 6.0, your subclass needs to
        respond to the requiresConstraintBasedLayout selector, like this:
      </para>
      <example>
        <code lang="C#"><![CDATA[
class MyView : UIView {
    [Export ("requiresConstraintBasedLayout")]
    bool UseNewLayout ()
    {
        return true;
    }
}
          ]]></code>
      </example>
      <para>
        If your view will use constraints among its own subviews to lay them
        out, you should override the <see cref="M:P:MonoTouch.UIKit.UIView.UpdateConstraints" /> which is
        called before the constraints-based layout is performed.
      </para>
      <para>
        
        Constraints-based layout is performed on the alignment rectangle
        instead of the view's <see cref="P:MonoTouch.UIKit.UIView.Frame" />.
        The alignment rectangle by default is computed as the <see cref="P:MonoTouch.UIKit.UIView.Frame" /> modified by the <see cref="P:MonoTouch.UIKit.UIView.AlignmentRectInsets" />.  You can
        change that behavior and provide your own alignment rectangle by
        overriding the <see cref="M:MonoTouch.UIKit.UIView.AlignmentRectForFrame(System.Drawing.RectangleF)" />
        and <see cref="M:MonoTouch.UIKit.UIView.FrameForAlignmentRect(System.Drawing.RectangleF)" />
        methods.
      </para>
      <format type="text/html">
        <h3>Layout</h3>
      </format>
      <para>
        The default layout system for UIViews is very simple.  UIViews are
        created with an initial <see cref="P:MonoTouch.UIKit.UIView.Frame" />
        and an <see cref="P:MonoTouch.UIKit.UIView.AutoresizingMask" /> that
        determines how the view will be resized in response to changes in
        the container's boundaries.
      </para>
      <para>
        You should set the default <see cref="P:MonoTouch.UIKit.UIView.AutoresizingMask" /> property after
        initialization.
      </para>
      <para>
        If your view will be a container for other views, you should
        configure their <see cref="P:MonoTouch.UIKit.UIView.AutoresizingMask" /> property.  If the
        layout behavior provided is not sufficient, you should override the
        <see cref="M:MonoTouch.UIKit.UIView.LayoutSubviews()" /> method.
        This method is responsible for updating the <see cref="P:MonoTouch.UIKit.UIView.Frame" /> property of each of the
        subviews.
      </para>
      <para>
        If the state of your view changes in response to some API calls,
        instead of changing the layout manually in response to the change,
        you should invoke the <see cref="M:MonoTouch.UIKit.UIView.SetNeedsLayout()" /> method which will
        flag the view for a layout.  The layout event will then be processed
        the next time the main loop runs.  By using this approach, you can
        coalesce multiple changes to the layout in a single pass.
      </para>
      <para>
        UIViews can implement the <see cref="M:MonoTouch.UIKit.UIView.SizeThatFits(System.Drawing.SizeF)" />
        method to report back what is their desired size based on the
        contents of the view.
      </para>
      <para>
        You can override the <see cref="M:MonoTouch.UIKit.UIView.SubviewAdded(MonoTouch.UIKit.UIView)" />
        and the <see cref="M:MonoTouch.UIKit.UIView.WillRemoveSubview(MonoTouch.UIKit.UIView)" />
        to track when subviews are added or removed to your UIView.
      </para>
      <para>
        You can override the <see cref="M:MonoTouch.UIKit.UIView.WillMoveToWindow(MonoTouch.UIKit.UIWindow)" />
        and the <see cref="M:MonoTouch.UIKit.UIView.MovedToWindow()" /> to
        track when your view is moved from one <see cref="T:MonoTouch.UIKit.UIWindow" /> to another.
      </para>
      <para>
        You can override the <see cref="M:MonoTouch.UIKit.UIView.WillMoveToSuperview(MonoTouch.UIKit.UIView)" />
        and the <see cref="M:MonoTouch.UIKit.UIView.MovedToSuperview()" /> to
        track when your view is added or removed from a superview.
      </para>
      <format type="text/html">
        <h2>Constraints Based Layout</h2>
      </format>
      <para>
        Starting with iOS 6.0 there is a new layout system available to
        developers, the constraints-based layout system.  This system
        differs from the traditional layout system in that it uses rules
        (constraints) that describe the relationships between subviews that
        should be preserved.  When views change in size (for example a label
        is updated) or the size of the container changes (for example, after
        a rotation), the new positions and sizes for the subviews are
        computed based on these constraints.
      </para>
      <para>
        To opt into this system, a subclass of UIView should expose a static
        method that is exported as "requiresConstraintBasedLayout" and
        returns true, like this:
      </para>
      <example>
        <code lang="C#"><![CDATA[
class MyView : UIView {
    [Export ("requiresConstraintBasedLayout")]
    static bool RequiresConstraintBasedLayout ()
    {
        return true;
    }
}
          ]]></code>
      </example>
      <format type="text/html">
        <h3>Event Handling</h3>
      </format>
      <para>
        If you are using gesture recognizers, you can add those directly to
        your constructor at initialization time.
      </para>
      <para>
        For the low-level touch event handling, you should override the <see cref="M:MonoTouch.UIKit.UIResponder.TouchesBegan(MonoTouch.Foundation.NSSet,MonoTouch.UIKit.UIEvent)" />, <see cref="M:MonoTouch.UIKit.UIResponder.TouchesMoved(MonoTouch.Foundation.NSSet,MonoTouch.UIKit.UIEvent)" />, <see cref="M:MonoTouch.UIKit.UIResponder.TouchesEnded(MonoTouch.Foundation.NSSet,MonoTouch.UIKit.UIEvent)" /> and <see cref="M:MonoTouch.UIKit.UIResponder.TouchesCancelled(MonoTouch.Foundation.NSSet,MonoTouch.UIKit.UIEvent)" /> methods.
      </para>
      <para>
        You do not need to call the base methods for any of the above
        methods if you are overriding UIView directly.  But you might want
        to call base if you are deriving from another UIView subclass.
      </para>
      <para>
        You can control whether a gesture recognizer is activated by
        overriding the <see cref="M:MonoTouch.UIKit.UIView.GestureRecognizerShouldBegin(MonoTouch.UIKit.UIGestureRecognizer)" />
        method.
      </para>
      <format type="text/html">
        <h2>Views and CALayers</h2>
      </format>
      <para>
        Each UIView is backed by a <see cref="N:MonoTouch.CoreAnimation" /> Layer (<see cref="T:MonoTouch.CoreAnimation.CALayer" />).  A CALayer
        represents the GPU-backed bitmap that is used to render your view
        into the screen.  When you paint into a UIView, you are actually
        painting into the CALayer.
      </para>
      <para>
        While the appearance of a UIView can be controlled by setting its
        <see cref="P:MonoTouch.UIKit.UIView.Frame" />, <see cref="P:MonoTouch.UIKit.UIView.Alpha" />, <see cref="P:MonoTouch.UIKit.UIView.BackgroundColor" />, or by overriding its <see cref="M:MonoTouch.UIKit.UIView.Draw" /> method, all
        those properties and functions are in fact modifying the <see cref="P:MonoTouch.CoreAnimation.CALayer" />
        owned by the view.
      </para>
      <para>
        The <see cref="P:MonoTouch.UIKit.UIView.Layer" /> property is a reference to the
        CALayer owned by the view. You can change the appearance of the view
        by modifying the properties of that layer.
      </para>
      <para>
        For example, you can add rounded corners to the UIView by modifying
        the <see cref="P:MonoTouch.CoreAnimation.CALayer.CornerRadius" /> of its layer:
      </para>
      <example>
        <code lang="C#"><![CDATA[
view.Layer.CornerRadius = 4;
        ]]></code>
      </example>
      <para>
        You can add drop shadows by modifying a variety of properties:
      </para>
      <example>
        <code lang="C#"><![CDATA[
view.Layer.ShadowColor = new CGColor (1, 0, 0);
view.Layer.ShadowOpacity = 1.0f;
view.Layer.ShadowOffset = new SizeF (0, 4);
        ]]></code>
      </example>
      <para>
        You can even apply a 3D transformation to the layer:
      </para>
      <example>
        <code lang="C#"><![CDATA[
view.Layer.Transform = CATransform3D.MakeRotation ((float)(Math.PI / 2), 1, 1, 1);
        ]]></code>
      </example>
      <para>
        Note that this transformation is a full 3D transform, with a
        perspective element, that is more versatile than UIView's 2D
        Transform property.   If you apply 3D transforms, you should no longer use the Frame property
      </para>
      <format type="text/html">
        <h3>Changing the CALayer</h3>
      </format>
      <para>
        The <see cref="P:MonoTouch.UIKit.UIView.Layer" /> owned by a view is automatically
        created and assigned to the view by UIKit and it defaults to be a
        <see cref="T:MonoTouch.CoreAnimation.CALayer" /> instance.   You can control the type
        of layer that is created for a view by responding to the "layerClass" 
        selector in a static method.
      </para>
      <para>
        Here is an example of a UIView subclass that uses a custom <see cref="T:MonoTouch.CoreAnimation.CALayer" /> to do its drawing. This
        layer, and therefore the view, always displays the color blue:
      </para>
      <example>
        <code lang="C#"><![CDATA[
public class BlueView : UIView
{
    [Export ("layerClass")]
    public static Class GetLayerClass ()
    {
        return new Class (typeof (BlueLayer));
    }

    public override void Draw (RectangleF rect)
    {
        // Do nothing, the Layer will do all the drawing
    }
}

public class BlueLayer : CALayer
{
    public override void DrawInContext (CGContext ctx)
    {
        ctx.SetFillColor (0, 0, 1, 1);
        ctx.FillRect (Bounds);
    }
}
          ]]></code>
      </example>
      <para>
        In this example, a new UIView class called "BlueView" is created. It
        exports a static method called "GetLayerClass" that tells UIKit the
        type of layer that this view wishes to own. In this example, the
        BlueView wishes to own a BlueLayer.
      </para>
      <para>
        It is now up to the BlueLayer to provide the visual representation
        of the view. It does this by executing CoreGraphics drawing code in
        its <see cref="M:MonoTouch.CoreAnimation.CALayer.DrawInContext(MonoTouch.CoreGraphics.CGContext)" />
        method. This method is very similar to a UIView's Draw method but is used to fill the layer.
        
      </para>
      <para>
        Even though the BlueLayer will do all drawing for the BlueView, the
        view must still override its Draw method. This override should do
        nothing and is just a signal to UIKit that the Layer will do all the
        work.
      </para>
      <format type="text/html">
        <h2>Motion Effects</h2>
      </format>
      <para> Motion Effects are a family of effects that can be
	  applied to UIViews in response to external events, typically
	  the device tilt.  </para>
      <para>

	  You can tie to motion effects the same properties that are
	  animatable already.  UIKit ships with <see cref="T:MonoTouch.UIKit.UIInterpolatingMotionEffect" /> which
	  allows you to controls a single property in response to a device tilt.

	</para>
      <para>
	  
	  One you create an effect, you can attach it to a view by
	  calling the <see cref="M:MonoTouch.UIKit.UIView.AddMotionEffect" /> method and
	  remove it by calling <see cref="M:MonoTouch.UIKit.UIView.RemoveMotionEffect" /> method.
	  The <see cref="P:MonoTouch.UIKit.UIView.MotionEffects" />
	  property can also be used to query or set a number of motion
	  effects at once.

	</para>
      <para>
	  You can also create your own motion effects by subclassing the <see cref="T:MonoTouch.UIKit.UIMotionEffect" />.
	</para>
      <format type="text/html">
        <h2>Tint Color</h2>
      </format>
      <para>

	Starting with iOS 7, the <see cref="P:MonoTouch.UIKit.UIView.TintColor" /> property will now
	propagate to subviews.  This allows applications to set a
	global tint color, and the color will be passed down to
	subviews for views that matter.  Some UIViews will respond
	specially based on the TintColor.  You should also set the
	<see cref="P:MonoTouch.UIKit.UIView.TintAdjustmentMode" /> to
	control the desaturation when some views are no longer active.

      </para>
      <!--
      <format type="text/html">
        <h2>Dynamics</h2>
      </format>
-->
      <format type="text/html">
        <h2>View Hierarchies</h2>
      </format>
      <para>iOS user interfaces are built from <see cref="T:MonoTouch.UIKit.UIView" /> hierarchies. Parent-child relationships determine not only the visual aspects of the UI, but determine how the application responds to touch events and orientation changes.</para>
      <para>View relationships may be built programmatically or via XIB files. <see cref="T:MonoTouch.UIKit.UIView" />s may have many <see cref="P:MonoTouch.UIKit.UIView.Subviews" /> but only one <see cref="P:MonoTouch.UIKit.UIView.Superview" />.</para>
      <para>The most common way to add subviews is to use <see cref="M:MonoTouch.UIKit.UIView.AddSubview" />, which appends the child view to the list of <see cref="P:MonoTouch.UIKit.UIView.Subviews" />. More precise control of ordering during insertion may be done with the <see cref="M:MonoTouch.UIKit.UIView.InsertSubview" />, <see cref="M:MonoTouch.UIKit.UIView.InsertSubviewAbove" />, and <see cref="M:MonoTouch.UIKit.UIView.InsertSubviewBelow" /> methods.</para>
      <para>The ordering of <see cref="P:MonoTouch.UIKit.UIView.Subviews" /> may be manipulated with the <see cref="M:MonoTouch.UIKit.UIView.BringSubviewToFront" />, <see cref="M:MonoTouch.UIKit.UIView.SendSubviewToBack" />, and <see cref="M:MonoTouch.UIKit.UIView.ExchangeSubview" /> methods.</para>
    </remarks>
    <related type="recipe" href="http://docs.xamarin.com/ios/Recipes/Animation/CoreAnimation/Animate_a_UIView_using_UIKit">Animate a UIView using UIKit</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIView ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("init")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Default constructor that initializes a new instance of this class with no parameters.</summary>
        <remarks>To be added.
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIView (MonoTouch.Foundation.NSCoder coder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class MonoTouch.Foundation.NSCoder coder) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("initWithCoder:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="coder" Type="MonoTouch.Foundation.NSCoder" />
      </Parameters>
      <Docs>
        <param name="coder">The unarchiver object.</param>
        <summary>A constructor that initializes the object from the data stored in the unarchiver object.</summary>
        <remarks>
          <para>This constructor is provided to allow the class to be initialized from an unarchiver (for example, during NIB deserialization).   This is part of the <see cref="T:MonoTouch.Foundation.NSCoding" />  protocol.</para>
          <para>If you want to create a subclass of this object and continue to support deserialization from an archive, you should implement a constructor with an identical signature: taking a single parameter of type <see cref="T:MonoTouch.Foundation.NSCoder" /> and decorate it with the [Export("initWithCoder:"] attribute declaration.</para>
          <para>The state of this object can also be serialized by using the companion method, EncodeTo.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIView (MonoTouch.Foundation.NSObjectFlag t);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class MonoTouch.Foundation.NSObjectFlag t) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="t" Type="MonoTouch.Foundation.NSObjectFlag" />
      </Parameters>
      <Docs>
        <param name="t">Unused sentinel value, pass NSObjectFlag.Empty.</param>
        <summary>Constructor to call on derived classes to skip initialization and merely allocate the object.</summary>
        <remarks>
          <para>This constructor should be called by derived classes when they completely construct the object in managed code and merely want the runtime to allocate and initialize the NSObject.   This is required to implement the two-step initialization process that Objective-C uses, the first step is to perform the object allocation, the second step is to initialize the object.   When you invoke the constructor that takes the NSObjectFlag.Empty you taking advantage of a direct path that goes all the way up to NSObject to merely allocate the object's memory and bind the Objective-C and C# objects together.    The actual initialization of the object is up to you.</para>
          <para>This constructor is typically used by the binding generator to allocate the object, but prevent the actual initialization to take place.   Once the allocation has taken place, the constructor has to initialize the object.   With constructors generated by the binding generator this means that it manually invokes one of the "init" methods to initialize the object.</para>
          <para>It is your responsibility to completely initialize the object if you chain up using the NSObjectFlag.Empty path.</para>
          <para>In general, if your constructors invokes the NSObjectFlag.Empty base implementation, then it should be calling an Objective-C init method.   If this is not the case, you should instead chain to the proper constructor in your class. </para>
          <para>The argument value is ignored and merely ensures that the only code that is executed is the construction phase is the basic NSObject allocation and runtime type registration.  Typically the chaining would look like this:</para>
          <example>
            <code lang="C#">
//
// The NSObjectFlag merely allocates the object and registers the
// C# class with the Objective-C runtime if necessary, but no actual
// initXxx method is invoked, that is done later in the constructor
//
// This is taken from MonoTouch's source code:
//
[Export ("initWithFrame:")]
public UIView (System.Drawing.RectangleF frame) : base (NSObjectFlag.Empty)
{
// Invoke the init method now.
	var initWithFrame = new Selector ("initWithFrame:").Handle;
	if (IsDirectBinding)
		Handle = MonoTouch.ObjCRuntime.Messaging.IntPtr_objc_msgSend_RectangleF (this.Handle, initWithFrame, frame);
	else
		Handle = MonoTouch.ObjCRuntime.Messaging.IntPtr_objc_msgSendSuper_RectangleF (this.SuperHandle, initWithFrame, frame);
}
</code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIView (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Pointer (handle) to the unmanaged object.</param>
        <summary>A constructor used when creating managed representations of unmanaged objects;  Called by the runtime.</summary>
        <remarks>
          <para>This constructor is invoked by the runtime infrastructure (<see cref="M:MonoTouch.ObjCRuntime.GetNSObject (System.IntPtr)" />) to create a new managed representation for a pointer to an unmanaged Objective-C object.    You should not invoke this method directly, instead you should call the GetNSObject method as it will prevent two instances of a managed object to point to the same native object.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIView (System.Drawing.RectangleF frame);" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Drawing.RectangleF frame) cil managed" apistyle="classic" />
      <MemberSignature Language="C#" Value="public UIView (MonoTouch.CoreGraphics.CGRect frame);" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype MonoTouch.CoreGraphics.CGRect frame) cil managed" apistyle="unified" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("initWithFrame:")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="frame" Type="System.Drawing.RectangleF" apistyle="classic" />
        <Parameter Name="frame" Type="MonoTouch.CoreGraphics.CGRect" apistyle="unified" />
      </Parameters>
      <Docs>
        <param name="frame">Frame used by the view, expressed in iOS points.</param>
        <summary>Initializes the UIView with the specified frame.</summary>
        <remarks>
          <para>This constructor is used to programmatically create a new instance of UIView with the specified dimension in the frame.   The object will only be displayed once it has been added to a view hierarchy by calling AddSubview in a containing view.</para>
          <para>This constructor is not invoked when deserializing objects from storyboards or XIB filesinstead the constructor that takes an NSCoder parameter is invoked.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityActivate">
      <MemberSignature Language="C#" Value="public virtual bool AccessibilityActivate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool AccessibilityActivate() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("accessibilityActivate")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Activates accessibility for this UIView, returning <see langword="true" /> on success.</summary>
        <returns>True upon success.</returns>
        <remarks>This is a Boolean which will return a true value upon success.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityActivationPoint">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.PointF AccessibilityActivationPoint { get; set; }" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.PointF AccessibilityActivationPoint" apistyle="classic" />
      <MemberSignature Language="C#" Value="public virtual MonoTouch.CoreGraphics.CGPoint AccessibilityActivationPoint { get; set; }" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype MonoTouch.CoreGraphics.CGPoint AccessibilityActivationPoint" apistyle="unified" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(5, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("accessibilityActivationPoint")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(5, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setAccessibilityActivationPoint:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.ObjCRuntime.Since(5, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType apistyle="classic">System.Drawing.PointF</ReturnType>
        <ReturnType apistyle="unified">MonoTouch.CoreGraphics.CGPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The screen coordinates for the accessibility element.</summary>
        <value>The default value is the center of the <see cref="P:MonoTouch.UIKit.UIView.AccessibilityFrame" />.</value>
        <remarks>
          <para>Application developers can set this value to move the location of the accessibility element. For instance, by default the <see cref="P:MonoTouch.UIKit.UIView.AccessibilityPoint" /> of an app icon is the center of the icon, but during rearrangement, the point is moved to the "remove control" (the circled X).</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityElementsHidden">
      <MemberSignature Language="C#" Value="public virtual bool AccessibilityElementsHidden { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AccessibilityElementsHidden" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(5, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("accessibilityElementsHidden")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(5, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setAccessibilityElementsHidden:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.ObjCRuntime.Since(5, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns whether or not the view's accessibility elements are visible.</summary>
        <value>Boolean indicating whther visible or not.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityFrame">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.RectangleF AccessibilityFrame { get; set; }" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.RectangleF AccessibilityFrame" apistyle="classic" />
      <MemberSignature Language="C#" Value="public virtual MonoTouch.CoreGraphics.CGRect AccessibilityFrame { get; set; }" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype MonoTouch.CoreGraphics.CGRect AccessibilityFrame" apistyle="unified" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("accessibilityFrame")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setAccessibilityFrame:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType apistyle="classic">System.Drawing.RectangleF</ReturnType>
        <ReturnType apistyle="unified">MonoTouch.CoreGraphics.CGRect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The Frame of the accessibility element, in screen coordinates.</summary>
        <value>The designated frame.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityHint">
      <MemberSignature Language="C#" Value="public virtual string AccessibilityHint { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AccessibilityHint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("accessibilityHint")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setAccessibilityHint:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A brief description of the action performed by the accessibility element.</summary>
        <value>String that contains the hint.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityIdentifier">
      <MemberSignature Language="C#" Value="public virtual string AccessibilityIdentifier { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AccessibilityIdentifier" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("accessibilityIdentifier")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setAccessibilityIdentifier:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Uniquely identifies <c>this</c> for the purposes of accessibility.</summary>
        <value>String identifier.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityLabel">
      <MemberSignature Language="C#" Value="public virtual string AccessibilityLabel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AccessibilityLabel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("accessibilityLabel")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setAccessibilityLabel:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A localized identifier for the accessibility element.</summary>
        <value>String label identifier text.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityLanguage">
      <MemberSignature Language="C#" Value="public virtual string AccessibilityLanguage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AccessibilityLanguage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("accessibilityLanguage")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setAccessibilityLanguage:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The BCP 47 language tag of the language used to speak the accessibility element's components.</summary>
        <value>String containing language tag.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityNavigationStyle">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIAccessibilityNavigationStyle AccessibilityNavigationStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype MonoTouch.UIKit.UIAccessibilityNavigationStyle AccessibilityNavigationStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(8, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("accessibilityNavigationStyle")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(8, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setAccessibilityNavigationStyle:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.ObjCRuntime.Since(8, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIAccessibilityNavigationStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityPath">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIBezierPath AccessibilityPath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIBezierPath AccessibilityPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("accessibilityPath")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setAccessibilityPath:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIBezierPath</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Allows the accessibility element to be non-rectangular.</summary>
        <value>
          <see langword="null" /> by default, in which case the <see cref="P:MonoTouch.UIKit.UIView.AccessibilityFrame" /> is used to highlight the element.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityTraits">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIAccessibilityTrait AccessibilityTraits { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype MonoTouch.UIKit.UIAccessibilityTrait AccessibilityTraits" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("accessibilityTraits")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setAccessibilityTraits:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIAccessibilityTrait</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A bitmask of the <see cref="T:MonoTouch.UIKit.UIAccessibilityTrait" />s of <c>this</c>.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityValue">
      <MemberSignature Language="C#" Value="public virtual string AccessibilityValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AccessibilityValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("accessibilityValue")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setAccessibilityValue:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The value of the accessibility element.</summary>
        <value>If the <see cref="T:MonoTouch.UIKit.UIView" /> has a label, returns the value of the label.</value>
        <remarks>
          <para>Application developers should override this if their <see cref="T:MonoTouch.UIKit.UIView" /> has both a label and a value.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityViewIsModal">
      <MemberSignature Language="C#" Value="public virtual bool AccessibilityViewIsModal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AccessibilityViewIsModal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(5, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("accessibilityViewIsModal")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(5, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setAccessibilityViewIsModal:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.ObjCRuntime.Since(5, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether Voice Over should ignore sibling elements.</summary>
        <value>The default value is <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (MonoTouch.UIKit.UIView view);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(class MonoTouch.UIKit.UIView view) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="view" Type="MonoTouch.UIKit.UIView" />
      </Parameters>
      <Docs>
        <param name="view">The subview to add.</param>
        <summary>This is an alias for <see cref="M:MonoTouch.UIKit.UIView.AddSubview" />, but uses the Add pattern as it allows C# 3.0 constructs to add subviews after creating the object.</summary>
        <remarks>
          <para>
            This method is equivalent to <see cref="M:MonoTouch.UIKit.UIView.AddSubview" /> and is present to enable C# 3.0 to add subviews at creation time.
          </para>
          <example>
            <code lang="C#"><![CDATA[
              var myView = new MyView (new RectangleF (0, 0, 320, 320)){
                new ImageGallery (region [0]),
                new ImageGallery (region [1]),
                new UILabel (new RectangleF (10, 10, 200, 200)){
                  Text = "Images from our Trip"
                }
              };
            ]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddConstraint">
      <MemberSignature Language="C#" Value="public virtual void AddConstraint (MonoTouch.UIKit.NSLayoutConstraint constraint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddConstraint(class MonoTouch.UIKit.NSLayoutConstraint constraint) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("addConstraint:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constraint" Type="MonoTouch.UIKit.NSLayoutConstraint" />
      </Parameters>
      <Docs>
        <param name="constraint">A <see cref="T:MonoTouch.UIKit.NSLayoutConstraint" /> to add. The <paramref name="constraint" /> must refer only to the receiving view or its subviews.</param>
        <summary>Adds a constraint to the layout of the receiving view or its subviews.</summary>
        <remarks>
          <para>The <paramref name="constraint" /> must refer only to the receiving view or its subviews.</para>
        </remarks>
        <altmember cref="P:MonoTouch.UIKit.UIView.Constraints" />
        <altmember cref="M:MonoTouch.UIKit.UIView.AddConstraints" />
        <altmember cref="M:MonoTouch.UIKit.UIView.RemoveConstraint" />
        <altmember cref="M:MonoTouch.UIKit.UIView.RemoveConstraints" />
        <altmember cref="P:MonoTouch.UIKit.UIView.TranslatesAutoresizingMaskIntoConstraints" />
      </Docs>
    </Member>
    <Member MemberName="AddConstraints">
      <MemberSignature Language="C#" Value="public virtual void AddConstraints (MonoTouch.UIKit.NSLayoutConstraint[] constraints);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddConstraints(class MonoTouch.UIKit.NSLayoutConstraint[] constraints) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("addConstraints:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constraints" Type="MonoTouch.UIKit.NSLayoutConstraint[]" />
      </Parameters>
      <Docs>
        <param name="constraints">An array of <see cref="T:MonoTouch.UIKit.NSLayoutConstraint" />s to add. The <paramref name="constraints" /> must refer only to the receiving view or its subviews.</param>
        <summary>Adds multiple constraints to the layout of the receiving view or its subviews.</summary>
        <remarks>
          <para>The <paramref name="constraints" /> must refer only to the receiving view or its subviews.</para>
          <para>In the following example, <format type="text/html"><a href="https://developer.apple.com/library/mac/#documentation/UserExperience/Conceptual/AutolayoutPG/Articles/formatLanguage.html#//apple_ref/doc/uid/TP40010853-CH3-SW1">Visual Format Language</a></format> specifies that the <c>blueView</c> be horizontally attched to the leading and trailing edge (sides), that the <c>blueView</c> and <c>greenView</c> be vertically attached to the leading and trailing edges (top and bottom) and separated by 30 pixels, and that the <c>greenView</c> be the same width as the <c>blueView</c> and attached to both the leading and trailing edges. The result is shown in the following image.</para>
          <example>
            <code lang="C#"><![CDATA[
mainView.AddSubview(blueView);
mainView.AddSubview(greenView);

greenView.TranslatesAutoresizingMaskIntoConstraints = false;
blueView.TranslatesAutoresizingMaskIntoConstraints = false;

var viewsDictionary = NSDictionary.FromObjectsAndKeys(new NSObject[] { greenView, blueView}, new NSObject[] { new NSString("green"), new NSString("blue")});
var metrics = new NSDictionary();

mainView.AddConstraints(NSLayoutConstraint.FromVisualFormat("H:|-[blue]-|",0, new NSDictionary(), viewsDictionary));
mainView.AddConstraints(NSLayoutConstraint.FromVisualFormat("V:|-[blue]-(==30)-[green(==blue)]-|",0, new NSDictionary(), viewsDictionary));
mainView.AddConstraints(NSLayoutConstraint.FromVisualFormat("|-[green(==blue)]-|",0, new NSDictionary(), viewsDictionary));
              ]]></code>
          </example>
          <para>
            <img href="MonoTouch.UIKit.UIView.AddConstraints.png" />
          </para>
        </remarks>
        <altmember cref="P:MonoTouch.UIKit.UIView.Constraints" />
        <altmember cref="M:MonoTouch.UIKit.UIView.AddConstraint" />
        <altmember cref="M:MonoTouch.UIKit.UIView.RemoveConstraint" />
        <altmember cref="M:MonoTouch.UIKit.UIView.RemoveConstraints" />
        <altmember cref="P:MonoTouch.UIKit.UIView.TranslatesAutoresizingMaskIntoConstraints" />
      </Docs>
    </Member>
    <Member MemberName="AddGestureRecognizer">
      <MemberSignature Language="C#" Value="public virtual void AddGestureRecognizer (MonoTouch.UIKit.UIGestureRecognizer gestureRecognizer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddGestureRecognizer(class MonoTouch.UIKit.UIGestureRecognizer gestureRecognizer) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("addGestureRecognizer:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(3, 2)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="gestureRecognizer" Type="MonoTouch.UIKit.UIGestureRecognizer" />
      </Parameters>
      <Docs>
        <param name="gestureRecognizer">The configured gesture recognizer to add to this view.</param>
        <summary>Adds a gesture recognizer to this view.</summary>
        <remarks>Adding a gesture recognizer to a view allows definition of the scope of that represented gesture, and causes it to receive touches that are hit-tested to that view and to all of its subviews. That view then establishes a strong reference to the gesture recognizer.
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddKeyframeWithRelativeStartTime" apistyle="classic">
      <MemberSignature Language="C#" Value="public static void AddKeyframeWithRelativeStartTime (double frameStartTime, double frameDuration, MonoTouch.Foundation.NSAction animations);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddKeyframeWithRelativeStartTime(float64 frameStartTime, float64 frameDuration, class MonoTouch.Foundation.NSAction animations) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("addKeyframeWithRelativeStartTime:relativeDuration:animations:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="frameStartTime" Type="System.Double" />
        <Parameter Name="frameDuration" Type="System.Double" />
        <Parameter Name="animations" Type="MonoTouch.Foundation.NSAction">
          <Attributes>
            <Attribute>
              <AttributeName>MonoTouch.ObjCRuntime.BlockProxy(typeof(MonoTouch.ObjCRuntime.Trampolines/NIDNSAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="frameStartTime">The starting time of the animation, relative to the containing action (0-1).</param>
        <param name="frameDuration">The duration of the animation, relative to the containing action (0-1).</param>
        <param name="animations">The action defining the ending state of the keyframe.</param>
        <summary>Adds a single keyframe to an animation, correlated with a relative start time.</summary>
        <remarks>
          <para>This method, when called within the <c>animations</c> action of a call to <see cref="M:MonoTouch.UIKit.UIView.AnimateKeyframes" />, specifies a keyframe in an animation sequence. Both the <paramref name="frameStartTime" /> and <paramref name="frameDuration" /> parameters range fro m 0 to 1 and specify durations relative to the enclosing <see cref="M:MonoTouch.UIKit.UIView.AnimateKeyframes" /><c>duration</c> parameter.</para>
          <para>For instance, in the following example (which shows the use of both passed-in <see cref="T:MonoTouch.Foundation.NSAction" /> parameters and a C# lambda expression), the third keyframe's <paramref name="frameStartTime" /> and <paramref name="frameDuration" /> are both set to 0.5; since the the containing <see cref="M:MonoTouch.UIKit.UIView.AnimateKeyframesAsync" />'s <paramref name="duration" /> is set to 3 seconds, this animation will start at 1.5 seconds and take 1.5 seconds to complete.</para>
          <example>
            <code lang="C#"><![CDATA[
var animationSucceeded = await UIView.AnimateKeyframesAsync(
		duration : 3,
		delay : 0,
		options: UIViewKeyframeAnimationOptions.AllowUserInteraction,
		animations: () => {
			UIView.AddKeyframeWithRelativeStartTime(0, 0.25, () => label.Frame = new RectangleF(label.Frame.Left + 250, label.Frame.Top, label.Frame.Width, label.Frame.Height)
				);
			UIView.AddKeyframeWithRelativeStartTime(0.25, 0.25, keyframe2);
			UIView.AddKeyframeWithRelativeStartTime(0.5, 0.5, keyframe3);
		}
	);
    ]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddKeyframeWithRelativeStartTime" apistyle="unified">
      <MemberSignature Language="C#" Value="public static void AddKeyframeWithRelativeStartTime (double frameStartTime, double frameDuration, Action animations);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddKeyframeWithRelativeStartTime(float64 frameStartTime, float64 frameDuration, class System.Action animations) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("addKeyframeWithRelativeStartTime:relativeDuration:animations:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="frameStartTime" Type="System.Double" />
        <Parameter Name="frameDuration" Type="System.Double" />
        <Parameter Name="animations" Type="System.Action">
          <Attributes>
            <Attribute>
              <AttributeName>MonoTouch.ObjCRuntime.BlockProxy(typeof(MonoTouch.ObjCRuntime.Trampolines/NIDAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="frameStartTime">The starting time of the animation, relative to the containing action (0-1)</param>
        <param name="frameDuration">The duration of the animation, relative to the containing action (0-1).</param>
        <param name="animations">The action defining the ending state of the keyframe.</param>
        <summary>Adds a single keyframe to an animation.</summary>
        <remarks>
          <para>This method, when called within the <c>animations</c> action of a call to <see cref="M:MonoTouch.UIKit.UIView.AnimateKeyframes" />, specifies a keyframe in an animation sequence. Both the <paramref name="frameStartTime" /> and <paramref name="frameDuration" /> parameters range fro m 0 to 1 and specify durations relative to the enclosing <see cref="M:MonoTouch.UIKit.UIView.AnimateKeyframes" /><c>duration</c> parameter.</para>
          <para>For instance, in the following example (which shows the use of both passed-in <see cref="T:MonoTouch.Foundation.NSAction" /> parameters and a C# lambda expression), the third keyframe's <paramref name="frameStartTime" /> and <paramref name="frameDuration" /> are both set to 0.5; since the the containing <see cref="M:MonoTouch.UIKit.UIView.AnimateKeyframesAsync" />'s <paramref name="duration" /> is set to 3 seconds, this animation will start at 1.5 seconds and take 1.5 seconds to complete.</para>
          <example>
            <code lang="C#"><![CDATA[
var animationSucceeded = await UIView.AnimateKeyframesAsync(
		duration : 3,
		delay : 0,
		options: UIViewKeyframeAnimationOptions.AllowUserInteraction,
		animations: () => {
			UIView.AddKeyframeWithRelativeStartTime(0, 0.25, () => label.Frame = new RectangleF(label.Frame.Left + 250, label.Frame.Top, label.Frame.Width, label.Frame.Height)
				);
			UIView.AddKeyframeWithRelativeStartTime(0.25, 0.25, keyframe2);
			UIView.AddKeyframeWithRelativeStartTime(0.5, 0.5, keyframe3);
		}
	);
    ]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddMotionEffect">
      <MemberSignature Language="C#" Value="public virtual void AddMotionEffect (MonoTouch.UIKit.UIMotionEffect effect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddMotionEffect(class MonoTouch.UIKit.UIMotionEffect effect) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("addMotionEffect:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="effect" Type="MonoTouch.UIKit.UIMotionEffect" />
      </Parameters>
      <Docs>
        <param name="effect">Motion effect to add to the view.</param>
        <summary>Adds the specified motion effect to the view.</summary>
        <remarks>This method, when called using the present UIView animation context, animates the transition to the specified motion effect's values.
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddSubview">
      <MemberSignature Language="C#" Value="public virtual void AddSubview (MonoTouch.UIKit.UIView view);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddSubview(class MonoTouch.UIKit.UIView view) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("addSubview:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="view" Type="MonoTouch.UIKit.UIView" />
      </Parameters>
      <Docs>
        <param name="view">
          <para>The <see cref="T:MonoTouch.UIKit.UIView" /> to add as a nested view of this view.</para>
        </param>
        <summary>Adds the specified view as a subview of this view.</summary>
        <remarks>
          <para>
            <see cref="M:MonoTouch.UIKit.UIView.AddSubview" /> appends the <paramref name="view" /> to the end of <c>this</c> <see cref="T:MonoTouch.UIKit.UIView" />'s <see cref="P:MonoTouch.UIKit.UIView.Subviews" />. The methods <see cref="M:MonoTouch.UIKit.UIView.InsertSubview" />, <see cref="M:MonoTouch.UIKit.UIView.InsertSubviewBelow" />, and <see cref="M:MonoTouch.UIKit.UIView.InsertSubviewAbove" /> can be used to control the order.</para>
          <para>To remove a <see cref="T:MonoTouch.UIKit.UIView" /> from <see cref="P:MonoTouch.UIKit.UIView.Subviews" />, call <see cref="M:MonoTouch.UIKit.UIView.RemoveFromSuperview" /> on the child <see cref="T:MonoTouch.UIKit.UIView" />.</para>
          <para>Since <see cref="T:MonoTouch.UIKit.UIView" />s can only have direct ancestor, this will overwrite the existing <see cref="P:MonoTouch.UIKit.UIView.Superview" /> of the <paramref name="view" />.</para>
          <para>A number of methods are called when a subview is added or removed:</para>
          <list type="bullet">
            <item>
              <term>
                <see cref="M:MonoTouch.UIKit.UIView.WillMoveToSuperview" />
              </term>
            </item>
            <item>
              <term>
                <see cref="M:MonoTouch.UIKit.UIView.WillMoveToWindow" />
              </term>
            </item>
            <item>
              <term>
                <see cref="M:MonoTouch.UIKit.UIView.WillRemoveSubview" />
              </term>
            </item>
            <item>
              <term>
                <see cref="M:MonoTouch.UIKit.UIView.SubviewAdded" />
              </term>
            </item>
            <item>
              <term>
                <see cref="M:MonoTouch.UIKit.UIView.MovedToSuperview" />
              </term>
            </item>
            <item>
              <term>
                <see cref="M:MonoTouch.UIKit.UIView.MovedToWindow" />
              </term>
            </item>
          </list>
          <para>The following diagram shows the sequence of calls resulting from a call to <see cref="M:MonoTouch.UIKit.UIView.AddSubview" />. Note that the calls to <see cref="M:MonoTouch.UIKit.UIView.WillMoveToWindow" /> and <see cref="M:MonoTouch.UIKit.UIView.MovedToWindow" /> occur shortly after <see cref="M:MonoTouch.UIKit.UIView.AddSubview" /> has completed.</para>
          <para>
            <img href="UIView.AddSubviewSequence.png" />
          </para>
        </remarks>
      </Docs>
      <altmember cref="P:MonoTouch.UIKit.UIView.Subviews" />
      <altmember cref="M:MonoTouch.UIKit.UIView.RemoveFromSuperview" />
    </Member>
    <Member MemberName="AddSubviews">
      <MemberSignature Language="C#" Value="public void AddSubviews (MonoTouch.UIKit.UIView[] views);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddSubviews(class MonoTouch.UIKit.UIView[] views) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="views" Type="MonoTouch.UIKit.UIView[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="views">An array of zero or more <see cref="T:MonoTouch.UIKit.UIView" />s.</param>
        <summary>Convenience routine to add various views to a UIView.</summary>
        <remarks>
          <para>
            This is merely a convenience routine that allows the application developer to add a number of views in a single call.
          </para>
          <example>
            <code lang="C#"><![CDATA[
myView.AddSubviews (label, button, entry, image1, image2);
            ]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AlignmentRectForFrame">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.RectangleF AlignmentRectForFrame (System.Drawing.RectangleF frame);" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Drawing.RectangleF AlignmentRectForFrame(valuetype System.Drawing.RectangleF frame) cil managed" apistyle="classic" />
      <MemberSignature Language="C#" Value="public virtual MonoTouch.CoreGraphics.CGRect AlignmentRectForFrame (MonoTouch.CoreGraphics.CGRect frame);" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype MonoTouch.CoreGraphics.CGRect AlignmentRectForFrame(valuetype MonoTouch.CoreGraphics.CGRect frame) cil managed" apistyle="unified" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("alignmentRectForFrame:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType apistyle="classic">System.Drawing.RectangleF</ReturnType>
        <ReturnType apistyle="unified">MonoTouch.CoreGraphics.CGRect</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="frame" Type="System.Drawing.RectangleF" apistyle="classic" />
        <Parameter Name="frame" Type="MonoTouch.CoreGraphics.CGRect" apistyle="unified" />
      </Parameters>
      <Docs>
        <param name="frame">A <see cref="T:System.Drawing.RectangleF" /> for which the alignment rectangle should be calculated.</param>
        <summary>Returns a customized alignment rectangle for Auto Layout.</summary>
        <returns>The alignment rectangle appropriate to the <paramref name="frame" />.</returns>
        <remarks>
          <para>By overriding this method, application developers can fully customize the alignment rectangle of the <see cref="T:MonoTouch.UIKit.UIView" />.Application developers who override this method must also override the complementary method <see cref="M:MonoTouch.UIKit.UIView.FrameForAlignmentRect" />. The two methods must provide complementary values.</para>
          <para>Auto Layout uses "alignment rectangles" to layout subviews rather than the subviews' <see cref="P:MonoTouch.UIKit.UIView.Frame" />. The <see cref="P:MonoTouch.UIKit.UIView.Frame" /> of a <see cref="T:MonoTouch.UIKit.UIView" /> may include visual elements, such as drop-shadows, that are not symmetrical around the <see cref="T:MonoTouch.UIKit.UIView" />'s logical center. The "alignment rectangle" for a <see cref="T:MonoTouch.UIKit.UIView" /> should be related to its logical content.</para>
          <para> By default, the "alignment rectangle" of a <see cref="T:MonoTouch.UIKit.UIView" /> is the <see cref="P:MonoTouch.UIKit.UIView.Frame" /> plus the <see cref="P:MonoTouch.UIKit.UIView.AlignmentRectInsets" />. The <see cref="M:MonoTouch.UIKit.UIView.AlignmentRectForFrame" /> and <see cref="M:MonoTouch.UIKit.UIView.FrameForAlignmentRect" /> methods can be used to fully customize the alignment rectangle.</para>
        </remarks>
        <altmember cref="M:MonoTouch.UIKit.UIView.FrameForAlignmentRect" />
        <altmember cref="M:MonoTouch.UIKit.UIView.AlignmentRectInsets" />
        <altmember cref="M:MonoTouch.UIKit.UIView.ViewForBaselineLayout" />
      </Docs>
    </Member>
    <Member MemberName="AlignmentRectInsets">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIEdgeInsets AlignmentRectInsets { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype MonoTouch.UIKit.UIEdgeInsets AlignmentRectInsets" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("alignmentRectInsets")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIEdgeInsets</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Adjustments to the <see cref="P:MonoTouch.UIKit.UIView.Frame" /> for use with Auto Layout.</summary>
        <value>The default value is an <see cref="T:MonoTouch.UIKit.UIEdgeInsets" /> whose values are all zero.</value>
        <remarks>
          <para>Application developers can use this property to modify the rectangle that is used by Auto Layout to control the <see cref="T:MonoTouch.UIKit.UIView" />'s ultimate alignment.</para>
          <para>Auto Layout uses "alignment rectangles" to layout subviews rather than the subviews' <see cref="P:MonoTouch.UIKit.UIView.Frame" />. The <see cref="P:MonoTouch.UIKit.UIView.Frame" /> of a <see cref="T:MonoTouch.UIKit.UIView" /> may include visual elements, such as drop-shadows, that are not symmetrical around the <see cref="T:MonoTouch.UIKit.UIView" />'s logical center. The "alignment rectangle" for a <see cref="T:MonoTouch.UIKit.UIView" /> should be related to its logical content.</para>
          <para> By default, the "alignment rectangle" of a <see cref="T:MonoTouch.UIKit.UIView" /> is the <see cref="P:MonoTouch.UIKit.UIView.Frame" /> plus the <see cref="P:MonoTouch.UIKit.UIView.AlignmentRectInsets" />. The <see cref="M:MonoTouch.UIKit.UIView.AlignmentRectForFrame" /> and <see cref="M:MonoTouch.UIKit.UIView.FrameForAlignmentRect" /> methods can be used to fully customize the alignment rectangle.</para>
        </remarks>
        <altmember cref="M:MonoTouch.UIKit.UIView.AlignmentRectForFrame" />
        <altmember cref="M:MonoTouch.UIKit.UIView.FrameForAlignmentRect" />
        <altmember cref="M:MonoTouch.UIKit.UIView.ViewForBaselineLayout" />
      </Docs>
    </Member>
    <Member MemberName="Alpha">
      <MemberSignature Language="C#" Value="public virtual float Alpha { get; set; }" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".property instance float32 Alpha" apistyle="classic" />
      <MemberSignature Language="C#" Value="public virtual nfloat Alpha { get; set; }" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.nfloat Alpha" apistyle="unified" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("alpha")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setAlpha:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType apistyle="classic">System.Single</ReturnType>
        <ReturnType apistyle="unified">System.nfloat</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Controls the transparency (alpha) value for the view.</summary>
        <value>0 to 1.</value>
        <remarks>
          <para>
            
            This controls the transparency for the view.  If the value
            is 1.0, the view is completely opaque, if the value is 0.0
            the view is completely transparent.    
          </para>
          <para>
            
            When the value of the view is in between 0 and 1, the
            contents of the view are composited with views that are
            lower in the view hierarchy or the superview.
            
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Animate" apistyle="classic">
      <MemberSignature Language="C#" Value="public static void Animate (double duration, MonoTouch.Foundation.NSAction animation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Animate(float64 duration, class MonoTouch.Foundation.NSAction animation) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("animateWithDuration:animations:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(4, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="animation" Type="MonoTouch.Foundation.NSAction">
          <Attributes>
            <Attribute>
              <AttributeName>MonoTouch.ObjCRuntime.BlockProxy(typeof(MonoTouch.ObjCRuntime.Trampolines/NIDNSAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="duration">Duration in seconds for the animation.</param>
        <param name="animation">Code that contains the changes that you will apply to your view.</param>
        <summary>Animates the property changes that take place in the specified action.</summary>
        <remarks>
          <para>
            This uses the CurveEaseOut and TransitionNone flags for the animation.
          </para>
          <example>
            <code lang="C#"><![CDATA[
// Animates hiding the label by setting the alpha to zero over three seconds.
UIView.Animate (3, () => { label.Alpha = 0; });
            ]]></code>
          </example>
        </remarks>
        <related type="recipe" href="http://docs.xamarin.com/ios/recipes/Animation/CoreAnimation/Animate_Using_Blocks" />
      </Docs>
    </Member>
    <Member MemberName="Animate" apistyle="unified">
      <MemberSignature Language="C#" Value="public static void Animate (double duration, Action animation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Animate(float64 duration, class System.Action animation) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("animateWithDuration:animations:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(4, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="animation" Type="System.Action">
          <Attributes>
            <Attribute>
              <AttributeName>MonoTouch.ObjCRuntime.BlockProxy(typeof(MonoTouch.ObjCRuntime.Trampolines/NIDAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="duration">Duration in seconds for the animation.</param>
        <param name="animation">Code containing the changes that you will apply to your view.</param>
        <summary>Animates the property changes that take place in the specified action.</summary>
        <remarks>
          <para>
            This uses the CurveEaseOut and TransitionNone flags for the animation.
          </para>
          <example>
            <code lang="C#"><![CDATA[
// Animates hiding the label by setting the alpha to zero over three seconds.
UIView.Animate (3, () => { label.Alpha = 0; });
            ]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Animate" apistyle="classic">
      <MemberSignature Language="C#" Value="public static void Animate (double duration, MonoTouch.Foundation.NSAction animation, MonoTouch.Foundation.NSAction completion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Animate(float64 duration, class MonoTouch.Foundation.NSAction animation, class MonoTouch.Foundation.NSAction completion) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="animation" Type="MonoTouch.Foundation.NSAction" />
        <Parameter Name="completion" Type="MonoTouch.Foundation.NSAction" />
      </Parameters>
      <Docs>
        <param name="duration">Duration in seconds for the animation.</param>
        <param name="animation">Code containing the changes that you will apply to your view.</param>
        <param name="completion">Code that is invoked when the animation completes.</param>
        <summary>Animates the property changes that take place in the specified action and invokes a completion callback when the animation completes.</summary>
        <remarks>
          <para>
            This uses The CurveEaseOut and TransitionNone flags for the animation.
          </para>
          <example>
            <code lang="C#"><![CDATA[
// Animates hiding the label by setting the alpha to zero over three seconds.
UIView.Animate (
duration: 3, 
animation: () => { view.Alpha = 0; },
completion: () => { view.RemoveFromSuperview (); });
            ]]></code>
          </example>
          <para>This method's <paramref name="completion" /> parameter is of type <see cref="T:MonoTouch.Foundation.NSAction" />, which does not receive a <c>Boolean finished</c> indicating whether the animation completed successfully. Application developers who rely on that value should instead use the <see cref="M:MonoTouch.UIKit.UIView.AnimateNotify" /> method.</para>
        </remarks>
        <related type="recipe" href="http://docs.xamarin.com/ios/recipes/Animation/CoreAnimation/Animate_Using_Blocks">Animate Using Blocks</related>
        <altmember cref="M:MonoTouch.UIKit.UIView.AnimateNotify" />
      </Docs>
    </Member>
    <Member MemberName="Animate" apistyle="unified">
      <MemberSignature Language="C#" Value="public static void Animate (double duration, Action animation, Action completion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Animate(float64 duration, class System.Action animation, class System.Action completion) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="animation" Type="System.Action" />
        <Parameter Name="completion" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="duration">Duration in seconds for the animation.</param>
        <param name="animation">Code containing the changes that you will apply to your view.</param>
        <param name="completion">Code that is invoked when the animation completes.</param>
        <summary>Animates the property changes that take place in the specified action and invokes a completion callback when the animation completes.</summary>
        <remarks>
          <para>
            This uses the CurveEaseOut and TransitionNone flags for the animation.
          </para>
          <example>
            <code lang="C#"><![CDATA[
// Animates hiding the label by setting the alpha to zero over three seconds.
UIView.Animate (3, () => { label.Alpha = 0; });
            ]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Animate" apistyle="classic">
      <MemberSignature Language="C#" Value="public static void Animate (double duration, double delay, MonoTouch.UIKit.UIViewAnimationOptions options, MonoTouch.Foundation.NSAction animation, MonoTouch.Foundation.NSAction completion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Animate(float64 duration, float64 delay, valuetype MonoTouch.UIKit.UIViewAnimationOptions options, class MonoTouch.Foundation.NSAction animation, class MonoTouch.Foundation.NSAction completion) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="delay" Type="System.Double" />
        <Parameter Name="options" Type="MonoTouch.UIKit.UIViewAnimationOptions" />
        <Parameter Name="animation" Type="MonoTouch.Foundation.NSAction" />
        <Parameter Name="completion" Type="MonoTouch.Foundation.NSAction" />
      </Parameters>
      <Docs>
        <param name="duration">Duration in seconds for the animation.</param>
        <param name="delay">Delay before the animation begins.</param>
        <param name="options">Animation options</param>
        <param name="animation">Code containing the changes that you will apply to your view. This action takes no parameters and returns no value. Do not use a null value for this parameter.</param>
        <param name="completion">Code that is invoked when the animation completes.</param>
        <summary>Creates an animation action that you can use to set up a keyframe-based animation. This action animates the property changes that take place in the specified action and invokes a completion callback when the animation completes.</summary>
        <remarks>
          <example>
            <code lang="C#"><![CDATA[
// Animates hiding the label by setting the alpha to zero over three seconds.
UIView.Animate (
  duration: 3, 
  delay: 0,
  options: UIViewAnimationOptions.AllowUserInteraction,
  animation: () => { view.Alpha = 0; },
  completion: () => { view.RemoveFromSuperview (); });
            ]]></code>
          </example>
          <para>This method's <paramref name="completion" /> parameter is of type <see cref="T:MonoTouch.Foundation.NSAction" />, which does not receive a <c>Boolean finished</c> indicating whether the animation completed successfully. Application developers who rely on that value should instead use the <see cref="M:MonoTouch.UIKit.UIView.AnimateNotify" /> method.</para>
        </remarks>
        <related type="recipe" href="http://docs.xamarin.com/ios/recipes/Animation/CoreAnimation/Animate_Using_Blocks" />
        <altmember cref="M:MonoTouch.UIKit.UIView.AnimateNotify" />
      </Docs>
    </Member>
    <Member MemberName="Animate" apistyle="unified">
      <MemberSignature Language="C#" Value="public static void Animate (double duration, double delay, MonoTouch.UIKit.UIViewAnimationOptions options, Action animation, Action completion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Animate(float64 duration, float64 delay, valuetype MonoTouch.UIKit.UIViewAnimationOptions options, class System.Action animation, class System.Action completion) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="delay" Type="System.Double" />
        <Parameter Name="options" Type="MonoTouch.UIKit.UIViewAnimationOptions" />
        <Parameter Name="animation" Type="System.Action" />
        <Parameter Name="completion" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="duration">Duration in seconds for the animation.</param>
        <param name="delay">Delay before the animation begins.</param>
        <param name="options">Animation options</param>
        <param name="animation">Code containing the changes that you will apply to your view.</param>
        <param name="completion">Code that is invoked when the animation completes.</param>
        <summary>Invokes animation changes to one or more views by specifying duration, delay, options, and a completion handler.</summary>
        <remarks>This method initiates a set of animations that areto be performed on this view. The action indicated in the animations parameter contains the code for the animation of the properties of one or more views.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AnimateAsync" apistyle="classic">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;bool&gt; AnimateAsync (double duration, MonoTouch.Foundation.NSAction animation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;bool&gt; AnimateAsync(float64 duration, class MonoTouch.Foundation.NSAction animation) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="animation" Type="MonoTouch.Foundation.NSAction" />
      </Parameters>
      <Docs>
        <param name="duration">Duration in seconds for the animation.</param>
        <param name="animation">Code containing the changes that you will apply to your view.</param>
        <summary>Animates the property changes that take place in the specified <paramref name="animation" /> as an asynchronous operation.</summary>
        <returns>A <see cref="T:System.Threading.Task&lt;T&gt;" /> whose <see cref="P:System.Threading.Task.Result" /> indicates whether the animation ran to completion or not.</returns>
        <remarks>
          <example>
            <code lang="C#"><![CDATA[
async void HideAsync()
{
	await UIView.AnimateAsync(3, () => label.Alpha = 0);
	label.RemoveFromSuperview();
	otherLabel.Text = "It's gone";
}
              ]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AnimateAsync" apistyle="unified">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;bool&gt; AnimateAsync (double duration, Action animation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;bool&gt; AnimateAsync(float64 duration, class System.Action animation) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="animation" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="duration">Duration in seconds for the animation.</param>
        <param name="animation">Code containing the changes that you will apply to your view.</param>
        <summary>Animates the property changes that take place in the specified <paramref name="animation" /> as an asynchronous operation.</summary>
        <returns>Indicates whether the animation ran to completion or not.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AnimateKeyframes" apistyle="classic">
      <MemberSignature Language="C#" Value="public static void AnimateKeyframes (double duration, double delay, MonoTouch.UIKit.UIViewKeyframeAnimationOptions options, MonoTouch.Foundation.NSAction animations, MonoTouch.UIKit.UICompletionHandler completion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AnimateKeyframes(float64 duration, float64 delay, valuetype MonoTouch.UIKit.UIViewKeyframeAnimationOptions options, class MonoTouch.Foundation.NSAction animations, class MonoTouch.UIKit.UICompletionHandler completion) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("animateKeyframesWithDuration:delay:options:animations:completion:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="delay" Type="System.Double" />
        <Parameter Name="options" Type="MonoTouch.UIKit.UIViewKeyframeAnimationOptions" />
        <Parameter Name="animations" Type="MonoTouch.Foundation.NSAction">
          <Attributes>
            <Attribute>
              <AttributeName>MonoTouch.ObjCRuntime.BlockProxy(typeof(MonoTouch.ObjCRuntime.Trampolines/NIDNSAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="completion" Type="MonoTouch.UIKit.UICompletionHandler">
          <Attributes>
            <Attribute>
              <AttributeName>MonoTouch.ObjCRuntime.BlockProxy(typeof(MonoTouch.ObjCRuntime.Trampolines/NIDUICompletionHandler))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="duration">Duration in seconds for the animation.</param>
        <param name="delay">Duration in seconds before starting the animation.</param>
        <param name="options">Designates a mask of options that indicates how the developer wants to perform the animations.</param>
        <param name="animations">An action object that contains the changes to be committed to the views.</param>
        <param name="completion">An action object that is to be executed when the animation sequence ends.</param>
        <summary>Animates the specified <paramref name="animations" /> action, in which keyframe animations may be used.</summary>
        <remarks>Creates an animation action that is to be used to set up a keyframe-based animation.
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AnimateKeyframes" apistyle="unified">
      <MemberSignature Language="C#" Value="public static void AnimateKeyframes (double duration, double delay, MonoTouch.UIKit.UIViewKeyframeAnimationOptions options, Action animations, MonoTouch.UIKit.UICompletionHandler completion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AnimateKeyframes(float64 duration, float64 delay, valuetype MonoTouch.UIKit.UIViewKeyframeAnimationOptions options, class System.Action animations, class MonoTouch.UIKit.UICompletionHandler completion) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("animateKeyframesWithDuration:delay:options:animations:completion:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="delay" Type="System.Double" />
        <Parameter Name="options" Type="MonoTouch.UIKit.UIViewKeyframeAnimationOptions" />
        <Parameter Name="animations" Type="System.Action">
          <Attributes>
            <Attribute>
              <AttributeName>MonoTouch.ObjCRuntime.BlockProxy(typeof(MonoTouch.ObjCRuntime.Trampolines/NIDAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="completion" Type="MonoTouch.UIKit.UICompletionHandler">
          <Attributes>
            <Attribute>
              <AttributeName>MonoTouch.ObjCRuntime.BlockProxy(typeof(MonoTouch.ObjCRuntime.Trampolines/NIDUICompletionHandler))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="duration">Duration in seconds for the animation.</param>
        <param name="delay">Duration in seconds before starting the animation.</param>
        <param name="options">Designates a mask of options that indicates how the developer wants to perform the animations.</param>
        <param name="animations">An action object that contains the changes to be committed to the views.</param>
        <param name="completion">An action object that is to be executed when the animation sequence ends.</param>
        <summary>Creates an animation action object that is to be used to set up keyframe-based animations for the current view.</summary>
        <remarks>Creates an animation action that is to be used to set up a keyframe-based animation.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AnimateKeyframesAsync" apistyle="classic">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;bool&gt; AnimateKeyframesAsync (double duration, double delay, MonoTouch.UIKit.UIViewKeyframeAnimationOptions options, MonoTouch.Foundation.NSAction animations);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;bool&gt; AnimateKeyframesAsync(float64 duration, float64 delay, valuetype MonoTouch.UIKit.UIViewKeyframeAnimationOptions options, class MonoTouch.Foundation.NSAction animations) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="delay" Type="System.Double" />
        <Parameter Name="options" Type="MonoTouch.UIKit.UIViewKeyframeAnimationOptions" />
        <Parameter Name="animations" Type="MonoTouch.Foundation.NSAction">
          <Attributes>
            <Attribute>
              <AttributeName>MonoTouch.ObjCRuntime.BlockProxy(typeof(MonoTouch.ObjCRuntime.Trampolines/NIDNSAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="duration">Duration in seconds for the animation.</param>
        <param name="delay">Duration in seconds before starting the animation.</param>
        <param name="options">Designates a mask of options that indicates how the developer wants to perform the animations.</param>
        <param name="animations">An action object that contains the changes to be committed to the views.</param>
        <summary>Animates the specified  action, in which keyframe animations may be used.</summary>
        <returns>
          <para>A task that represents the asynchronous AnimateKeyframes operation.   The value of the TResult parameter is a MonoTouch.UIKit.UICompletionHandler.</para>
        </returns>
        <remarks>
          <para>Keyframe sequences must be added using <see cref="M:MonoTouch.UIKit.UIView.AddKeyframeWithRelativeStartTime" />.</para>
          <para>Note that the start time and duration of the animation components of <paramref name="animations" /> are percentages of the overall animation <paramref name="duration" />. For instance, in the following example, the third keyframe starts at 1.5 seconds and takes 1.5 seconds to complete:</para>
          <example>
            <code lang="C#"><![CDATA[
async void AnimateAsync()
{
	var keyframe2 = new NSAction(delegate{
			label.Frame = new RectangleF(label.Frame.Left, label.Frame.Top + 250, label.Frame.Width, label.Frame.Height);
		});

	var keyframe3 = new NSAction(delegate{
			label.Frame = new RectangleF(label.Frame.Left - 250, label.Frame.Top, label.Frame.Width, label.Frame.Height);
		});

	var animationSucceeded = await UIView.AnimateKeyframesAsync(
		duration : 3,
		delay : 0,
		options: UIViewKeyframeAnimationOptions.AllowUserInteraction,
		animations: () => {
			UIView.AddKeyframeWithRelativeStartTime(0, 0.25, () => label.Frame = new RectangleF(label.Frame.Left + 250, label.Frame.Top, label.Frame.Width, label.Frame.Height)
				);
			UIView.AddKeyframeWithRelativeStartTime(0.25, 0.25, keyframe2);
			UIView.AddKeyframeWithRelativeStartTime(0.5, 0.5, keyframe3);
		}
	);

			label.Text = String.Format("Animation Completed? {0}", animationSucceeded);
}              
              ]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AnimateKeyframesAsync" apistyle="unified">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;bool&gt; AnimateKeyframesAsync (double duration, double delay, MonoTouch.UIKit.UIViewKeyframeAnimationOptions options, Action animations);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;bool&gt; AnimateKeyframesAsync(float64 duration, float64 delay, valuetype MonoTouch.UIKit.UIViewKeyframeAnimationOptions options, class System.Action animations) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="delay" Type="System.Double" />
        <Parameter Name="options" Type="MonoTouch.UIKit.UIViewKeyframeAnimationOptions" />
        <Parameter Name="animations" Type="System.Action">
          <Attributes>
            <Attribute>
              <AttributeName>MonoTouch.ObjCRuntime.BlockProxy(typeof(MonoTouch.ObjCRuntime.Trampolines/NIDAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="duration">Duration in seconds for the animation.</param>
        <param name="delay">Duration in seconds before starting the animation.</param>
        <param name="options">Designates a mask of options that indicates how the developer wants to perform the animations.</param>
        <param name="animations">This designates an action object that contains the changes to be committed to the views.</param>
        <summary>Animates the specified action, in which keyframe animations may be used.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AnimateNotify" apistyle="classic">
      <MemberSignature Language="C#" Value="public static void AnimateNotify (double duration, MonoTouch.Foundation.NSAction animation, MonoTouch.UIKit.UICompletionHandler completion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AnimateNotify(float64 duration, class MonoTouch.Foundation.NSAction animation, class MonoTouch.UIKit.UICompletionHandler completion) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("animateWithDuration:animations:completion:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(4, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="animation" Type="MonoTouch.Foundation.NSAction">
          <Attributes>
            <Attribute>
              <AttributeName>MonoTouch.ObjCRuntime.BlockProxy(typeof(MonoTouch.ObjCRuntime.Trampolines/NIDNSAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="completion" Type="MonoTouch.UIKit.UICompletionHandler">
          <Attributes>
            <Attribute>
              <AttributeName>MonoTouch.ObjCRuntime.BlockProxy(typeof(MonoTouch.ObjCRuntime.Trampolines/NIDUICompletionHandler))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="duration">Duration in seconds for the animation.</param>
        <param name="animation">Code containing the changes that you will apply to your view.</param>
        <param name="completion">
          <para>The method to invoke when the animation has completed.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Animates the property changes that take place in the specified action.</summary>
        <remarks>
        </remarks>
        <related type="recipe" href="http://docs.xamarin.com/ios/recipes/Animation/CoreAnimation/Animate_Using_Blocks" />
        <altmember cref="M:MonoTouch.UIKit.UIView.Animate" />
      </Docs>
    </Member>
    <Member MemberName="AnimateNotify" apistyle="unified">
      <MemberSignature Language="C#" Value="public static void AnimateNotify (double duration, Action animation, MonoTouch.UIKit.UICompletionHandler completion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AnimateNotify(float64 duration, class System.Action animation, class MonoTouch.UIKit.UICompletionHandler completion) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("animateWithDuration:animations:completion:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(4, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="animation" Type="System.Action">
          <Attributes>
            <Attribute>
              <AttributeName>MonoTouch.ObjCRuntime.BlockProxy(typeof(MonoTouch.ObjCRuntime.Trampolines/NIDAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="completion" Type="MonoTouch.UIKit.UICompletionHandler">
          <Attributes>
            <Attribute>
              <AttributeName>MonoTouch.ObjCRuntime.BlockProxy(typeof(MonoTouch.ObjCRuntime.Trampolines/NIDUICompletionHandler))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="duration">Duration in seconds for the animation.</param>
        <param name="animation">Code containing the changes that you will apply to your view.</param>
        <param name="completion">The method to invoke when the animation has completed.</param>
        <summary>Animates the property changes that take place in the specified action.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AnimateNotify" apistyle="classic">
      <MemberSignature Language="C#" Value="public static void AnimateNotify (double duration, double delay, MonoTouch.UIKit.UIViewAnimationOptions options, MonoTouch.Foundation.NSAction animation, MonoTouch.UIKit.UICompletionHandler completion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AnimateNotify(float64 duration, float64 delay, valuetype MonoTouch.UIKit.UIViewAnimationOptions options, class MonoTouch.Foundation.NSAction animation, class MonoTouch.UIKit.UICompletionHandler completion) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("animateWithDuration:delay:options:animations:completion:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(4, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="delay" Type="System.Double" />
        <Parameter Name="options" Type="MonoTouch.UIKit.UIViewAnimationOptions" />
        <Parameter Name="animation" Type="MonoTouch.Foundation.NSAction">
          <Attributes>
            <Attribute>
              <AttributeName>MonoTouch.ObjCRuntime.BlockProxy(typeof(MonoTouch.ObjCRuntime.Trampolines/NIDNSAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="completion" Type="MonoTouch.UIKit.UICompletionHandler">
          <Attributes>
            <Attribute>
              <AttributeName>MonoTouch.ObjCRuntime.BlockProxy(typeof(MonoTouch.ObjCRuntime.Trampolines/NIDUICompletionHandler))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="duration">Duration in seconds for the animation.</param>
        <param name="delay">Delay before the animation begins.</param>
        <param name="options">Animation options</param>
        <param name="animation">Code containing the changes that you will apply to your view.</param>
        <param name="completion">
          <para>The method to invoke when the animation has completed.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Animates the property changes that take place in the specified action and invokes a completion callback when the animation completes.</summary>
        <remarks>
        </remarks>
        <related type="recipe" href="http://docs.xamarin.com/ios/recipes/Animation/CoreAnimation/Animate_Using_Blocks" />
        <altmember cref="M:UIKit.UIView.Animate" />
      </Docs>
    </Member>
    <Member MemberName="AnimateNotify" apistyle="unified">
      <MemberSignature Language="C#" Value="public static void AnimateNotify (double duration, double delay, MonoTouch.UIKit.UIViewAnimationOptions options, Action animation, MonoTouch.UIKit.UICompletionHandler completion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AnimateNotify(float64 duration, float64 delay, valuetype MonoTouch.UIKit.UIViewAnimationOptions options, class System.Action animation, class MonoTouch.UIKit.UICompletionHandler completion) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("animateWithDuration:delay:options:animations:completion:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(4, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="delay" Type="System.Double" />
        <Parameter Name="options" Type="MonoTouch.UIKit.UIViewAnimationOptions" />
        <Parameter Name="animation" Type="System.Action">
          <Attributes>
            <Attribute>
              <AttributeName>MonoTouch.ObjCRuntime.BlockProxy(typeof(MonoTouch.ObjCRuntime.Trampolines/NIDAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="completion" Type="MonoTouch.UIKit.UICompletionHandler">
          <Attributes>
            <Attribute>
              <AttributeName>MonoTouch.ObjCRuntime.BlockProxy(typeof(MonoTouch.ObjCRuntime.Trampolines/NIDUICompletionHandler))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="duration">Duration in seconds for the animation.</param>
        <param name="delay">Delay before the animation begins.</param>
        <param name="options">Animation options</param>
        <param name="animation">Code containing the changes that you will apply to your view.</param>
        <param name="completion">The method to invoke when the animation has completed.</param>
        <summary>Animates the property changes that take place in the specified action and invokes a completion callback when the animation completes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AnimateNotify" apistyle="unified">
      <MemberSignature Language="C#" Value="public static void AnimateNotify (double duration, double delay, nfloat springWithDampingRatio, nfloat initialSpringVelocity, MonoTouch.UIKit.UIViewAnimationOptions options, Action animations, MonoTouch.UIKit.UICompletionHandler completion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AnimateNotify(float64 duration, float64 delay, valuetype System.nfloat springWithDampingRatio, valuetype System.nfloat initialSpringVelocity, valuetype MonoTouch.UIKit.UIViewAnimationOptions options, class System.Action animations, class MonoTouch.UIKit.UICompletionHandler completion) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("animateWithDuration:delay:usingSpringWithDamping:initialSpringVelocity:options:animations:completion:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="delay" Type="System.Double" />
        <Parameter Name="springWithDampingRatio" Type="System.nfloat" />
        <Parameter Name="initialSpringVelocity" Type="System.nfloat" />
        <Parameter Name="options" Type="MonoTouch.UIKit.UIViewAnimationOptions" />
        <Parameter Name="animations" Type="System.Action">
          <Attributes>
            <Attribute>
              <AttributeName>MonoTouch.ObjCRuntime.BlockProxy(typeof(MonoTouch.ObjCRuntime.Trampolines/NIDAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="completion" Type="MonoTouch.UIKit.UICompletionHandler">
          <Attributes>
            <Attribute>
              <AttributeName>MonoTouch.ObjCRuntime.BlockProxy(typeof(MonoTouch.ObjCRuntime.Trampolines/NIDUICompletionHandler))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="duration">Duration in seconds for the animation.</param>
        <param name="delay">Delay before the animation begins.</param>
        <param name="springWithDampingRatio">Damping ratio set for spring animation when it is approaching its quiescent state. Value between 0 and 1 representing the amount of damping to apply to the spring effect.</param>
        <param name="initialSpringVelocity">Initial spring velocity prior to attachment. The initial velocity of the spring, in points per second.</param>
        <param name="options">Animation options.</param>
        <param name="animations">Code containing the changes that you will apply to your view.</param>
        <param name="completion">
          <para>The method to invoke when the animation has completed.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AnimateNotify" apistyle="classic">
      <MemberSignature Language="C#" Value="public static void AnimateNotify (double duration, double delay, float springWithDampingRatio, float initialSpringVelocity, MonoTouch.UIKit.UIViewAnimationOptions options, MonoTouch.Foundation.NSAction animations, MonoTouch.UIKit.UICompletionHandler completion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AnimateNotify(float64 duration, float64 delay, float32 springWithDampingRatio, float32 initialSpringVelocity, valuetype MonoTouch.UIKit.UIViewAnimationOptions options, class MonoTouch.Foundation.NSAction animations, class MonoTouch.UIKit.UICompletionHandler completion) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("animateWithDuration:delay:usingSpringWithDamping:initialSpringVelocity:options:animations:completion:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="delay" Type="System.Double" />
        <Parameter Name="springWithDampingRatio" Type="System.Single" />
        <Parameter Name="initialSpringVelocity" Type="System.Single" />
        <Parameter Name="options" Type="MonoTouch.UIKit.UIViewAnimationOptions" />
        <Parameter Name="animations" Type="MonoTouch.Foundation.NSAction">
          <Attributes>
            <Attribute>
              <AttributeName>MonoTouch.ObjCRuntime.BlockProxy(typeof(MonoTouch.ObjCRuntime.Trampolines/NIDNSAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="completion" Type="MonoTouch.UIKit.UICompletionHandler">
          <Attributes>
            <Attribute>
              <AttributeName>MonoTouch.ObjCRuntime.BlockProxy(typeof(MonoTouch.ObjCRuntime.Trampolines/NIDUICompletionHandler))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="duration">Duration in seconds for the animation.</param>
        <param name="delay">Delay before the animation begins.</param>
        <param name="springWithDampingRatio">Value between 0 and 1 representing the amount of damping to apply to the spring effect.</param>
        <param name="initialSpringVelocity">The initial velocity of the spring, in points per second.</param>
        <param name="options">Animation options.</param>
        <param name="animations">The changes to be applied to the view.</param>
        <param name="completion">
          <para>The method to invoke when the animation completes.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Animates the specified property changes with an added spring-like effect.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AnimateNotifyAsync" apistyle="classic">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;bool&gt; AnimateNotifyAsync (double duration, MonoTouch.Foundation.NSAction animation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;bool&gt; AnimateNotifyAsync(float64 duration, class MonoTouch.Foundation.NSAction animation) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="animation" Type="MonoTouch.Foundation.NSAction">
          <Attributes>
            <Attribute>
              <AttributeName>MonoTouch.ObjCRuntime.BlockProxy(typeof(MonoTouch.ObjCRuntime.Trampolines/NIDNSAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="duration">Duration in seconds for the animation.</param>
        <param name="animation">Code containing the changes that you will apply to your view.</param>
        <summary>Animates the property changes that take place in the specified action and invokes a completion callback when the animation completes.</summary>
        <returns>
          <para>A task that represents the asynchronous AnimateNotify operation. The value of the TResult parameter is a MonoTouch.UIKit.UICompletionHandler.</para>
        </returns>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="AnimateNotifyAsync" apistyle="unified">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;bool&gt; AnimateNotifyAsync (double duration, Action animation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;bool&gt; AnimateNotifyAsync(float64 duration, class System.Action animation) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="animation" Type="System.Action">
          <Attributes>
            <Attribute>
              <AttributeName>MonoTouch.ObjCRuntime.BlockProxy(typeof(MonoTouch.ObjCRuntime.Trampolines/NIDAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="duration">Duration in seconds for the animation.</param>
        <param name="animation">Delay before the animation begins.</param>
        <summary>Animates the property changes that take place in the specified block and invokes a completion callback when the animation completes.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AnimateNotifyAsync" apistyle="classic">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;bool&gt; AnimateNotifyAsync (double duration, double delay, MonoTouch.UIKit.UIViewAnimationOptions options, MonoTouch.Foundation.NSAction animation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;bool&gt; AnimateNotifyAsync(float64 duration, float64 delay, valuetype MonoTouch.UIKit.UIViewAnimationOptions options, class MonoTouch.Foundation.NSAction animation) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="delay" Type="System.Double" />
        <Parameter Name="options" Type="MonoTouch.UIKit.UIViewAnimationOptions" />
        <Parameter Name="animation" Type="MonoTouch.Foundation.NSAction">
          <Attributes>
            <Attribute>
              <AttributeName>MonoTouch.ObjCRuntime.BlockProxy(typeof(MonoTouch.ObjCRuntime.Trampolines/NIDNSAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="duration">Duration in seconds for the animation.</param>
        <param name="delay">Delay before the animation begins.</param>
        <param name="options">Animation options.</param>
        <param name="animation">The changes to be applied to the view.</param>
        <summary>Executes the specified <paramref name="animation" /> as an asynchronous operation.</summary>
        <returns>A <see cref="T:System.Threading.Task`1" /> whose <see cref="P:System.Threading.Result" /> indicates whether the <paramref name="animations" /> completed.</returns>
        <remarks>.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AnimateNotifyAsync" apistyle="unified">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;bool&gt; AnimateNotifyAsync (double duration, double delay, MonoTouch.UIKit.UIViewAnimationOptions options, Action animation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;bool&gt; AnimateNotifyAsync(float64 duration, float64 delay, valuetype MonoTouch.UIKit.UIViewAnimationOptions options, class System.Action animation) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="delay" Type="System.Double" />
        <Parameter Name="options" Type="MonoTouch.UIKit.UIViewAnimationOptions" />
        <Parameter Name="animation" Type="System.Action">
          <Attributes>
            <Attribute>
              <AttributeName>MonoTouch.ObjCRuntime.BlockProxy(typeof(MonoTouch.ObjCRuntime.Trampolines/NIDAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="duration">Duration in seconds for the animation.</param>
        <param name="delay">Delay before the animation begins.</param>
        <param name="options">Animation options.</param>
        <param name="animation">The changes to be applied to the view.</param>
        <summary></summary>
        <returns></returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="AnimateNotifyAsync" apistyle="unified">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;bool&gt; AnimateNotifyAsync (double duration, double delay, nfloat springWithDampingRatio, nfloat initialSpringVelocity, MonoTouch.UIKit.UIViewAnimationOptions options, Action animations);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;bool&gt; AnimateNotifyAsync(float64 duration, float64 delay, valuetype System.nfloat springWithDampingRatio, valuetype System.nfloat initialSpringVelocity, valuetype MonoTouch.UIKit.UIViewAnimationOptions options, class System.Action animations) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="delay" Type="System.Double" />
        <Parameter Name="springWithDampingRatio" Type="System.nfloat" />
        <Parameter Name="initialSpringVelocity" Type="System.nfloat" />
        <Parameter Name="options" Type="MonoTouch.UIKit.UIViewAnimationOptions" />
        <Parameter Name="animations" Type="System.Action">
          <Attributes>
            <Attribute>
              <AttributeName>MonoTouch.ObjCRuntime.BlockProxy(typeof(MonoTouch.ObjCRuntime.Trampolines/NIDAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="duration">Duration in seconds for the animation.</param>
        <param name="delay">Delay before the animation begins.</param>
        <param name="springWithDampingRatio">Damping ratio set for spring animation when it is approaching its quiescent state. Value between 0 and 1 representing the amount of damping to apply to the spring effect.</param>
        <param name="initialSpringVelocity">Initial spring velocity prior to attachment. The initial velocity of the spring, in points per second.</param>
        <param name="options">Animation options</param>
        <param name="animations">Code containing the changes that you will apply to your view.</param>
        <summary></summary>
        <returns>
          <para>A task that represents the asynchronous AnimateNotify operation.   The value of the TResult parameter is a MonoTouch.UIKit.UICompletionHandler.</para>
        </returns>
        <remarks>
          <para copied="true">The AnimateNotifyAsync method is suitable to be used with C# async by returning control to the caller with a Task representing the operation.</para>
          <para copied="true"></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AnimateNotifyAsync" apistyle="classic">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;bool&gt; AnimateNotifyAsync (double duration, double delay, float springWithDampingRatio, float initialSpringVelocity, MonoTouch.UIKit.UIViewAnimationOptions options, MonoTouch.Foundation.NSAction animations);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;bool&gt; AnimateNotifyAsync(float64 duration, float64 delay, float32 springWithDampingRatio, float32 initialSpringVelocity, valuetype MonoTouch.UIKit.UIViewAnimationOptions options, class MonoTouch.Foundation.NSAction animations) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="delay" Type="System.Double" />
        <Parameter Name="springWithDampingRatio" Type="System.Single" />
        <Parameter Name="initialSpringVelocity" Type="System.Single" />
        <Parameter Name="options" Type="MonoTouch.UIKit.UIViewAnimationOptions" />
        <Parameter Name="animations" Type="MonoTouch.Foundation.NSAction">
          <Attributes>
            <Attribute>
              <AttributeName>MonoTouch.ObjCRuntime.BlockProxy(typeof(MonoTouch.ObjCRuntime.Trampolines/NIDNSAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="duration">Duration in seconds for the animation.</param>
        <param name="delay">Delay before the animation begins.</param>
        <param name="springWithDampingRatio">Value between 0 and 1 representing the amount of damping to apply to the spring effect.</param>
        <param name="initialSpringVelocity">The initial velocity of the spring, in points per second.</param>
        <param name="options">Animation options.</param>
        <param name="animations">The changes to be applied to the view.</param>
        <summary>Animates the specified property changes with an added spring-like effect.</summary>
        <returns>
          <para>A task that represents the asynchronous AnimateNotify operation.   The value of the Result parameter is a MonoTouch.UIKit.UICompletionHandler.</para>
        </returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AnimationsEnabled">
      <MemberSignature Language="C#" Value="public static bool AnimationsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool AnimationsEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("areAnimationsEnabled")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setAnimationsEnabled:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies whether animations are displayed or not.</summary>
        <value>The default value is <see langword="true" />.</value>
        <remarks>
          <para>Whether this is <see langword="true" /> or <see langword="false" />, the code inside animation blocks will execute. A <see langword="false" /> value simply means the animation does not display.</para>
          <para>Setting this value during an existing animation will not modify that animation's display.</para>
        </remarks>
        <altmember cref="M:MonoTouch.UIKit.UIView.PerformWithoutAnimation" />
      </Docs>
    </Member>
    <Member MemberName="AnimationWillEnd">
      <MemberSignature Language="C#" Value="public static event MonoTouch.Foundation.NSAction AnimationWillEnd;" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".event class MonoTouch.Foundation.NSAction AnimationWillEnd" apistyle="classic" />
      <MemberSignature Language="C#" Value="public static event Action AnimationWillEnd;" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".event class System.Action AnimationWillEnd" apistyle="unified" />
      <MemberType>Event</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType apistyle="classic">MonoTouch.Foundation.NSAction</ReturnType>
        <ReturnType apistyle="unified">System.Action</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>This event is raised when the animations will end.</summary>
        <remarks>
          Notice that these events are only fired as long as the application does not install its own animation delegate by calling <see cref="M:MonoTouch.UIKit.UIView.SetAnimationDelegate(MonoTouch.Foundation.NSObject)" />. 
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AnimationWillStart">
      <MemberSignature Language="C#" Value="public static event MonoTouch.Foundation.NSAction AnimationWillStart;" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".event class MonoTouch.Foundation.NSAction AnimationWillStart" apistyle="classic" />
      <MemberSignature Language="C#" Value="public static event Action AnimationWillStart;" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".event class System.Action AnimationWillStart" apistyle="unified" />
      <MemberType>Event</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType apistyle="classic">MonoTouch.Foundation.NSAction</ReturnType>
        <ReturnType apistyle="unified">System.Action</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>This event is raised when the animations will start.</summary>
        <remarks>
          Notice that these events are only fired as long as the application does not install its own animation delegate by calling <see cref="M:MonoTouch.UIKit.UIView.SetAnimationDelegate(MonoTouch.Foundation.NSObject)" />. 
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AnnouncementDidFinishNotification">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString AnnouncementDidFinishNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString AnnouncementDidFinishNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIAccessibilityAnnouncementDidFinishNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for AnnouncementDidFinish</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:MonoTouch.Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
    UIView.AnnouncementDidFinishNotification, (notification) => {
        Console.WriteLine ("Received the notification UIView", notification); 
    });


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIView", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIView.AnnouncementDidFinishNotification, Callback);
}
              ]]></code>
          </example>
        </remarks>
        <altmember cref="P:MonoTouch.UIKit.UIView.AnnouncementNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.AnnouncementDidFinishNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.ClosedCaptioningStatusDidChangeNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.GuidedAccessStatusDidChangeNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.InvertColorStatusDidChangeNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.AnnouncementNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.LayoutChangedNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.MonoAudioStatusDidChangeNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.PageScrolledNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.ScreenChangedNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.VoiceOverStatusChangedNotification" />
      </Docs>
    </Member>
    <Member MemberName="AnnouncementNotification">
      <MemberSignature Language="C#" Value="public static int AnnouncementNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 AnnouncementNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIAccessibilityAnnouncementNotification", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An accessibility notification that an announcement will happen.</summary>
        <value>.</value>
        <remarks></remarks>
        <altmember cref="P:MonoTouch.UIKit.UIView.AnnouncementNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.AnnouncementDidFinishNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.ClosedCaptioningStatusDidChangeNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.GuidedAccessStatusDidChangeNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.InvertColorStatusDidChangeNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.AnnouncementNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.LayoutChangedNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.MonoAudioStatusDidChangeNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.PageScrolledNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.ScreenChangedNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.VoiceOverStatusChangedNotification" />
      </Docs>
    </Member>
    <Member MemberName="Appearance">
      <MemberSignature Language="C#" Value="public static MonoTouch.UIKit.UIView.UIViewAppearance Appearance { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.UIKit.UIView/UIViewAppearance Appearance" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIView+UIViewAppearance</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Strongly-typed property that returns the UIAppearance class for this class.</summary>
        <value>
        </value>
        <remarks>Setting any appearance properties on this instance will affect the appearance of all instances of UIView.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppearanceWhenContainedIn">
      <MemberSignature Language="C#" Value="public static MonoTouch.UIKit.UIView.UIViewAppearance AppearanceWhenContainedIn (Type[] containers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class MonoTouch.UIKit.UIView/UIViewAppearance AppearanceWhenContainedIn(class System.Type[] containers) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIView+UIViewAppearance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containers" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="containers">List of types that you want to have as the containers to apply this particular appearance</param>
        <summary>Returns a strongly typed UIAppearance for instances of this class when the view is hosted in the specified hierarchy.</summary>
        <returns>The appearance proxy object that you can use to set properties when the given container hierarchy is active</returns>
        <remarks>
          <para>The returned object represents the UIAppearance proxy where you can set appearance properties for instances of UIView when those instances are contained in the hierarchy specified by the <paramref name="containers" /> parameter.</para>
          <para>The following example shows how the AppearanceWhenContainedIn method works</para>
          <example>
            <code lang="C#">
var mySliders = UISlider.AppearanceWhenContainedIn (typeof (UINavigationBar), typeof (UIPopoverController));
mySliders.TintColor = UIColor.Red;
</code>
          </example>
          <para>For more information, see the documentation for the <see cref="T:MonoTouch.UIKit.UIAppearance" /> class.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoresizingMask">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIViewAutoresizing AutoresizingMask { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype MonoTouch.UIKit.UIViewAutoresizing AutoresizingMask" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("autoresizingMask")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setAutoresizingMask:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIViewAutoresizing</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A bitmask that specifies how the receiver should resize itself when it's super-view's bounds change.</summary>
        <value>The default value is <see cref="P:MonoTouch.UIKit.UIViewAutoresizing.None" />.</value>
        <remarks>
          <para>Application developers may wish to use the more powerful Auto Layout capability rather than the older Autoresizing Mask capability.</para>
          <para>The <see cref="M:MonoTouch.UIKit.UIView.AutoresizingMask" /> is a powerful feature that handles a good deal of the complexity of resizing views, such as occurs during device rotation. However, it is not necessarily a complete solution. For instance, when using a <see cref="T:MonoTouch.UIKit.UIScrollView" />,  logic may require the <see cref="P:MonoTouch.UIKit.UIScrollView.ContentSize" /> to be resized. In such situations, application developers may subscribe to the <c>UIDeviceOrientationDidChangeNotification</c> and implement a custom method with additional resizing logic:</para>
          <example>
            <code lang="C#"><![CDATA[
//During initialization, subscribe to orientation changes              
NSNotificationCenter.DefaultCenter.AddObserver ("UIDeviceOrientationDidChangeNotification", DeviceRotated);

protected void DeviceRotated (NSNotification notification)
{
    //Code to resize UIScrollView.ContentSize and other custom on-rotation logic
}
              ]]></code>
          </example>
        </remarks>
        <altmember cref="M:MonoTouch.UIKit.UIView.AutoResizingMask" />
      </Docs>
    </Member>
    <Member MemberName="AutosizesSubviews">
      <MemberSignature Language="C#" Value="public virtual bool AutosizesSubviews { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutosizesSubviews" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("autoresizesSubviews")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setAutoresizesSubviews:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies whether the receiver should automatically resize its <see cref="P:MonoTouch.UIKit.UIView.Subviews" /> when the receiver's <see cref="P:MonoTouch.UIKit.UIView.Bounds" /> change.</summary>
        <value>The default value is <see langword="true" />.</value>
        <remarks>
          <para>If this value is <see langword="true" />, this <see cref="T:MonoTouch.UIKit.UIView" /> will resize its <see cref="P:MonoTouch.UIKit.UIView.Subviews" /> when this <see cref="T:MonoTouch.UIKit.UIView" />'s <see cref="P:MonoTouch.UIKit.UIView.Bounds" /> change.</para>
          <para>Application developers may wish to use the more powerful Auto Layout capability rather than the older Autoresizing Mask capability.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundColor">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIColor BackgroundColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIColor BackgroundColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("backgroundColor")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setBackgroundColor:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIColor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sets the background color of the <see cref="T:MonoTouch.UIKit.UIView" />.</summary>
        <value>
          <para>The default value is <see langword="null" />.</para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>
          <para>The <see cref="P:MonoTouch.UIKit.UIView.BackgroundColor" /> is the rear-most visible element of a <see cref="T:MonoTouch.UIKit.UIView" />, but developers should be aware that certain <see cref="T:MonoTouch.UIKit.UIView" /> subclasses such as <see cref="T:MonoTouch.UIKit.UITableViewCell" /> and <see cref="T:MonoTouch.UIKit.UICollectionViewCell" /> have a <see cref="P:MonoTouch.UIKit.UITableViewCell.BackgroundView" /> that may obscure their <see cref="P:MonoTouch.UIKit.UIView.BackgroundColor" />.</para>
          <para id="tool-remark">This member participates in the <see cref="T:MonoTouch.UIKit.UIAppearance" /> styling system.  See the <see cref="P:MonoTouch.UIKit.UIView.Appearance" /> property and the <see cref="M:MonoTouch.UIKit.UIView.AppearanceWhenContainedIn" /> method.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginAnimations">
      <MemberSignature Language="C#" Value="public static void BeginAnimations (string animation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginAnimations(string animation) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="animation" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="animation">The animation identifier.</param>
        <summary>Indicates the beginning of an animation block.</summary>
        <remarks>
          <para>Application developers should prefer to use the more compact syntax of the <see cref="M:MonoTouch.UIKit.UIView.Animate" /> method.</para>
          <para>Older versions of iOS used a matched set of <see cref="M:MonoTouch.UIKit.UIView.BeginAnimations" /> and <see cref="M:MonoTouch.UIKit.UIView.CommitAnimations" /> to specify an animation block. The following code, taken from the "Animate a UIView using UIKit" recipe, shows the technique:</para>
          <example>
            <code lang="C#"><![CDATA[
UIView.BeginAnimations ("slideAnimation");

UIView.SetAnimationDuration (2);
UIView.SetAnimationCurve (UIViewAnimationCurve.EaseInOut);
UIView.SetAnimationRepeatCount (2);
UIView.SetAnimationRepeatAutoreverses (true);
UIView.SetAnimationDelegate (this);
UIView.SetAnimationDidStopSelector (
  new Selector ("slideAnimationFinished:"));
_imageView.Center = new PointF (UIScreen.MainScreen.Bounds.Right -
  _imageView.Frame.Width / 2, _imageView.Center.Y);
UIView.CommitAnimations ();
              ]]></code>
          </example>
        </remarks>
        <altmember cref="M:MonoTouch.UIKit.UIView.CommitAnimations" />
        <related type="recipe" href="http://docs.xamarin.com/iOS/Recipes/Animation/CoreAnimation/Animate_a_UIView_using_UIKit" />
        <!-- TODO: Switch to UUID-based URL -->
      </Docs>
    </Member>
    <Member MemberName="BeginAnimations">
      <MemberSignature Language="C#" Value="public static void BeginAnimations (string animationID, IntPtr context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginAnimations(string animationID, native int context) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("beginAnimations:context:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="animationID" Type="System.String" />
        <Parameter Name="context" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="animationID">
          <para>The animation identifier.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <param name="context">A handle to custom data that provides context for the animation.</param>
        <summary>Indicates the beginning of an animation block</summary>
        <remarks>
          <para>Application developers should prefer to use the more compact syntax of the <see cref="M:MonoTouch.UIKit.UIView.Animate" /> method.</para>
          <para>If no native data is being used for <paramref name="context" />, application developers should specify <paramref name="context" /> as <see cref="F:System.IntPtr.Zero" />.        </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BoldTextStatusDidChangeNotification">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString BoldTextStatusDidChangeNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString BoldTextStatusDidChangeNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIAccessibilityBoldTextStatusDidChangeNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for BoldTextStatusDidChange</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:MonoTouch.Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <example>
            <code lang="c#">
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIView.BoldTextStatusDidChangeNotification, (notification) =&gt; {Console.WriteLine ("Received the notification UIView", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIView", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIView.BoldTextStatusDidChangeNotification, Callback);
}
</code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bounds">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.RectangleF Bounds { get; set; }" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.RectangleF Bounds" apistyle="classic" />
      <MemberSignature Language="C#" Value="public virtual MonoTouch.CoreGraphics.CGRect Bounds { get; set; }" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype MonoTouch.CoreGraphics.CGRect Bounds" apistyle="unified" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("bounds")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setBounds:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType apistyle="classic">System.Drawing.RectangleF</ReturnType>
        <ReturnType apistyle="unified">MonoTouch.CoreGraphics.CGRect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The usable frame of the view, specified using the view's own coordinate system.</summary>
        <value>
        </value>
        <remarks>
          <para>
            This property represents the usable
            frame of the view.  Unlike the <see cref="P:MonoTouch.UIKit.UIView.Frame" />, the <see cref="P:MonoTouch.UIKit.UIView.Bounds" /> do not use the container's
            coordinate space, but instead represent the size in the view's own
            coordinate space.  By default the <see cref="P:MonoTouch.UIKit.UIView.Bounds" /> location is
            (0,0).
          </para>
          <para>
            
            When you update this property, it will modify the <see cref="P:MonoTouch.UIKit.UIView.Frame" /> based on the value
            of the <see cref="P:MonoTouch.UIKit.UIView.Center" />.  You
            can also change the position of your view by updating the
            <see cref="P:MonoTouch.UIKit.UIView.Center" /> property.
            
          </para>
          <para>
            When the Bound property is changed, the size of the view is affected
            relative to the <see cref="P:MonoTouch.UIKit.UIView.Center" /> property.
          </para>
          <para>The <see cref="P:MonoTouch.UIKit.UIView.Bounds" /> property is relative to <c>this</c> <see cref="T:MonoTouch.UIKit.UIView" />'s coordinate system. For instance, the following example shows a view (a <see cref="T:MonoTouch.UIKit.UIImageView" />, actually) that has been rotated 45 degrees. The value of <c>flowerView.Bounds</c> remains [{0,0},{100,100}]. In contrast, the <see cref="P:MonoTouch.UIKit.UIView.Frame" /> property is expressed in terms of the containing view's coordinate system. In this case, after the rotation has been applied, the value of <c>flowerView.Frame</c> becomes [{79.3,79.3}, {141.4, 141.4}].</para>
          <example>
            <code lang="C#"><![CDATA[
var flowerView = new UIImageView(new RectangleF(100, 100, 100, 100)) {
	Image = UIImage.FromFile("flower.png"),
	ContentMode = UIViewContentMode.Center,
	ClipsToBounds = true
};

flowerView.Transform = CGAffineTransform.MakeRotation((float) Math.PI / 4);
view.AddSubview(flowerView);            
              ]]></code>
          </example>
          <para>
            <img href="UIKit.UIView.Frame.png" />
          </para>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BringSubviewToFront">
      <MemberSignature Language="C#" Value="public virtual void BringSubviewToFront (MonoTouch.UIKit.UIView view);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BringSubviewToFront(class MonoTouch.UIKit.UIView view) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("bringSubviewToFront:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="view" Type="MonoTouch.UIKit.UIView" />
      </Parameters>
      <Docs>
        <param name="view">
          <para>The subview to move to the front.</para>
        </param>
        <summary>Moves the specified subview so that it appears in front of other <see cref="P:MonoTouch.UIKit.UIView.Subviews" />.</summary>
        <remarks>
        </remarks>
        <altmember cref="M:MonoTouch.UIKit.UIView.SendSubviewToBack" />
      </Docs>
    </Member>
    <Member MemberName="Center">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.PointF Center { get; set; }" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.PointF Center" apistyle="classic" />
      <MemberSignature Language="C#" Value="public virtual MonoTouch.CoreGraphics.CGPoint Center { get; set; }" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype MonoTouch.CoreGraphics.CGPoint Center" apistyle="unified" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("center")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setCenter:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType apistyle="classic">System.Drawing.PointF</ReturnType>
        <ReturnType apistyle="unified">MonoTouch.CoreGraphics.CGPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The center of the view, in the container coordinate space.</summary>
        <value>This value is measured in points, not pixels.</value>
        <remarks>
          <para>
            When you update this property, this will automatically
            adjust corresponding  <see cref="P:MonoTouch.UIKit.UIView.Frame" />.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClassHandle">
      <MemberSignature Language="C#" Value="public override IntPtr ClassHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ClassHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The handle for this class.</summary>
        <value>The pointer to the Objective-C class.</value>
        <remarks>Each MonoTouch class mirrors an unmanaged Objective-C class.   This value contains the pointer to the Objective-C class, it is similar to calling objc_getClass with the object name.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearsContextBeforeDrawing">
      <MemberSignature Language="C#" Value="public virtual bool ClearsContextBeforeDrawing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ClearsContextBeforeDrawing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("clearsContextBeforeDrawing")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setClearsContextBeforeDrawing:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies that the drawing buffer be erased prior to calling <see cref="M:MonoTouch.UIKit.UIView.DrawRect" /></summary>
        <value>The default value is <see langword="true" />.</value>
        <remarks>
          <para>If this value is <see langword="true" />, the receiver's <see cref="P:MonoTouch.UIKit.UIView.Bounds" /> are erased and set to transparent black before the receiver's <see cref="M:MonoTouch.UIKit.UIView.DrawRect" /> method is called.</para>
          <para>If the application developer has written a highly optimized <see cref="M:MonoTouch.UIKit.UIView.DrawRect" />, this property can be set to <see langword="false" /> which may lead to a performance improvement.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClipsToBounds">
      <MemberSignature Language="C#" Value="public virtual bool ClipsToBounds { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ClipsToBounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("clipsToBounds")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setClipsToBounds:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies whether the <see cref="P:MonoTouch.UIKit.UIView.Subviews" /> are confined to the <see cref="P:MonoTouch.UIKit.UIView.Bounds" /> of the receiver.</summary>
        <value>The default value is <see langword="false" />.</value>
        <remarks>
          <para>If this property is <see langword="false" />, subviews whose <see cref="P:MonoTouch.UIKit.UIView.Frame" /> extends beyond their <see cref="P:MonoTouch.UIKit.UIView.Superview" />'s <see cref="P:MonoTouch.UIKit.UIView.Bounds" /> will be fully displayed. If this property is <see langword="true" />, only that portion that lies within their <see cref="P:MonoTouch.UIKit.UIView.Superview" />'s <see cref="P:MonoTouch.UIKit.UIView.Bounds" /> will be displayed. </para>
          <para>In the following image, the green rectangles are subviews of the blue rectangles (<c>var innerView = new UIView(new RectangleF(-10, 10, 175, 25));</c>). The top blue rectangle has its <see cref="P:MonoTouch.UIKit.UIView.ClipsToBounds" /> left at the default <see langword="false" /> value while the lower rectangle shows the clipping that occurs when <see cref="P:MonoTouch.UIKit.UIView.ClipsToBounds" /> is set to <see langword="true" />.</para>
          <para>
            <img href="MonoTouch.UIKit.UIView.ClipsToBounds.png" />
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClosedCaptioningStatusDidChangeNotification">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString ClosedCaptioningStatusDidChangeNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString ClosedCaptioningStatusDidChangeNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIAccessibilityClosedCaptioningStatusDidChangeNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(5, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(5, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for ClosedCaptioningStatusDidChange</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:MonoTouch.Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
    UIView.ClosedCaptioningStatusDidChangeNotification, (notification) => {
        Console.WriteLine ("Received the notification UIView", notification); 
    });

// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIView", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIView.ClosedCaptioningStatusDidChangeNotification, Callback);
}
              ]]></code>
          </example>
        </remarks>
        <altmember cref="P:MonoTouch.UIKit.UIView.AnnouncementNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.AnnouncementDidFinishNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.ClosedCaptioningStatusDidChangeNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.GuidedAccessStatusDidChangeNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.InvertColorStatusDidChangeNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.AnnouncementNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.LayoutChangedNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.MonoAudioStatusDidChangeNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.PageScrolledNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.ScreenChangedNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.VoiceOverStatusChangedNotification" />
      </Docs>
    </Member>
    <Member MemberName="CommitAnimations">
      <MemberSignature Language="C#" Value="public static void CommitAnimations ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CommitAnimations() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("commitAnimations")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indicates the end of an animation block.</summary>
        <remarks>
          <para>Application developers should prefer to use the more compact syntax of the <see cref="M:MonoTouch.UIKit.UIView.Animate" /> method.</para>
          <para>Older versions of iOS used a matched set of <see cref="M:MonoTouch.UIKit.UIView.BeginAnimations" /> and <see cref="M:MonoTouch.UIKit.UIView.CommitAnimations" /> to specify an animation block. The following code, taken from the "Animate a UIView using UIKit" recipe, shows the technique:</para>
          <example>
            <code lang="C#"><![CDATA[
  UIView.BeginAnimations ("slideAnimation");
  
  UIView.SetAnimationDuration (2);
  UIView.SetAnimationCurve (UIViewAnimationCurve.EaseInOut);
  UIView.SetAnimationRepeatCount (2);
  UIView.SetAnimationRepeatAutoreverses (true);
  UIView.SetAnimationDelegate (this);
  UIView.SetAnimationDidStopSelector (
    new Selector ("slideAnimationFinished:"));
  _imageView.Center = new PointF (UIScreen.MainScreen.Bounds.Right -
    _imageView.Frame.Width / 2, _imageView.Center.Y);
  UIView.CommitAnimations ();
              ]]></code>
          </example>
        </remarks>
        <altmember cref="M:MonoTouch.UIKit.UIView.BeginAnimations" />
        <related type="recipe" href="http://docs.xamarin.com/iOS/Recipes/Animation/CoreAnimation/Animate_a_UIView_using_UIKit" />
        <!-- TODO: Switch to UUID-based URL -->
      </Docs>
    </Member>
    <Member MemberName="Constraints">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.NSLayoutConstraint[] Constraints { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.NSLayoutConstraint[] Constraints" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("constraints")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.NSLayoutConstraint[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The constraints used by Auto Layout on this <see cref="T:MonoTouch.UIKit.UIView" />.</summary>
        <value>The default value is an empty array.</value>
        <remarks>
          <para>
            Auto Layout uses the <see cref="P:MonoTouch.UIKit.UIView.Constraints" /> of a <see cref="T:MonoTouch.UIKit.UIView" /> to lay out its <see cref="P:MonoTouch.UIKit.UIView.Subviews" />. These constraints are set with <see cref="M:MonoTouch.UIKit.UIView.AddConstraint" /> or <see cref="M:MonoTouch.UIKit.UIView.AddConstraints" />. 
          </para>
          <para>
            The <see cref="P:MonoTouch.UIKit.NSLayoutConstraint.DebugDescription" /> property can be helpful in debugging Auto Layout issues. 
          </para>
          <example>
            <code lang="C#"><![CDATA[
foreach(var c in mainView.Constraints)
{
    Console.WriteLine(c.DebugDescription);
}              
              ]]></code>
          </example>
        </remarks>
        <altmember cref="M:MonoTouch.UIKit.UIView.AddConstraint" />
        <altmember cref="M:MonoTouch.UIKit.UIView.AddConstraints" />
        <altmember cref="M:MonoTouch.UIKit.UIView.RemoveConstraint" />
        <altmember cref="M:MonoTouch.UIKit.UIView.RemoveConstraints" />
        <altmember cref="P:MonoTouch.UIKit.UIView.TranslatesAutoresizingMaskIntoConstraints" />
      </Docs>
    </Member>
    <Member MemberName="ContentCompressionResistancePriority">
      <MemberSignature Language="C#" Value="public virtual float ContentCompressionResistancePriority (MonoTouch.UIKit.UILayoutConstraintAxis axis);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float32 ContentCompressionResistancePriority(valuetype MonoTouch.UIKit.UILayoutConstraintAxis axis) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("contentCompressionResistancePriorityForAxis:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="axis" Type="MonoTouch.UIKit.UILayoutConstraintAxis" />
      </Parameters>
      <Docs>
        <param name="axis">The axis whose resistance is being queried.</param>
        <summary>Returns the resistance of an axis to compression below its intrinsic size.</summary>
        <returns>A <see cref="T:MonoTouch.UIKit.UILayoutPriority" /> that specifies how resistant the view is along the <paramref name="axis" /> to compression below its intrinsic size.</returns>
        <remarks>Application developers should not override this method. Instead, they should manipulate the result by using <see cref="M:MonoTouch.UIKit.UIView.SetContentCompressionResistancePriority" />.</remarks>
        <altmember cref="M:MonoTouch.UIKit.UIView.SetContentCompressionResistancePriority" />
      </Docs>
    </Member>
    <Member MemberName="ContentHuggingPriority">
      <MemberSignature Language="C#" Value="public virtual float ContentHuggingPriority (MonoTouch.UIKit.UILayoutConstraintAxis axis);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float32 ContentHuggingPriority(valuetype MonoTouch.UIKit.UILayoutConstraintAxis axis) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("contentHuggingPriorityForAxis:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="axis" Type="MonoTouch.UIKit.UILayoutConstraintAxis" />
      </Parameters>
      <Docs>
        <param name="axis">The axis whose resistance is being queried.</param>
        <summary>Returns the resistance of an axis to expansion larger than its intrinsic size.</summary>
        <returns>A <see cref="T:MonoTouch.UIKit.UILayoutPriority" /> that specifies how resistant the view is along the <paramref name="axis" /> to expansion beyond its intrinsic size.</returns>
        <remarks>Application developers should not override this method. Instead, they should manipulate the result by using <see cref="M:MonoTouch.UIKit.UIView.SetContentHuggingPriority" />.</remarks>
        <altmember cref="M:MonoTouch.UIKit.UIView.SetContentHuggingPriority" />
      </Docs>
    </Member>
    <Member MemberName="ContentMode">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIViewContentMode ContentMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype MonoTouch.UIKit.UIViewContentMode ContentMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("contentMode")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setContentMode:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIViewContentMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Controls how the cached bitmap of a view must be rendered when the view's bounds change.</summary>
        <value>
        </value>
        <remarks>
          <para>
            Used to control how the cached bitmap of the UIView changes when the <see cref="P:MonoTouch.UIKit.UIView.Frame" /> or <see cref="P:MonoTouch.UIKit.UIView.Bounds" /> properties are updated.   
          </para>
          <para>
            This property works in conjunction with the <see cref="P:MonoTouch.UIKit.UIView.ContentStretch" /> property.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentScaleFactor">
      <MemberSignature Language="C#" Value="public virtual float ContentScaleFactor { get; set; }" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".property instance float32 ContentScaleFactor" apistyle="classic" />
      <MemberSignature Language="C#" Value="public virtual nfloat ContentScaleFactor { get; set; }" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.nfloat ContentScaleFactor" apistyle="unified" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(4, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("contentScaleFactor")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(4, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setContentScaleFactor:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.ObjCRuntime.Since(4, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType apistyle="classic">System.Single</ReturnType>
        <ReturnType apistyle="unified">System.nfloat</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The number of device pixels per logical coordinate point.</summary>
        <value>The default value depends on the underlying hardware and the backing view type. The value is typically either 2.0 or 1.0.</value>
        <remarks>
          <para>The coordinate space used by application developers is measured in logical points. High-resolution (Retina) displays will have more than a single physical pixel per logical point and this property specifies the scale factor.</para>
          <para>
            <see cref="T:MonoTouch.UIKit.UIView" />s that are backed by a <see cref="T:MonoTouch.CoreAnimation.CAEAGLLayer" /> may return 1.0 even if they are being displayed on a high-resolution screen.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentStretch">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.RectangleF ContentStretch { get; set; }" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.RectangleF ContentStretch" apistyle="classic" />
      <MemberSignature Language="C#" Value="public virtual MonoTouch.CoreGraphics.CGRect ContentStretch { get; set; }" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype MonoTouch.CoreGraphics.CGRect ContentStretch" apistyle="unified" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Deprecated in iOS 6.0", false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("contentStretch")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setContentStretch:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType apistyle="classic">System.Drawing.RectangleF</ReturnType>
        <ReturnType apistyle="unified">MonoTouch.CoreGraphics.CGRect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Defines an area of the view that is intended to be stretchable.</summary>
        <value>
        </value>
        <remarks>This property was deprecated in iOS 6.0.   Developers are advised to use UIImageView with a stretchable UIImage instead.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertPointFromCoordinateSpace">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.PointF ConvertPointFromCoordinateSpace (System.Drawing.PointF point, MonoTouch.UIKit.IUICoordinateSpace coordinateSpace);" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Drawing.PointF ConvertPointFromCoordinateSpace(valuetype System.Drawing.PointF point, class MonoTouch.UIKit.IUICoordinateSpace coordinateSpace) cil managed" apistyle="classic" />
      <MemberSignature Language="C#" Value="public virtual MonoTouch.CoreGraphics.CGPoint ConvertPointFromCoordinateSpace (MonoTouch.CoreGraphics.CGPoint point, MonoTouch.UIKit.IUICoordinateSpace coordinateSpace);" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype MonoTouch.CoreGraphics.CGPoint ConvertPointFromCoordinateSpace(valuetype MonoTouch.CoreGraphics.CGPoint point, class MonoTouch.UIKit.IUICoordinateSpace coordinateSpace) cil managed" apistyle="unified" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("convertPoint:fromCoordinateSpace:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType apistyle="classic">System.Drawing.PointF</ReturnType>
        <ReturnType apistyle="unified">MonoTouch.CoreGraphics.CGPoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.PointF" apistyle="classic" />
        <Parameter Name="coordinateSpace" Type="MonoTouch.UIKit.IUICoordinateSpace" />
        <Parameter Name="point" Type="MonoTouch.CoreGraphics.CGPoint" apistyle="unified" />
      </Parameters>
      <Docs>
        <param name="point">A point whose location is in the coordinate system of the <paramref name="coordinateSpace" />.</param>
        <param name="coordinateSpace">Defines a region.</param>
        <summary>Converts a point from coordinate space.</summary>
        <returns>Point converted to the coordinate space.</returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertPointFromView">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.PointF ConvertPointFromView (System.Drawing.PointF point, MonoTouch.UIKit.UIView fromView);" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Drawing.PointF ConvertPointFromView(valuetype System.Drawing.PointF point, class MonoTouch.UIKit.UIView fromView) cil managed" apistyle="classic" />
      <MemberSignature Language="C#" Value="public virtual MonoTouch.CoreGraphics.CGPoint ConvertPointFromView (MonoTouch.CoreGraphics.CGPoint point, MonoTouch.UIKit.UIView fromView);" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype MonoTouch.CoreGraphics.CGPoint ConvertPointFromView(valuetype MonoTouch.CoreGraphics.CGPoint point, class MonoTouch.UIKit.UIView fromView) cil managed" apistyle="unified" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("convertPoint:fromView:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType apistyle="classic">System.Drawing.PointF</ReturnType>
        <ReturnType apistyle="unified">MonoTouch.CoreGraphics.CGPoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.PointF" apistyle="classic" />
        <Parameter Name="fromView" Type="MonoTouch.UIKit.UIView" />
        <Parameter Name="point" Type="MonoTouch.CoreGraphics.CGPoint" apistyle="unified" />
      </Parameters>
      <Docs>
        <param name="point">
          <para>A point whose location is in the coordinate system of the <paramref name="fromView" />.</para>
        </param>
        <param name="fromView">
          <para>The <see cref="T:MonoTouch.UIKit.UIView" /> in whose coordinate system the <paramref name="point" /> is expressed.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>
          <para>Returns the point, in the receiver's coordinate system, of the <paramref name="point" /> in the <paramref name="fromView" />'s coordinate space.</para>
        </summary>
        <returns>
          <para>The point, translated between coordinate systems.</para>
        </returns>
        <remarks>
          <para>
            The <see cref="P:MonoTouch.UIKit.UIView.Bounds" /> property specifies a local coordinate system. This method returns the location, in <c>this</c> <see cref="T:MonoTouch.UIKit.UIView" />'s <see cref="P:MonoTouch.UIKit.UIView.Bounds" /> coordinate system of the <paramref name="point" /> in <paramref name="fromView" />'s <see cref="P:MonoTouch.UIKit.UIView.Bounds" />' coordinate system.
          </para>
        </remarks>
        <altmember cref="M:MonoTouch.UIKit.ConvertPointToView" />
        <altmember cref="M:MonoTouch.UIKit.ConvertRectFromView" />
        <altmember cref="M:MonoTouch.UIKit.ConvertRectToView" />
      </Docs>
    </Member>
    <Member MemberName="ConvertPointToCoordinateSpace">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.PointF ConvertPointToCoordinateSpace (System.Drawing.PointF point, MonoTouch.UIKit.IUICoordinateSpace coordinateSpace);" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Drawing.PointF ConvertPointToCoordinateSpace(valuetype System.Drawing.PointF point, class MonoTouch.UIKit.IUICoordinateSpace coordinateSpace) cil managed" apistyle="classic" />
      <MemberSignature Language="C#" Value="public virtual MonoTouch.CoreGraphics.CGPoint ConvertPointToCoordinateSpace (MonoTouch.CoreGraphics.CGPoint point, MonoTouch.UIKit.IUICoordinateSpace coordinateSpace);" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype MonoTouch.CoreGraphics.CGPoint ConvertPointToCoordinateSpace(valuetype MonoTouch.CoreGraphics.CGPoint point, class MonoTouch.UIKit.IUICoordinateSpace coordinateSpace) cil managed" apistyle="unified" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("convertPoint:toCoordinateSpace:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType apistyle="classic">System.Drawing.PointF</ReturnType>
        <ReturnType apistyle="unified">MonoTouch.CoreGraphics.CGPoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.PointF" apistyle="classic" />
        <Parameter Name="coordinateSpace" Type="MonoTouch.UIKit.IUICoordinateSpace" />
        <Parameter Name="point" Type="MonoTouch.CoreGraphics.CGPoint" apistyle="unified" />
      </Parameters>
      <Docs>
        <param name="point">A point whose location is in the coordinate system of the <paramref name="coordinateSpace" />.</param>
        <param name="coordinateSpace">Defines a region.</param>
        <summary>Converts point to coordinate space.</summary>
        <returns>Point converted to coordinate space.</returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertPointToView">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.PointF ConvertPointToView (System.Drawing.PointF point, MonoTouch.UIKit.UIView toView);" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Drawing.PointF ConvertPointToView(valuetype System.Drawing.PointF point, class MonoTouch.UIKit.UIView toView) cil managed" apistyle="classic" />
      <MemberSignature Language="C#" Value="public virtual MonoTouch.CoreGraphics.CGPoint ConvertPointToView (MonoTouch.CoreGraphics.CGPoint point, MonoTouch.UIKit.UIView toView);" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype MonoTouch.CoreGraphics.CGPoint ConvertPointToView(valuetype MonoTouch.CoreGraphics.CGPoint point, class MonoTouch.UIKit.UIView toView) cil managed" apistyle="unified" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("convertPoint:toView:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType apistyle="classic">System.Drawing.PointF</ReturnType>
        <ReturnType apistyle="unified">MonoTouch.CoreGraphics.CGPoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.PointF" apistyle="classic" />
        <Parameter Name="toView" Type="MonoTouch.UIKit.UIView" />
        <Parameter Name="point" Type="MonoTouch.CoreGraphics.CGPoint" apistyle="unified" />
      </Parameters>
      <Docs>
        <param name="point">
          <para>A point whose location is in the coordinate system of <c>this</c> <see cref="T:MonoTouch.UIKit.UIView" />.</para>
        </param>
        <param name="toView">
          <para>The <see cref="T:MonoTouch.UIKit.UIView" /> to whose local coordinate system the point should be translated.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Returns the point, in the <paramref name="toView" />'s coordinate system, of the <paramref name="point" /> in <c>this</c> <see cref="T:MonoTouch.UIKit.UIView" />'s local coordinate system.</summary>
        <returns>
          <para>The point, translated between coordinated systems.</para>
        </returns>
        <remarks>
          <para>
            The <see cref="P:MonoTouch.UIKit.UIView.Bounds" /> property specifies a local coordinate system. This method returns the location, in <paramref name="toView" />'s <see cref="P:MonoTouch.UIKit.UIView.Bounds" />' coordinate system of the <paramref name="point" /> in <c>this</c> <see cref="T:MonoTouch.UIKit.UIView" />'s <see cref="P:MonoTouch.UIKit.UIView.Bounds" />' coordinate system.
          </para>
        </remarks>
        <altmember cref="M:MonoTouch.UIKit.ConvertPointFromView" />
        <altmember cref="M:MonoTouch.UIKit.ConvertRectFromView" />
        <altmember cref="M:MonoTouch.UIKit.ConvertRectToView" />
      </Docs>
    </Member>
    <Member MemberName="ConvertRectFromCoordinateSpace">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.RectangleF ConvertRectFromCoordinateSpace (System.Drawing.RectangleF rect, MonoTouch.UIKit.IUICoordinateSpace coordinateSpace);" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Drawing.RectangleF ConvertRectFromCoordinateSpace(valuetype System.Drawing.RectangleF rect, class MonoTouch.UIKit.IUICoordinateSpace coordinateSpace) cil managed" apistyle="classic" />
      <MemberSignature Language="C#" Value="public virtual MonoTouch.CoreGraphics.CGRect ConvertRectFromCoordinateSpace (MonoTouch.CoreGraphics.CGRect rect, MonoTouch.UIKit.IUICoordinateSpace coordinateSpace);" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype MonoTouch.CoreGraphics.CGRect ConvertRectFromCoordinateSpace(valuetype MonoTouch.CoreGraphics.CGRect rect, class MonoTouch.UIKit.IUICoordinateSpace coordinateSpace) cil managed" apistyle="unified" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("convertRect:fromCoordinateSpace:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType apistyle="classic">System.Drawing.RectangleF</ReturnType>
        <ReturnType apistyle="unified">MonoTouch.CoreGraphics.CGRect</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" apistyle="classic" />
        <Parameter Name="coordinateSpace" Type="MonoTouch.UIKit.IUICoordinateSpace" />
        <Parameter Name="rect" Type="MonoTouch.CoreGraphics.CGRect" apistyle="unified" />
      </Parameters>
      <Docs>
        <param name="rect">The <see cref="T:System.Drawing.RectangleF" /> expressed in the <paramref name="coordinateSpace" />'s local coordinate system.</param>
        <param name="coordinateSpace">Defines a region.</param>
        <summary>Converts a rectangle from coordinate space.</summary>
        <returns>Converted rectangle.</returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertRectFromView">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.RectangleF ConvertRectFromView (System.Drawing.RectangleF rect, MonoTouch.UIKit.UIView fromView);" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Drawing.RectangleF ConvertRectFromView(valuetype System.Drawing.RectangleF rect, class MonoTouch.UIKit.UIView fromView) cil managed" apistyle="classic" />
      <MemberSignature Language="C#" Value="public virtual MonoTouch.CoreGraphics.CGRect ConvertRectFromView (MonoTouch.CoreGraphics.CGRect rect, MonoTouch.UIKit.UIView fromView);" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype MonoTouch.CoreGraphics.CGRect ConvertRectFromView(valuetype MonoTouch.CoreGraphics.CGRect rect, class MonoTouch.UIKit.UIView fromView) cil managed" apistyle="unified" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("convertRect:fromView:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType apistyle="classic">System.Drawing.RectangleF</ReturnType>
        <ReturnType apistyle="unified">MonoTouch.CoreGraphics.CGRect</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" apistyle="classic" />
        <Parameter Name="fromView" Type="MonoTouch.UIKit.UIView" />
        <Parameter Name="rect" Type="MonoTouch.CoreGraphics.CGRect" apistyle="unified" />
      </Parameters>
      <Docs>
        <param name="rect">
          <para>The <see cref="T:System.Drawing.RectangleF" /> expressed in the <paramref name="fromView" />'s local coordinate system.</para>
        </param>
        <param name="fromView">
          <para>The <see cref="T:MonoTouch.UIKit.UIView" /> in whose coordinate system the <paramref name="rect" /> is expressed.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>
          <para>Returns the <see cref="T:System.Drawing.RectangleF" />, in the receiver's coordinate system, of the <paramref name="rect" /> in the <paramref name="fromView" />'s coordinate space.</para>
        </summary>
        <returns>
          <para>The rectangle, translated between coordinate systems.</para>
        </returns>
        <remarks>
          <para>
            The <see cref="P:MonoTouch.UIKit.UIView.Bounds" /> property specifies a local coordinate system. This method returns the location, in <c>this</c> <see cref="T:MonoTouch.UIKit.UIView" />'s <see cref="P:MonoTouch.UIKit.UIView.Bounds" /> coordinate system of the <paramref name="rect" /> in <paramref name="fromView" />'s <see cref="P:MonoTouch.UIKit.UIView.Bounds" />' coordinate system.
          </para>
        </remarks>
        <altmember cref="M:MonoTouch.UIKit.ConvertPointFromView" />
        <altmember cref="M:MonoTouch.UIKit.ConvertPointToView" />
        <altmember cref="M:MonoTouch.UIKit.ConvertRectToView" />
      </Docs>
    </Member>
    <Member MemberName="ConvertRectToCoordinateSpace">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.RectangleF ConvertRectToCoordinateSpace (System.Drawing.RectangleF rect, MonoTouch.UIKit.IUICoordinateSpace coordinateSpace);" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Drawing.RectangleF ConvertRectToCoordinateSpace(valuetype System.Drawing.RectangleF rect, class MonoTouch.UIKit.IUICoordinateSpace coordinateSpace) cil managed" apistyle="classic" />
      <MemberSignature Language="C#" Value="public virtual MonoTouch.CoreGraphics.CGRect ConvertRectToCoordinateSpace (MonoTouch.CoreGraphics.CGRect rect, MonoTouch.UIKit.IUICoordinateSpace coordinateSpace);" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype MonoTouch.CoreGraphics.CGRect ConvertRectToCoordinateSpace(valuetype MonoTouch.CoreGraphics.CGRect rect, class MonoTouch.UIKit.IUICoordinateSpace coordinateSpace) cil managed" apistyle="unified" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("convertRect:toCoordinateSpace:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType apistyle="classic">System.Drawing.RectangleF</ReturnType>
        <ReturnType apistyle="unified">MonoTouch.CoreGraphics.CGRect</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" apistyle="classic" />
        <Parameter Name="coordinateSpace" Type="MonoTouch.UIKit.IUICoordinateSpace" />
        <Parameter Name="rect" Type="MonoTouch.CoreGraphics.CGRect" apistyle="unified" />
      </Parameters>
      <Docs>
        <param name="rect">The <see cref="T:System.Drawing.RectangleF" /> expressed in the <paramref name="coordinateSpace" />'s local coordinate system.</param>
        <param name="coordinateSpace">Defines a region.</param>
        <summary>Converts a rectangle TO coordinate space.</summary>
        <returns></returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertRectToView">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.RectangleF ConvertRectToView (System.Drawing.RectangleF rect, MonoTouch.UIKit.UIView toView);" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Drawing.RectangleF ConvertRectToView(valuetype System.Drawing.RectangleF rect, class MonoTouch.UIKit.UIView toView) cil managed" apistyle="classic" />
      <MemberSignature Language="C#" Value="public virtual MonoTouch.CoreGraphics.CGRect ConvertRectToView (MonoTouch.CoreGraphics.CGRect rect, MonoTouch.UIKit.UIView toView);" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype MonoTouch.CoreGraphics.CGRect ConvertRectToView(valuetype MonoTouch.CoreGraphics.CGRect rect, class MonoTouch.UIKit.UIView toView) cil managed" apistyle="unified" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("convertRect:toView:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType apistyle="classic">System.Drawing.RectangleF</ReturnType>
        <ReturnType apistyle="unified">MonoTouch.CoreGraphics.CGRect</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" apistyle="classic" />
        <Parameter Name="toView" Type="MonoTouch.UIKit.UIView" />
        <Parameter Name="rect" Type="MonoTouch.CoreGraphics.CGRect" apistyle="unified" />
      </Parameters>
      <Docs>
        <param name="rect">
          <para>The <see cref="T:System.Drawing.RectangleF" /> expressed in this <see cref="T:MonoTouch.UIKit.UIView" /> local coordinate system.</para>
        </param>
        <param name="toView">
          <para>The <see cref="T:MonoTouch.UIKit.UIView" /> to whose local coordinate system the <paramref name="rect" /> should be translated.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Returns the <see cref="T:System.Drawing.RectangleF" />, in the <paramref name="toView" />'s coordinate system, of the <paramref name="rect" /> in <c>this</c> <see cref="T:MonoTouch.UIKit.UIView" />'s local coordinate system.</summary>
        <returns>
          <para>The rectangle, translated between coordinated systems.</para>
        </returns>
        <remarks>
          <para>
            The <see cref="P:MonoTouch.UIKit.UIView.Bounds" /> property specifies a local coordinate system. This method returns the rectangle, in <paramref name="toView" />'s <see cref="P:MonoTouch.UIKit.UIView.Bounds" />' coordinate system of the <paramref name="rect" /> in <c>this</c> <see cref="T:MonoTouch.UIKit.UIView" />'s <see cref="P:MonoTouch.UIKit.UIView.Bounds" />' coordinate system.
          </para>
        </remarks>
        <altmember cref="M:MonoTouch.UIKit.ConvertPointFromView" />
        <altmember cref="M:MonoTouch.UIKit.ConvertPointToView" />
        <altmember cref="M:MonoTouch.UIKit.ConvertRectFromView" />
      </Docs>
    </Member>
    <Member MemberName="DarkerSystemColorsStatusDidChangeNotification">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString DarkerSystemColorsStatusDidChangeNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString DarkerSystemColorsStatusDidChangeNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIAccessibilityDarkerSystemColorsStatusDidChangeNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for DarkerSystemColorsStatusDidChange</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:MonoTouch.Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <example>
            <code lang="c#">
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIView.DarkerSystemColorsStatusDidChangeNotification, (notification) =&gt; {Console.WriteLine ("Received the notification UIView", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIView", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIView.DarkerSystemColorsStatusDidChangeNotification, Callback);
}
</code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DecodeRestorableState">
      <MemberSignature Language="C#" Value="public virtual void DecodeRestorableState (MonoTouch.Foundation.NSCoder coder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DecodeRestorableState(class MonoTouch.Foundation.NSCoder coder) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("decodeRestorableStateWithCoder:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="coder" Type="MonoTouch.Foundation.NSCoder" />
      </Parameters>
      <Docs>
        <param name="coder">The <see cref="T:MonoTouch.Foundation.NSCoder" /> used to decode the state.</param>
        <summary>Application developers can override this method to support state restoration.</summary>
        <remarks />
        <altmember cref="M:Monotouch.UIKit.UIView.EncodeRestorableState" />
        <altmember cref="M:MonoTouch.UIKit.UIApplicationDelegate.ShouldRestoreApplicationState" />
        <altmember cref="M:MonoTouch.UIKit.UIApplicationDelegate.ShouldSaveApplicationState" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <para>If set to <see langword="true" />, the method is invoked directly and will dispose manage and unmanaged resources;   If set to <see langword="false" /> the method is being called by the garbage collector finalizer and should only release unmanaged resources.</para>
        </param>
        <summary>Releases the resources used by the UIView object.</summary>
        <remarks>
          <para>This Dispose method releases the resources used by the UIView class.</para>
          <para>This method is called by both the Dispose() method and the object finalizer (Finalize).    When invoked by the Dispose method, the parameter disposing <paramref name="disposing" /> is set to <see langword="true" /> and any managed object references that this object holds are also disposed or released;  when invoked by the object finalizer, on the finalizer thread the value is set to <see langword="false" />. </para>
          <para>Calling the Dispose method when you are finished using the UIView ensures that all external resources used by this managed object are released as soon as possible.  Once you have invoked the Dispose method, the object is no longer useful and you should no longer make any calls to it.</para>
          <para>  For more information on how to override this method and on the Dispose/IDisposable pattern, read the ``Implementing a Dispose Method'' document at http://msdn.microsoft.com/en-us/library/fs2xkftw.aspx</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Draw">
      <MemberSignature Language="C#" Value="public virtual void Draw (System.Drawing.RectangleF rect);" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Draw(valuetype System.Drawing.RectangleF rect) cil managed" apistyle="classic" />
      <MemberSignature Language="C#" Value="public virtual void Draw (MonoTouch.CoreGraphics.CGRect rect);" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Draw(valuetype MonoTouch.CoreGraphics.CGRect rect) cil managed" apistyle="unified" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("drawRect:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" apistyle="classic" />
        <Parameter Name="rect" Type="MonoTouch.CoreGraphics.CGRect" apistyle="unified" />
      </Parameters>
      <Docs>
        <param name="rect">
          <para>The <see cref="T:System.Drawing.RectangleF" /> to draw.</para>
        </param>
        <summary>Draws the view within the passed-in rectangle.</summary>
        <remarks>
          <para>
            The <see cref="M:MonoTouch.UIKit.UIView.Draw" /> method should never be called directly. It is called by iOS
            during run loop processing. The first time through the run loop, it
            is called. After that, it will be called on demand whenever the view
            has been marked as needing display by calling <see cref="M:MonoTouch.UIKit.UIView.SetNeedsDisplay" /> or
            <see cref="M:MonoTouch.UIKit.UIView.SetNeedsDisplayInRect(System.Drawing.RectangleF)" />.
          </para>
          <para>
            Core Graphics uses device independent points rather than
            pixels. This allows drawing code to scale between different
            resolutions. For example, on a Retina display, 1 point is equivalent
            to 2 pixels, while on non-Retina displays, 1 point corresponds to 1
            pixel.
          </para>
          <example>
            <code lang="C#"><![CDATA[
public override void Draw (RectangleF rect)
{
    base.Draw (rect);

    var context = UIGraphics.GetCurrentContext ();

    context.SetLineWidth(4);
    UIColor.Red.SetFill ();
    UIColor.Blue.SetStroke ();

    var path = new CGPath ();

    path.AddLines(new PointF[]{
    new PointF(100,200),
    new PointF(160,100), 
    new PointF(220,200)});

    path.CloseSubpath();

    context.AddPath(path);		
    context.DrawPath(CGPathDrawingMode.FillStroke);
}
              ]]></code>
          </example>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawRect">
      <MemberSignature Language="C#" Value="public virtual void DrawRect (System.Drawing.RectangleF area, MonoTouch.UIKit.UIViewPrintFormatter formatter);" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawRect(valuetype System.Drawing.RectangleF area, class MonoTouch.UIKit.UIViewPrintFormatter formatter) cil managed" apistyle="classic" />
      <MemberSignature Language="C#" Value="public virtual void DrawRect (MonoTouch.CoreGraphics.CGRect area, MonoTouch.UIKit.UIViewPrintFormatter formatter);" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawRect(valuetype MonoTouch.CoreGraphics.CGRect area, class MonoTouch.UIKit.UIViewPrintFormatter formatter) cil managed" apistyle="unified" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("drawRect:forViewPrintFormatter:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(4, 2)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="area" Type="System.Drawing.RectangleF" apistyle="classic" />
        <Parameter Name="formatter" Type="MonoTouch.UIKit.UIViewPrintFormatter" />
        <Parameter Name="area" Type="MonoTouch.CoreGraphics.CGRect" apistyle="unified" />
      </Parameters>
      <Docs>
        <param name="area">The region to be printed.</param>
        <param name="formatter">The configured UIViewPrintFormatter,
          which is obtained by accessing the <see cref="P:MonoTouch.UIKit.UIView.PrintFormatter" /> property.</param>
        <summary>Draws a region for printing.</summary>
        <remarks>
          <para>
            UIViews can be printed.  The default behavior is for the contents of
            the UIView as rendered by the <see cref="M:MonoTouch.UIKit.UIView.Draw(System.Drawing.RectangleF)" />
            method to be printed.
          </para>
          <para>
            You should override the <see cref="M:MonoTouch.UIKit.UIView.DrawRect(System.Drawing.RectangleF,MonoTouch.UIKit.UIView.UIViewPrintFormatter)" />
            method if you want to provide a different implementation
            while printing.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF DrawString (string str, System.Drawing.PointF point, MonoTouch.UIKit.UIFont font);" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF DrawString(string str, valuetype System.Drawing.PointF point, class MonoTouch.UIKit.UIFont font) cil managed" apistyle="classic" />
      <MemberSignature Language="C#" Value="public MonoTouch.CoreGraphics.CGSize DrawString (string str, MonoTouch.CoreGraphics.CGPoint point, MonoTouch.UIKit.UIFont font);" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype MonoTouch.CoreGraphics.CGSize DrawString(string str, valuetype MonoTouch.CoreGraphics.CGPoint point, class MonoTouch.UIKit.UIFont font) cil managed" apistyle="unified" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType apistyle="classic">System.Drawing.SizeF</ReturnType>
        <ReturnType apistyle="unified">MonoTouch.CoreGraphics.CGSize</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="point" Type="System.Drawing.PointF" apistyle="classic" />
        <Parameter Name="font" Type="MonoTouch.UIKit.UIFont" />
        <Parameter Name="point" Type="MonoTouch.CoreGraphics.CGPoint" apistyle="unified" />
      </Parameters>
      <Docs>
        <param name="str">The string to draw.</param>
        <param name="point">The origin of the text drawing rectangle.</param>
        <param name="font">The font to use in drawing.</param>
        <summary>Draws the specified text at the specified location with the specified font.</summary>
        <returns>The actual size of the font with which the text was rendered.</returns>
        <remarks>
          <para>The <paramref name="point" /> specifies the origin (not the text baseline) of the drawing rectangle. In other words, the text will render below and to the right of the <paramref name="point" />.</para>
          <para>This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF DrawString (string str, System.Drawing.RectangleF rect, MonoTouch.UIKit.UIFont font);" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF DrawString(string str, valuetype System.Drawing.RectangleF rect, class MonoTouch.UIKit.UIFont font) cil managed" apistyle="classic" />
      <MemberSignature Language="C#" Value="public MonoTouch.CoreGraphics.CGSize DrawString (string str, MonoTouch.CoreGraphics.CGRect rect, MonoTouch.UIKit.UIFont font);" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype MonoTouch.CoreGraphics.CGSize DrawString(string str, valuetype MonoTouch.CoreGraphics.CGRect rect, class MonoTouch.UIKit.UIFont font) cil managed" apistyle="unified" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType apistyle="classic">System.Drawing.SizeF</ReturnType>
        <ReturnType apistyle="unified">MonoTouch.CoreGraphics.CGSize</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="rect" Type="System.Drawing.RectangleF" apistyle="classic" />
        <Parameter Name="font" Type="MonoTouch.UIKit.UIFont" />
        <Parameter Name="rect" Type="MonoTouch.CoreGraphics.CGRect" apistyle="unified" />
      </Parameters>
      <Docs>
        <param name="str">String to draw.</param>
        <param name="rect">Bounding rectangle.</param>
        <param name="font">Font to use to draw the string.</param>
        <summary>
          <para>
	    Deprecated in iOS7.  Use NSString.DrawString(PointF, UIStringAttributes) instead.
	  </para>
          <para>
	    Draws the string in the specified rectangle with the specified font.
	  </para>
        </summary>
        <returns>The actual size used by the rendering.</returns>
        <remarks>
          <para>This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF DrawString (string str, System.Drawing.RectangleF rect, MonoTouch.UIKit.UIFont font, MonoTouch.UIKit.UILineBreakMode mode);" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF DrawString(string str, valuetype System.Drawing.RectangleF rect, class MonoTouch.UIKit.UIFont font, valuetype MonoTouch.UIKit.UILineBreakMode mode) cil managed" apistyle="classic" />
      <MemberSignature Language="C#" Value="public MonoTouch.CoreGraphics.CGSize DrawString (string str, MonoTouch.CoreGraphics.CGRect rect, MonoTouch.UIKit.UIFont font, MonoTouch.UIKit.UILineBreakMode mode);" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype MonoTouch.CoreGraphics.CGSize DrawString(string str, valuetype MonoTouch.CoreGraphics.CGRect rect, class MonoTouch.UIKit.UIFont font, valuetype MonoTouch.UIKit.UILineBreakMode mode) cil managed" apistyle="unified" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType apistyle="classic">System.Drawing.SizeF</ReturnType>
        <ReturnType apistyle="unified">MonoTouch.CoreGraphics.CGSize</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="rect" Type="System.Drawing.RectangleF" apistyle="classic" />
        <Parameter Name="font" Type="MonoTouch.UIKit.UIFont" />
        <Parameter Name="mode" Type="MonoTouch.UIKit.UILineBreakMode" />
        <Parameter Name="rect" Type="MonoTouch.CoreGraphics.CGRect" apistyle="unified" />
      </Parameters>
      <Docs>
        <param name="str">String to draw.</param>
        <param name="rect">Bounding rectangle.</param>
        <param name="font">Font to use to draw the string.</param>
        <param name="mode">The linebreak mode to use to draw the string.</param>
        <summary>
          <para>
	    Deprecated in iOS7.  Use NSString.DrawString(RectangleF, UIStringAttributes) instead
	  </para>
          <para>
	    Draws the string in the specified rectangle with the specified font.
	  </para>
        </summary>
        <returns>The actual size used by the rendering.</returns>
        <remarks>
          <para>This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF DrawString (string str, System.Drawing.RectangleF rect, MonoTouch.UIKit.UIFont font, MonoTouch.UIKit.UILineBreakMode mode, MonoTouch.UIKit.UITextAlignment alignment);" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF DrawString(string str, valuetype System.Drawing.RectangleF rect, class MonoTouch.UIKit.UIFont font, valuetype MonoTouch.UIKit.UILineBreakMode mode, valuetype MonoTouch.UIKit.UITextAlignment alignment) cil managed" apistyle="classic" />
      <MemberSignature Language="C#" Value="public MonoTouch.CoreGraphics.CGSize DrawString (string str, MonoTouch.CoreGraphics.CGRect rect, MonoTouch.UIKit.UIFont font, MonoTouch.UIKit.UILineBreakMode mode, MonoTouch.UIKit.UITextAlignment alignment);" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype MonoTouch.CoreGraphics.CGSize DrawString(string str, valuetype MonoTouch.CoreGraphics.CGRect rect, class MonoTouch.UIKit.UIFont font, valuetype MonoTouch.UIKit.UILineBreakMode mode, valuetype MonoTouch.UIKit.UITextAlignment alignment) cil managed" apistyle="unified" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType apistyle="classic">System.Drawing.SizeF</ReturnType>
        <ReturnType apistyle="unified">MonoTouch.CoreGraphics.CGSize</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="rect" Type="System.Drawing.RectangleF" apistyle="classic" />
        <Parameter Name="font" Type="MonoTouch.UIKit.UIFont" />
        <Parameter Name="mode" Type="MonoTouch.UIKit.UILineBreakMode" />
        <Parameter Name="alignment" Type="MonoTouch.UIKit.UITextAlignment" />
        <Parameter Name="rect" Type="MonoTouch.CoreGraphics.CGRect" apistyle="unified" />
      </Parameters>
      <Docs>
        <param name="str">String to draw.</param>
        <param name="rect">Bounding rectangle.</param>
        <param name="font">Font to use to draw the string.</param>
        <param name="mode">The linebreak mode to use to draw the string.</param>
        <param name="alignment">The text alignment to use when drawing the string.</param>
        <summary>
          <para>Deprecated in iOS7.  Use NSString.DrawString(RectangleF, UIStringAttributes) instead</para>
          <para>Draws the string in the specified rectangle with the specified font.</para>
        </summary>
        <returns>The actual size used by the rendering.</returns>
        <remarks>
          <para>This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF DrawString (string str, System.Drawing.PointF point, float width, MonoTouch.UIKit.UIFont font, MonoTouch.UIKit.UILineBreakMode breakMode);" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF DrawString(string str, valuetype System.Drawing.PointF point, float32 width, class MonoTouch.UIKit.UIFont font, valuetype MonoTouch.UIKit.UILineBreakMode breakMode) cil managed" apistyle="classic" />
      <MemberSignature Language="C#" Value="public MonoTouch.CoreGraphics.CGSize DrawString (string str, MonoTouch.CoreGraphics.CGPoint point, nfloat width, MonoTouch.UIKit.UIFont font, MonoTouch.UIKit.UILineBreakMode breakMode);" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype MonoTouch.CoreGraphics.CGSize DrawString(string str, valuetype MonoTouch.CoreGraphics.CGPoint point, valuetype System.nfloat width, class MonoTouch.UIKit.UIFont font, valuetype MonoTouch.UIKit.UILineBreakMode breakMode) cil managed" apistyle="unified" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType apistyle="classic">System.Drawing.SizeF</ReturnType>
        <ReturnType apistyle="unified">MonoTouch.CoreGraphics.CGSize</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="point" Type="System.Drawing.PointF" apistyle="classic" />
        <Parameter Name="width" Type="System.Single" apistyle="classic" />
        <Parameter Name="font" Type="MonoTouch.UIKit.UIFont" />
        <Parameter Name="breakMode" Type="MonoTouch.UIKit.UILineBreakMode" />
        <Parameter Name="point" Type="MonoTouch.CoreGraphics.CGPoint" apistyle="unified" />
        <Parameter Name="width" Type="System.nfloat" apistyle="unified" />
      </Parameters>
      <Docs>
        <param name="str">String to draw.</param>
        <param name="point">The position where the string should be drawn.</param>
        <param name="width">The maximum width to use when drawing.</param>
        <param name="font">Font to use to draw the string.</param>
        <param name="breakMode">The linebreak mode to use to draw the string.</param>
        <summary>
          <para>
	    Deprecated in iOS7.  Use NSString.DrawString(RectangleF, UIStringAttributes) instead.
	  </para>
          <para>
	    Draws the string in the specified rectangle with the specified font.
	  </para>
        </summary>
        <returns>The actual size used by the rendering.</returns>
        <remarks>
          <para>This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawString" apistyle="classic">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF DrawString (string str, System.Drawing.PointF point, float width, MonoTouch.UIKit.UIFont font, float minFontSize, float actualFontSize, MonoTouch.UIKit.UILineBreakMode breakMode, MonoTouch.UIKit.UIBaselineAdjustment adjustment);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF DrawString(string str, valuetype System.Drawing.PointF point, float32 width, class MonoTouch.UIKit.UIFont font, float32 minFontSize, float32 actualFontSize, valuetype MonoTouch.UIKit.UILineBreakMode breakMode, valuetype MonoTouch.UIKit.UIBaselineAdjustment adjustment) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Advice("Use the version with a `ref float actualFontSize`")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="point" Type="System.Drawing.PointF" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="font" Type="MonoTouch.UIKit.UIFont" />
        <Parameter Name="minFontSize" Type="System.Single" />
        <Parameter Name="actualFontSize" Type="System.Single" />
        <Parameter Name="breakMode" Type="MonoTouch.UIKit.UILineBreakMode" />
        <Parameter Name="adjustment" Type="MonoTouch.UIKit.UIBaselineAdjustment" />
      </Parameters>
      <Docs>
        <param name="str">String to draw.</param>
        <param name="point">The position where the string should be drawn.</param>
        <param name="width">The maximum width to use when drawing.</param>
        <param name="font">Font to use to draw the string.</param>
        <param name="minFontSize">The minimum acceptable font size.</param>
        <param name="actualFontSize">The font size ultimately used to draw
        </param>
        <param name="breakMode">The linebreak mode to use to draw the string.</param>
        <param name="adjustment">Baseline adjustment to use.</param>
        <summary>Obsolete version of this method, use the version with a `ref float actualizeFontSize' parameter instead</summary>
        <returns>The actual size used by the rendering.</returns>
        <remarks>
          <para>This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF DrawString (string str, System.Drawing.PointF point, float width, MonoTouch.UIKit.UIFont font, float fontSize, MonoTouch.UIKit.UILineBreakMode breakMode, MonoTouch.UIKit.UIBaselineAdjustment adjustment);" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF DrawString(string str, valuetype System.Drawing.PointF point, float32 width, class MonoTouch.UIKit.UIFont font, float32 fontSize, valuetype MonoTouch.UIKit.UILineBreakMode breakMode, valuetype MonoTouch.UIKit.UIBaselineAdjustment adjustment) cil managed" apistyle="classic" />
      <MemberSignature Language="C#" Value="public MonoTouch.CoreGraphics.CGSize DrawString (string str, MonoTouch.CoreGraphics.CGPoint point, nfloat width, MonoTouch.UIKit.UIFont font, nfloat fontSize, MonoTouch.UIKit.UILineBreakMode breakMode, MonoTouch.UIKit.UIBaselineAdjustment adjustment);" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype MonoTouch.CoreGraphics.CGSize DrawString(string str, valuetype MonoTouch.CoreGraphics.CGPoint point, valuetype System.nfloat width, class MonoTouch.UIKit.UIFont font, valuetype System.nfloat fontSize, valuetype MonoTouch.UIKit.UILineBreakMode breakMode, valuetype MonoTouch.UIKit.UIBaselineAdjustment adjustment) cil managed" apistyle="unified" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType apistyle="classic">System.Drawing.SizeF</ReturnType>
        <ReturnType apistyle="unified">MonoTouch.CoreGraphics.CGSize</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="point" Type="System.Drawing.PointF" apistyle="classic" />
        <Parameter Name="width" Type="System.Single" apistyle="classic" />
        <Parameter Name="font" Type="MonoTouch.UIKit.UIFont" />
        <Parameter Name="fontSize" Type="System.Single" apistyle="classic" />
        <Parameter Name="breakMode" Type="MonoTouch.UIKit.UILineBreakMode" />
        <Parameter Name="adjustment" Type="MonoTouch.UIKit.UIBaselineAdjustment" />
        <Parameter Name="point" Type="MonoTouch.CoreGraphics.CGPoint" apistyle="unified" />
        <Parameter Name="width" Type="System.nfloat" apistyle="unified" />
        <Parameter Name="fontSize" Type="System.nfloat" apistyle="unified" />
      </Parameters>
      <Docs>
        <param name="str">String to draw.</param>
        <param name="point">The position where the string should be drawn.</param>
        <param name="width">The maximum width to use when drawing.</param>
        <param name="font">Font to use to draw the string.</param>
        <param name="fontSize">The font size to use</param>
        <param name="breakMode">The linebreak mode to use to draw the string.</param>
        <param name="adjustment">Baseline adjustment to use.</param>
        <summary>
          <para>Deprecated in iOS7.  Use NSString.DrawString(RectangleF, UIStringAttributes) instead.</para>
          <para>Draws the string in the specified rectangle with the specified font.</para>
        </summary>
        <returns>The actual size used by the rendering.</returns>
        <remarks>
          <para>This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF DrawString (string str, System.Drawing.PointF point, float width, MonoTouch.UIKit.UIFont font, float minFontSize, ref float actualFontSize, MonoTouch.UIKit.UILineBreakMode breakMode, MonoTouch.UIKit.UIBaselineAdjustment adjustment);" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF DrawString(string str, valuetype System.Drawing.PointF point, float32 width, class MonoTouch.UIKit.UIFont font, float32 minFontSize, float32 actualFontSize, valuetype MonoTouch.UIKit.UILineBreakMode breakMode, valuetype MonoTouch.UIKit.UIBaselineAdjustment adjustment) cil managed" apistyle="classic" />
      <MemberSignature Language="C#" Value="public MonoTouch.CoreGraphics.CGSize DrawString (string str, MonoTouch.CoreGraphics.CGPoint point, nfloat width, MonoTouch.UIKit.UIFont font, nfloat minFontSize, ref nfloat actualFontSize, MonoTouch.UIKit.UILineBreakMode breakMode, MonoTouch.UIKit.UIBaselineAdjustment adjustment);" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype MonoTouch.CoreGraphics.CGSize DrawString(string str, valuetype MonoTouch.CoreGraphics.CGPoint point, valuetype System.nfloat width, class MonoTouch.UIKit.UIFont font, valuetype System.nfloat minFontSize, valuetype System.nfloat actualFontSize, valuetype MonoTouch.UIKit.UILineBreakMode breakMode, valuetype MonoTouch.UIKit.UIBaselineAdjustment adjustment) cil managed" apistyle="unified" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType apistyle="classic">System.Drawing.SizeF</ReturnType>
        <ReturnType apistyle="unified">MonoTouch.CoreGraphics.CGSize</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="point" Type="System.Drawing.PointF" apistyle="classic" />
        <Parameter Name="width" Type="System.Single" apistyle="classic" />
        <Parameter Name="font" Type="MonoTouch.UIKit.UIFont" />
        <Parameter Name="minFontSize" Type="System.Single" apistyle="classic" />
        <Parameter Name="actualFontSize" Type="System.Single&amp;" RefType="ref" apistyle="classic" />
        <Parameter Name="breakMode" Type="MonoTouch.UIKit.UILineBreakMode" />
        <Parameter Name="adjustment" Type="MonoTouch.UIKit.UIBaselineAdjustment" />
        <Parameter Name="point" Type="MonoTouch.CoreGraphics.CGPoint" apistyle="unified" />
        <Parameter Name="width" Type="System.nfloat" apistyle="unified" />
        <Parameter Name="minFontSize" Type="System.nfloat" apistyle="unified" />
        <Parameter Name="actualFontSize" Type="System.nfloat&amp;" RefType="ref" apistyle="unified" />
      </Parameters>
      <Docs>
        <param name="str">String to draw.</param>
        <param name="point">The position where the string should be drawn.</param>
        <param name="width">The maximum width to use when drawing.</param>
        <param name="font">Font to use to draw the string.</param>
        <param name="minFontSize">Minimum font size that can be used.</param>
        <param name="actualFontSize">On return, this will contain the font size used.</param>
        <param name="breakMode">The linebreak mode to use to draw the string.</param>
        <param name="adjustment">Baseline adjustment to use.</param>
        <summary>Obsolete version of this method, use the version with a `ref float actualizeFontSize' parameter instead</summary>
        <returns>The actual size used by the rendering.</returns>
        <remarks>
          <para>
            
            This drawing routine will try to draw the string at the
            specified position with the specified width.  If the text
            does not fit in the specified width, the font sized will
            be reduced until it reaches the size specified by
            <paramref name="minFontSize" />.  Any text that does not
            fit will at that point be truncated according to the
            <paramref name="breakMode" /> rule.
          </para>
          <para>This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawViewHierarchy">
      <MemberSignature Language="C#" Value="public virtual bool DrawViewHierarchy (System.Drawing.RectangleF rect, bool afterScreenUpdates);" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool DrawViewHierarchy(valuetype System.Drawing.RectangleF rect, bool afterScreenUpdates) cil managed" apistyle="classic" />
      <MemberSignature Language="C#" Value="public virtual bool DrawViewHierarchy (MonoTouch.CoreGraphics.CGRect rect, bool afterScreenUpdates);" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool DrawViewHierarchy(valuetype MonoTouch.CoreGraphics.CGRect rect, bool afterScreenUpdates) cil managed" apistyle="unified" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("drawViewHierarchyInRect:afterScreenUpdates:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" apistyle="classic" />
        <Parameter Name="afterScreenUpdates" Type="System.Boolean" />
        <Parameter Name="rect" Type="MonoTouch.CoreGraphics.CGRect" apistyle="unified" />
      </Parameters>
      <Docs>
        <param name="rect">Bounding rectangle.</param>
        <param name="afterScreenUpdates">Returns a Boolean that indicates whether a snapshot is to be rendered after the most recent changes have been incorporated. Specify NO to render the snapshot in the view hierarchy’s current state, which may or may not include recent changes.</param>
        <summary>Renders the view hierarchy (slower than <see cref="M:MonoTouch.UIKit.UIView.SnapshotView" />).</summary>
        <returns>
          <see langword="false" /> if the snapshot is incomplete.</returns>
        <remarks>
          <para>This method is not as fast as <see cref="M:MonoTouch.UIKit.UIView.SnapshotView" />, but allows for effects (image filers, blurs, etc.).</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableInputClicksWhenVisible" apistyle="classic">
      <MemberSignature Language="C#" Value="public virtual bool EnableInputClicksWhenVisible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableInputClicksWhenVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(4, 2)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("enableInputClicksWhenVisible")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(4, 2)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies whether input "clicks" should play.</summary>
        <value>The default value is <see langword="false" />.</value>
        <remarks>For input clicks to be heard, the application user must have enabled keyboard clicks in Settings &gt; Sounds.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EncodeRestorableState">
      <MemberSignature Language="C#" Value="public virtual void EncodeRestorableState (MonoTouch.Foundation.NSCoder coder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EncodeRestorableState(class MonoTouch.Foundation.NSCoder coder) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("encodeRestorableStateWithCoder:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="coder" Type="MonoTouch.Foundation.NSCoder" />
      </Parameters>
      <Docs>
        <param name="coder">The <see cref="T:MonoTouch.Foundation.NSCoder" /> to encode the state.</param>
        <summary>Application developers can override this method to store state associated with the view.</summary>
        <remarks />
        <altmember cref="M:Monotouch.UIKit.UIView.DecodeRestorableState" />
        <altmember cref="M:MonoTouch.UIKit.UIApplicationDelegate.ShouldRestoreApplicationState" />
        <altmember cref="M:MonoTouch.UIKit.UIApplicationDelegate.ShouldSaveApplicationState" />
      </Docs>
    </Member>
    <Member MemberName="EncodeTo" apistyle="unified">
      <MemberSignature Language="C#" Value="public virtual void EncodeTo (MonoTouch.Foundation.NSCoder encoder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EncodeTo(class MonoTouch.Foundation.NSCoder encoder) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("encodeWithCoder:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="encoder" Type="MonoTouch.Foundation.NSCoder" />
      </Parameters>
      <Docs>
        <param name="encoder">The encoder object where the state of the object will be stored</param>
        <summary>Encodes the state of the object on the provided encoder</summary>
        <remarks>
          <para>This method is part of the <see cref="T:MonoTouch.Foundation.NSCoding" /> protocol and is used by applications to preserve the state of the object into an archive.</para>
          <para>Users will typically create a <see cref="T:MonoTouch.Foundation.NSKeyedArchived" /> and then invoke the <see cref="M:MonoTouch.Foundation.NSKeyedArchived.ArchiveRootObjectToFile" /> which will call into this method</para>
          <para>If you want to allow your object to be archived, you should override this method and store your state in using the provided <see paramref="encoder" /> parameter.   In addition, you should also implement a constructor that takes an NSCoder argument and is exported with [Export ("initWithCoder:")]</para>
          <example>
            <code lang="c#">public void override EncodeTo (NSCoder coder){
    c.Encode (1, key: "version");
    c.Encode (userName, key: "userName");
    c.Encode (hostName, key: "hostName");</code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndEditing">
      <MemberSignature Language="C#" Value="public bool EndEditing (bool force);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndEditing(bool force) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="force" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="force">If <see langword="true" />, overrides the subview's resignation choice.</param>
        <summary>Causes the view (or an appropriate subview) to resign first responder status.</summary>
        <returns>
          <see langword="true" /> if the view resigned first responder status.</returns>
        <remarks>
          <para>This method causes the view or one of its <see cref="P:MonoTouch.UIKit.UIView.Subviews" /> to resign first responder status. If <paramref name="force" /> is <see langword="true" />, the field is not even asked to resign: it is forced.</para>
          <para>This method returns <see langword="true" /> if the view or subview resigned first responder status. It will return <see langword="false" /> if:</para>
          <list type="bullet">
            <item>
              <term>Neither the <see cref="T:MonoTouch.UIKit.UIView" /> nor any of its <see cref="P:MonoTouch.UIKit.UIView.Subviews" /> was first responder; or
              </term>
            </item>
            <item>
              <term>The <paramref name="force" /> parameter was <see langword="false" /> and the first responder refused to resign (i.e., returned <see langword="false" /> from <see cref="M:MonoTouch.UIKit.UIResponder.ResignFirstResponder" />.)
              </term>
            </item>
          </list>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExchangeSubview">
      <MemberSignature Language="C#" Value="public virtual void ExchangeSubview (int atIndex, int withSubviewAtIndex);" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ExchangeSubview(int32 atIndex, int32 withSubviewAtIndex) cil managed" apistyle="classic" />
      <MemberSignature Language="C#" Value="public virtual void ExchangeSubview (nint atIndex, nint withSubviewAtIndex);" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ExchangeSubview(valuetype System.nint atIndex, valuetype System.nint withSubviewAtIndex) cil managed" apistyle="unified" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("exchangeSubviewAtIndex:withSubviewAtIndex:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="atIndex" Type="System.Int32" apistyle="classic" />
        <Parameter Name="withSubviewAtIndex" Type="System.Int32" apistyle="classic" />
        <Parameter Name="atIndex" Type="System.nint" apistyle="unified" />
        <Parameter Name="withSubviewAtIndex" Type="System.nint" apistyle="unified" />
      </Parameters>
      <Docs>
        <param name="atIndex">
          <para>An index within the zero-based <see cref="P:MonoTouch.UIKit.UIView.Subviews" /> array.</para>
        </param>
        <param name="withSubviewAtIndex">
          <para>Another index within the zero-based <see cref="P:MonoTouch.UIKit.UIView.Subviews" /> array.</para>
        </param>
        <summary>
          <para>This method exchanges the indices of two <see cref="T:MonoTouch.UIKit.UIView" />s within the <see cref="P:MonoTouch.UIKit.UIView.Subviews" /> array. </para>
        </summary>
        <remarks>
        </remarks>
        <altmember cref="M:MonoTouch.UIKit.UIView.AddSubview" />
        <altmember cref="M:MonoTouch.UIKit.UIView.InsertSubview" />
        <altmember cref="M:MonoTouch.UIKit.UIView.InsertSubviewAbove" />
        <altmember cref="M:MonoTouch.UIKit.UIView.InsertSubviewBelow" />
      </Docs>
    </Member>
    <Member MemberName="ExclusiveTouch">
      <MemberSignature Language="C#" Value="public virtual bool ExclusiveTouch { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveTouch" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("isExclusiveTouch")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setExclusiveTouch:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Restricts the event delivery to this view.</summary>
        <value>The default value is false.</value>
        <remarks>
          <para>
            
            When this property is set, if this view starts tracking a
            touch, no other views in the window will receive these
            events.  Additionally, a view that has set this property
            to true wont receive any events that are associated with
            other views in the window.
          </para>
          <para>
            
            If a finger touches a view that hast this property set,
            the event is only delivered if no other view in the window
            is tracking a finger.  If a finger touches a non-exclusive
            window, the event is only delivered if there are no
            exclusive views tracking a finger.
            
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExerciseAmbiguityInLayout">
      <MemberSignature Language="C#" Value="public virtual void ExerciseAmbiguityInLayout ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ExerciseAmbiguityInLayout() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("exerciseAmbiguityInLayout")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Randomly changes the <see cref="P:MonoTouch.UIKit.UIView.Frame" /> within an ambiguous set of Auto Layout constraints.</summary>
        <remarks>
          <para>This is a debugging method that should not be used in production applications.</para>
          <para>This method should be used with an under-constrained (ambiguous) Auto Layout. When called, it varies the <see cref="P:MonoTouch.UIKit.UIView.Frame" /> among its valid values, providing visual cues to assist the application developer in determining needed constraints.</para>
        </remarks>
        <altmember cref="P:MonoTouch.UIKit.UIView.HasAmbiguousLayout" />
      </Docs>
    </Member>
    <Member MemberName="Frame">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.RectangleF Frame { get; set; }" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.RectangleF Frame" apistyle="classic" />
      <MemberSignature Language="C#" Value="public virtual MonoTouch.CoreGraphics.CGRect Frame { get; set; }" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype MonoTouch.CoreGraphics.CGRect Frame" apistyle="unified" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("frame")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setFrame:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType apistyle="classic">System.Drawing.RectangleF</ReturnType>
        <ReturnType apistyle="unified">MonoTouch.CoreGraphics.CGRect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Coordinates of the view relative to its container.</summary>
        <value>The value of this property is in points, not pixels.</value>
        <remarks>
          <para>The <see cref="P:MonoTouch.UIKit.UIView.Frame" /> property is expressed in terms of the <see cref="P:MonoTouch.UIKit.UIView.Superview" />'s coordinate system. (The <see cref="P:MonoTouch.UIKit.UIView.Bounds" /> property is expressed in terms of <c>this</c> <see cref="T:MonoTouch.UIKit.UIView" />'s coordinate system.)</para>
          <para>The following example shows just one way the <see cref="P:MonoTouch.UIKit.UIView.Frame" />'s coordinate system and values can vary from that of the <see cref="P:MonoTouch.UIKit.UIView" />'s <see cref="P:MonoTouch.UIKit.UIView.Bounds" />. In this case, a <see cref="T:MonoTouch.UIKit.UIImageView" /> is placed with an initial <see cref="P:MonoTouch.UIKit.UIView.Frame" /> originating at {100,100} and of size {100,100}. Once rotated, both the origin and size of the <see cref="P:MonoTouch.UIKit.UIView.Frame" /> bounding box shift: the origin to accomodate the rotation and the sizes in order to contain the diagonal of the {100,100} box. The <see cref="P:MonoTouch.UIKit.UIView.Bounds" /> of the <c>flowerView</c> remains [{0,0},{100,100}].</para>
          <example>
            <code lang="C#"><![CDATA[
var flowerView = new UIImageView(new RectangleF(100, 100, 100, 100)) {
	Image = UIImage.FromFile("flower.png"),
	ContentMode = UIViewContentMode.Center,
	ClipsToBounds = true
};

flowerView.Transform = CGAffineTransform.MakeRotation((float) Math.PI / 4);
view.AddSubview(flowerView);            
              
              ]]></code>
          </example>
          <para>
            <img href="UIKit.UIView.Frame.png" />
          </para>
          <para>
            
            When changes are done to this property, the <see cref="P:MonoTouch.UIKit.UIView.Center" /> is updated with
            the new location and the <see cref="P:MonoTouch.UIKit.UIView.Bounds" /> is updated with
            the new dimensions and a re-layout of the subviews is
            performed.
            
          </para>
          <para>
            
            Changing this property will not trigger a call to <see cref="M:MonoTouch.UIKit.UIView.Draw(System.Drawing.RectangleF)" /> unless you set the <see cref="P:MonoTouch.UIKit.UIView.ContentMode" /> property to
            <see cref="E:MonoTouch.UIKit.UIViewContentMode.Redraw" />.
            
          </para>
          <para>
            
            At least on iOS 6 and later, changing this property causes the a
            re-layout of the subviews, even if the dimensions are the
            same.  This can cause performance problems as some views
            (like UITableView) can perform some very expensive
            computations when they are laid out.  
            
          </para>
          <para>
            
            If your <see cref="P:MonoTouch.UIKit.UIView.ContentMode" />
            property is set to <see cref="E:MonoTouch.UIKit.UIViewContentMode.Redraw" />, you
            can avoid a redraw of your view if you update the <see cref="P:MonoTouch.UIKit.UIView.Center" /> property instead
            of updating the Frame as that one will merely move the
            view without triggering a call to <see cref="M:MonoTouch.UIKit.UIView.LayoutSubviews()" />.
            
          </para>
          <para id="tool-remark">
            This property participates in the implicit animation
            protocol, changing it outside of a transaction will trigger
            an implicit animation for its values.
          </para>
          <para>
            
            If you change the <see cref="P:MonoTouch.UIKit.UIView.Transform" /> property to a
            matrix that does not represent the identity matrix,
            changing this property can have unintended consequences.   In those cases, you should instead update <see cref="P:MonoTouch.UIKit.UIView.Center" /> and <see cref="P:MonoTouch.UIKit.UIView.Bounds" /> directly.
            
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FrameForAlignmentRect">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.RectangleF FrameForAlignmentRect (System.Drawing.RectangleF alignmentRect);" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Drawing.RectangleF FrameForAlignmentRect(valuetype System.Drawing.RectangleF alignmentRect) cil managed" apistyle="classic" />
      <MemberSignature Language="C#" Value="public virtual MonoTouch.CoreGraphics.CGRect FrameForAlignmentRect (MonoTouch.CoreGraphics.CGRect alignmentRect);" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype MonoTouch.CoreGraphics.CGRect FrameForAlignmentRect(valuetype MonoTouch.CoreGraphics.CGRect alignmentRect) cil managed" apistyle="unified" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("frameForAlignmentRect:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType apistyle="classic">System.Drawing.RectangleF</ReturnType>
        <ReturnType apistyle="unified">MonoTouch.CoreGraphics.CGRect</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="alignmentRect" Type="System.Drawing.RectangleF" apistyle="classic" />
        <Parameter Name="alignmentRect" Type="MonoTouch.CoreGraphics.CGRect" apistyle="unified" />
      </Parameters>
      <Docs>
        <param name="alignmentRect">A <see cref="T:System.Drawing.RectangleF" /> for which the frame rectangle should be calculated.</param>
        <summary>Returns the frame resulting from applying the <paramref name="alignmentRect" /> to the current Auto Layout constraints.</summary>
        <returns>
          <para>The frame rectangle appropriate to the <paramref name="alignmentRect" />/</para>
        </returns>
        <remarks>
          <para>By overriding this method, application developers can fully customize the alignment rectangle of the <see cref="T:MonoTouch.UIKit.UIView" />.Application developers who override this method must also override the complementary method <see cref="M:MonoTouch.UIKit.UIView.AlignmentRectForFrame" />. The two methods must provide complementary values.</para>
          <para>Auto Layout uses "alignment rectangles" to layout subviews rather than the subviews' <see cref="P:MonoTouch.UIKit.UIView.Frame" />. The <see cref="P:MonoTouch.UIKit.UIView.Frame" /> of a <see cref="T:MonoTouch.UIKit.UIView" /> may include visual elements, such as drop-shadows, that are not symmetrical around the <see cref="T:MonoTouch.UIKit.UIView" />'s logical center. The "alignment rectangle" for a <see cref="T:MonoTouch.UIKit.UIView" /> should be related to its logical content.</para>
          <para> By default, the "alignment rectangle" of a <see cref="T:MonoTouch.UIKit.UIView" /> is the <see cref="P:MonoTouch.UIKit.UIView.Frame" /> plus the <see cref="P:MonoTouch.UIKit.UIView.AlignmentRectInsets" />. The <see cref="M:MonoTouch.UIKit.UIView.AlignmentRectForFrame" /> and <see cref="M:MonoTouch.UIKit.UIView.FrameForAlignmentRect" /> methods can be used to fully customize the alignment rectangle.</para>
        </remarks>
        <altmember cref="M:MonoTouch.UIKit.UIView.AlignmentRectForFrame" />
        <altmember cref="M:MonoTouch.UIKit.UIView.AlignmentRectInsets" />
        <altmember cref="M:MonoTouch.UIKit.UIView.ViewForBaselineLayout" />
      </Docs>
    </Member>
    <Member MemberName="GestureRecognizers">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIGestureRecognizer[] GestureRecognizers { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIGestureRecognizer[] GestureRecognizers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(3, 2)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("gestureRecognizers")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(3, 2)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setGestureRecognizers:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.ObjCRuntime.Since(3, 2)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIGestureRecognizer[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The array of <see cref="T:MonoTouch.UIKit.UIGestureRecognizer" />s for this <see cref="T:MonoTouch.UIKit.UIView" />.</summary>
        <value>The default value is <see langword="null" />.</value>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="GestureRecognizerShouldBegin">
      <MemberSignature Language="C#" Value="public virtual bool GestureRecognizerShouldBegin (MonoTouch.UIKit.UIGestureRecognizer gestureRecognizer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GestureRecognizerShouldBegin(class MonoTouch.UIKit.UIGestureRecognizer gestureRecognizer) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("gestureRecognizerShouldBegin:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="gestureRecognizer" Type="MonoTouch.UIKit.UIGestureRecognizer" />
      </Parameters>
      <Docs>
        <param name="gestureRecognizer">The gesture recognizer that is
          trying to transitioning out of the <see cref="T:MonoTouch.UIKit.UIGestureRecognizerState" />'s Possible state.</param>
        <summary>Determines if the specified gesture recognizers
          should be allowed to track touch events.</summary>
        <returns>
        </returns>
        <remarks>
          Override this method if your application handles touches
          directly, it controls whether an associated
          <see cref="T:MonoTouch.UIKit.UIGestureRecognizer" /> should execute or not.
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAppearance&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static MonoTouch.UIKit.UIView.UIViewAppearance GetAppearance&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class MonoTouch.UIKit.UIView/UIViewAppearance GetAppearance&lt;T&gt;() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIView+UIViewAppearance</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">Should be <c>UIView</c> to retrieve <see cref="T:MonoTouch.UIKit.UIViewAppearance" />.</typeparam>
        <summary>The strongly-typed IUIAppearance for this object.</summary>
        <returns>The <see cref="T:MonoTouch.UIKit.UIViewAppearance" /> for <c>this</c>.</returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAppearance&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static MonoTouch.UIKit.UIView.UIViewAppearance GetAppearance&lt;T&gt; (MonoTouch.UIKit.UITraitCollection traits);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class MonoTouch.UIKit.UIView/UIViewAppearance GetAppearance&lt;T&gt;(class MonoTouch.UIKit.UITraitCollection traits) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIView+UIViewAppearance</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="traits" Type="MonoTouch.UIKit.UITraitCollection" />
      </Parameters>
      <Docs>
        <typeparam name="T">Should be <c>UIView</c> to retrieve <see cref="T:MonoTouch.UIKit.UIViewAppearance" />.</typeparam>
        <param name="traits">Traits for the defined collection.</param>
        <summary>IUIAppearance for this object with specified traits.</summary>
        <returns>The <see cref="T:MonoTouch.UIKit.UIViewAppearance" /> for <c>this</c> with traits.</returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAppearance&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static MonoTouch.UIKit.UIView.UIViewAppearance GetAppearance&lt;T&gt; (MonoTouch.UIKit.UITraitCollection traits, Type[] containers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class MonoTouch.UIKit.UIView/UIViewAppearance GetAppearance&lt;T&gt;(class MonoTouch.UIKit.UITraitCollection traits, class System.Type[] containers) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIView+UIViewAppearance</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="traits" Type="MonoTouch.UIKit.UITraitCollection" />
        <Parameter Name="containers" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">Should be <c>UIView</c> to retrieve <see cref="T:MonoTouch.UIKit.UIViewAppearance" />.</typeparam>
        <param name="traits">Traits for the defined collection.</param>
        <param name="containers">Customized container view.</param>
        <summary>IUIAppearance for this object with specified traits and customized container.</summary>
        <returns>The <see cref="T:MonoTouch.UIKit.UIViewAppearance" /> for <c>this</c> with traits and container.</returns>
        <remarks>.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConstraintsAffectingLayout">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.NSLayoutConstraint[] GetConstraintsAffectingLayout (MonoTouch.UIKit.UILayoutConstraintAxis axis);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class MonoTouch.UIKit.NSLayoutConstraint[] GetConstraintsAffectingLayout(valuetype MonoTouch.UIKit.UILayoutConstraintAxis axis) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("constraintsAffectingLayoutForAxis:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.NSLayoutConstraint[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="axis" Type="MonoTouch.UIKit.UILayoutConstraintAxis" />
      </Parameters>
      <Docs>
        <param name="axis">The direction of interest.</param>
        <summary>Returns the array of <see cref="T:MonoTouch.UIKit.NSLayoutConstraint" /> that are affecting the layout of the <see cref="T:MonoTouch.UIKit.UIView" /> along the specified <paramref name="axis" />.</summary>
        <returns>The default value is an empty array.</returns>
        <remarks>
          <para>This is a debugging method that should not be used in production applications.</para>
          <para>
            The returned array may contain <see cref="T:MonoTouch.UIKit.NSLayoutConstraint" />s that do not explicitly reference <c>this</c> <see cref="T:MonoTouch.UIKit.UIView" /> but which nonetheless affect the <see cref="P:MonoTouch.UIKit.UIView.Frame" />. For instance, if <c>this</c> is pinned to <c>anotherView</c> and <c>anotherView</c> is pinned to it's <see cref="P:MonoTouch.UIKit.UIView.Superview" />, the method may return both constraints. 
          </para>
          <para>This method is a debugging oriented helper method and is not guaranteed to return the complete set (or any) <see cref="T:MonoTouch.UIKit.NSLayoutConstraint" />s. </para>
          <para>If this method is called directly from within <see cref="M:MonoTouch.UIKit.UIViewController.ViewDidLoad" />, it will generally return an empty array. If it is invoked as shown in the following example, it appears to be more likely to provide a comprehensive answer.</para>
          <example>
            <code lang="C#"><![CDATA[
mainView.AddConstraints(NSLayoutConstraint.FromVisualFormat("H:|-[blue]-|", 0, new NSDictionary(), viewsDictionary));
mainView.AddConstraints(NSLayoutConstraint.FromVisualFormat("V:|-[blue]-(==30)-[green(==blue)]-|", 0, new NSDictionary(), viewsDictionary));
mainView.AddConstraints(NSLayoutConstraint.FromVisualFormat("|-[green(==blue)]-|", 0, new NSDictionary(), viewsDictionary));

System.Threading.ThreadPool.QueueUserWorkItem(delegate {
  InvokeOnMainThread(delegate {
    foreach(var c2 in blueView.GetConstraintsAffectingLayout(UILayoutConstraintAxis.Horizontal))
    {
      Console.WriteLine(c2);
    }
  });
});
              ]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns an enumerator that lists all of the subviews in this view</summary>
        <returns>
        </returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GrayscaleStatusDidChangeNotification">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString GrayscaleStatusDidChangeNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString GrayscaleStatusDidChangeNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIAccessibilityGrayscaleStatusDidChangeNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for GrayscaleStatusDidChange</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:MonoTouch.Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <example>
            <code lang="c#">
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIView.GrayscaleStatusDidChangeNotification, (notification) =&gt; {Console.WriteLine ("Received the notification UIView", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIView", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIView.GrayscaleStatusDidChangeNotification, Callback);
}
</code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GuidedAccessStatusDidChangeNotification">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString GuidedAccessStatusDidChangeNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString GuidedAccessStatusDidChangeNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIAccessibilityGuidedAccessStatusDidChangeNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for GuidedAccessStatusDidChange</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:MonoTouch.Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
    UIView.GuidedAccessStatusDidChangeNotification, (notification) => {
        Console.WriteLine ("Received the notification UIView", notification); 
    }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIView", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIView.GuidedAccessStatusDidChangeNotification, Callback);
}
              ]]></code>
          </example>
        </remarks>
        <altmember cref="P:MonoTouch.UIKit.UIView.AnnouncementNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.AnnouncementDidFinishNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.ClosedCaptioningStatusDidChangeNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.GuidedAccessStatusDidChangeNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.InvertColorStatusDidChangeNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.AnnouncementNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.LayoutChangedNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.MonoAudioStatusDidChangeNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.PageScrolledNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.ScreenChangedNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.VoiceOverStatusChangedNotification" />
      </Docs>
    </Member>
    <Member MemberName="HasAmbiguousLayout">
      <MemberSignature Language="C#" Value="public virtual bool HasAmbiguousLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasAmbiguousLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("hasAmbiguousLayout")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns <see langword="true" /> if the Auto Layout for this <see cref="T:MonoTouch.UIKit.UIView" /> is ambiguous.</summary>
        <value>Returns <see langword="false" /> if the <see cref="T:MonoTouch.UIKit.UIView" />'s constraints are sufficient to accurately specify its alignment rectangle.</value>
        <remarks>
          <para>This is a debugging method that should not be used in production applications.</para>
          <para>This method can be used to determine if the set of <see cref="T:MonoTouch.UIKit.NSLayoutConstraint" />s for a <see cref="T:MonoTouch.UIKit.UIView" /> are sufficient to fully determine the alignment rectangle or if they are ambiguous. </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Hidden">
      <MemberSignature Language="C#" Value="public virtual bool Hidden { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Hidden" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("isHidden")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setHidden:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies whether the <see cref="T:MonoTouch.UIKit.UIView" /> displays or not.</summary>
        <value>The default value is <see langword="false" />.</value>
        <remarks>
          <para>A hidden <see cref="T:MonoTouch.UIKit.UIView" /> does not display and does not receive input events. It does, however, participate in resizing and layout events and remains in its <see cref="P:MonoTouch.UIKit.UIView.Superview" />'s list of <see cref="P:MonoTouch.UIKit.UIView.Subviews" />s.</para>
          <para>A hidden <see cref="T:MonoTouch.UIKit.UIView" /> hides its descendant views in addition to hiding itself. This does not affect the <see cref="P:MonoTouch.UIKit.UIView.Hidden" /> property of the descendant views. Thus, a <see cref="T:MonoTouch.UIKit.UIView" /> may be hidden even though its <see cref="P:MonoTouch.UIKit.UIView.Hidden" /> property is <see langword="false" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HitTest">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIView HitTest (System.Drawing.PointF point, MonoTouch.UIKit.UIEvent uievent);" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class MonoTouch.UIKit.UIView HitTest(valuetype System.Drawing.PointF point, class MonoTouch.UIKit.UIEvent uievent) cil managed" apistyle="classic" />
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIView HitTest (MonoTouch.CoreGraphics.CGPoint point, MonoTouch.UIKit.UIEvent uievent);" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class MonoTouch.UIKit.UIView HitTest(valuetype MonoTouch.CoreGraphics.CGPoint point, class MonoTouch.UIKit.UIEvent uievent) cil managed" apistyle="unified" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("hitTest:withEvent:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIView</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.PointF" apistyle="classic" />
        <Parameter Name="uievent" Type="MonoTouch.UIKit.UIEvent" />
        <Parameter Name="point" Type="MonoTouch.CoreGraphics.CGPoint" apistyle="unified" />
      </Parameters>
      <Docs>
        <param name="point">
          <para>The location to test.</para>
        </param>
        <param name="uievent">
          <para>The event that triggered this call.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Determines the most nested view that contains the point.</summary>
        <returns>
          <para>The most nested view that contains the point, or null if the point falls outside of the boundaris of the view.</para>
        </returns>
        <remarks>
          <para>
            
            This method iterates over all of the visible subviews that
            have user interaction enabled and that are not entirely
            transparent to find the most nested view that contains the
            point.  For each of those views, the method <see cref="M:MonoTouch.UIKit.UIView.PointInside(System.Drawing.PointF,&#xA;     MonoTouch.UIKit.UIEvent)" /> is invoked to determine if
            there is a match.     
            
          </para>
        </remarks>
        <altmember cref="M:MonoTouch.UIKit.UIView.PointInside" />
      </Docs>
    </Member>
    <Member MemberName="InsertSubview">
      <MemberSignature Language="C#" Value="public virtual void InsertSubview (MonoTouch.UIKit.UIView view, int atIndex);" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void InsertSubview(class MonoTouch.UIKit.UIView view, int32 atIndex) cil managed" apistyle="classic" />
      <MemberSignature Language="C#" Value="public virtual void InsertSubview (MonoTouch.UIKit.UIView view, nint atIndex);" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void InsertSubview(class MonoTouch.UIKit.UIView view, valuetype System.nint atIndex) cil managed" apistyle="unified" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("insertSubview:atIndex:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="view" Type="MonoTouch.UIKit.UIView" />
        <Parameter Name="atIndex" Type="System.Int32" apistyle="classic" />
        <Parameter Name="atIndex" Type="System.nint" apistyle="unified" />
      </Parameters>
      <Docs>
        <param name="view">
          <para>The view to add as a nested view of this view.</para>
        </param>
        <param name="atIndex">
          <para>The index in the stack of subviews where this view
            will be inserted.</para>
        </param>
        <summary>Inserts the specified subview at the specified
          location as a subview of this view.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertSubviewAbove">
      <MemberSignature Language="C#" Value="public virtual void InsertSubviewAbove (MonoTouch.UIKit.UIView view, MonoTouch.UIKit.UIView siblingSubview);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void InsertSubviewAbove(class MonoTouch.UIKit.UIView view, class MonoTouch.UIKit.UIView siblingSubview) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("insertSubview:aboveSubview:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="view" Type="MonoTouch.UIKit.UIView" />
        <Parameter Name="siblingSubview" Type="MonoTouch.UIKit.UIView" />
      </Parameters>
      <Docs>
        <param name="view">
          <para>The view to add as a nested view of this view.</para>
        </param>
        <param name="siblingSubview">
          <para>The subview of this view that will be below the view.</para>
        </param>
        <summary>Inserts the specified view above the siblingSubvie in
          the view hierarchy</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertSubviewBelow">
      <MemberSignature Language="C#" Value="public virtual void InsertSubviewBelow (MonoTouch.UIKit.UIView view, MonoTouch.UIKit.UIView siblingSubview);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void InsertSubviewBelow(class MonoTouch.UIKit.UIView view, class MonoTouch.UIKit.UIView siblingSubview) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("insertSubview:belowSubview:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="view" Type="MonoTouch.UIKit.UIView" />
        <Parameter Name="siblingSubview" Type="MonoTouch.UIKit.UIView" />
      </Parameters>
      <Docs>
        <param name="view">
          <para>The view to add as a nested view of this view.</para>
        </param>
        <param name="siblingSubview">
          <para>The subview of this view that will be below the view.</para>
        </param>
        <summary>Inserts the specified view below the <paramref name="siblingSubview" /> in
          the view hierarchy.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IntrinsicContentSize">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.SizeF IntrinsicContentSize { get; }" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.SizeF IntrinsicContentSize" apistyle="classic" />
      <MemberSignature Language="C#" Value="public virtual MonoTouch.CoreGraphics.CGSize IntrinsicContentSize { get; }" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype MonoTouch.CoreGraphics.CGSize IntrinsicContentSize" apistyle="unified" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("intrinsicContentSize")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType apistyle="classic">System.Drawing.SizeF</ReturnType>
        <ReturnType apistyle="unified">MonoTouch.CoreGraphics.CGSize</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The size of the intrinsic content of the <see cref="T:MonoTouch.UIKit.UIView" />.</summary>
        <value>The default value is {<see cref="P:MonoTouch.UIKit.UIView.NoIntrinsicMetric" />, <see cref="P:MonoTouch.UIKit.UIView.NoIntrinsicMetric" />}.</value>
        <remarks>
          <para>Some views, such as <see cref="T:MonoTouch.UIKit.UILabel" />s, have a natural intrinsic size that is not related to the actual <see cref="P:MonoTouch.UIKit.UIView.Frame" /> that contains the entirety of the <see cref="T:MonoTouch.UIKit.UIView" />. This property allows the <see cref="T:MonoTouch.UIKit.UIView" /> to tell the Auto Layout system what <see cref="T:System.Drawing.SizeF" /> it would prefer to be.</para>
          <para>If a <see cref="T:MonoTouch.UIKit.UIView" /> has no intrinsic size, it should return the default {<see cref="P:MonoTouch.UIKit.UIView.NoIntrinsicMetric" />,<see cref="P:MonoTouch.UIKit.UIView.NoIntrinsicMetric" />} value.</para>
        </remarks>
        <altmember cref="M:MonoTouch.UIKit.UIView.InvalidateIntrinsicContentSize" />
        <altmember cref="M:MonoTouch.UIKit.UIView.SetContentCompressionResistancePriority" />
      </Docs>
    </Member>
    <Member MemberName="InvalidateIntrinsicContentSize">
      <MemberSignature Language="C#" Value="public virtual void InvalidateIntrinsicContentSize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void InvalidateIntrinsicContentSize() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("invalidateIntrinsicContentSize")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Alerts the Auto Layout system that the intrinsic value of the <see cref="T:MonoTouch.UIKit.UIView" /> has changed.</summary>
        <remarks>
          <para>Application developers should call this method when they have overridden <see cref="P:MonoTouch.UIKit.UIView.IntrinsicContentSize" /> and something has happened to change the value of that property. The Auto Layout system will use the new property in its next layout pass.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvertColorsStatusDidChangeNotification">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString InvertColorsStatusDidChangeNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString InvertColorsStatusDidChangeNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIAccessibilityInvertColorsStatusDidChangeNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for InvertColorsStatusDidChange</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:MonoTouch.Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
    UIView.InvertColorsStatusDidChangeNotification, (notification) => {
        Console.WriteLine ("Received the notification UIView", notification); 
    });


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIView", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIView.InvertColorsStatusDidChangeNotification, Callback);
}
              ]]></code>
          </example>
        </remarks>
        <altmember cref="P:MonoTouch.UIKit.UIView.AnnouncementNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.AnnouncementDidFinishNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.ClosedCaptioningStatusDidChangeNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.GuidedAccessStatusDidChangeNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.InvertColorStatusDidChangeNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.AnnouncementNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.LayoutChangedNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.MonoAudioStatusDidChangeNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.PageScrolledNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.ScreenChangedNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.VoiceOverStatusChangedNotification" />
      </Docs>
    </Member>
    <Member MemberName="IsAccessibilityElement">
      <MemberSignature Language="C#" Value="public virtual bool IsAccessibilityElement { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAccessibilityElement" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("isAccessibilityElement")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setIsAccessibilityElement:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether <c>this</c> is an accessibility element.</summary>
        <value>
          <see langword="true" /> if the <see cref="T:MonoTouch.UIKit.UIView" /> is an accessibility element.</value>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDescendantOfView">
      <MemberSignature Language="C#" Value="public virtual bool IsDescendantOfView (MonoTouch.UIKit.UIView view);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsDescendantOfView(class MonoTouch.UIKit.UIView view) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("isDescendantOfView:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="view" Type="MonoTouch.UIKit.UIView" />
      </Parameters>
      <Docs>
        <param name="view">
          <para>The <see cref="T:MonoTouch.UIKit.UIView" /> that may be an ancestore of <c>this</c> <see cref="T:MonoTouch.UIKit.UIView" />.</para>
        </param>
        <summary>Returns <see langword="true" /> if <c>this</c> <see cref="T:MonoTouch.UIKit.UIView" /> is in the <paramref name="view" />'s view hierarchy.</summary>
        <returns>
          <para>Returns <see langword="true" /> if the <paramref name="view" /> is the same as <c>this</c> or if the <paramref name="view" /> is an ancestor of <c>this</c>.</para>
        </returns>
        <remarks>
          <para>A <see cref="T:MonoTouch.UIKit.UIView" /> is a descendant of another <paramref name="view" /> if the views are the same or if the <paramref name="view" /> can be reached by repeatedly retrieving the <see cref="P:MonoTouch.UIKit.UIView.Superview" /> property. This is the equivalent to specifying that <c>this</c> <see cref="T:MonoTouch.UIKit.UIView" /> is in <paramref name="view" />'s view hierarchy.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Layer">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.CoreAnimation.CALayer Layer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.CoreAnimation.CALayer Layer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("layer")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.CoreAnimation.CALayer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The Core Animation layer used for rendering.</summary>
        <value>Returns the <see cref="T:MonoTouch.CoreAnimation.CALayer" /> that the <see cref="T:MonoTouch.UIKit.UIView" /> is being rendered on.</value>
        <remarks>
          <para>This method will not return <see langword="null" />.</para>
          <para>The <see cref="T:MonoTouch.UIKit.UIView" /> and the <see cref="T:MonoTouch.CoreAnimation.CALayer" /> are tightly coupled and should not be reassigned.</para>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LayoutChangedNotification">
      <MemberSignature Language="C#" Value="public static int LayoutChangedNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 LayoutChangedNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIAccessibilityLayoutChangedNotification", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An accessibility notification indicating that the layout has changed.</summary>
        <value>The layer that the view is being rendered on..</value>
        <remarks></remarks>
        <altmember cref="P:MonoTouch.UIKit.UIView.AnnouncementNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.AnnouncementDidFinishNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.ClosedCaptioningStatusDidChangeNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.GuidedAccessStatusDidChangeNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.InvertColorStatusDidChangeNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.AnnouncementNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.LayoutChangedNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.MonoAudioStatusDidChangeNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.PageScrolledNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.ScreenChangedNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.VoiceOverStatusChangedNotification" />
      </Docs>
    </Member>
    <Member MemberName="LayoutIfNeeded">
      <MemberSignature Language="C#" Value="public virtual void LayoutIfNeeded ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void LayoutIfNeeded() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("layoutIfNeeded")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lays out the subviews if needed.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LayoutMargins">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIEdgeInsets LayoutMargins { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype MonoTouch.UIKit.UIEdgeInsets LayoutMargins" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("layoutMargins")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setLayoutMargins:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIEdgeInsets</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lays out margins.</summary>
        <value></value>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="LayoutMarginsDidChange">
      <MemberSignature Language="C#" Value="public virtual void LayoutMarginsDidChange ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void LayoutMarginsDidChange() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("layoutMarginsDidChange")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lays out changed subviews.</summary>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="LayoutSubviews">
      <MemberSignature Language="C#" Value="public virtual void LayoutSubviews ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void LayoutSubviews() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("layoutSubviews")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lays out subviews.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaskView">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIView MaskView { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIView MaskView" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("maskView")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setMaskView:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns mask view.</summary>
        <value></value>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="MonoAudioStatusDidChangeNotification">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString MonoAudioStatusDidChangeNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString MonoAudioStatusDidChangeNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIAccessibilityMonoAudioStatusDidChangeNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(5, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(5, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for MonoAudioStatusDidChange</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:MonoTouch.Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
    UIView.MonoAudioStatusDidChangeNotification, (notification) => {
        Console.WriteLine ("Received the notification UIView", notification); 
    });


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIView", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIView.MonoAudioStatusDidChangeNotification, Callback);
}
              ]]></code>
          </example>
        </remarks>
        <altmember cref="P:MonoTouch.UIKit.UIView.AnnouncementNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.AnnouncementDidFinishNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.ClosedCaptioningStatusDidChangeNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.GuidedAccessStatusDidChangeNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.InvertColorStatusDidChangeNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.AnnouncementNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.LayoutChangedNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.MonoAudioStatusDidChangeNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.PageScrolledNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.ScreenChangedNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.VoiceOverStatusChangedNotification" />
      </Docs>
    </Member>
    <Member MemberName="MotionEffects">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIMotionEffect[] MotionEffects { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIMotionEffect[] MotionEffects" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("motionEffects")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setMotionEffects:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIMotionEffect[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Current set of motion effects on this view.</summary>
        <value>
        </value>
        <remarks>You can use this property to retrieve the list of currently active motion effects, or to set the list of motion effects on this view.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MovedToSuperview">
      <MemberSignature Language="C#" Value="public virtual void MovedToSuperview ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MovedToSuperview() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("didMoveToSuperview")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indicates the <see cref="T:MonoTouch.UIKit.UIView" /> has had its <see cref="P:MonoTouch.UIKit.UIView.Superview" /> property changed.</summary>
        <remarks>
          <para>Application developers can override this method to perform additional calculations when the <see cref="P:MonoTouch.UIKit.UIView.Superview" /> changes.</para>
          <para>This method is only called on the immediate descendants of the <see cref="P:MonoTouch.UIKit.UIView.Superview" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MovedToWindow">
      <MemberSignature Language="C#" Value="public virtual void MovedToWindow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MovedToWindow() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("didMoveToWindow")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indicates the <see cref="T:MonoTouch.UIKit.UIView" /> has had its <see cref="P:MonoTouch.UIKit.UIView.Window" /> property changed.</summary>
        <remarks>
          <para>Application developers can override this method to perform additional calculations whent he <see cref="P:MonoTouch.UIKit.UIView.Window" /> changes.</para>
          <para>This method is called on all members of the <see cref="T:MonoTouch.UIKit.UIView" />'s view hierarchy when the <see cref="P:MonoTouch.UIKit.UIView.Window" /> property changes.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MultipleTouchEnabled">
      <MemberSignature Language="C#" Value="public virtual bool MultipleTouchEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MultipleTouchEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("isMultipleTouchEnabled")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setMultipleTouchEnabled:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Controls whether the UIView can handle multitouch events.</summary>
        <value>State of multiple touch recotgnition.</value>
        <remarks>
          UIViews by default only handle a single touch event at once.  If you
          want your view to handle multiple touches, you must set this property
          to true.
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NeedsUpdateConstraints">
      <MemberSignature Language="C#" Value="public virtual bool NeedsUpdateConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool NeedsUpdateConstraints() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("needsUpdateConstraints")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indicates that the Auto Layout constraints of the <see cref="T:MonoTouch.UIKit.UIView" /> need updating.</summary>
        <returns>If this method returns <see langword="true" />, the Auto Layout system will call <see cref="M:MonoTouch.UIKit.UIView.UpdateConstraints" /> during its layout pass.</returns>
        <remarks>
          <para>This method is checked by the Auto Layout system to determine if the <see cref="P:MonoTouch.UIKit.UIView.Constraints" /> for this <see cref="T:MonoTouch.UIKit.UIView" /> need updating. If this method returns <see langword="true" />, the method <see cref="M:MonoTouch.UIKit.UIView.UpdateConstraints" /> will be called and should perform the updates.</para>
        </remarks>
        <altmember cref="M:Monotouch.UIKit.UIView.SetNeedsUpdateConstraints" />
      </Docs>
    </Member>
    <Member MemberName="NoIntrinsicMetric">
      <MemberSignature Language="C#" Value="public static float NoIntrinsicMetric { get; }" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".property float32 NoIntrinsicMetric" apistyle="classic" />
      <MemberSignature Language="C#" Value="public static nfloat NoIntrinsicMetric { get; }" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.nfloat NoIntrinsicMetric" apistyle="unified" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIViewNoIntrinsicMetric", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType apistyle="classic">System.Single</ReturnType>
        <ReturnType apistyle="unified">System.nfloat</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UIViewNoIntrinsicMetric</summary>
        <value>
        </value>
        <remarks>
          <para>This property is associated with the <see cref="M:MonoTouch.UIKit.UIView.IntrinsicContentSize" /> method. This value indicates that the <see cref="T:MonoTouch.UIKit.UIView" /> has no natural size in a particular dimension.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NotificationSwitchControlIdentifier">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString NotificationSwitchControlIdentifier { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString NotificationSwitchControlIdentifier" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIAccessibilityNotificationSwitchControlIdentifier", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for NotificationSwitchContr</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:MonoTouch.Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <example>
            <code lang="c#">
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIView.NotificationSwitchControlIdentifier, (notification) =&gt; {Console.WriteLine ("Received the notification UIView", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIView", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIView.NotificationSwitchControlIdentifier, Callback);
}
</code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Opaque">
      <MemberSignature Language="C#" Value="public virtual bool Opaque { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Opaque" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("isOpaque")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setOpaque:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determines whether the view is opaque or not.</summary>
        <value>
        </value>
        <remarks>
          <para>
            
            If you set this value to true, you should make sure that
            the entire area is painted, if you do not, the behavior is
            undefined.  You should also set the <see cref="P:MonoTouch.UIKit.UIView.Alpha" /> property to 1.0.
            
          </para>
          <para>
            Whenever possible, you should try to set the view as
            opaque, as that informs UIKit that the view does not need
            to be composited and blended with underlying views.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PageScrolledNotification">
      <MemberSignature Language="C#" Value="public static int PageScrolledNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 PageScrolledNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIAccessibilityPageScrolledNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(4, 2)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(4, 2)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An accessibility notification indicating that the page has scrolled.</summary>
        <value></value>
        <remarks></remarks>
        <altmember cref="P:MonoTouch.UIKit.UIView.AnnouncementNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.AnnouncementDidFinishNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.ClosedCaptioningStatusDidChangeNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.GuidedAccessStatusDidChangeNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.InvertColorStatusDidChangeNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.AnnouncementNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.LayoutChangedNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.MonoAudioStatusDidChangeNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.PageScrolledNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.ScreenChangedNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.VoiceOverStatusChangedNotification" />
      </Docs>
    </Member>
    <Member MemberName="PauseAssistiveTechnologyNotification">
      <MemberSignature Language="C#" Value="public static int PauseAssistiveTechnologyNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 PauseAssistiveTechnologyNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIAccessibilityPauseAssistiveTechnologyNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pauses assistive technology notifications.</summary>
        <value></value>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformSystemAnimation" apistyle="classic">
      <MemberSignature Language="C#" Value="public static void PerformSystemAnimation (MonoTouch.UIKit.UISystemAnimation animation, MonoTouch.UIKit.UIView[] views, MonoTouch.UIKit.UIViewAnimationOptions options, MonoTouch.Foundation.NSAction parallelAnimations, MonoTouch.UIKit.UICompletionHandler completion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PerformSystemAnimation(valuetype MonoTouch.UIKit.UISystemAnimation animation, class MonoTouch.UIKit.UIView[] views, valuetype MonoTouch.UIKit.UIViewAnimationOptions options, class MonoTouch.Foundation.NSAction parallelAnimations, class MonoTouch.UIKit.UICompletionHandler completion) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("performSystemAnimation:onViews:options:animations:completion:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="animation" Type="MonoTouch.UIKit.UISystemAnimation" />
        <Parameter Name="views" Type="MonoTouch.UIKit.UIView[]" />
        <Parameter Name="options" Type="MonoTouch.UIKit.UIViewAnimationOptions" />
        <Parameter Name="parallelAnimations" Type="MonoTouch.Foundation.NSAction">
          <Attributes>
            <Attribute>
              <AttributeName>MonoTouch.ObjCRuntime.BlockProxy(typeof(MonoTouch.ObjCRuntime.Trampolines/NIDNSAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="completion" Type="MonoTouch.UIKit.UICompletionHandler">
          <Attributes>
            <Attribute>
              <AttributeName>MonoTouch.ObjCRuntime.BlockProxy(typeof(MonoTouch.ObjCRuntime.Trampolines/NIDUICompletionHandler))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="animation">A defined system animation to perform.</param>
        <param name="views">Views on which to to perform the animations.</param>
        <param name="options">Mask of options that indicates how the animations are to be performed.</param>
        <param name="parallelAnimations">Additional animations specified to run alongside system animation.</param>
        <param name="completion">Action object that is executed when the animation sequence ends.</param>
        <summary>Performs a system-provided animation and optional parallel animations.</summary>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformSystemAnimation" apistyle="unified">
      <MemberSignature Language="C#" Value="public static void PerformSystemAnimation (MonoTouch.UIKit.UISystemAnimation animation, MonoTouch.UIKit.UIView[] views, MonoTouch.UIKit.UIViewAnimationOptions options, Action parallelAnimations, MonoTouch.UIKit.UICompletionHandler completion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PerformSystemAnimation(valuetype MonoTouch.UIKit.UISystemAnimation animation, class MonoTouch.UIKit.UIView[] views, valuetype MonoTouch.UIKit.UIViewAnimationOptions options, class System.Action parallelAnimations, class MonoTouch.UIKit.UICompletionHandler completion) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("performSystemAnimation:onViews:options:animations:completion:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="animation" Type="MonoTouch.UIKit.UISystemAnimation" />
        <Parameter Name="views" Type="MonoTouch.UIKit.UIView[]" />
        <Parameter Name="options" Type="MonoTouch.UIKit.UIViewAnimationOptions" />
        <Parameter Name="parallelAnimations" Type="System.Action">
          <Attributes>
            <Attribute>
              <AttributeName>MonoTouch.ObjCRuntime.BlockProxy(typeof(MonoTouch.ObjCRuntime.Trampolines/NIDAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="completion" Type="MonoTouch.UIKit.UICompletionHandler">
          <Attributes>
            <Attribute>
              <AttributeName>MonoTouch.ObjCRuntime.BlockProxy(typeof(MonoTouch.ObjCRuntime.Trampolines/NIDUICompletionHandler))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="animation">Defined UISystemAnimation to perform.</param>
        <param name="views">Views on which to to perform the animations.</param>
        <param name="options">Mask of options that indicates how the animations are to be performed.</param>
        <param name="parallelAnimations">Additional animations specified to run alongside system animation.</param>
        <param name="completion">Action object that is executed when the animation sequence ends.</param>
        <summary>Performs specified system-provided animation sequence on one or more views, together with user-defined parallel animations.</summary>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformSystemAnimationAsync" apistyle="classic">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;bool&gt; PerformSystemAnimationAsync (MonoTouch.UIKit.UISystemAnimation animation, MonoTouch.UIKit.UIView[] views, MonoTouch.UIKit.UIViewAnimationOptions options, MonoTouch.Foundation.NSAction parallelAnimations);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;bool&gt; PerformSystemAnimationAsync(valuetype MonoTouch.UIKit.UISystemAnimation animation, class MonoTouch.UIKit.UIView[] views, valuetype MonoTouch.UIKit.UIViewAnimationOptions options, class MonoTouch.Foundation.NSAction parallelAnimations) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="animation" Type="MonoTouch.UIKit.UISystemAnimation" />
        <Parameter Name="views" Type="MonoTouch.UIKit.UIView[]" />
        <Parameter Name="options" Type="MonoTouch.UIKit.UIViewAnimationOptions" />
        <Parameter Name="parallelAnimations" Type="MonoTouch.Foundation.NSAction">
          <Attributes>
            <Attribute>
              <AttributeName>MonoTouch.ObjCRuntime.BlockProxy(typeof(MonoTouch.ObjCRuntime.Trampolines/NIDNSAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="animation">A defined system animation to perform.</param>
        <param name="views">Views on which to to perform the animations.</param>
        <param name="options">Mask of options that indicates how the animations are to be performed.</param>
        <param name="parallelAnimations">Additional animations specified to run alongside system animation.</param>
        <summary>Performs a system-provided animation and optional parallel animations.</summary>
        <returns>
          <para>A task that represents the asynchronous PerformSystemAnimation operation.   The value of the TResult parameter is a MonoTouch.UIKit.UICompletionHandler.</para>
        </returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformSystemAnimationAsync" apistyle="unified">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;bool&gt; PerformSystemAnimationAsync (MonoTouch.UIKit.UISystemAnimation animation, MonoTouch.UIKit.UIView[] views, MonoTouch.UIKit.UIViewAnimationOptions options, Action parallelAnimations);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;bool&gt; PerformSystemAnimationAsync(valuetype MonoTouch.UIKit.UISystemAnimation animation, class MonoTouch.UIKit.UIView[] views, valuetype MonoTouch.UIKit.UIViewAnimationOptions options, class System.Action parallelAnimations) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="animation" Type="MonoTouch.UIKit.UISystemAnimation" />
        <Parameter Name="views" Type="MonoTouch.UIKit.UIView[]" />
        <Parameter Name="options" Type="MonoTouch.UIKit.UIViewAnimationOptions" />
        <Parameter Name="parallelAnimations" Type="System.Action">
          <Attributes>
            <Attribute>
              <AttributeName>MonoTouch.ObjCRuntime.BlockProxy(typeof(MonoTouch.ObjCRuntime.Trampolines/NIDAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="animation">Defined UISystemAnimation to perform.</param>
        <param name="views">Views on which to to perform the animations.</param>
        <param name="options">Mask of options that indicates how the animations are to be performed.</param>
        <param name="parallelAnimations">Additional animations specified to run alongside system animation.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformWithoutAnimation" apistyle="classic">
      <MemberSignature Language="C#" Value="public static void PerformWithoutAnimation (MonoTouch.Foundation.NSAction actionsWithoutAnimation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PerformWithoutAnimation(class MonoTouch.Foundation.NSAction actionsWithoutAnimation) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("performWithoutAnimation:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="actionsWithoutAnimation" Type="MonoTouch.Foundation.NSAction">
          <Attributes>
            <Attribute>
              <AttributeName>MonoTouch.ObjCRuntime.BlockProxy(typeof(MonoTouch.ObjCRuntime.Trampolines/NIDNSAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="actionsWithoutAnimation">View transition code that is to be performed without animation.</param>
        <summary>Applies a set of changes to a view with a guarantee that animations will not be used.</summary>
        <remarks>
          <para>Application developers should use this method within an animation block rather than temporarily setting  <see cref="P:MonoTouch.UIKit.UIView.AnimationsEnabled" /> to <see langword="false" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformWithoutAnimation" apistyle="unified">
      <MemberSignature Language="C#" Value="public static void PerformWithoutAnimation (Action actionsWithoutAnimation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PerformWithoutAnimation(class System.Action actionsWithoutAnimation) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("performWithoutAnimation:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="actionsWithoutAnimation" Type="System.Action">
          <Attributes>
            <Attribute>
              <AttributeName>MonoTouch.ObjCRuntime.BlockProxy(typeof(MonoTouch.ObjCRuntime.Trampolines/NIDAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="actionsWithoutAnimation">View transition code that is to be performed without animation.</param>
        <summary>Applies a set of changes to a view with a guarantee that animations will not be used.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PointInside">
      <MemberSignature Language="C#" Value="public virtual bool PointInside (System.Drawing.PointF point, MonoTouch.UIKit.UIEvent uievent);" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool PointInside(valuetype System.Drawing.PointF point, class MonoTouch.UIKit.UIEvent uievent) cil managed" apistyle="classic" />
      <MemberSignature Language="C#" Value="public virtual bool PointInside (MonoTouch.CoreGraphics.CGPoint point, MonoTouch.UIKit.UIEvent uievent);" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool PointInside(valuetype MonoTouch.CoreGraphics.CGPoint point, class MonoTouch.UIKit.UIEvent uievent) cil managed" apistyle="unified" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("pointInside:withEvent:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.PointF" apistyle="classic" />
        <Parameter Name="uievent" Type="MonoTouch.UIKit.UIEvent" />
        <Parameter Name="point" Type="MonoTouch.CoreGraphics.CGPoint" apistyle="unified" />
      </Parameters>
      <Docs>
        <param name="point">
          <para>The location being checked.</para>
        </param>
        <param name="uievent">
          <para>The event that triggered this method call, or <see langword="null" />.
          </para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Returns <see langword="true" /> if the specified point is within the <see cref="T:MonoTouch.UIKit.UIView" />'s <see cref="P:MonoTouch.UIKit.UIView.Bounds" />.</summary>
        <returns>Returns <see langword="true" /> if the specified point is within the <see cref="T:MonoTouch.UIKit.UIView" />'s <see cref="P:MonoTouch.UIKit.UIView.Bounds" />.</returns>
        <remarks>
          <para>The <paramref name="point" /> is evaluated in <c>this</c> <see cref="T:MonoTouch.UIKit.UIView" />'s coordinate system.</para>
        </remarks>
        <altmember cref="M:MonoTouch.UIKit.UIView.HitTest" />
      </Docs>
    </Member>
    <Member MemberName="PreservesSuperviewLayoutMargins">
      <MemberSignature Language="C#" Value="public virtual bool PreservesSuperviewLayoutMargins { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PreservesSuperviewLayoutMargins" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("preservesSuperviewLayoutMargins")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setPreservesSuperviewLayoutMargins:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Preserves layout margins for superview.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReduceMotionStatusDidChangeNotification">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString ReduceMotionStatusDidChangeNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString ReduceMotionStatusDidChangeNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIAccessibilityReduceMotionStatusDidChangeNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for ReduceMotionStatusDidChange</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:MonoTouch.Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <example>
            <code lang="c#">
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIView.ReduceMotionStatusDidChangeNotification, (notification) =&gt; {Console.WriteLine ("Received the notification UIView", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIView", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIView.ReduceMotionStatusDidChangeNotification, Callback);
}
</code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReduceTransparencyStatusDidChangeNotification">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString ReduceTransparencyStatusDidChangeNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString ReduceTransparencyStatusDidChangeNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIAccessibilityReduceTransparencyStatusDidChangeNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for ReduceTransparencyStatusDidChange</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:MonoTouch.Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <example>
            <code lang="c#">
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIView.ReduceTransparencyStatusDidChangeNotification, (notification) =&gt; {Console.WriteLine ("Received the notification UIView", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIView", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIView.ReduceTransparencyStatusDidChangeNotification, Callback);
}
</code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveConstraint">
      <MemberSignature Language="C#" Value="public virtual void RemoveConstraint (MonoTouch.UIKit.NSLayoutConstraint constraint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveConstraint(class MonoTouch.UIKit.NSLayoutConstraint constraint) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("removeConstraint:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constraint" Type="MonoTouch.UIKit.NSLayoutConstraint" />
      </Parameters>
      <Docs>
        <param name="constraint">The <see cref="T:MonoTouch.UIKit.NSLayoutConstraint" /> to be removed.</param>
        <summary>Removes an Auto Layout constraint from the <see cref="T:MonoTouch.UIKit.UIView" />'s <see cref="P:MonoTouch.UIKit.UIView.Constraints" />.</summary>
        <remarks />
        <altmember cref="P:MonoTouch.UIKit.UIView.Constraints" />
        <altmember cref="M:MonoTouch.UIKit.UIView.AddConstraint" />
        <altmember cref="M:MonoTouch.UIKit.UIView.AddConstraints" />
        <altmember cref="M:MonoTouch.UIKit.UIView.RemoveConstraints" />
        <altmember cref="P:MonoTouch.UIKit.UIView.TranslatesAutoresizingMaskIntoConstraints" />
      </Docs>
    </Member>
    <Member MemberName="RemoveConstraints">
      <MemberSignature Language="C#" Value="public virtual void RemoveConstraints (MonoTouch.UIKit.NSLayoutConstraint[] constraints);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveConstraints(class MonoTouch.UIKit.NSLayoutConstraint[] constraints) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("removeConstraints:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constraints" Type="MonoTouch.UIKit.NSLayoutConstraint[]" />
      </Parameters>
      <Docs>
        <param name="constraints">The <see cref="T:MonoTouch.UIKit.NSLayoutConstraint" />s to be removed.</param>
        <summary>Removes multiple Auto Layout constraints from the <see cref="T:MonoTouch.UIKit.UIView" />'s <see cref="P:MonoTouch.UIKit.UIView.Constraints" />.</summary>
        <remarks />
        <altmember cref="P:MonoTouch.UIKit.UIView.Constraints" />
        <altmember cref="M:MonoTouch.UIKit.UIView.AddConstraint" />
        <altmember cref="M:MonoTouch.UIKit.UIView.AddConstraints" />
        <altmember cref="M:MonoTouch.UIKit.UIView.RemoveConstraint" />
        <altmember cref="P:MonoTouch.UIKit.UIView.TranslatesAutoresizingMaskIntoConstraints" />
      </Docs>
    </Member>
    <Member MemberName="RemoveFromSuperview">
      <MemberSignature Language="C#" Value="public virtual void RemoveFromSuperview ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveFromSuperview() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("removeFromSuperview")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Detaches the <see cref="T:MonoTouch.UIKit.UIView" /> from its <see cref="P:MonoTouch.UIKit.UIView.Superview" />.</summary>
        <remarks>
          <para>Application developers must not call this method from within the <see cref="M:MonoTouch.UIKit.UIView" />'s <see cref="M:MonoTouch.UIKit.UIView.DrawRect" /> method.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveGestureRecognizer">
      <MemberSignature Language="C#" Value="public virtual void RemoveGestureRecognizer (MonoTouch.UIKit.UIGestureRecognizer gestureRecognizer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveGestureRecognizer(class MonoTouch.UIKit.UIGestureRecognizer gestureRecognizer) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("removeGestureRecognizer:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(3, 2)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="gestureRecognizer" Type="MonoTouch.UIKit.UIGestureRecognizer" />
      </Parameters>
      <Docs>
        <param name="gestureRecognizer">The <see cref="T:MonoTouch.UIKit.UIGestureRecognizer" /> to remove.</param>
        <summary>Removes a gesture recognizer from the <see cref="T:MonoTouch.UIKit.UIView" />'s <see cref="P:MonoTouch.UIKit.UIView.GestureRecognizers" />.</summary>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="RemoveMotionEffect">
      <MemberSignature Language="C#" Value="public virtual void RemoveMotionEffect (MonoTouch.UIKit.UIMotionEffect effect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveMotionEffect(class MonoTouch.UIKit.UIMotionEffect effect) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("removeMotionEffect:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="effect" Type="MonoTouch.UIKit.UIMotionEffect" />
      </Parameters>
      <Docs>
        <param name="effect">Motion effect to remove from the view.</param>
        <summary>Removes the specified motion effect to the view.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RequiresConstraintBasedLayout">
      <MemberSignature Language="C#" Value="public static bool RequiresConstraintBasedLayout ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool RequiresConstraintBasedLayout() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("requiresConstraintBasedLayout")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indicates that the <see cref="T:MonoTouch.UIKit.UIView" /> uses Auto Layout.</summary>
        <returns>The default value is <see langword="false" />.</returns>
        <remarks>
          <para>Application developers should override this method to return  <see langword="true" /> if their <see cref="T:MonoTouch.UIKit.UIView" /> relies on Auto Layout.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResizableSnapshotView">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIView ResizableSnapshotView (System.Drawing.RectangleF rect, bool afterScreenUpdates, MonoTouch.UIKit.UIEdgeInsets capInsets);" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class MonoTouch.UIKit.UIView ResizableSnapshotView(valuetype System.Drawing.RectangleF rect, bool afterScreenUpdates, valuetype MonoTouch.UIKit.UIEdgeInsets capInsets) cil managed" apistyle="classic" />
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIView ResizableSnapshotView (MonoTouch.CoreGraphics.CGRect rect, bool afterScreenUpdates, MonoTouch.UIKit.UIEdgeInsets capInsets);" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class MonoTouch.UIKit.UIView ResizableSnapshotView(valuetype MonoTouch.CoreGraphics.CGRect rect, bool afterScreenUpdates, valuetype MonoTouch.UIKit.UIEdgeInsets capInsets) cil managed" apistyle="unified" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("resizableSnapshotViewFromRect:afterScreenUpdates:withCapInsets:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIView</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" apistyle="classic" />
        <Parameter Name="afterScreenUpdates" Type="System.Boolean" />
        <Parameter Name="capInsets" Type="MonoTouch.UIKit.UIEdgeInsets" />
        <Parameter Name="rect" Type="MonoTouch.CoreGraphics.CGRect" apistyle="unified" />
      </Parameters>
      <Docs>
        <param name="rect">Defines the section of the view that you want to capture. The defined rectangle must be within the bounds of the coordinate space for the current view</param>
        <param name="afterScreenUpdates">A Boolean that specifies if a snapshot should be taken subsequent to  changes.</param>
        <param name="capInsets">Edge insets used to define the stretchable portion of a returned view’s content.</param>
        <summary>Creates an image snapshot of a portion of the <see cref="T:MonoTouch.UIKit.UIView" />, with stretchable insets.</summary>
        <returns>A <see cref="T:MonoTouch.UIKit.UIView" /> that contains the rendered contents of <c>this</c> <see cref="T:MonoTouch.UIKit.UIView" />.</returns>
        <remarks>
          <para>Application developers who do not want the returned view to have a stretchable area should specify <see cref="P:MonoTouch.UIKit.UIEdgeInsets.Zero" /> for <paramref name="capInsets" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RestorationIdentifier">
      <MemberSignature Language="C#" Value="public virtual string RestorationIdentifier { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RestorationIdentifier" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("restorationIdentifier")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setRestorationIdentifier:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>If not <see langword="null" />, indicates that the <see cref="T:MonoTouch.UIKit.UIView" /> supports state preservation and restoration.</summary>
        <value>The default value is <see langword="null" />. </value>
        <remarks>
          <para>If this method returns the default <see langword="null" /> value, the <see cref="T:MonoTouch.UIKit.UIView" /> will not have its state preserved and restored.</para>
          <para>If the <see cref="T:MonoTouch.UIKit.UIView" /> does need state preservation and restoration, this method should be overridden to return a <see cref="T:System.String" />.</para>
          <para>In addition to returning a non-<c>null</c> <see cref="P:MonoTouch.UIKit.UIView.RestorationIdentifier" />, so too must the <see cref="T:MonoTouch.UIKit.UIViewController" /> for which this <see cref="T:MonoTouch.UIKit.UIView" /> is the <see cref="P:MonoTouch.UIKit.UIViewController.View" /> and all the ancestor  <see cref="T:MonoTouch.UIKit.UIViewController" />s reachable by the <see cref="P:MonoTouch.UIKit.UIViewController.Parent" /> property.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResumeAssistiveTechnologyNotification">
      <MemberSignature Language="C#" Value="public static int ResumeAssistiveTechnologyNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 ResumeAssistiveTechnologyNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIAccessibilityResumeAssistiveTechnologyNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Resumes assistive technology notifications.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScreenChangedNotification">
      <MemberSignature Language="C#" Value="public static int ScreenChangedNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 ScreenChangedNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIAccessibilityScreenChangedNotification", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An accessibility notification that the screen has changed.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:MonoTouch.UIKit.UIView.AnnouncementNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.AnnouncementDidFinishNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.ClosedCaptioningStatusDidChangeNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.GuidedAccessStatusDidChangeNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.InvertColorStatusDidChangeNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.AnnouncementNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.LayoutChangedNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.MonoAudioStatusDidChangeNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.PageScrolledNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.ScreenChangedNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.VoiceOverStatusChangedNotification" />
      </Docs>
    </Member>
    <Member MemberName="SendSubviewToBack">
      <MemberSignature Language="C#" Value="public virtual void SendSubviewToBack (MonoTouch.UIKit.UIView view);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SendSubviewToBack(class MonoTouch.UIKit.UIView view) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("sendSubviewToBack:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="view" Type="MonoTouch.UIKit.UIView" />
      </Parameters>
      <Docs>
        <param name="view">
          <para>The <see cref="T:MonoTouch.UIKit.UIView" /> to be sent to the back.</para>
        </param>
        <summary>Moves a <see cref="T:MonoTouch.UIKit.UIView" /> so that it appears behind all its siblings.</summary>
        <remarks>
          <para>This method moves the <paramref name="view" /> so that it appears behind other <see cref="T:MonoTouch.UIKit.UIView" />s in the <see cref="P:MonoTouch.UIKit.UIView.Subviews" /> array. Display z-order is determined by the position of the <see cref="T:MonoTouch.UIKit.UIView" /> in the <see cref="P:MonoTouch.UIKit.UIView.Subviews" /> array and this method moves <paramref name="view" /> to the first location in the <see cref="P:MonoTouch.UIKit.UIView.Subviews" /> array. 
          </para>
        </remarks>
        <altmember cref="M:MonoTouch.UIKit.UIView.BringSubviewToFront" />
        <altmember cref="M:MonoTouch.UIKit.UIView.ExchangeSubview" />
      </Docs>
    </Member>
    <Member MemberName="SetAnimationBeginsFromCurrentState">
      <MemberSignature Language="C#" Value="public static void SetAnimationBeginsFromCurrentState (bool fromCurrentState);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAnimationBeginsFromCurrentState(bool fromCurrentState) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setAnimationBeginsFromCurrentState:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromCurrentState" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fromCurrentState">Returns true if you want to start the
          animation from the current state, false otherwise.</param>
        <summary>Sets whether the animation transaction will animate
          from the current view state.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAnimationCurve">
      <MemberSignature Language="C#" Value="public static void SetAnimationCurve (MonoTouch.UIKit.UIViewAnimationCurve curve);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAnimationCurve(valuetype MonoTouch.UIKit.UIViewAnimationCurve curve) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setAnimationCurve:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="curve" Type="MonoTouch.UIKit.UIViewAnimationCurve" />
      </Parameters>
      <Docs>
        <param name="curve">A curve used to animate the property changes.</param>
        <summary>Sets the animation curve for this animation transaction.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAnimationDelay">
      <MemberSignature Language="C#" Value="public static void SetAnimationDelay (double delay);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAnimationDelay(float64 delay) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setAnimationDelay:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delay" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="delay">Animation delay in seconds.</param>
        <summary>Sets the animation delay for this animation transaction.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAnimationDelegate">
      <MemberSignature Language="C#" Value="public static void SetAnimationDelegate (MonoTouch.Foundation.NSObject del);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAnimationDelegate(class MonoTouch.Foundation.NSObject del) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setAnimationDelegate:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="del" Type="MonoTouch.Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="del">Delegate object used to define the methods registered using the "SetAnimationDidStopSelector".</param>
        <summary>Allows the app developer to create a custom animation delegate.</summary>
        <remarks>
          <para>This method is discouraged for applications targeting iOS 4+.</para>
          <para>This method, with <see cref="M:MonoTouch.UIKit.UIView.SetAnimationWillStartSelector" /> and <see cref="M:MonoTouch.UIKit.UIView.SetAnimationDidStopSelector" /> allows the application developer to register a custom delegate object for animations created using the now-discouraged <see cref="M:MonoTouch.UIKit.UIView.BeginAnimations" /> / <see cref="M:MonoTouch.UIKit.UIView.CommitAnimations" /> method, rather than the preferred block-based animations.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAnimationDidStopSelector">
      <MemberSignature Language="C#" Value="public static void SetAnimationDidStopSelector (MonoTouch.ObjCRuntime.Selector sel);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAnimationDidStopSelector(class MonoTouch.ObjCRuntime.Selector sel) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setAnimationDidStopSelector:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sel" Type="MonoTouch.ObjCRuntime.Selector" />
      </Parameters>
      <Docs>
        <param name="sel">Delegate object used to define the methods registered using the "SetAnimationDidStopSelector"</param>
        <summary>Specifies the selector to be used by a custom animation delegate when animation ends.</summary>
        <remarks>
          <para>This method is discouraged for applications targeting iOS 4+.</para>
          <para>This method, with <see cref="M:MonoTouch.UIKit.UIView.SetAnimationDelegate" /> and <see cref="M:MonoTouch.UIKit.UIView.SetAnimationWillStartSelector" />, can be used to create a custom animation delegate.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAnimationDuration">
      <MemberSignature Language="C#" Value="public static void SetAnimationDuration (double duration);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAnimationDuration(float64 duration) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setAnimationDuration:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="duration">Duration in seconds.</param>
        <summary>Sets the duration for this animation transaction.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAnimationRepeatAutoreverses">
      <MemberSignature Language="C#" Value="public static void SetAnimationRepeatAutoreverses (bool repeatAutoreverses);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAnimationRepeatAutoreverses(bool repeatAutoreverses) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setAnimationRepeatAutoreverses:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="repeatAutoreverses" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="repeatAutoreverses">True if this animation should autoreverse when it completes.</param>
        <summary>Sets whether this animation transaction will automatically reverse when it completes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAnimationRepeatCount">
      <MemberSignature Language="C#" Value="public static void SetAnimationRepeatCount (float repeatCount);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAnimationRepeatCount(float32 repeatCount) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setAnimationRepeatCount:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="repeatCount" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="repeatCount">The repeat count for this transaction.</param>
        <summary>Sets the repeat count for this animation transaction.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAnimationStartDate">
      <MemberSignature Language="C#" Value="public static void SetAnimationStartDate (MonoTouch.Foundation.NSDate startDate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAnimationStartDate(class MonoTouch.Foundation.NSDate startDate) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setAnimationStartDate:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startDate" Type="MonoTouch.Foundation.NSDate" />
      </Parameters>
      <Docs>
        <param name="startDate">Start time defined to begin the animations.</param>
        <summary>Specifies when the animation should begin.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAnimationTransition">
      <MemberSignature Language="C#" Value="public static void SetAnimationTransition (MonoTouch.UIKit.UIViewAnimationTransition transition, MonoTouch.UIKit.UIView forView, bool cache);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAnimationTransition(valuetype MonoTouch.UIKit.UIViewAnimationTransition transition, class MonoTouch.UIKit.UIView forView, bool cache) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setAnimationTransition:forView:cache:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transition" Type="MonoTouch.UIKit.UIViewAnimationTransition" />
        <Parameter Name="forView" Type="MonoTouch.UIKit.UIView" />
        <Parameter Name="cache" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="transition">The transition to be applied to the view.</param>
        <param name="forView">The view to which to apply the transition.</param>
        <param name="cache">Set to YES, if before and after images of the view are to be rendered once and used to create frames in the animation; set to NO, when the view and its contents are to be updated for each frame of the transition animation</param>
        <summary>Sets a transition to be used during an animation block.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAnimationWillStartSelector">
      <MemberSignature Language="C#" Value="public static void SetAnimationWillStartSelector (MonoTouch.ObjCRuntime.Selector sel);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAnimationWillStartSelector(class MonoTouch.ObjCRuntime.Selector sel) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setAnimationWillStartSelector:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sel" Type="MonoTouch.ObjCRuntime.Selector" />
      </Parameters>
      <Docs>
        <param name="sel">A message that is sent to the animation delegate before the animations commence.</param>
        <summary>Specifies the selector to be used by a custom animation delegate when animation is about to begin.</summary>
        <remarks>
          <para>This method is discouraged for applications targeting iOS 4+.</para>
          <para>This method, with <see cref="M:MonoTouch.UIKit.UIView.SetAnimationDelegate" /> and <see cref="M:MonoTouch.UIKit.UIView.SetAnimationDidStopSelector" />, can be used to create a custom animation delegate.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetContentCompressionResistancePriority">
      <MemberSignature Language="C#" Value="public virtual void SetContentCompressionResistancePriority (float priority, MonoTouch.UIKit.UILayoutConstraintAxis axis);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetContentCompressionResistancePriority(float32 priority, valuetype MonoTouch.UIKit.UILayoutConstraintAxis axis) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setContentCompressionResistancePriority:forAxis:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Single" />
        <Parameter Name="axis" Type="MonoTouch.UIKit.UILayoutConstraintAxis" />
      </Parameters>
      <Docs>
        <param name="priority">The new priority. Preferable if a member of <see cref="T:MonoTouch.UIKit.UILayoutPriority" />.</param>
        <param name="axis">The axis for which the resistance is being set.</param>
        <summary>Sets the resistance to compression below the <see cref="T:MonoTouch.UIKit.UIView" />'s <see cref="P:MonoTouch.UIKit.UIView.IntrinsicContentSize" />.</summary>
        <remarks>
          <para>This method sets the resistance of a <see cref="T:MonoTouch.UIKit.UIView" /> to compression to a size smaller than its <see cref="P:MonoTouch.UIKit.UIView.IntrinsicContentSize" />. Application developers should set this property for both <see cref="F:MonoTouch.UIKit.UILayoutConstraintAxis.Horizontal" /> and <see cref="F:MonoTouch.UIKit.UILayoutConstraintAxis.Vertical" />.</para>
        </remarks>
        <altmember cref="M:MonoTouch.UIKit.UIView.ContentCompressionResistancePriority" />
        <altmember cref="M:MonoTouch.UIKit.UIView.SetContentHuggingPriority" />
      </Docs>
    </Member>
    <Member MemberName="SetContentHuggingPriority">
      <MemberSignature Language="C#" Value="public virtual void SetContentHuggingPriority (float priority, MonoTouch.UIKit.UILayoutConstraintAxis axis);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetContentHuggingPriority(float32 priority, valuetype MonoTouch.UIKit.UILayoutConstraintAxis axis) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setContentHuggingPriority:forAxis:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Single" />
        <Parameter Name="axis" Type="MonoTouch.UIKit.UILayoutConstraintAxis" />
      </Parameters>
      <Docs>
        <param name="priority">The new priority. Preferable if a member of <see cref="T:MonoTouch.UIKit.UILayoutPriority" />.</param>
        <param name="axis">The axis for which the resistance is being set.</param>
        <summary>Sets the resistance to expansion beyond the <see cref="T:MonoTouch.UIKit.UIView" />'s <see cref="P:MonoTouch.UIKit.UIView.IntrinsicContentSize" />.</summary>
        <remarks>
          <para>This method sets the resistance of a <see cref="T:MonoTouch.UIKit.UIView" /> to expansion to a size greater than its <see cref="P:MonoTouch.UIKit.UIView.IntrinsicContentSize" />. Application developers should set this property for both <see cref="F:MonoTouch.UIKit.UILayoutConstraintAxis.Horizontal" /> and <see cref="F:MonoTouch.UIKit.UILayoutConstraintAxis.Vertical" />.</para>
        </remarks>
        <altmember cref="M:MonoTouch.UIKit.UIView.SetContentCompressionResistancePriority" />
      </Docs>
    </Member>
    <Member MemberName="SetNeedsDisplay">
      <MemberSignature Language="C#" Value="public virtual void SetNeedsDisplay ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetNeedsDisplay() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setNeedsDisplay")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Marks the view dirty and queues a redraw operation on it.</summary>
        <remarks>
          <para>
            This method is invoked if the contents of the view need to
            be refreshed due to a change of state or geometry.  Invoking
            this method will cause the <see cref="M:MonoTouch.UIKit.UIView.Draw(System.Drawing.RectangleF)" />
            method to be invoked.
          </para>
          <para>
            Alternatively you can use the <see cref="M:MonoTouch.UIKit.UIView.SetNeedsDisplayInRect(System.Drawing.RectangleF)" />
            method to only mark a specific region of the view to be repainted.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetNeedsDisplayInRect">
      <MemberSignature Language="C#" Value="public virtual void SetNeedsDisplayInRect (System.Drawing.RectangleF rect);" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetNeedsDisplayInRect(valuetype System.Drawing.RectangleF rect) cil managed" apistyle="classic" />
      <MemberSignature Language="C#" Value="public virtual void SetNeedsDisplayInRect (MonoTouch.CoreGraphics.CGRect rect);" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetNeedsDisplayInRect(valuetype MonoTouch.CoreGraphics.CGRect rect) cil managed" apistyle="unified" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setNeedsDisplayInRect:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" apistyle="classic" />
        <Parameter Name="rect" Type="MonoTouch.CoreGraphics.CGRect" apistyle="unified" />
      </Parameters>
      <Docs>
        <param name="rect">
          <para>The region that will be marked as dirty.</para>
        </param>
        <summary>Marks a region of the view as dirty and queues a redraw operation on that region.</summary>
        <remarks>
          <para>
            This method is invoked if a region of the contents of the view need to
            be refreshed due to a change of state or geometry.  Invoking
            this method will cause the <see cref="M:MonoTouch.UIKit.UIView.Draw(System.Drawing.RectangleF)" />
            method to be invoked.
          </para>
          <para>
            Alternatively you can use the <see cref="M:MonoTouch.UIKit.UIView.SetNeedsDisplay" />
            method if you want to repaint the entire view.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetNeedsLayout">
      <MemberSignature Language="C#" Value="public virtual void SetNeedsLayout ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetNeedsLayout() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setNeedsLayout")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sets whether subviews need to be rearranged before displaying.</summary>
        <remarks>
          If the state of your view changes in response to some API calls,
          instead of changing the layout manually in response to the change,
          you should invoke this method which will
          flag the view for a layout.  The layout event will then be processed
          the next time the main loop runs.  By using this approach, you can
          coalesce multiple changes to the layout in a single pass.
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetNeedsUpdateConstraints">
      <MemberSignature Language="C#" Value="public virtual void SetNeedsUpdateConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetNeedsUpdateConstraints() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setNeedsUpdateConstraints")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indicates to the Auto Layout system that it must call <see cref="M:MonoTouch.UIKit.UIView.UpdateConstraints" />.</summary>
        <remarks>
          <para>This method tells the Auto Layout system to call <see cref="M:MonoTouch.UIKit.UIView.UpdateConstraints" />, which will calculate new constraint parameters.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldGroupAccessibilityChildren">
      <MemberSignature Language="C#" Value="public virtual bool ShouldGroupAccessibilityChildren { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShouldGroupAccessibilityChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("shouldGroupAccessibilityChildren")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setShouldGroupAccessibilityChildren:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether the <see cref="T:MonoTouch.UIKit.UIView" />'s children should be grouped for the purposes of voice-over, regardless of their position on the screen.</summary>
        <value>The default value is <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeThatFits">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.SizeF SizeThatFits (System.Drawing.SizeF size);" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Drawing.SizeF SizeThatFits(valuetype System.Drawing.SizeF size) cil managed" apistyle="classic" />
      <MemberSignature Language="C#" Value="public virtual MonoTouch.CoreGraphics.CGSize SizeThatFits (MonoTouch.CoreGraphics.CGSize size);" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype MonoTouch.CoreGraphics.CGSize SizeThatFits(valuetype MonoTouch.CoreGraphics.CGSize size) cil managed" apistyle="unified" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("sizeThatFits:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType apistyle="classic">System.Drawing.SizeF</ReturnType>
        <ReturnType apistyle="unified">MonoTouch.CoreGraphics.CGSize</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Drawing.SizeF" apistyle="classic" />
        <Parameter Name="size" Type="MonoTouch.CoreGraphics.CGSize" apistyle="unified" />
      </Parameters>
      <Docs>
        <param name="size">
          <para>The current <see cref="T:System.Drawing.SizeF" /> of the <see cref="T:MonoTouch.UIKit.UIView" /></para>
        </param>
        <summary>Returns the <see cref="T:System.Drawing.SizeF" /> that best fits <c>this</c> <see cref="T:MonoTouch.UIKit.UIView" />.</summary>
        <returns>
          <para>The default value is the <see cref="T:MonoTouch.UIKit.UIView" />'s <see cref="P:MonoTouch.UIKit.UIView.Bounds" />' <see cref="P:System.Drawing.RectangleF.Size" />.</para>
        </returns>
        <remarks>
        </remarks>
        <altmember cref="M:MonoToch.UIKit.UIView.SizeToFit" />
      </Docs>
    </Member>
    <Member MemberName="SizeToFit">
      <MemberSignature Language="C#" Value="public virtual void SizeToFit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SizeToFit() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("sizeToFit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Moves and resizes the <see cref="T:MonoTouch.UIKit.UIView" /> so that it tightly encloses its <see cref="P:MonoTouch.UIKit.UIView.Subviews" /></summary>
        <remarks>
          <para>Calling this method resizes the <see cref="T:MonoTouch.UIKit.UIView" /> so that it just encloses its subviews. Some <see cref="T:MonoTouch.UIKit.UIView" /> that do not have their <see cref="P:MonoTouch.UIKit.UIView.Superview" /> property set resize themselves to the screen bounds, so application developers should generally make sure that they have assembled an appropriate view hierarchy before calling <see cref="M:MonoTouch.UIKit.UIView.SizeToFit" />.</para>
          <para>Application developers should not override this method. Instead, application developers should override <see cref="M:MonoTouch.UIKit.UIView.SizeThatFits" />, which this method will call.</para>
        </remarks>
        <altmember cref="M:MonoTouch.UIKit.UIView.SizeThatFits" />
      </Docs>
    </Member>
    <Member MemberName="SnapshotView">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIView SnapshotView (bool afterScreenUpdates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class MonoTouch.UIKit.UIView SnapshotView(bool afterScreenUpdates) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("snapshotViewAfterScreenUpdates:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIView</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="afterScreenUpdates" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="afterScreenUpdates">Boolean that indicates whether the snapshot should be taken subsequent to recent changes being incorporated.</param>
        <summary>Creates a <see cref="T:MonoTouch.UIKit.UIView" /> that contains a snapshot image of the current view's contents.</summary>
        <returns>A new view object that is based upon a snapshot of the rendered contents of the current view.</returns>
        <remarks>
          <para>This method is faster than rendering a view into a bitmap context. Application developers can use this method to create a visual proxy for their view before performing animations on a complex view hierarchy.</para>
        </remarks>
        <altmember cref="M:MonoTouch.UIKit.UIView.ResizableSnapshotView" />
        <altmember cref="M:MonoTouch.UIKit.UIView.DrawViewHierarchy" />
      </Docs>
    </Member>
    <Member MemberName="SpeakScreenStatusDidChangeNotification">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString SpeakScreenStatusDidChangeNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString SpeakScreenStatusDidChangeNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIAccessibilitySpeakScreenStatusDidChangeNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for SpeakScreenStatusDidChange</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:MonoTouch.Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <example>
            <code lang="c#">
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIView.SpeakScreenStatusDidChangeNotification, (notification) =&gt; {Console.WriteLine ("Received the notification UIView", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIView", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIView.SpeakScreenStatusDidChangeNotification, Callback);
}
</code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SpeakSelectionStatusDidChangeNotification">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString SpeakSelectionStatusDidChangeNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString SpeakSelectionStatusDidChangeNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIAccessibilitySpeakSelectionStatusDidChangeNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for SpeakSelectionStatusDidChange</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:MonoTouch.Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <example>
            <code lang="c#">
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIView.SpeakSelectionStatusDidChangeNotification, (notification) =&gt; {Console.WriteLine ("Received the notification UIView", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIView", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIView.SpeakSelectionStatusDidChangeNotification, Callback);
}
</code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SpeechAttributeLanguage">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString SpeechAttributeLanguage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString SpeechAttributeLanguage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIAccessibilitySpeechAttributeLanguage", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retrieves the language used during voice-over.</summary>
        <value>A BCP-47 language code.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SpeechAttributePitch">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString SpeechAttributePitch { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString SpeechAttributePitch" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIAccessibilitySpeechAttributePitch", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retrieves the pitch used by voice-over.</summary>
        <value>Values range from 0.5 (low pitch) to 2.0 (high pitch).</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SpeechAttributePunctuation">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString SpeechAttributePunctuation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString SpeechAttributePunctuation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIAccessibilitySpeechAttributePunctuation", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether punctuation is being pronounced by voice-over.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StringSize">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF StringSize (string str, MonoTouch.UIKit.UIFont font);" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF StringSize(string str, class MonoTouch.UIKit.UIFont font) cil managed" apistyle="classic" />
      <MemberSignature Language="C#" Value="public MonoTouch.CoreGraphics.CGSize StringSize (string str, MonoTouch.UIKit.UIFont font);" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype MonoTouch.CoreGraphics.CGSize StringSize(string str, class MonoTouch.UIKit.UIFont font) cil managed" apistyle="unified" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType apistyle="classic">System.Drawing.SizeF</ReturnType>
        <ReturnType apistyle="unified">MonoTouch.CoreGraphics.CGSize</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="font" Type="MonoTouch.UIKit.UIFont" />
      </Parameters>
      <Docs>
        <param name="str">The string whose size is being calculated.</param>
        <param name="font">The font to be used in the size calculation.</param>
        <summary>
          <para>Deprecated in iOS7.  Use NSString.GetSizeUsingAttributes(UIStringAttributes) instead.</para>
          <para>Calculates the <see cref="T:System.Drawing.SizeF" /> of the specified string if it were rendered with the specified font.</para>
        </summary>
        <returns>Returns the <see cref="T:System.Drawing.SizeF" /> of the specified string if it were rendered with the specified font.</returns>
        <remarks>
          <para>Application developers can use this method to calculate text metrics. It does not render or otherwise change state in the <see cref="T:MonoTouch.UIKit.UIView" />.</para>
          <para>In iOS 6 and later, this method calculates the size using the <see cref="M:MonoTouch.UIKit.UILineBreakMode.WordWrap" /> line-break mode. In earlier versions, this method returns the calculation without any line breaks.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StringSize">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF StringSize (string str, MonoTouch.UIKit.UIFont font, System.Drawing.SizeF constrainedToSize);" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF StringSize(string str, class MonoTouch.UIKit.UIFont font, valuetype System.Drawing.SizeF constrainedToSize) cil managed" apistyle="classic" />
      <MemberSignature Language="C#" Value="public MonoTouch.CoreGraphics.CGSize StringSize (string str, MonoTouch.UIKit.UIFont font, MonoTouch.CoreGraphics.CGSize constrainedToSize);" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype MonoTouch.CoreGraphics.CGSize StringSize(string str, class MonoTouch.UIKit.UIFont font, valuetype MonoTouch.CoreGraphics.CGSize constrainedToSize) cil managed" apistyle="unified" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType apistyle="classic">System.Drawing.SizeF</ReturnType>
        <ReturnType apistyle="unified">MonoTouch.CoreGraphics.CGSize</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="font" Type="MonoTouch.UIKit.UIFont" />
        <Parameter Name="constrainedToSize" Type="System.Drawing.SizeF" apistyle="classic" />
        <Parameter Name="constrainedToSize" Type="MonoTouch.CoreGraphics.CGSize" apistyle="unified" />
      </Parameters>
      <Docs>
        <param name="str">The string whose size is being calculated.</param>
        <param name="font">The font to be used in the size calculation.</param>
        <param name="constrainedToSize">The maximum <see cref="T:System.Drawing.SizeF" /> allowed for the string.</param>
        <summary>
          <para>Deprecated in iOS7.   Use NSString.GetBoundingRect (SizeF, NSStringDrawingOptions, UIStringAttributes,NSStringDrawingContext) instead.</para>
          <para>Calculates the <see cref="T:System.Drawing.SizeF" /> of the specified string if it were rendered with the specified font and constrained to the specified size.</para>
        </summary>
        <returns>Returns the <see cref="T:System.Drawing.SizeF" /> of the specified string if it were rendered with the specified font and constrained to the specified size.</returns>
        <remarks>
          <para>Application developers can use this method to calculate text metrics. It does not render or otherwise change state in the <see cref="T:MonoTouch.UIKit.UIView" />.</para>
          <para>This method calculates the size that the <paramref name="str" /> would require if rendered with the <paramref name="font" />, but if it the rendering were not allowed to exceed the dimensions of the <paramref name="constrainedToSize" /><see cref="T:System.Drawing.SizeF" />. This method calculates the size using <see cref="M:MonoTouch.UIKit.UILineBreakMode.WordWrap" /> line-break mode. If the calculated size exceeds the available dimensions, the method will attempt to truncate the string internally and return a <see cref="T:System.Drawing.SizeF" /> based on that truncated text. If the <see cref="P:System.Drawing.SizeF.Height" /> of the <paramref name="constrainedToSize" /> argument is less than that of a single line of text in the specfied font, the method may return a <see cref="T:System.Drawing.SizeF" /> whose <see cref="P:System.Drawing.SizeF.Height" /> is greater than that in <paramref name="constrainedToSize" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StringSize">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF StringSize (string str, MonoTouch.UIKit.UIFont font, System.Drawing.SizeF constrainedToSize, MonoTouch.UIKit.UILineBreakMode lineBreakMode);" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF StringSize(string str, class MonoTouch.UIKit.UIFont font, valuetype System.Drawing.SizeF constrainedToSize, valuetype MonoTouch.UIKit.UILineBreakMode lineBreakMode) cil managed" apistyle="classic" />
      <MemberSignature Language="C#" Value="public MonoTouch.CoreGraphics.CGSize StringSize (string str, MonoTouch.UIKit.UIFont font, MonoTouch.CoreGraphics.CGSize constrainedToSize, MonoTouch.UIKit.UILineBreakMode lineBreakMode);" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype MonoTouch.CoreGraphics.CGSize StringSize(string str, class MonoTouch.UIKit.UIFont font, valuetype MonoTouch.CoreGraphics.CGSize constrainedToSize, valuetype MonoTouch.UIKit.UILineBreakMode lineBreakMode) cil managed" apistyle="unified" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType apistyle="classic">System.Drawing.SizeF</ReturnType>
        <ReturnType apistyle="unified">MonoTouch.CoreGraphics.CGSize</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="font" Type="MonoTouch.UIKit.UIFont" />
        <Parameter Name="constrainedToSize" Type="System.Drawing.SizeF" apistyle="classic" />
        <Parameter Name="lineBreakMode" Type="MonoTouch.UIKit.UILineBreakMode" />
        <Parameter Name="constrainedToSize" Type="MonoTouch.CoreGraphics.CGSize" apistyle="unified" />
      </Parameters>
      <Docs>
        <param name="str">The string whose size is being calculated.</param>
        <param name="font">The font to be used in the size calculation.</param>
        <param name="constrainedToSize">The maximum <see cref="T:System.Drawing.SizeF" /> allowed for the string.</param>
        <param name="lineBreakMode">The line-break mode to be used in the calculation.</param>
        <summary>
          <para>Deprecated in iOS7.   Use NSString.GetBoundingRect (SizeF, NSStringDrawingOptions, UIStringAttributes,NSStringDrawingContext) instead.</para>
          <para>Calculates the <see cref="T:System.Drawing.SizeF" /> of the specified string if it were rendered with the specified: font, size constraint, and line-break mode.</para>
        </summary>
        <returns>Returns the <see cref="T:System.Drawing.SizeF" /> of the specified string if it were rendered with the specified: font, size constraint, and line-break mode.</returns>
        <remarks>
          <para>Application developers can use this method to calculate text metrics. It does not render or otherwise change state in the <see cref="T:MonoTouch.UIKit.UIView" />.</para>
          <para>This method calculates the size that the <paramref name="str" /> would require if rendered with the <paramref name="font" />, but if it the rendering were not allowed to exceed the dimensions of the <paramref name="constrainedToSize" /><see cref="T:System.Drawing.SizeF" />. This method calculates the size using the specified <paramref name="lineBreakMode" /> line-break mode. If the calculated size exceeds the available dimensions, the method will attempt to truncate the string internally and return a <see cref="T:System.Drawing.SizeF" /> based on that truncated text. If the <see cref="P:System.Drawing.SizeF.Height" /> of the <paramref name="constrainedToSize" /> argument is less than that of a single line of text in the specfied font, the method may return a <see cref="T:System.Drawing.SizeF" /> whose <see cref="P:System.Drawing.SizeF.Height" /> is greater than that in <paramref name="constrainedToSize" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StringSize">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF StringSize (string str, MonoTouch.UIKit.UIFont font, float forWidth, MonoTouch.UIKit.UILineBreakMode breakMode);" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF StringSize(string str, class MonoTouch.UIKit.UIFont font, float32 forWidth, valuetype MonoTouch.UIKit.UILineBreakMode breakMode) cil managed" apistyle="classic" />
      <MemberSignature Language="C#" Value="public MonoTouch.CoreGraphics.CGSize StringSize (string str, MonoTouch.UIKit.UIFont font, nfloat forWidth, MonoTouch.UIKit.UILineBreakMode breakMode);" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype MonoTouch.CoreGraphics.CGSize StringSize(string str, class MonoTouch.UIKit.UIFont font, valuetype System.nfloat forWidth, valuetype MonoTouch.UIKit.UILineBreakMode breakMode) cil managed" apistyle="unified" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType apistyle="classic">System.Drawing.SizeF</ReturnType>
        <ReturnType apistyle="unified">MonoTouch.CoreGraphics.CGSize</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="font" Type="MonoTouch.UIKit.UIFont" />
        <Parameter Name="forWidth" Type="System.Single" apistyle="classic" />
        <Parameter Name="breakMode" Type="MonoTouch.UIKit.UILineBreakMode" />
        <Parameter Name="forWidth" Type="System.nfloat" apistyle="unified" />
      </Parameters>
      <Docs>
        <param name="str">The string whose size is being calculated.</param>
        <param name="font">The font to be used in the size calculation.</param>
        <param name="forWidth">The maximum width to be used in the calculation.</param>
        <param name="breakMode">The line-break mode to be used in the calculation.</param>
        <summary>
          <para>Deprecated in iOS7.   Use NSString.GetBoundingRect (SizeF, NSStringDrawingOptions, UIStringAttributes,NSStringDrawingContext) instead.</para>
          <para>Calculates the <see cref="T:System.Drawing.SizeF" /> of a single line of the specified string if it were rendered with the specified: font, width constraint, and line-break mode.</para>
        </summary>
        <returns>Returns the <see cref="T:System.Drawing.SizeF" /> of the first line of the specified string if it were rendered with the specified: font, width constraint, and line-break mode.</returns>
        <remarks>
          <para>Application developers can use this method to calculate text metrics. It does not render or otherwise change state in the <see cref="T:MonoTouch.UIKit.UIView" />.</para>
          <para>This method calculates the size that the first line of the <paramref name="str" /> would require if rendered with the <paramref name="font" />, if the rendering were not allowed to exceed the width of  <paramref name="forWidth" />. This method uses the specified <paramref name="lineBreakMode" /> line-break mode to truncate the string when it exceeds <paramref name="forWidth" />. If the <see cref="P:System.Drawing.SizeF.Height" /> of the <paramref name="constrainedToSize" /> argument is less than that of a single line of text in the specfied font, the method may return a <see cref="T:System.Drawing.SizeF" /> whose <see cref="P:System.Drawing.SizeF.Height" /> is greater than that in <paramref name="constrainedToSize" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StringSize">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF StringSize (string str, MonoTouch.UIKit.UIFont font, float minFontSize, ref float actualFontSize, float forWidth, MonoTouch.UIKit.UILineBreakMode lineBreakMode);" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF StringSize(string str, class MonoTouch.UIKit.UIFont font, float32 minFontSize, float32 actualFontSize, float32 forWidth, valuetype MonoTouch.UIKit.UILineBreakMode lineBreakMode) cil managed" apistyle="classic" />
      <MemberSignature Language="C#" Value="public MonoTouch.CoreGraphics.CGSize StringSize (string str, MonoTouch.UIKit.UIFont font, nfloat minFontSize, ref nfloat actualFontSize, nfloat forWidth, MonoTouch.UIKit.UILineBreakMode lineBreakMode);" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype MonoTouch.CoreGraphics.CGSize StringSize(string str, class MonoTouch.UIKit.UIFont font, valuetype System.nfloat minFontSize, valuetype System.nfloat actualFontSize, valuetype System.nfloat forWidth, valuetype MonoTouch.UIKit.UILineBreakMode lineBreakMode) cil managed" apistyle="unified" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType apistyle="classic">System.Drawing.SizeF</ReturnType>
        <ReturnType apistyle="unified">MonoTouch.CoreGraphics.CGSize</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="font" Type="MonoTouch.UIKit.UIFont" />
        <Parameter Name="minFontSize" Type="System.Single" apistyle="classic" />
        <Parameter Name="actualFontSize" Type="System.Single&amp;" RefType="ref" apistyle="classic" />
        <Parameter Name="forWidth" Type="System.Single" apistyle="classic" />
        <Parameter Name="lineBreakMode" Type="MonoTouch.UIKit.UILineBreakMode" />
        <Parameter Name="minFontSize" Type="System.nfloat" apistyle="unified" />
        <Parameter Name="actualFontSize" Type="System.nfloat&amp;" RefType="ref" apistyle="unified" />
        <Parameter Name="forWidth" Type="System.nfloat" apistyle="unified" />
      </Parameters>
      <Docs>
        <param name="str">The string whose size is being calculated.</param>
        <param name="font">The font to be used in the size calculation.</param>
        <param name="minFontSize">The minimum size to which the font can be shrunk before resorting to text-truncation.</param>
        <param name="actualFontSize">An output reference parameter that holds the calculate font size.</param>
        <param name="forWidth">The maximum width to be used in the calculation.</param>
        <param name="lineBreakMode">The line-break mode to be used in the calculation.</param>
        <summary>
          <para>Deprecated on iOS7.</para>
          <para>Calculates the <see cref="T:System.Drawing.SizeF" />  and size of the font of the first line of the specified string if it were rendered with the specified constraints.</para>
        </summary>
        <returns>Returns the <see cref="T:System.Drawing.SizeF" /> of the first line of the specified string if it were rendered with the specified constraints. Assigns the calculated font size to <paramref name="actualFontSize" />.</returns>
        <remarks>
          <para>Application developers can use this method to calculate text metrics. It does not render or otherwise change state in the <see cref="T:MonoTouch.UIKit.UIView" />.</para>
          <para>This method calculates the size that the first line of the <paramref name="str" /> would require if rendered with the <paramref name="font" />, if the font were allowed to shrink as necessary to fit in the width of  <paramref name="forWidth" />. This method tries to use smaller font sizes to fit the entire text in a single line of width less than or equal to <paramref name="forWidth" />. If, even with a font of <paramref name="minFontSize" /> size, the entire string cannot fit, the string is truncated using the <paramref name="lineBreakMode" /> line-break mode until it's rendered width is less than or equal to <paramref name="forWidth" />. </para>
          <para>The reference parameter <paramref name="actualFontSize" /> is assigned the font size that is ultimately used by the calculation.</para>
          <para>The following example code shows the use of this method. The output is "Metrics are {Width=100, Height=15} with required font size of: 7.5."</para>
          <example>
            <code lang="C#"><![CDATA[
var v = new UIView();
var str = "Hark! I hear the cannons roar!";
var font = UIFont.FromName("Helvetica", 12);
var minFontSize = 6;
Single actualFontSize = 0;
var forWidth = 100;
var lineBreakMode = UILineBreakMode.WordWrap;
var textSize = v.StringSize(str, font, minFontSize, ref actualFontSize, forWidth, lineBreakMode);
Console.WriteLine("Metrics are {0} with required font size of: {1}", textSize, actualFontSize);
            ]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SubviewAdded">
      <MemberSignature Language="C#" Value="public virtual void SubviewAdded (MonoTouch.UIKit.UIView uiview);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SubviewAdded(class MonoTouch.UIKit.UIView uiview) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("didAddSubview:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uiview" Type="MonoTouch.UIKit.UIView" />
      </Parameters>
      <Docs>
        <param name="uiview">
          <para>The view that was added as a subview.</para>
        </param>
        <summary>Tells the view when subviews are added.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Subviews">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIView[] Subviews { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIView[] Subviews" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("subviews")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIView[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An array of <see cref="T:MonoTouch.UIKit.UIView" />s that are contained within <c>this</c> <see cref="T:MonoTouch.UIKit.UIView" />.</summary>
        <value>The default value is an empty array.</value>
        <remarks>
          <para>
            This property defines the view hierarchy of a <see cref="T:MonoTouch.UIKit.UIView" />. The complete view hierarchy includes the <see cref="T:MonoTouch.UIKit.UIView" />'s <see cref="P:MonoTouch.UIKit.UIView.Superview" /> and the descendent <see cref="T:MonoTouch.UIKit.UIView" />s that are <see cref="P:MonoTouch.UIKit.UIView.Subview" />s of <see cref="P:MonoTouch.UIKit.UIView.Subview" />s, but the methods for manipulating the hierarchy are focused on manipulating subviews (e.g., <see cref="M:MonoTouch.UIKit.UIView.AddSubview" />, <see cref="M:MonoTouch.UIKit.UIView.InsertSubview" />, etc.).
          </para>
          <para>The position of a <see cref="T:MonoTouch.UIKit.UIView" /> in the <see cref="P:MonoTouch.UIKit.UIView.Subviews" /> array determines that <see cref="T:MonoTouch.UIKit.UIView" />'s z-order among the subviews. The <see cref="T:MonoTouch.UIKit.UIView" /> at index 0 is the rear-most view. <see cref="T:MonoTouch.UIKit.UIView" />s can be initialized in a desired z-order by using <see cref="M:MonoTouch.UIKit.UIView.InsertSubviewAbove" /> and <see cref="M:MonoTouch.UIKit.UIView.InsertSubviewBelow" />. <see cref="T:MonoTouch.UIKit.UIView" />s can be brought forward or sent backward in z-order by using <see cref="M:MonoTouch.UIKit.UIView.ExchangeSubview" />.</para>
          <para>Application developers should not manipulate or modify <see cref="P:MonoTouch.UIKit.UIView.Subviews" /> of framework-supplied <see cref="T:MonoTouch.UIKit.UIView" />s, as they may change without notice in system updates.</para>
        </remarks>
        <altmember cref="P:Monotouch.UIKit.UIView.Superview" />
      </Docs>
    </Member>
    <Member MemberName="Superview">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIView Superview { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIView Superview" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("superview")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The <see cref="T:MonoTouch.UIKit.UIView" />, if any, that contains <c>this</c> <see cref="T:MonoTouch.UIKit.UIView" /> in its <see cref="P:MonoTouch.UIKit.UIView.Subviews" />.</summary>
        <value>The default value is <see langword="null" />.</value>
        <remarks>
          <para>This value may be <see langword="null" />, indicating that the <see cref="T:MonoTouch.UIKit.UIView" /> is not contained within another <see cref="T:MonoTouch.UIKit.UIView" />'s view hierarchy.</para>
        </remarks>
        <altmember cref="P:MonoTouch.UIKit.UIView.Subviews" />
      </Docs>
    </Member>
    <Member MemberName="SwitchControlStatusDidChangeNotification">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString SwitchControlStatusDidChangeNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString SwitchControlStatusDidChangeNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIAccessibilitySwitchControlStatusDidChangeNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for SwitchControlStatusDidChange</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:MonoTouch.Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <example>
            <code lang="c#">
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIView.SwitchControlStatusDidChangeNotification, (notification) =&gt; {Console.WriteLine ("Received the notification UIView", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIView", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIView.SwitchControlStatusDidChangeNotification, Callback);
}
</code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SystemLayoutSizeFittingSize">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.SizeF SystemLayoutSizeFittingSize (System.Drawing.SizeF size);" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Drawing.SizeF SystemLayoutSizeFittingSize(valuetype System.Drawing.SizeF size) cil managed" apistyle="classic" />
      <MemberSignature Language="C#" Value="public virtual MonoTouch.CoreGraphics.CGSize SystemLayoutSizeFittingSize (MonoTouch.CoreGraphics.CGSize size);" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype MonoTouch.CoreGraphics.CGSize SystemLayoutSizeFittingSize(valuetype MonoTouch.CoreGraphics.CGSize size) cil managed" apistyle="unified" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("systemLayoutSizeFittingSize:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType apistyle="classic">System.Drawing.SizeF</ReturnType>
        <ReturnType apistyle="unified">MonoTouch.CoreGraphics.CGSize</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Drawing.SizeF" apistyle="classic" />
        <Parameter Name="size" Type="MonoTouch.CoreGraphics.CGSize" apistyle="unified" />
      </Parameters>
      <Docs>
        <param name="size">This parameter should be <see cref="P:MonoTouch.UIKit.UIView.UILayoutFittingCompressedSize" /> to retrieve the smallest possible size or <see cref="P:MonoTouch.UIKit.UIView.UILayoutFittingExpandedSize" /> to retrieve the largest possible size</param>
        <summary>Calculates the smallest or largest size that this <see cref="T:MonoTouch.UIKit.UIView" /> can have that satisfies its Auto Layout constraints.</summary>
        <returns>Returns the smallest (if <paramref name="size" /> == <see cref="P:MonoTouch.UIKit.UIView.UILayoutFittingCompressedSize" />) or largest (if <paramref name="size" /> == <see cref="P:MonoTouch.UIKit.UIView.UILayoutFittingExpandedSize" />)<see cref="T:System.Drawing.SizeF" /> that satisfies the constraints that relate to this <see cref="T:MonoTouch.UIKit.UIView" />.</returns>
        <remarks>
          <para>
            This method can calculate either the largest or the smallest size consistent with the Auto Layout constraints of <c>this</c> <see cref="T:MonoTouch.UIKit.UIView" /> and the constraints of its <see cref="P:MonoTouch.UIKit.UIView.Subviews" />. This method may only be called with <paramref name="size" /> equal to one of the predefined <see cref="T:System.Drawing.SizeF" />s <see cref="P:MonoTouch.UIKit.UIView.UILayoutFittingCompressedSize" /> or <see cref="P:MonoTouch.UIKit.UIView.UILayoutFittingExpandedSize" />.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SystemLayoutSizeFittingSize">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.SizeF SystemLayoutSizeFittingSize (System.Drawing.SizeF targetSize, float horizontalFittingPriority, float verticalFittingPriority);" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Drawing.SizeF SystemLayoutSizeFittingSize(valuetype System.Drawing.SizeF targetSize, float32 horizontalFittingPriority, float32 verticalFittingPriority) cil managed" apistyle="classic" />
      <MemberSignature Language="C#" Value="public virtual MonoTouch.CoreGraphics.CGSize SystemLayoutSizeFittingSize (MonoTouch.CoreGraphics.CGSize targetSize, float horizontalFittingPriority, float verticalFittingPriority);" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype MonoTouch.CoreGraphics.CGSize SystemLayoutSizeFittingSize(valuetype MonoTouch.CoreGraphics.CGSize targetSize, float32 horizontalFittingPriority, float32 verticalFittingPriority) cil managed" apistyle="unified" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("systemLayoutSizeFittingSize:withHorizontalFittingPriority:verticalFittingPriority:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType apistyle="classic">System.Drawing.SizeF</ReturnType>
        <ReturnType apistyle="unified">MonoTouch.CoreGraphics.CGSize</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetSize" Type="System.Drawing.SizeF" apistyle="classic" />
        <Parameter Name="horizontalFittingPriority" Type="System.Single" />
        <Parameter Name="verticalFittingPriority" Type="System.Single" />
        <Parameter Name="targetSize" Type="MonoTouch.CoreGraphics.CGSize" apistyle="unified" />
      </Parameters>
      <Docs>
        <param name="targetSize">Specifies if you want the smallest or largest possible size that meets given constraints.</param>
        <param name="horizontalFittingPriority">Horizomtal fitting constraint.</param>
        <param name="verticalFittingPriority">Vertical fitting constraint.</param>
        <summary>Defines the fitting constraints for layout.</summary>
        <returns>Returns the constraints for the view.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public virtual int Tag { get; set; }" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Tag" apistyle="classic" />
      <MemberSignature Language="C#" Value="public virtual nint Tag { get; set; }" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.nint Tag" apistyle="unified" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("tag")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setTag:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType apistyle="classic">System.Int32</ReturnType>
        <ReturnType apistyle="unified">System.nint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An integer that can be used to identify a specific <see cref="T:MonoTouch.UIKit.UIView" /> instance.</summary>
        <value>The default value is 0.</value>
        <remarks>
          <para>The stability and uniqueness of this property is entirely the responsibility of the application developer.</para>
        </remarks>
        <altmember cref="M:MonoTouch.UIKit.UIView.ViewWithTag" />
      </Docs>
    </Member>
    <Member MemberName="TintAdjustmentMode">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIViewTintAdjustmentMode TintAdjustmentMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype MonoTouch.UIKit.UIViewTintAdjustmentMode TintAdjustmentMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("tintAdjustmentMode")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setTintAdjustmentMode:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIViewTintAdjustmentMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The tint adjustment applied to this <see cref="T:MonoTouch.UIKit.UIView" /> or one of its parent views.</summary>
        <value>To be added.</value>
        <remarks>
        </remarks>
        <altmember cref="M:MonoTouch.UIKit.UIView.TintColorDidChange" />
      </Docs>
    </Member>
    <Member MemberName="TintColor">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIColor TintColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIColor TintColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("tintColor")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setTintColor:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIColor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A highlight color which should be used to indicate interactive controls.</summary>
        <value>
          <para>(More documentation for this node is coming)</para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>
          <para>Starting in iOS 7, application developers should use <see cref="P:MonoTouch.UIKit.UIView.TintColor" /> to indicate interaction elements within their UI. <see cref="P:MonoTouch.UIKit.UIView.TintColor " /> is hierarchical; that is, setting the <see cref="P:MonoTouch.UIKit.UIView.TintColor" /> on a top-level <see cref="T:MonoTouch.UIKit.UIView" /> will carry through to child views until the <see cref="P:MonoTouch.UIKit.UIView.TintColor" /> is overridden.</para>
          <para>When a <see cref="T:MonoTouch.UIKit.UIActionSheet" /> is displayed, visible <see cref="T:MonoTouch.UIKit.UIView" />s will have their tint grayed out (desaturated), indicating to the application user that they must interact with the <see cref="T:MonoTouch.UIKit.UIActionSheet" />. Application developers who wish to customize the desaturation of their <see cref="T:MonoTouch.UIKit.UIView" />s should override the <see cref="M:MonoTouch.UIKit.UIView.TintColorDidChange" /> method.</para>
          <para id="tool-remark">This member participates in the <see cref="T:MonoTouch.UIKit.UIAppearance" /> styling system.  See the <see cref="P:MonoTouch.UIKit.UIView.Appearance" /> property and the <see cref="M:MonoTouch.UIKit.UIView.AppearanceWhenContainedIn" /> method.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TintColorDidChange">
      <MemberSignature Language="C#" Value="public virtual void TintColorDidChange ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void TintColorDidChange() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("tintColorDidChange")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(7, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Called when the <see cref="P:MonoTouch.UIKit.UIView.TintColor" /> changes, such as when a <see cref="T:MonoTouch.UIKit.UIActionSheet" /> is displayed.</summary>
        <remarks>
          <para>When a <see cref="T:MonoTouch.UIKit.UIActionSheet" /> is displayed, visible <see cref="T:MonoTouch.UIKit.UIView" />s will have their tint grayed out (desaturated), indicating to the application user that they must interact with the <see cref="T:MonoTouch.UIKit.UIActionSheet" />. By overriding this method, application developers can customize the desaturation of custom <see cref="T:MonoTouch.UIKit.UIView" />s.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TraitAdjustable">
      <MemberSignature Language="C#" Value="public static long TraitAdjustable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 TraitAdjustable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIAccessibilityTraitAdjustable", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An accessibility trait indicating that the underlying value can be adjusted continuously, as with a slider.</summary>
        <value>The value to be set for the trait.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TraitAllowsDirectInteraction">
      <MemberSignature Language="C#" Value="public static long TraitAllowsDirectInteraction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 TraitAllowsDirectInteraction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIAccessibilityTraitAllowsDirectInteraction", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(5, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(5, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An accessibility trait indicating that the user can interact directly with the <see cref="T:MonoTouch.UIKit.UIView" />.</summary>
        <value>The value to be set for the trait.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TraitButton">
      <MemberSignature Language="C#" Value="public static long TraitButton { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 TraitButton" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIAccessibilityTraitButton", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An accessibility trait indicating button-like behavior.</summary>
        <value>The value to be set for the trait.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TraitCausesPageTurn">
      <MemberSignature Language="C#" Value="public static long TraitCausesPageTurn { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 TraitCausesPageTurn" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIAccessibilityTraitCausesPageTurn", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(5, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(5, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An accessibility trait indicating that the <see cref="T:MonoTouch.UIKit.UIView" /> causes a page turn after voice over completes.</summary>
        <value>The value to be set for the trait.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TraitCollection">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UITraitCollection TraitCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UITraitCollection TraitCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("traitCollection")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UITraitCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns a trait collection.</summary>
        <value>TThe value to be set for the trait.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TraitCollectionDidChange">
      <MemberSignature Language="C#" Value="public virtual void TraitCollectionDidChange (MonoTouch.UIKit.UITraitCollection previousTraitCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void TraitCollectionDidChange(class MonoTouch.UIKit.UITraitCollection previousTraitCollection) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("traitCollectionDidChange:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_8_0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="previousTraitCollection" Type="MonoTouch.UIKit.UITraitCollection" />
      </Parameters>
      <Docs>
        <param name="previousTraitCollection">Previous trait collection.</param>
        <summary>Defines previous trait collection.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TraitHeader">
      <MemberSignature Language="C#" Value="public static long TraitHeader { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 TraitHeader" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIAccessibilityTraitHeader", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An accessibility trait indicating that the <see cref="T:MonoTouch.UIKit.UIView" /> is a divider between content sections.</summary>
        <value>The value to be set for the trait.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TraitImage">
      <MemberSignature Language="C#" Value="public static long TraitImage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 TraitImage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIAccessibilityTraitImage", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An accessibility trait indicating the view should be treated as an image.</summary>
        <value>The value to be set for the trait.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TraitKeyboardKey">
      <MemberSignature Language="C#" Value="public static long TraitKeyboardKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 TraitKeyboardKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIAccessibilityTraitKeyboardKey", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An accessibility trait indicating that the <see cref="T:MonoTouch.UIKit.UIView" /> should be treated as a keyboard key.</summary>
        <value>The value to be set for the trait.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TraitLink">
      <MemberSignature Language="C#" Value="public static long TraitLink { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 TraitLink" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIAccessibilityTraitLink", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An accessibility trait indicating that the <see cref="T:MonoTouch.UIKit.UIView" /> should be treated as a hyperlink.</summary>
        <value>The value to be set for the trait.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TraitNone">
      <MemberSignature Language="C#" Value="public static long TraitNone { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 TraitNone" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIAccessibilityTraitNone", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indicates that the <see cref="T:MonoTouch.UIKit.UIView" /> has no accessibility traits.</summary>
        <value>The value to be set for the trait.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TraitNotEnabled">
      <MemberSignature Language="C#" Value="public static long TraitNotEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 TraitNotEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIAccessibilityTraitNotEnabled", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An accessibility trait indicating that the <see cref="T:MonoTouch.UIKit.UIView" /> is disabled and does not allow user interaction.</summary>
        <value>The value to be set for the trait.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TraitPlaysSound">
      <MemberSignature Language="C#" Value="public static long TraitPlaysSound { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 TraitPlaysSound" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIAccessibilityTraitPlaysSound", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An accessibility trait indicating the accessibility element should play its sound when the <see cref="T:MonoTouch.UIKit.UIView" /> is activated.</summary>
        <value>The value to be set for the trait.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TraitSearchField">
      <MemberSignature Language="C#" Value="public static long TraitSearchField { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 TraitSearchField" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIAccessibilityTraitSearchField", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An accessibility trait indicating that the <see cref="T:MonoTouch.UIKit.UIView" /> is a search field.</summary>
        <value>The value to be set for the trait.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TraitSelected">
      <MemberSignature Language="C#" Value="public static long TraitSelected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 TraitSelected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIAccessibilityTraitSelected", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An accessibility trait indicating that the <see cref="T:MonoTouch.UIKit.UIView" /> is currently selected.</summary>
        <value>The value to be set for the trait.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TraitStartsMediaSession">
      <MemberSignature Language="C#" Value="public static long TraitStartsMediaSession { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 TraitStartsMediaSession" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIAccessibilityTraitStartsMediaSession", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An accessibility trait that starts a media session when the <see cref="T:MonoTouch.UIKit.UIView" /> is activated.</summary>
        <value>The value to be set for the trait.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TraitStaticText">
      <MemberSignature Language="C#" Value="public static long TraitStaticText { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 TraitStaticText" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIAccessibilityTraitStaticText", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An accessibility trait indicating that the <see cref="T:MonoTouch.UIKit.UIView" /> contains static text.</summary>
        <value>The value to be set for the trait.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TraitSummaryElement">
      <MemberSignature Language="C#" Value="public static long TraitSummaryElement { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 TraitSummaryElement" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIAccessibilityTraitSummaryElement", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An accessibility trait indicating that the <see cref="T:MonoTouch.UIKit.UIView" /> contains summary information.</summary>
        <value>The value to be set for the trait.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TraitUpdatesFrequently">
      <MemberSignature Language="C#" Value="public static long TraitUpdatesFrequently { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 TraitUpdatesFrequently" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIAccessibilityTraitUpdatesFrequently", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An accessibility trait indicating that the <see cref="T:MonoTouch.UIKit.UIView" /> updates frequently.</summary>
        <value>The value to be set for the trait.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Transform">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.CoreGraphics.CGAffineTransform Transform { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype MonoTouch.CoreGraphics.CGAffineTransform Transform" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("transform")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setTransform:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.CoreGraphics.CGAffineTransform</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The transform of the <see cref="T:MonoTouch.UIKit.UIView" />, relative to the center of its bounds.</summary>
        <value>The default value is the identity transform.</value>
        <remarks>
          <para>
            This property can be used to manipulate the <see cref="T:MonoTouch.CoreGraphics.CGAffineTransform" /> that is applied to the <see cref="T:MonoTouch.UIKit.UIView" /> prior to rendering. The <see cref="P:MonoTouch.UIKit.UIView.Transform" /> is applied to the center of the <see cref="T:MonoTouch.UIKit.UIView" />'s <see cref="P:MonoTouch.UIKit.UIView.Bounds" />. 
          </para>
          <para>
            The transform is applied prior to Auto Layout constraints being applied. For instance, the following code shows constraints that, with default transforms, lay out three equally sized subviews with 30-pixel vertical spacing. A scaling transform is applied to the green view and a rotational transform to the yellow. The following image shows the result: the transforms are applied and then the Auto Layout constraints are resolved. The result is that the views are resized such that their width and height match the constraints. This effectively overrides the scaling transform on the green view while rotating and scaling the yellow view such that it's alignment rectangle satisfies the constraints.
          </para>
          <example>
            <code lang="C#"><![CDATA[
mainView.AddConstraints(NSLayoutConstraint.FromVisualFormat("H:|-[blue]-|", 0, new NSDictionary(), viewsDictionary));
mainView.AddConstraints(NSLayoutConstraint.FromVisualFormat("V:|-[blue]-(==30)-[green(==blue)]-(==30)-[yellow(==blue)]-|", 0, new NSDictionary(), viewsDictionary));
mainView.AddConstraints(NSLayoutConstraint.FromVisualFormat("|-[green(==blue)]-|", 0, new NSDictionary(), viewsDictionary));
mainView.AddConstraints(NSLayoutConstraint.FromVisualFormat("|-[yellow(==blue)]-|", 0, new NSDictionary(), viewsDictionary));

greenView.Transform = CGAffineTransform.MakeScale(2F, 2F);
yellowView.Transform = CGAffineTransform.MakeRotation((float)(Math.PI / 10));		
]]></code>
          </example>
          <para>
            <img href="MonoTouch.UIKit.View.Transform.png" />
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transition" apistyle="classic">
      <MemberSignature Language="C#" Value="public static void Transition (MonoTouch.UIKit.UIView fromView, MonoTouch.UIKit.UIView toView, double duration, MonoTouch.UIKit.UIViewAnimationOptions options, MonoTouch.Foundation.NSAction completion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Transition(class MonoTouch.UIKit.UIView fromView, class MonoTouch.UIKit.UIView toView, float64 duration, valuetype MonoTouch.UIKit.UIViewAnimationOptions options, class MonoTouch.Foundation.NSAction completion) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromView" Type="MonoTouch.UIKit.UIView" />
        <Parameter Name="toView" Type="MonoTouch.UIKit.UIView" />
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="options" Type="MonoTouch.UIKit.UIViewAnimationOptions" />
        <Parameter Name="completion" Type="MonoTouch.Foundation.NSAction" />
      </Parameters>
      <Docs>
        <param name="fromView">The initial view.</param>
        <param name="toView">The final view.</param>
        <param name="duration">The duration, in seconds, of the animation.</param>
        <param name="options">A mask of options to be used with the animation.</param>
        <param name="completion">A <see cref="T:MonoTouch.Foundation.NSAction" /> to be executed at the end of the animation. This parameter may be <see langword="null" />.</param>
        <summary>Specifies a transition animation to be used between the specified <see cref="T:MonoTouch.UIKit.UIView" />s.</summary>
        <remarks>
          <para>Application developers should prefer to use the method <see cref="M:MonoTouch.UIKit.UIView.TransitionNotify" />, whose behavior is identical, but which has a <see cref="T:MonoTouch.UIKit.UICompletionHandler" /> instead of an <see cref="T:MonoTouch.Foundation.NSAction" /> for its completion hander. The <see cref="T:MonoTouch.UIKit.UICompletionHandler" /> receives a parameter indicating whether the animation completed successfully or not.</para>
          <para>This static method provides an animation that shows the transition from <paramref name="fromView" /> to <paramref name="toView" />.</para>
          <para>If <paramref name="duration" /> is less than or equal to 0, no animation is displayed, but <paramref name="completion" /> is executed.</para>
          <para> If <paramref name="options" /> does not include <see cref="P:MonoTouch.UIKit.UIViewAnimationOptions.ShowHideTransitionViews" />, <paramref name="fromView" /> is removed from it's <see cref="P:MonoTouch.UIKit.UIView.Superview" />'s view hierarchy and <paramref name="toView" /> is inserted into that <see cref="T:MonoTouch.UIKit.UIView" />'s <see cref="P:MonoTouch.UIKit.UIView.Subviews" />. If <paramref name="options" /> includes <see cref="P:MonoTouch.UIKit.UIViewAnimationOptions.ShowHideTransitionViews" />, <paramref name="toView" /> and <paramref name="fromView" /> are not removed and added to the view hierarchy of <paramref name="toView" />'s <see cref="P:MonoTouch.UIKit.UIView.Superview" />, but instead <paramref name="fromView" /> is hidden and <paramref name="toView" /> is shown (both must have the same <see cref="P:MonoTouch.UIKit.UIView.Superview" />.)</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transition" apistyle="unified">
      <MemberSignature Language="C#" Value="public static void Transition (MonoTouch.UIKit.UIView fromView, MonoTouch.UIKit.UIView toView, double duration, MonoTouch.UIKit.UIViewAnimationOptions options, Action completion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Transition(class MonoTouch.UIKit.UIView fromView, class MonoTouch.UIKit.UIView toView, float64 duration, valuetype MonoTouch.UIKit.UIViewAnimationOptions options, class System.Action completion) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromView" Type="MonoTouch.UIKit.UIView" />
        <Parameter Name="toView" Type="MonoTouch.UIKit.UIView" />
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="options" Type="MonoTouch.UIKit.UIViewAnimationOptions" />
        <Parameter Name="completion" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="fromView">The initial view.</param>
        <param name="toView">The final view.</param>
        <param name="duration">The duration, in seconds, of the animation.</param>
        <param name="options">A mask of options to be used with the animation.</param>
        <param name="completion">An action to be executed at the end of the animation.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Transition" apistyle="classic">
      <MemberSignature Language="C#" Value="public static void Transition (MonoTouch.UIKit.UIView withView, double duration, MonoTouch.UIKit.UIViewAnimationOptions options, MonoTouch.Foundation.NSAction animation, MonoTouch.Foundation.NSAction completion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Transition(class MonoTouch.UIKit.UIView withView, float64 duration, valuetype MonoTouch.UIKit.UIViewAnimationOptions options, class MonoTouch.Foundation.NSAction animation, class MonoTouch.Foundation.NSAction completion) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="withView" Type="MonoTouch.UIKit.UIView" />
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="options" Type="MonoTouch.UIKit.UIViewAnimationOptions" />
        <Parameter Name="animation" Type="MonoTouch.Foundation.NSAction" />
        <Parameter Name="completion" Type="MonoTouch.Foundation.NSAction" />
      </Parameters>
      <Docs>
        <param name="withView">The <see cref="T:MonoTouch.UIKit.UIView" /> whose state is being manipulated and in which the animation should occur.</param>
        <param name="duration">The duration of the animation in seconds.</param>
        <param name="options">A mask of options to be used with the animation.</param>
        <param name="animation">An <see cref="T:MonoTouch.Foundation.NSAction" /> containing the animation and state manipulation of the <paramref name="withView" />.</param>
        <param name="completion">An <see cref="T:MonoTouch.Foundation.NSAction" /> to be executed at the end of the animation. This parameter may be <see langword="null" />.</param>
        <summary>Specifies a transition animation on the specified collection view.</summary>
        <remarks>
          <para>Application developers should prefer to use the method <see cref="M:MonoTouch.UIKit.UIView.TransitionNotify" />, whose behavior is identical, but which has a <see cref="T:MonoTouch.UIKit.UICompletionHandler" /> instead of an <see cref="T:MonoTouch.Foundation.NSAction" /> for its completion hander. The <see cref="T:MonoTouch.UIKit.UICompletionHandler" /> receives a parameter indicating whether the animation completed successfully or not.</para>
          <para>This static method specifies an animation within the <paramref name="withView" /> container <see cref="T:MonoTouch.UIKit.UIView" />.</para>
          <para>If duration is less than or equal to 0, no animation is displayed, but both <paramref name="animation" /> and <paramref name="completion" /> are executed.</para>
          <para>The <paramref name="animation" /> action may animate addition, removal, showing, or hiding subviews. If other animations are desired, the application developer must include <see cref="P:MonoTouch.UIKit.UIViewAnimationOptions.AllowAnimatedContent" /> in the <paramref name="options" />.</para>
          <para>During animation, user interactions are disabled for the animated <see cref="T:MonoTouch.UIKit.UIView" />s. To enable interaction during the animation, the application developer must set <see cref="P:MonoTouchUIKit.UIViewANimationAoptions.AllowUserInteraction" /> in <paramref name="options" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transition" apistyle="unified">
      <MemberSignature Language="C#" Value="public static void Transition (MonoTouch.UIKit.UIView withView, double duration, MonoTouch.UIKit.UIViewAnimationOptions options, Action animation, Action completion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Transition(class MonoTouch.UIKit.UIView withView, float64 duration, valuetype MonoTouch.UIKit.UIViewAnimationOptions options, class System.Action animation, class System.Action completion) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="withView" Type="MonoTouch.UIKit.UIView" />
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="options" Type="MonoTouch.UIKit.UIViewAnimationOptions" />
        <Parameter Name="animation" Type="System.Action" />
        <Parameter Name="completion" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="withView">The view that performs the transition.</param>
        <param name="duration">Duration set for transition animation.</param>
        <param name="options">A mask of options defining animations performance.</param>
        <param name="animation">Action object containing  changes to make to the specified view.</param>
        <param name="completion">Action object for execution when the animation sequence completes.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TransitionNotify">
      <MemberSignature Language="C#" Value="public static void TransitionNotify (MonoTouch.UIKit.UIView fromView, MonoTouch.UIKit.UIView toView, double duration, MonoTouch.UIKit.UIViewAnimationOptions options, MonoTouch.UIKit.UICompletionHandler completion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TransitionNotify(class MonoTouch.UIKit.UIView fromView, class MonoTouch.UIKit.UIView toView, float64 duration, valuetype MonoTouch.UIKit.UIViewAnimationOptions options, class MonoTouch.UIKit.UICompletionHandler completion) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("transitionFromView:toView:duration:options:completion:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(4, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromView" Type="MonoTouch.UIKit.UIView" />
        <Parameter Name="toView" Type="MonoTouch.UIKit.UIView" />
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="options" Type="MonoTouch.UIKit.UIViewAnimationOptions" />
        <Parameter Name="completion" Type="MonoTouch.UIKit.UICompletionHandler">
          <Attributes>
            <Attribute>
              <AttributeName>MonoTouch.ObjCRuntime.BlockProxy(typeof(MonoTouch.ObjCRuntime.Trampolines/NIDUICompletionHandler))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="fromView">The initial view.</param>
        <param name="toView">The final view.</param>
        <param name="duration">The duration, in seconds, of the animation.</param>
        <param name="options">A mask of options to be used with the animation.</param>
        <param name="completion">
          <para>An <see cref="T:MonoTouch.UIKit.UICompletionHandler" /> to be executed at the end of the animation. This parameter may be <see langword="null" />.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Specifies a transition animation to be used between the specified <see cref="T:MonoTouch.UIKit.UIView" />s.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TransitionNotify" apistyle="classic">
      <MemberSignature Language="C#" Value="public static void TransitionNotify (MonoTouch.UIKit.UIView withView, double duration, MonoTouch.UIKit.UIViewAnimationOptions options, MonoTouch.Foundation.NSAction animation, MonoTouch.UIKit.UICompletionHandler completion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TransitionNotify(class MonoTouch.UIKit.UIView withView, float64 duration, valuetype MonoTouch.UIKit.UIViewAnimationOptions options, class MonoTouch.Foundation.NSAction animation, class MonoTouch.UIKit.UICompletionHandler completion) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("transitionWithView:duration:options:animations:completion:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(4, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="withView" Type="MonoTouch.UIKit.UIView" />
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="options" Type="MonoTouch.UIKit.UIViewAnimationOptions" />
        <Parameter Name="animation" Type="MonoTouch.Foundation.NSAction">
          <Attributes>
            <Attribute>
              <AttributeName>MonoTouch.ObjCRuntime.BlockProxy(typeof(MonoTouch.ObjCRuntime.Trampolines/NIDNSAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="completion" Type="MonoTouch.UIKit.UICompletionHandler">
          <Attributes>
            <Attribute>
              <AttributeName>MonoTouch.ObjCRuntime.BlockProxy(typeof(MonoTouch.ObjCRuntime.Trampolines/NIDUICompletionHandler))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="withView">The <see cref="T:MonoTouch.UIKit.UIView" /> whose state is being manipulated and in which the animation should occur.</param>
        <param name="duration">The duration of the animation in seconds.</param>
        <param name="options">A mask of options to be used with the animation.</param>
        <param name="animation">An <see cref="T:MonoTouch.Foundation.NSAction" /> containing the animation and state manipulation of the <paramref name="withView" />.</param>
        <param name="completion">
          <para>The method to invoke when the transition completes.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Specifies a transition animation on the specified collection view.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TransitionNotify" apistyle="unified">
      <MemberSignature Language="C#" Value="public static void TransitionNotify (MonoTouch.UIKit.UIView withView, double duration, MonoTouch.UIKit.UIViewAnimationOptions options, Action animation, MonoTouch.UIKit.UICompletionHandler completion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TransitionNotify(class MonoTouch.UIKit.UIView withView, float64 duration, valuetype MonoTouch.UIKit.UIViewAnimationOptions options, class System.Action animation, class MonoTouch.UIKit.UICompletionHandler completion) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("transitionWithView:duration:options:animations:completion:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(4, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="withView" Type="MonoTouch.UIKit.UIView" />
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="options" Type="MonoTouch.UIKit.UIViewAnimationOptions" />
        <Parameter Name="animation" Type="System.Action">
          <Attributes>
            <Attribute>
              <AttributeName>MonoTouch.ObjCRuntime.BlockProxy(typeof(MonoTouch.ObjCRuntime.Trampolines/NIDAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="completion" Type="MonoTouch.UIKit.UICompletionHandler">
          <Attributes>
            <Attribute>
              <AttributeName>MonoTouch.ObjCRuntime.BlockProxy(typeof(MonoTouch.ObjCRuntime.Trampolines/NIDUICompletionHandler))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="withView">View whose state is being manipulated and in which the animation should occur.</param>
        <param name="duration">The duration of the animation in seconds.</param>
        <param name="options">A mask of options to be used with the animation.</param>
        <param name="animation">Action containing the animation and state manipulation of the view.</param>
        <param name="completion">The method to invoke when the transition completes.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TransitionNotifyAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;bool&gt; TransitionNotifyAsync (MonoTouch.UIKit.UIView fromView, MonoTouch.UIKit.UIView toView, double duration, MonoTouch.UIKit.UIViewAnimationOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;bool&gt; TransitionNotifyAsync(class MonoTouch.UIKit.UIView fromView, class MonoTouch.UIKit.UIView toView, float64 duration, valuetype MonoTouch.UIKit.UIViewAnimationOptions options) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromView" Type="MonoTouch.UIKit.UIView" />
        <Parameter Name="toView" Type="MonoTouch.UIKit.UIView" />
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="options" Type="MonoTouch.UIKit.UIViewAnimationOptions" />
      </Parameters>
      <Docs>
        <param name="fromView">The initial view.</param>
        <param name="toView">The final view.</param>
        <param name="duration">The duration, in seconds, of the animation.</param>
        <param name="options">A mask of options to be used with the animation.</param>
        <summary>Specifies a transition animation to be used between the specified s.</summary>
        <returns>
          <para>A task that represents the asynchronous TransitionNotify operation.   The value of the TResult parameter is a MonoTouch.UIKit.UICompletionHandler.</para>
        </returns>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="TransitionNotifyAsync" apistyle="classic">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;bool&gt; TransitionNotifyAsync (MonoTouch.UIKit.UIView withView, double duration, MonoTouch.UIKit.UIViewAnimationOptions options, MonoTouch.Foundation.NSAction animation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;bool&gt; TransitionNotifyAsync(class MonoTouch.UIKit.UIView withView, float64 duration, valuetype MonoTouch.UIKit.UIViewAnimationOptions options, class MonoTouch.Foundation.NSAction animation) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="withView" Type="MonoTouch.UIKit.UIView" />
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="options" Type="MonoTouch.UIKit.UIViewAnimationOptions" />
        <Parameter Name="animation" Type="MonoTouch.Foundation.NSAction">
          <Attributes>
            <Attribute>
              <AttributeName>MonoTouch.ObjCRuntime.BlockProxy(typeof(MonoTouch.ObjCRuntime.Trampolines/NIDNSAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="withView">The  whose state is being manipulated and in which the animation should occur.</param>
        <param name="duration">The duration of the animation in seconds.</param>
        <param name="options">A mask of options to be used with the animation.</param>
        <param name="animation">An  containing the animation and state manipulation of the .</param>
        <summary>Specifies a transition animation on the specified collection view.</summary>
        <returns>
          <para>A task that represents the asynchronous TransitionNotify operation.   The value of the TResult parameter is a MonoTouch.UIKit.UICompletionHandler.</para>
        </returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TransitionNotifyAsync" apistyle="unified">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;bool&gt; TransitionNotifyAsync (MonoTouch.UIKit.UIView withView, double duration, MonoTouch.UIKit.UIViewAnimationOptions options, Action animation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;bool&gt; TransitionNotifyAsync(class MonoTouch.UIKit.UIView withView, float64 duration, valuetype MonoTouch.UIKit.UIViewAnimationOptions options, class System.Action animation) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="withView" Type="MonoTouch.UIKit.UIView" />
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="options" Type="MonoTouch.UIKit.UIViewAnimationOptions" />
        <Parameter Name="animation" Type="System.Action">
          <Attributes>
            <Attribute>
              <AttributeName>MonoTouch.ObjCRuntime.BlockProxy(typeof(MonoTouch.ObjCRuntime.Trampolines/NIDAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="withView">The view whose state is being manipulated and in which the animation should occur.</param>
        <param name="duration">The duration of the animation in seconds.</param>
        <param name="options">A mask of options to be used with the animation.</param>
        <param name="animation">An action containing the animation and state manipulation of the view.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TranslatesAutoresizingMaskIntoConstraints">
      <MemberSignature Language="C#" Value="public virtual bool TranslatesAutoresizingMaskIntoConstraints { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TranslatesAutoresizingMaskIntoConstraints" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("translatesAutoresizingMaskIntoConstraints")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setTranslatesAutoresizingMaskIntoConstraints:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies whether the autoresizing mask should be translated into constraints for Auto Layout.</summary>
        <value>The default value is <see langword="true" />.</value>
        <remarks>
          <para>If this property is <see langword="true" />, this <see cref="T:MonoTouch.UIKit.UIView" />'s <see cref="P:MonoTouch.UIKit.UIView.Superview" /> will convert this <see cref="T:MonoTouch.UIKit.UIView" />'s <see cref="P:MonoTouch.UIKit.UIView.AutoresizingMask" /> into <see cref="T:MonoTouch.UIKit.NSLayoutConstraint" />s and include them in the <see cref="P:MonoTouch.UIKit.UIView.Superview" />'s <see cref="P:MonoTouch.UIKit.UIView.Constraints" />.</para>
          <para>If the application developer is using Auto Layout, setting this property to <see langword="false" /> will often provide a clearer starting point for programmatically specifying constraints.</para>
          <para>In an over-constrained Auto Layout, the appearance of <c>NSAutoresizingMaskLayoutConstraint</c> in the Auto Layout debugging information is often an indication that the Application Developer has inappropriately left this property as <see langword="true" /> somewhere.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UILayoutFittingCompressedSize">
      <MemberSignature Language="C#" Value="public static System.Drawing.SizeF UILayoutFittingCompressedSize { get; }" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Drawing.SizeF UILayoutFittingCompressedSize" apistyle="classic" />
      <MemberSignature Language="C#" Value="public static MonoTouch.CoreGraphics.CGSize UILayoutFittingCompressedSize { get; }" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".property valuetype MonoTouch.CoreGraphics.CGSize UILayoutFittingCompressedSize" apistyle="unified" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UILayoutFittingCompressedSize", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType apistyle="classic">System.Drawing.SizeF</ReturnType>
        <ReturnType apistyle="unified">MonoTouch.CoreGraphics.CGSize</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UILayoutFittingCompressedSize</summary>
        <value>
        </value>
        <remarks>Indicates that <see cref="M:MonoTouch.UIKit.UIView.SystemLayoutSizeFittingSize" /> should calculate the smallest possible size.</remarks>
        <altmember cref="M:MonoTouch.UIKit.UIView.SystemLayoutSizeFittingSize" />
      </Docs>
    </Member>
    <Member MemberName="UILayoutFittingExpandedSize">
      <MemberSignature Language="C#" Value="public static System.Drawing.SizeF UILayoutFittingExpandedSize { get; }" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Drawing.SizeF UILayoutFittingExpandedSize" apistyle="classic" />
      <MemberSignature Language="C#" Value="public static MonoTouch.CoreGraphics.CGSize UILayoutFittingExpandedSize { get; }" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".property valuetype MonoTouch.CoreGraphics.CGSize UILayoutFittingExpandedSize" apistyle="unified" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UILayoutFittingExpandedSize", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType apistyle="classic">System.Drawing.SizeF</ReturnType>
        <ReturnType apistyle="unified">MonoTouch.CoreGraphics.CGSize</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UILayoutFittingExpandedSize</summary>
        <value>
        </value>
        <remarks>Indicates that <see cref="M:MonoTouch.UIKit.UIView.SystemLayoutSizeFittingSize" /> should calculate the largest possible size.</remarks>
        <altmember cref="M:MonoTouch.UIKit.UIView.SystemLayoutSizeFittingSize" />
      </Docs>
    </Member>
    <Member MemberName="UpdateConstraints">
      <MemberSignature Language="C#" Value="public virtual void UpdateConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UpdateConstraints() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("updateConstraints")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Updates the Auto Layout constraints for the <see cref="T:MonoTouch.UIKit.UIView" />.</summary>
        <remarks>
          <para>Application developers may override this method in order to create and update custom constraints for use with Auto Layout.</para>
          <para>The Auto Layout system calls this method prior to layout. The <see cref="T:MonoTouch.UIKit.UIView" />'s properties will be in a stable state when this method is called and application developers should be able to establish valid constraints.</para>
          <para>Application developers may add or remove constraints in this method. If they do so, they must call <see cref="M:MonoTouch.UIKit.UIView.SetNeedsUpdateConstraints" /> to notify the Auto Layout system that further updating is required.</para>
          <para>Application developers must not invalidate existing <see cref="T:MonoTouch.UIKit.NSLayoutConstraint" />s during this method. Applications developers must not perform drawing actions or invoke layout recalculation during this method.</para>
          <para>Application developers must call <c>base.UpdateConstraints()</c> in their implementations of this method.</para>
        </remarks>
        <altmember cref="M:MonoTouch.UIKit.UIView.UpdateConstraintsIfNeeded" />
      </Docs>
    </Member>
    <Member MemberName="UpdateConstraintsIfNeeded">
      <MemberSignature Language="C#" Value="public virtual void UpdateConstraintsIfNeeded ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UpdateConstraintsIfNeeded() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("updateConstraintsIfNeeded")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Updates the constraints of the <see cref="T:MonoTouch.UIKit.UIView" /> and its <see cref="P:MonoTouch.UIKit.UIView.Subviews" />.</summary>
        <remarks>
          <para>Application developers should not overide this method.</para>
          <para>This method is called by the Auto Layout system during layout. Application developers may invoke it to ensure that constraints are current.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserInteractionEnabled">
      <MemberSignature Language="C#" Value="public virtual bool UserInteractionEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UserInteractionEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("isUserInteractionEnabled")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setUserInteractionEnabled:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determines whether input events are processed by this view.</summary>
        <value>
        </value>
        <remarks>
          <para>
            
            This property is used to control whether input events are
            delivered to the view.  By default all views receive
            events.  
            
          </para>
          <para>
            
            During animations, UIKit will disable event delivery to
            your view unless you pass the <see cref="E:MonoTouch.UIKit.UIViewAnimationOptions" />.AllowUserInteraction
            flag to your animation function.
            
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewForBaselineLayout">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIView ViewForBaselineLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIView ViewForBaselineLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("viewForBaselineLayout")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns the <see cref="T:MonoTouch.UIKit.UIView" /> upon which baseline constraints should be applied.</summary>
        <value>The default value is <c>this</c> <see cref="T:MonoTouch.UIKit.UIView" />.</value>
        <remarks>
          <para>Returns the <see cref="T:MonoTouch.UIKit.UIView" /> for which constraints relating to <see cref="F:MonoTouch.UIKit.NSLayoutAttribute.Baseline" /> should apply. The baseline for many <see cref="T:MonoTouch.UIKit.UIView" />s is the bottom of the view but in a <see cref="T:MonoTouch.UIKit.UILabel" />, for instance, the baseline should be the position of the text baseline.</para>
          <para>The returned value must be either <c>this</c> or a view in <c>this</c>'s subview hierarchy.</para>
        </remarks>
        <altmember cref="M:MonoTouch.UIKit.UIView.AlignmentRectForFrame" />
        <altmember cref="M:MonoTouch.UIKit.UIView.FrameForAlignmentRect" />
        <altmember cref="M:MonoTouch.UIKit.UIView.AlignmentRectInsets" />
      </Docs>
    </Member>
    <Member MemberName="ViewPrintFormatter">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIViewPrintFormatter ViewPrintFormatter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIViewPrintFormatter ViewPrintFormatter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(4, 2)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("viewPrintFormatter")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.ObjCRuntime.Since(4, 2)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIViewPrintFormatter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns a <see cref="T:MonoTouch.UIKit.UIViewPrintFormatter" /> appropriate for the <see cref="T:MonoTouch.UIKit.UIView" />.</summary>
        <value>This method may return <see langword="null" /> if an appropriate <see cref="T:MonoTouch.UIKit.UIViewPrintFormatter" /> could not be created.</value>
        <remarks>
          <para>This method produces a t<see cref="T:MonoTouch.UIKit.UIViewPrintFormatter" /> that can be configured with the page layout options desired by the application.</para>
          <para>Every time this method is called, it creates a new <see cref="T:MonoTouch.UIKit.UIViewPrintFormatter" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewWithTag">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIView ViewWithTag (int tag);" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class MonoTouch.UIKit.UIView ViewWithTag(int32 tag) cil managed" apistyle="classic" />
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIView ViewWithTag (nint tag);" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class MonoTouch.UIKit.UIView ViewWithTag(valuetype System.nint tag) cil managed" apistyle="unified" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("viewWithTag:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIView</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tag" Type="System.Int32" apistyle="classic" />
        <Parameter Name="tag" Type="System.nint" apistyle="unified" />
      </Parameters>
      <Docs>
        <param name="tag">
          <para>The identifier being searched for.</para>
        </param>
        <summary>Returns the <see cref="T:MonoTouch.UIKit.UIView" /> identified by the <paramref name="tag" />. May return <see langword="null" />.</summary>
        <returns>
          <para>The view in the view hierarchy whose <see cref="P:MonoTouch.UIKit.UIView.Tag" /> is equal to <paramref name="tag" />.</para>
        </returns>
        <remarks>
          <para>This method searches the current <see cref="T:MonoTouch.UIKit.UIView" />'s view hierarchy (i.e., <c>this</c>, it's <see cref="P:MonoTouch.UIKit.UIView.Subviews" /> and their descendants) and returns the <see cref="T:MonoTouch.UIKit.UIView" />, if any, whose <see cref="P:MonoTouch.UIKit.UIView.Tag" /> property is equal to the <paramref name="tag" /> parameter. If no such <see cref="T:MonoTouch.UIKit.UIView" /> exists, this method returns <see langword="null" />.</para>
        </remarks>
        <altmember cref="P:MonoTouch.UIKit.UIView.Tag" />
      </Docs>
    </Member>
    <Member MemberName="VoiceOverStatusChanged">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString VoiceOverStatusChanged { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString VoiceOverStatusChanged" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Field("UIAccessibilityVoiceOverStatusChanged", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An accessibility notification indicating that the status of voice-over has changed.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:MonoTouch.UIKit.UIView.AnnouncementNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.AnnouncementDidFinishNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.ClosedCaptioningStatusDidChangeNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.GuidedAccessStatusDidChangeNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.InvertColorStatusDidChangeNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.AnnouncementNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.LayoutChangedNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.MonoAudioStatusDidChangeNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.PageScrolledNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.ScreenChangedNotification" />
        <altmember cref="P:MonoTouch.UIKit.UIView.VoiceOverStatusChangedNotification" />
      </Docs>
    </Member>
    <Member MemberName="WillMoveToSuperview">
      <MemberSignature Language="C#" Value="public virtual void WillMoveToSuperview (MonoTouch.UIKit.UIView newsuper);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WillMoveToSuperview(class MonoTouch.UIKit.UIView newsuper) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("willMoveToSuperview:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newsuper" Type="MonoTouch.UIKit.UIView" />
      </Parameters>
      <Docs>
        <param name="newsuper">
          <para>The <see cref="T:MonoTouch.UIKit.UIView" /> to which <c>this</c> <see cref="T:MonoTouch.UIKit.UIView" /> is being moved.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Called before the <see cref="P:MonoTouch.UIKit.UIView.Superview" /> changes.</summary>
        <remarks>
          <para>This method is called by the runtime when assigning the <see cref="P:MonoTouch.UIKit.UIView.Superview" /> property and is invoked shortly before the change is made.</para>
          <para>By default, this method does nothing. Application developers can override the method in order to perform additional processing.</para>
        </remarks>
        <altmember cref="M:MonoTouch.UIKit.UIView.MovedToSuperview" />
      </Docs>
    </Member>
    <Member MemberName="WillMoveToWindow">
      <MemberSignature Language="C#" Value="public virtual void WillMoveToWindow (MonoTouch.UIKit.UIWindow window);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WillMoveToWindow(class MonoTouch.UIKit.UIWindow window) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("willMoveToWindow:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="window" Type="MonoTouch.UIKit.UIWindow" />
      </Parameters>
      <Docs>
        <param name="window">
          <para>Called before the window at the root of the <see cref="T:MonoTouch.UIKit.UIView" />'s view hierarchy changes.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>
          <para>This method is called by the runtime when assigning a new <see cref="T:MonoTouch.UIKit.UIWindow" /> to the <see cref="T:MonoTouch.UIKit.UIView" />'s view hierarcy. This method will be called on all <see cref="T:MonoTouch.UIKit.UIView" />s in the hierarchy, not just the top-level <see cref="T:MonoTouch.UIKit.UIView" />. </para>
          <para>By default, this method does nothing. Application developers can override the method in order to perform additional processing.</para>
        </summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WillRemoveSubview">
      <MemberSignature Language="C#" Value="public virtual void WillRemoveSubview (MonoTouch.UIKit.UIView uiview);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WillRemoveSubview(class MonoTouch.UIKit.UIView uiview) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("willRemoveSubview:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uiview" Type="MonoTouch.UIKit.UIView" />
      </Parameters>
      <Docs>
        <param name="uiview">
          <para>The subview that will be removed.</para>
        </param>
        <summary>Called prior to the removal of a subview.</summary>
        <remarks>
          <para>This method is called by the runtime when a <see cref="T:MonoTouch.UIKit.UIView" /> is removed from the <see cref="P:MonoTouch.UIKit.UIView.Subviews" /> array. </para>
          <para>By default, this method does nothing. Application developers can override the method in order to perform additional processing.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Window">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIWindow Window { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIWindow Window" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("window")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIWindow</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The <see cref="T:MonoTouch.UIKit.UIWindow" /> of the <see cref="T:MonoTouch.UIKit.UIView" />.</summary>
        <value>The default value is <see langword="null" />.</value>
        <remarks />
      </Docs>
    </Member>
  </Members>
</Type>
