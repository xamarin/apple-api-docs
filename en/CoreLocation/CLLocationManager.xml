<Type Name="CLLocationManager" FullName="CoreLocation.CLLocationManager">
  <TypeSignature Language="C#" Value="public class CLLocationManager : Foundation.NSObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit CLLocationManager extends Foundation.NSObject" />
  <AssemblyInfo>
    <AssemblyName>Xamarin.iOS</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Foundation.NSObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Foundation.Register("CLLocationManager", true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Manages the delivery of location, region, and heading events to your application.</summary>
    <remarks>
      <format type="text/html">
        <h2>Requesting Authorization</h2>
      </format>
      <para> Starting with iOS 8, developers that want to request
	access to the location information must request permission
	from the user to do so before they can receive events. This is
	done by calling either the <see cref="M:CoreLocation.CLLocationManager.RequestWhenInUseAuthorization" />
	or the <see cref="M:CoreLocation.CLLocationManager.RequestAlwaysAuthorization" />
	methods. When these methods are invoked, the system will
	prompt the user for authorization, and if he grants it, the <see cref="E:CoreLocation.CLLocationManager.AuthorizationChanged" /> event
	will be raised if set (or if you are using the Delegate idiom,
	the <see cref="M:CoreLocation.CLLocationManagerDelegate.AuthorizationChanged" /> method
	will be invoked.
      </para>
      <para>
        Additionally, developers must add one or both of the keys 
        <c>NSLocationWhenInUseUsageDescription</c> and 
        <c>NSLocationAlwaysUsageDescription</c> in their app's <c>info.plist</c>. 
        These keys are strings that can be used to describe why the app needs location
        access.
      </para>
      <para>
	Developers should use
	an idiom like this:
      </para>
      <example>
        <code lang="c#"><![CDATA[
var manager = new CLLocationManager();
manager.AuthorizationChanged += (sender, args) => {
	Console.WriteLine ("Authorization changed to: {0}", args.Status);
};
if (UIDevice.CurrentDevice.CheckSystemVersion(8,0))
    manager.RequestWhenInUseAuthorization();
]]></code>
      </example>
      <format type="text/html">
        <h2>Tracking the device's location</h2>
      </format>
      <para>The most common use-case for the <see cref="T:CoreLocation.CLLocationManager" /> is tracking the device while the application is in the foreground. (See also "Background Updating and Deferred Mode" below.)</para>
      <para>Application developers may use either C#-style events or Apple's delegate-object pattern to track foreground location updating. For C#-style events, developers can use the <see cref="E:CoreLocation.CLLocationManager.LocationsUpdated" /> event:</para>
      <example>
        <code lang="C#"><![CDATA[
var mgr = new CLLocationManager();
mgr.LocationsUpdated += (sender, e) => {
	foreach(var loc in e.Locations)
	{
		Console.WriteLine(loc);
	}
};
mgr.StartUpdatingLocation();
          ]]></code>
        <code lang="F#"><![CDATA[
let mgr = new CLLocationManager()
mgr.LocationsUpdated.Add( fun e ->
    e.Locations |> Seq.map Console.WriteLine |> ignore )
mgr.StartUpdatingLocations()          
          ]]></code>
      </example>
      <para>While C#-style events are more concise, the <see cref="T:CoreLocation.CLLocationManager" /> must use the delegate-object pattern for certain behaviors (for instance, deferred updating), and it may be more consistent for an application to use the delegate-object pattern even when C#-style events are available. The delegate-object pattern consists of assigning a customized <see cref="T:CoreLocation.CLLocationManagerDelegate" /> object to the <see cref="P:CoreLocation.CLLocationManager.Delegate" /> property of the <see cref="T:CoreLocation.CLLocationManager" />:</para>
      <example>
        <code lang="C#"><![CDATA[
var mgr = new CLLocationManager();
mgr.Delegate = new MyLocationDelegate();
mgr.StartUpdatingLocation();
//...etc...

public class MyLocationDelegate : CLLocationManagerDelegate {
	public override void LocationsUpdated (CLLocationManager manager, CLLocation[] locations) {
		foreach(var loc in locations) {
			Console.WriteLine(loc);
		}
	}
}          
          ]]></code>
        <code lang="F#"><![CDATA[
let mgr = new CLLocationManager()
mgr.Delegate <- new MyLocationDelegate()
mgr.StartUpdatingLocation()
//...etc...

type MyLocationDelegate () = inherit CLLocationManagerDelegate()
    override this.LocationsUpdated ( manager : CLLocationManager, locations : CLLocation[] ) = 
        locations 
        |> Seq.map Console.WriteLine
        |> ignore          
          ]]></code>
      </example>
      <format type="text/html">
        <h2>Region monitoring (Geofencing)</h2>
      </format>
      <para>The <see cref="T:CoreLocation.CLLocationManager" /> can track the device's entry and exit from geographical regions (geofences). A region will be a subtype of <see cref="T:CoreLocation.CLRegion" /> : either a <see cref="T:CoreLocation.CLCircularRegion" /> or a region associated with an iBeacon, of type <see cref="T:CoreLocation.CLBeaconRegion" />.</para>
      <para>
        <see cref="T:CoreLocation.CLRegion" /> identity should only be compared via the <see cref="P:CoreLocation.CLRegion.Identifier" /> property. Regions are monitored at the operating-system level and new <see cref="T:CoreLocation.CLRegion" /> objects with the specified <see cref="P:CoreLocation.CLRegion.Identifier" /> may be instantiated by the system when the device enters or exists an area; these <see cref="T:CoreLocation.CLRegion" />s will be different objects (<c>myExpectedRegion != myReceivedRegion</c>) but will have the same <see cref="P:CoreLocation.CLRegion.Identifier" /> (<c>myExpectedRegion.Identifier.Equals(myReceivedRegion.Identifier, StringComparison.Ordinal)</c>).</para>
      <para>Application developers can use either C#-style events or Apple's delegate-object pattern:</para>
      <example>
        <code lang="C#"><![CDATA[
var rgn = new CLCircularRegion(new CLLocationCoordinate2D(latitude, longitude), 50, "target");
mgr = new CLLocationManager();
mgr.RegionEntered += (s,e) => Console.WriteLine("Entered region " + e.Region.Identifier);
mgr.RegionLeft += (s,e) => Console.WriteLine("Left region " + e.Region.Identifier);
mgr.StartMonitoring(rgn);
          ]]></code>
        <code lang="F#"><![CDATA[
let rgn = new CLCircularRegion(new CLLocationCoordinate2D(latitude, longitude), 50, "target")     
let mgr = new CLLocationManager()
mgr.RegionEntered.Add( fun e -> Console.WriteLine("Entered region " + e.Region.Identifier))
mgr.RegionLeft.Add( fun e -> Console.WriteLine("Left region " + e.Region.Identifier))
mgr.StartMonitoring(rgn)
          ]]></code>
      </example>
      <code lang="C#"><![CDATA[
var rgn = new CLCircularRegion(new CLLocationCoordinate2D(latitude, longitude), 50, "target");
mgr = new CLLocationManager();
var del = new MyLocationDelegate();
mgr.Delegate = del;
mgr.StartMonitoring(rgn);
//...etc...

public class MyLocationDelegate : CLLocationManagerDelegate {
    public override void RegionEntered (CLLocationManager mgr, CLRegion rgn) {
        Console.WriteLine ("Entered region " + rgn.Identifier);
    }

    public override void RegionLeft (CLLocationManager mgr, CLRegion rgn) {
        Console.WriteLine ("Left region " + rgn.Identifier);
    }
}
       ]]></code>
      <code lang="F#"><![CDATA[
let rgn = new CLCircularRegion(new CLLocationCoordinate2D(latitude, longitude), 50, "target")
let mgr = new CLLocationManager()
mgr.Delegate <- new MyLocationDelegate()
mgr.StartMonitoring(rgn)
//...etc...

type MyLocationDelegate () = inherit CLLocationManagerDelegate()
    override this.RegionEntered ( mgr : CLLocationManager, rgn : CLRegion ) = 
        Console.WriteLine ("Entered region " + rgn.Identifier)

    override this.RegionLeft ( mgr : CLLocationManager, rgn : CLRegion ) =
        Console.WriteLine ("Left region " + rgn.Identifier)
        
        ]]></code>
      <format type="text/html">
        <h2>iBeacon Ranging</h2>
      </format>
      <para>In iOS 7, Apple introduced iBeacons, which combine region-processing using server and GPS services and nearby promixity ranging using Bluetooth Low-Energy (BLE) signaling.</para>
      <para>Once within a <see cref="T:CoreLocation.CLBeaconRegion" /> (see previous section), applications may track "ranging" events relating to fine-grained changes in the distance between the device and nearby iBeacons. iBeacon ranging is primarily a function of radio signal strength, which can vary significantly based on environment, electrical noise, etc. Application developers should not attempt to estimate precise distances from the <see cref="P:CoreLocation.CLBeacon.Proximity" /> or <see cref="P:CoreLocation.CLBeacon.RSSI" /> properties.</para>
      <para>Ranging is done with code similar to:</para>
      <para>iBeacons also support "ranging" for determining physical proximity with a higher precision with the <see cref="P:Foundation.CLBeacon.Proximity" /> property. The following example shows how ranging should be used as a qualitative measure:</para>
      <example>
        <code lang="C#"><![CDATA[
locationManager.DidRangeBeacons += (lm, rangeEvents) => {
    switch(rangeEvents.Beacons[0].Proximity){
    case CLProximity.Far : 
        Console.WriteLine("You're getting colder!");
        break;
    case CLProximity.Near :
        Console.WriteLine("You're getting warmer!");
        break;
    case CLProximity.Immediate :
        Console.WriteLine("You're red hot!");
        break;]]></code>
        <code lang="F#"><![CDATA[
locationManager.DidRangeBeacons.Add(fun rangeEvents ->
    let s = match rangeEvents.Beacons.[0].Proximity with
        | CLProximity.Far  -> "You're getting colder!"
        | CLProximity.Near -> "You're getting warmer!"
        | CLProximity.Immediate -> "You're red hot!"
        | CLProximity.Unknown -> "I can't tell"
        | _ -> raise(ArgumentOutOfRangeException("Unknown argument"))
    Console.WriteLine(s)   
)
locationManager.StartRangingBeacons(beaconRegion)       
        ]]></code>
      </example>
      <block subset="none" type="behaviors">
        <format type="text/html">
          <h2>Background Updating and Deferred Mode</h2>
        </format>
        <para>Locations can be updated while the application is in the background. This requires that the <c>info.plist</c> be modified using either Xamarin Studio's visual editor:</para>
        <para>
          <img href="CoreLocation.CLLocationManager.BackgroundModesEnabled" />
        </para>
        <para>Or by adding the key manually:</para>
        <example>
          <code lang="C#"><![CDATA[
<key>UIBackgroundModes</key>
<array>
    <string>location</string>
</array>            
]]></code>
        </example>
        <para>Power consumption is an important consideration for all backgrounding scenarios. In the case of location data, GPS-enabled hardware may be able to record and cache accurate location but defer the delivery to the application for some amount of time. This "deferred mode" has several constraints:  </para>
        <list type="bullet">
          <item>
            <term>GPS hardware must be available</term>
          </item>
          <item>
            <term>The <see cref="P:CoreLocation.CLLocationManager.Delegate" /> property must be assigned to an object whose class implements the <see cref="M:CoreLocation.CLLocationManagerDelegate.LocationsUpdated" /> method.</term>
          </item>
          <item>
            <term>The <see cref="P:CoreLocation.CLLocationManager.DesiredAccuracy" /> property must be set to <see cref="P:CoreLocation.CLLocation.AccuracyBest" /> or <see cref="P:CoreLocation.CLLocation.AccuracyBestForNavigation" />.</term>
          </item>
        </list>
        <para>If those conditions are satisfied, the application can request deferred delivery when backgrounded by calling the <see cref="M:CoreLocation.CLLocationManager.AllowDeferredLocationUpdatesUntil" /> method.</para>
      </block>
      <block subset="none" type="behaviors">
        <format type="text/html">
          <h2>Importance of Delegate object</h2>
        </format>
        <para>Generally, when using Xamarin.iOS, developers can freely choose whether to use C# <c>event</c>s or Apple-style "delegate objects" to react to object lifecycle events. Several <see cref="T:CoreLocation.CLLocationManager" /> methods, however, require the delegate-object pattern. For instance, <see cref="M:CoreLocation.CLLocationManager.AllowDeferredLocationUpdatesUntil" /> will raise a runtime exception if the <see cref="P:CoreLocation.CLLocationManager.Delegate" /> property is not set to an object whose class implements <see cref="M:CoreLocation.CLLocationManagerDelegate.LocationsUpdated" /> method.</para>
      </block>
    </remarks>
    <related type="article" href="http://docs.xamarin.com/guides/cross-platform/application_fundamentals/backgrounding/part_4_ios_backgrounding_walkthroughs/location_walkthrough/">Background Location Walkthrough</related>
    <related type="sample" href="http://samples.xamarin.com/Samples/ByGuid?guid=747bae48-05f5-4dec-a9fa-4cb979056b2d">Example_CoreLocation</related>
    <related type="article" href="http://blog.xamarin.com/play-find-the-monkey-with-ios7-ibeacons">Play 'Find the Monkey' with iOS 7 iBeacons</related>
    <related type="PlatformDocAPI" href="https://developer.apple.com/library/ios/documentation/CoreLocation/Reference/CLLocationManager_Class/index.html">Apple documentation for <c>CLLocationManager</c></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public CLLocationManager ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("init")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Default constructor that initializes a new instance of this class with no parameters.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CLLocationManager (Foundation.NSObjectFlag t);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class Foundation.NSObjectFlag t) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="t" Type="Foundation.NSObjectFlag" />
      </Parameters>
      <Docs>
        <param name="t">Unused sentinel value, pass NSObjectFlag.Empty.</param>
        <summary>Constructor to call on derived classes to skip initialization and merely allocate the object.</summary>
        <remarks>
          <para>This constructor should be called by derived classes when they completely construct the object in managed code and merely want the runtime to allocate and initialize the NSObject.   This is required to implement the two-step initialization process that Objective-C uses, the first step is to perform the object allocation, the second step is to initialize the object.   When developers invoke the constructor that takes the NSObjectFlag.Empty they take advantage of a direct path that goes all the way up to NSObject to merely allocate the object's memory and bind the Objective-C and C# objects together.    The actual initialization of the object is up to the developer.</para>
          <para>This constructor is typically used by the binding generator to allocate the object, but prevent the actual initialization to take place.   Once the allocation has taken place, the constructor has to initialize the object.   With constructors generated by the binding generator this means that it manually invokes one of the "init" methods to initialize the object.</para>
          <para>It is the developer's responsibility to completely initialize the object if they chain up using the NSObjectFlag.Empty path.</para>
          <para>In general, if the developer's constructor invokes the NSObjectFlag.Empty base implementation, then it should be calling an Objective-C init method.   If this is not the case, developers should instead chain to the proper constructor in their class. </para>
          <para>The argument value is ignored and merely ensures that the only code that is executed is the construction phase is the basic NSObject allocation and runtime type registration.  Typically the chaining would look like this:</para>
          <example>
            <code lang="C#"><![CDATA[
//
// The NSObjectFlag merely allocates the object and registers the
// C# class with the Objective-C runtime if necessary, but no actual
// initXxx method is invoked, that is done later in the constructor
//
// This is taken from Xamarin.iOS's source code:
//
[Export ("initWithFrame:")]
public UIView (System.Drawing.RectangleF frame) : base (NSObjectFlag.Empty)
{
// Invoke the init method now.
	var initWithFrame = new Selector ("initWithFrame:").Handle;
	if (IsDirectBinding)
		Handle = ObjCRuntime.Messaging.IntPtr_objc_msgSend_CGRect (this.Handle, initWithFrame, frame);
	else
		Handle = ObjCRuntime.Messaging.IntPtr_objc_msgSendSuper_CGRect (this.SuperHandle, initWithFrame, frame);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CLLocationManager (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig specialname rtspecialname instance void .ctor(native int handle) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Pointer (handle) to the unmanaged object.</param>
        <summary>A constructor used when creating managed representations of unmanaged objects;  Called by the runtime.</summary>
        <remarks>
          <para>This constructor is invoked by the runtime infrastructure (<see cref="M:ObjCRuntime.Runtime.GetNSObject(System.IntPtr)" />) to create a new managed representation for a pointer to an unmanaged Objective-C object.    Developers should not invoke this method directly, instead they should call the GetNSObject method as it will prevent two instances of a managed object to point to the same native object.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActivityType">
      <MemberSignature Language="C#" Value="public virtual CoreLocation.CLActivityType ActivityType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype CoreLocation.CLActivityType ActivityType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.WatchOS, 4, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("activityType")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.WatchOS, 4, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setActivityType:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.WatchOS, 4, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>CoreLocation.CLActivityType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Used to provide the operating system clues for better power consumption / accuracy.</summary>
        <value>The default value is <see cref="F:CoreLocation.CLActivityType.Other" />.</value>
        <remarks>
          <para>Application developers should set this property when possible. It provides clues to the system about the application's need. For instance, if set to <see cref="P:CoreLocation.CLActivityType.AutomativeNavigation" /> and the device has not moved for awhile, the system might power down updates until movement is detected.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowDeferredLocationUpdatesUntil">
      <MemberSignature Language="C#" Value="public virtual void AllowDeferredLocationUpdatesUntil (double distance, double timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AllowDeferredLocationUpdatesUntil(float64 distance, float64 timeout) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("allowDeferredLocationUpdatesUntilTraveled:timeout:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="distance" Type="System.Double" />
        <Parameter Name="timeout" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="distance">A distance, in meters, after which location updates should be delivered.</param>
        <param name="timeout">A time, in seconds, after which location updates should be delivered.</param>
        <summary>Suggests that location updates are deferred until either <paramref name="distance" /> has been traveled or <paramref name="timeout" /> has passed.</summary>
        <remarks>
          <para>Application developers must implement <see cref="T:CoreLocation.CLLocationManagerDelegate" /> and assign the <see cref="P:CoreLocation.CLLocationManager.Delegate" /> property prior to calling this method, or they will receive a runtime exception.</para>
          <para>Application developers who require GPS-accurate location information when their application is in the background, but do not need that information in near-real-time should use this method to defer delivery. Deferred delivery consumes significantly less power.</para>
          <para>This method is only a request. Location updates may occur even if the application is in deferred mode. If updates occur when the application is in deferred mode, the application will stay in deferred mode.</para>
          <para>If the application is in the foreground, location updates are not delayed.</para>
          <para>This method requires GPS hardware to be available, <see cref="P:CoreLocation.CLLocationManager.DistanceFilter" /> to be <see cref="P:CoreLocation.CLLocationDistance.None" />, and <see cref="P:CoreLocation.CLLocationManager.DesiredAccuracy" /> be either <see cref="P:CoreLocation.CLLocation.AccuracyBest" /> or <see cref="P:CoreLocation.CLLocation.AccuracyBestForNavigation" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowsBackgroundLocationUpdates">
      <MemberSignature Language="C#" Value="public virtual bool AllowsBackgroundLocationUpdates { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowsBackgroundLocationUpdates" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.WatchOS, 4, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("allowsBackgroundLocationUpdates")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.WatchOS, 4, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setAllowsBackgroundLocationUpdates:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.WatchOS, 4, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a Boolean value that controls whether the application will respond to location updates while it is suspended.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthorizationChanged">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;CoreLocation.CLAuthorizationChangedEventArgs&gt; AuthorizationChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class CoreLocation.CLAuthorizationChangedEventArgs&gt; AuthorizationChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;CoreLocation.CLAuthorizationChangedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Event raised by the object.</summary>
        <remarks>If developers do not assign a value to this event, this will reset the value for the WeakDelegate property to an internal handler that maps delegates to events.</remarks>
        <altmember cref="M:CoreLocation.CLLocationManager.Status" />
      </Docs>
    </Member>
    <Member MemberName="ClassHandle">
      <MemberSignature Language="C#" Value="public override IntPtr ClassHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ClassHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The handle for this class.</summary>
        <value>The pointer to the Objective-C class.</value>
        <remarks>Each Xamarin.iOS class mirrors an unmanaged Objective-C class.   This value contains the pointer to the Objective-C class, it is similar to calling objc_getClass with the object name.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeferredLocationUpdatesAvailable">
      <MemberSignature Language="C#" Value="public static bool DeferredLocationUpdatesAvailable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool DeferredLocationUpdatesAvailable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.MacOSX, 10, 9, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("deferredLocationUpdatesAvailable")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.MacOSX, 10, 9, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether background-generated deferred location data are available.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeferredUpdatesFinished">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;Foundation.NSErrorEventArgs&gt; DeferredUpdatesFinished;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class Foundation.NSErrorEventArgs&gt; DeferredUpdatesFinished" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;Foundation.NSErrorEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Event raised by the object.</summary>
        <remarks>If developers do not assign a value to this event, this will reset the value for the WeakDelegate property to an internal handler that maps delegates to events.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Delegate">
      <MemberSignature Language="C#" Value="public CoreLocation.ICLLocationManagerDelegate Delegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class CoreLocation.ICLLocationManagerDelegate Delegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>CoreLocation.ICLLocationManagerDelegate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An instance of the CoreLocation.ICLLocationManagerDelegate model class which acts as the class delegate.</summary>
        <value>
          <para>The instance of the CoreLocation.ICLLocationManagerDelegate model class</para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>
          <para>The delegate instance assigned to this object will be used to handle events or provide data on demand to this class.</para>
          <para>When setting the Delegate or WeakDelegate values events will be delivered to the specified instance instead of being delivered to the C#-style events</para>
          <para>This is the strongly typed version of the object, developers should use the WeakDelegate property instead if they want to merely assign a class derived from NSObject that has been decorated with [Export] attributes.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DesiredAccuracy">
      <MemberSignature Language="C#" Value="public virtual double DesiredAccuracy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 DesiredAccuracy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Foundation.Export("desiredAccuracy")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setDesiredAccuracy:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The accuracy preferred by the app. (Coarser accuracies consume less power.)</summary>
        <value>The default value is <see cref="P:CoreLocation.CLLocation.AccuracyBest" />.</value>
        <remarks>
          <para>Application developers should set this value to the coarsest resolution suitable to their needs.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DidDetermineState">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;CoreLocation.CLRegionStateDeterminedEventArgs&gt; DidDetermineState;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class CoreLocation.CLRegionStateDeterminedEventArgs&gt; DidDetermineState" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;CoreLocation.CLRegionStateDeterminedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Event raised by the object.</summary>
        <remarks>If developers do not assign a value to this event, this will reset the value for the WeakDelegate property to an internal handler that maps delegates to events.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DidRangeBeacons">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;CoreLocation.CLRegionBeaconsRangedEventArgs&gt; DidRangeBeacons;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class CoreLocation.CLRegionBeaconsRangedEventArgs&gt; DidRangeBeacons" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;CoreLocation.CLRegionBeaconsRangedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Event raised by the object.</summary>
        <remarks>If developers do not assign a value to this event, this will reset the value for the WeakDelegate property to an internal handler that maps delegates to events.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DidStartMonitoringForRegion">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;CoreLocation.CLRegionEventArgs&gt; DidStartMonitoringForRegion;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class CoreLocation.CLRegionEventArgs&gt; DidStartMonitoringForRegion" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;CoreLocation.CLRegionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Event raised by the object.</summary>
        <remarks>If developers do not assign a value to this event, this will reset the value for the WeakDelegate property to an internal handler that maps delegates to events.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DidVisit">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;CoreLocation.CLVisitedEventArgs&gt; DidVisit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class CoreLocation.CLVisitedEventArgs&gt; DidVisit" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;CoreLocation.CLVisitedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Event raised by the object.</summary>
        <remarks>If developers do not assign a value to this event, this will reset the value for the WeakDelegate property to an internal handler that maps delegates to events.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowDeferredLocationUpdates">
      <MemberSignature Language="C#" Value="public virtual void DisallowDeferredLocationUpdates ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DisallowDeferredLocationUpdates() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("disallowDeferredLocationUpdates")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Turns off deferred background location updates.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:CoreLocation.CLLocationManager.AllowDeferredLocationUpdatesUntil" />
      </Docs>
    </Member>
    <Member MemberName="DismissHeadingCalibrationDisplay">
      <MemberSignature Language="C#" Value="public virtual void DismissHeadingCalibrationDisplay ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DismissHeadingCalibrationDisplay() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("dismissHeadingCalibrationDisplay")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Removes the heading calibration view from the display.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <para>If set to <see langword="true" />, the method is invoked directly and will dispose manage and unmanaged resources;   If set to <see langword="false" /> the method is being called by the garbage collector finalizer and should only release unmanaged resources.</para>
        </param>
        <summary>Releases the resources used by the CLLocationManager object.</summary>
        <remarks>
          <para>This Dispose method releases the resources used by the CLLocationManager class.</para>
          <para>This method is called by both the Dispose() method and the object finalizer (Finalize).    When invoked by the Dispose method, the parameter disposing <paramref name="disposing" /> is set to <see langword="true" /> and any managed object references that this object holds are also disposed or released;  when invoked by the object finalizer, on the finalizer thread the value is set to <see langword="false" />. </para>
          <para>Calling the Dispose method when the application is finished using the CLLocationManager ensures that all external resources used by this managed object are released as soon as possible.  Once developers have invoked the Dispose method, the object is no longer useful and developers should no longer make any calls to it.</para>
          <para>  For more information on how to override this method and on the Dispose/IDisposable pattern, read the ``Implementing a Dispose Method'' document at http://msdn.microsoft.com/en-us/library/fs2xkftw.aspx</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DistanceFilter">
      <MemberSignature Language="C#" Value="public virtual double DistanceFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 DistanceFilter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Foundation.Export("distanceFilter")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setDistanceFilter:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The minimum horizontal distance, in meters, the device has to move before issuing a location update.</summary>
        <value>The default value is <see cref="P:CoreLocation.CLLocationDistance.None" />.</value>
        <remarks>
          <para>If this value is set to <see cref="P:CoreLocation.CLLocationDistance.None" />, the app will receive all location updates.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Failed">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;Foundation.NSErrorEventArgs&gt; Failed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class Foundation.NSErrorEventArgs&gt; Failed" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;Foundation.NSErrorEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Event raised by the object.</summary>
        <remarks>If developers do not assign a value to this event, this will reset the value for the WeakDelegate property to an internal handler that maps delegates to events.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Heading">
      <MemberSignature Language="C#" Value="public virtual CoreLocation.CLHeading Heading { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class CoreLocation.CLHeading Heading" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 4, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("heading")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 4, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>CoreLocation.CLHeading</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The most recent heading (direction in which the device is traveling).</summary>
        <value>This value may be <see langword="null" /> if heading updates have not been started.</value>
        <remarks>
          <para>Heading information is only available on devices with a hardware magnetometer. (See <see cref="P:CoreLocation.CLLocationManager.HeadingAvailable" />.)</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HeadingAvailable">
      <MemberSignature Language="C#" Value="public static bool HeadingAvailable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool HeadingAvailable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 4, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.MacOSX, 10, 7, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("headingAvailable")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 4, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.MacOSX, 10, 7, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether the <see cref="P:CoreLocation.CLLocationManager.Heading" /> property is not <see langword="null" />.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HeadingFilter">
      <MemberSignature Language="C#" Value="public virtual double HeadingFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 HeadingFilter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("headingFilter")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setHeadingFilter:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The minimum change in heading, in degreees, necessary to generate a location update.</summary>
        <value>The default value is 1 (degree).</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HeadingOrientation">
      <MemberSignature Language="C#" Value="public virtual CoreLocation.CLDeviceOrientation HeadingOrientation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype CoreLocation.CLDeviceOrientation HeadingOrientation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 4, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("headingOrientation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 4, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setHeadingOrientation:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 4, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>CoreLocation.CLDeviceOrientation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The orientation used to determine heading calculations.</summary>
        <value>The default value assumes that the app, in upright portrait mode, represents due North.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMonitoringAvailable">
      <MemberSignature Language="C#" Value="public static bool IsMonitoringAvailable (ObjCRuntime.Class regionClass);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMonitoringAvailable(class ObjCRuntime.Class regionClass) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("isMonitoringAvailableForClass:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.MacOSX, 10, 10, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regionClass" Type="ObjCRuntime.Class" />
      </Parameters>
      <Docs>
        <param name="regionClass">Objective-C class, must derive from CLRegion.</param>
        <summary>Determines whether the device supports region monitoring for the specified kind of CLRegion.</summary>
        <returns>True if the device supports it, false otherwise.</returns>
        <remarks>
          <para>
            This method merely determines whether region monitoring is
            available in the hardware, it does not determine whether the
            user has enabled location services or whether the
            application has been granted permission to use this.  You
            must request permission separately.
          </para>
          <para>
            To determine whether you have permission to access
            location services, use <see cref="T:CoreLocation.CLLocationManager" />.
          </para>
          <example>
            <code lang="C#"><![CDATA[
var isAvail = CLLocationManager.IsMonitoringAvailable(typeof(CLCircularRegion));                
                ]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMonitoringAvailable">
      <MemberSignature Language="C#" Value="public static bool IsMonitoringAvailable (Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMonitoringAvailable(class System.Type t) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="t">Type of the class, must derive from CLRegion.</param>
        <summary>Determines whether the device supports region monitoring for the specified kind of CLRegion.</summary>
        <returns>True if the device supports it, false otherwise.</returns>
        <remarks>
          <para>
            This method merely determines whether region monitoring is
            available in the hardware, it does not determine whether the
            user has enabled location services or whether the
            application has been granted permission to use this.  You
            must request permission separately.
          </para>
          <para>
            To determine whether you have permission to access
            location services, use <see cref="T:CoreLocation.CLLocationManager" />.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsRangingAvailable">
      <MemberSignature Language="C#" Value="public static bool IsRangingAvailable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsRangingAvailable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("isRangingAvailable")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a Boolean value that tells whether the device can range Bluetooth beacons.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Location">
      <MemberSignature Language="C#" Value="public virtual CoreLocation.CLLocation Location { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class CoreLocation.CLLocation Location" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Foundation.Export("location")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>CoreLocation.CLLocation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The most recently-retrieved <see cref="T:CoreLocation.CLLocation" />.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LocationServicesEnabled">
      <MemberSignature Language="C#" Value="public static bool LocationServicesEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool LocationServicesEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 4, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("locationServicesEnabled")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 4, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether location services are available.</summary>
        <value>
          <see langword="true" /> if the necessary hardware exists and the user has allowed the app's request for access.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LocationsUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;CoreLocation.CLLocationsUpdatedEventArgs&gt; LocationsUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class CoreLocation.CLLocationsUpdatedEventArgs&gt; LocationsUpdated" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;CoreLocation.CLLocationsUpdatedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Event raised by the object.</summary>
        <remarks>If developers do not assign a value to this event, this will reset the value for the WeakDelegate property to an internal handler that maps delegates to events.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LocationUpdatesPaused">
      <MemberSignature Language="C#" Value="public event EventHandler LocationUpdatesPaused;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LocationUpdatesPaused" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Event raised by the object.</summary>
        <remarks>If developers do not assign a value to this event, this will reset the value for the WeakDelegate property to an internal handler that maps delegates to events.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LocationUpdatesResumed">
      <MemberSignature Language="C#" Value="public event EventHandler LocationUpdatesResumed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LocationUpdatesResumed" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Event raised by the object.</summary>
        <remarks>If developers do not assign a value to this event, this will reset the value for the WeakDelegate property to an internal handler that maps delegates to events.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumRegionMonitoringDistance">
      <MemberSignature Language="C#" Value="public virtual double MaximumRegionMonitoringDistance { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MaximumRegionMonitoringDistance" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 4, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.MacOSX, 10, 8, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("maximumRegionMonitoringDistance")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 4, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.MacOSX, 10, 8, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The largest boundary distance, in meters, that can be assigned to a region.</summary>
        <value>A return value of -1 indicates that region monitoring is unavailable.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxTimeInterval">
      <MemberSignature Language="C#" Value="public static double MaxTimeInterval { get; }" />
      <MemberSignature Language="ILAsm" Value=".property float64 MaxTimeInterval" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("CLTimeIntervalMax", "CoreLocation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant CLTimeInternalMax</summary>
        <value>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MonitoredRegions">
      <MemberSignature Language="C#" Value="public virtual Foundation.NSSet MonitoredRegions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Foundation.NSSet MonitoredRegions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 4, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.MacOSX, 10, 8, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("monitoredRegions")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 4, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.MacOSX, 10, 8, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The set of <see cref="T:CoreLocation.CLRegion" />s being monitored by the app.</summary>
        <value>To be added.</value>
        <remarks>
          <para>The <see cref="T:CoreLocation.CLRegion" />s objects returned by this method may be different than those created by the app. Application developers should use the <see cref="P:CoreLocation.CLRegion.Identifier" /> property to determine equality.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MonitoringFailed">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;CoreLocation.CLRegionErrorEventArgs&gt; MonitoringFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class CoreLocation.CLRegionErrorEventArgs&gt; MonitoringFailed" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;CoreLocation.CLRegionErrorEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Event raised by the object.</summary>
        <remarks>If developers do not assign a value to this event, this will reset the value for the WeakDelegate property to an internal handler that maps delegates to events.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PausesLocationUpdatesAutomatically">
      <MemberSignature Language="C#" Value="public virtual bool PausesLocationUpdatesAutomatically { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PausesLocationUpdatesAutomatically" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("pausesLocationUpdatesAutomatically")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setPausesLocationUpdatesAutomatically:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether the system is allowed to pause location updates (for instance, if the device has not moved in awhile).</summary>
        <value>The default value is <see langword="true" />.</value>
        <remarks>
          <para>Application developers can make pauses more logical by assigning <see cref="P:CoreLocation.CLLocationManager.ActivityType" /> appropriately.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Purpose">
      <MemberSignature Language="C#" Value="public virtual string Purpose { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Purpose" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 3, 2, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.MacOSX, 10, 7, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 3, 2, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("purpose")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 3, 2, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.MacOSX, 10, 7, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 3, 2, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setPurpose:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 3, 2, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.MacOSX, 10, 7, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 3, 2, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Developers should not use this deprecated property. </summary>
        <value>To be added.</value>
        <remarks>
          <para>Application developers should not use this deprecated property.</para>
          <para>Prior to iOS 6, this property was displayed to the user when they were prompted as to whether to allow location services.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RangedRegions">
      <MemberSignature Language="C#" Value="public virtual Foundation.NSSet RangedRegions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Foundation.NSSet RangedRegions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("rangedRegions")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The set of <see cref="T:CoreLocation.CLRegion" />s being tracked using ranging.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RangingBeaconsDidFailForRegion">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;CoreLocation.CLRegionBeaconsFailedEventArgs&gt; RangingBeaconsDidFailForRegion;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class CoreLocation.CLRegionBeaconsFailedEventArgs&gt; RangingBeaconsDidFailForRegion" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;CoreLocation.CLRegionBeaconsFailedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Event raised by the object.</summary>
        <remarks>If developers do not assign a value to this event, this will reset the value for the WeakDelegate property to an internal handler that maps delegates to events.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegionEntered">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;CoreLocation.CLRegionEventArgs&gt; RegionEntered;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class CoreLocation.CLRegionEventArgs&gt; RegionEntered" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;CoreLocation.CLRegionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Event raised by the object.</summary>
        <remarks>If developers do not assign a value to this event, this will reset the value for the WeakDelegate property to an internal handler that maps delegates to events.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegionLeft">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;CoreLocation.CLRegionEventArgs&gt; RegionLeft;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class CoreLocation.CLRegionEventArgs&gt; RegionLeft" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;CoreLocation.CLRegionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Event raised by the object.</summary>
        <remarks>If developers do not assign a value to this event, this will reset the value for the WeakDelegate property to an internal handler that maps delegates to events.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegionMonitoringAvailable">
      <MemberSignature Language="C#" Value="public static bool RegionMonitoringAvailable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool RegionMonitoringAvailable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.None, "Use 'IsMonitoringAvailable' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.MacOSX, 10, 10, ObjCRuntime.PlatformArchitecture.None, "Use 'IsMonitoringAvailable' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 4, 0, ObjCRuntime.PlatformArchitecture.None, "Use 'IsMonitoringAvailable' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.MacOSX, 10, 8, ObjCRuntime.PlatformArchitecture.None, "Use 'IsMonitoringAvailable' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("regionMonitoringAvailable")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.None, "Use 'IsMonitoringAvailable' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.MacOSX, 10, 10, ObjCRuntime.PlatformArchitecture.None, "Use 'IsMonitoringAvailable' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 4, 0, ObjCRuntime.PlatformArchitecture.None, "Use 'IsMonitoringAvailable' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.MacOSX, 10, 8, ObjCRuntime.PlatformArchitecture.None, "Use 'IsMonitoringAvailable' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Application developers should use <see cref="M:CoreLocation.CLLocationManager.IsMonitoringAvailable" /> rather than this deprecated method.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegionMonitoringEnabled">
      <MemberSignature Language="C#" Value="public static bool RegionMonitoringEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool RegionMonitoringEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.None, "Use 'IsMonitoringAvailable' and 'AuthorizationStatus' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.MacOSX, 10, 10, ObjCRuntime.PlatformArchitecture.None, "Use 'IsMonitoringAvailable' and 'AuthorizationStatus' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 4, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 4, 0, ObjCRuntime.PlatformArchitecture.None, "Use 'IsMonitoringAvailable' and 'AuthorizationStatus' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.MacOSX, 10, 8, ObjCRuntime.PlatformArchitecture.None, "Use 'IsMonitoringAvailable' and 'AuthorizationStatus' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("regionMonitoringEnabled")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.None, "Use 'IsMonitoringAvailable' and 'AuthorizationStatus' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.MacOSX, 10, 10, ObjCRuntime.PlatformArchitecture.None, "Use 'IsMonitoringAvailable' and 'AuthorizationStatus' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 4, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 4, 0, ObjCRuntime.PlatformArchitecture.None, "Use 'IsMonitoringAvailable' and 'AuthorizationStatus' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.MacOSX, 10, 8, ObjCRuntime.PlatformArchitecture.None, "Use 'IsMonitoringAvailable' and 'AuthorizationStatus' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Application developers should use <see cref="M:CoreLocation.CLLocationManager.IsMonitoringAvailable" /> rather than this deprecated method.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestAlwaysAuthorization">
      <MemberSignature Language="C#" Value="public virtual void RequestAlwaysAuthorization ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RequestAlwaysAuthorization() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("requestAlwaysAuthorization")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Displays an interface to the user that requests authorization to use location services any time that the app is running.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestLocation">
      <MemberSignature Language="C#" Value="public virtual void RequestLocation ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RequestLocation() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("requestLocation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Requests the current location.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestState">
      <MemberSignature Language="C#" Value="public virtual void RequestState (CoreLocation.CLRegion region);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RequestState(class CoreLocation.CLRegion region) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("requestStateForRegion:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.MacOSX, 10, 10, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="region" Type="CoreLocation.CLRegion" />
      </Parameters>
      <Docs>
        <param name="region">The region whose state is being queried.</param>
        <summary>Asynchronously requests information on the state of the <paramref name="region" />.</summary>
        <remarks>
          <para>Application developers must have assigned the <see cref="P:CoreLocation.CLLocationManager.Delegate" /> property to an object that implements <see cref="M:CoreLocation.CLLocationManagerDelegate.DidDetermineState" /> prior to calling this method. The <see cref="M:CoreLocation.CLLocationManagerDelegate.DidDetermineState" /> method will be called at some point subsequently.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestWhenInUseAuthorization">
      <MemberSignature Language="C#" Value="public virtual void RequestWhenInUseAuthorization ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RequestWhenInUseAuthorization() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("requestWhenInUseAuthorization")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Displays an interface to the user that requests authorization to use location services any time that the app is in the foreground.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldDisplayHeadingCalibration">
      <MemberSignature Language="C#" Value="public CoreLocation.CLLocationManagerEventArgs ShouldDisplayHeadingCalibration { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class CoreLocation.CLLocationManagerEventArgs ShouldDisplayHeadingCalibration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>CoreLocation.CLLocationManagerEventArgs</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Delegate invoked by the object to get a value.</summary>
        <value>To be added.</value>
        <remarks>Developers assign a function, delegate or anonymous method to this property to return a value to the object.   If developers assign a value to this property, it this will reset the value for the WeakDelegate property to an internal handler that maps delegates to events.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowsBackgroundLocationIndicator">
      <MemberSignature Language="C#" Value="public virtual bool ShowsBackgroundLocationIndicator { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowsBackgroundLocationIndicator" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.MacOSX, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("showsBackgroundLocationIndicator")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.MacOSX, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setShowsBackgroundLocationIndicator:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.MacOSX, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SignificantLocationChangeMonitoringAvailable">
      <MemberSignature Language="C#" Value="public static bool SignificantLocationChangeMonitoringAvailable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SignificantLocationChangeMonitoringAvailable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 4, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.MacOSX, 10, 7, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("significantLocationChangeMonitoringAvailable")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 4, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.MacOSX, 10, 7, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether "significant location change" monitoring (e.g., via cell tower switch) is available.</summary>
        <value>
          <see langword="true" /> if such monitoring is available.</value>
        <remarks>
          <para>"Significant location change" monitoring is the lowest-power location monitoring mode and is done primarily via tracking cellphone tower changes. This type of monitoring is primarily useful for applications that are satisfied by approximate location data. </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StartMonitoring">
      <MemberSignature Language="C#" Value="public virtual void StartMonitoring (CoreLocation.CLRegion region);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void StartMonitoring(class CoreLocation.CLRegion region) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("startMonitoringForRegion:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 5, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.MacOSX, 10, 8, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="region" Type="CoreLocation.CLRegion" />
      </Parameters>
      <Docs>
        <param name="region">The region to be monitored.</param>
        <summary>Begins monitoring <paramref name="region" /> for entry and exit.</summary>
        <remarks>
          <para>An application may monitor up to 20 uniquely-named (defined by <see cref="P:CoreLocation.CLRegion.Identifier" />) regions. The speed with which region notifications are delivered is dependent on network connectivity.</para>
          <para>Region entry/exit notifications typically arrive within 3-5 minutes. Regions of less than 400m radius work better on iPhone 4S and later devices. (Notification speed seems fastest on devices with M7 coprocessors.)</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StartMonitoring">
      <MemberSignature Language="C#" Value="public virtual void StartMonitoring (CoreLocation.CLRegion region, double desiredAccuracy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void StartMonitoring(class CoreLocation.CLRegion region, float64 desiredAccuracy) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("startMonitoringForRegion:desiredAccuracy:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 4, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 4, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="region" Type="CoreLocation.CLRegion" />
        <Parameter Name="desiredAccuracy" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="region">Region to monitor</param>
        <param name="desiredAccuracy">Accuracy in meters.</param>
        <summary>Starts monitoring the region.</summary>
        <remarks>
          <para>An application may monitor up to 20 uniquely-named (defined by <see cref="P:CoreLocation.CLRegion.Identifier" />) regions. The speed with which region notifications are delivered is dependent on network connectivity.</para>
          <para>Region entry/exit notifications typically arrive within 3-5 minutes. Regions of less than 400m radius work better on iPhone 4S and later devices. (Notification speed seems fastest on devices with M7 coprocessors.)</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StartMonitoringSignificantLocationChanges">
      <MemberSignature Language="C#" Value="public virtual void StartMonitoringSignificantLocationChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void StartMonitoringSignificantLocationChanges() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("startMonitoringSignificantLocationChanges")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 4, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.MacOSX, 10, 7, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Starts monitoring for significant changes.</summary>
        <remarks>
          <para>This is the most energy-efficient monitoring mode and primarily relies on cellphone-tower changes. It is most appropriate for applications that do not have precise location-monitoring needs. </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StartMonitoringVisits">
      <MemberSignature Language="C#" Value="public virtual void StartMonitoringVisits ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void StartMonitoringVisits() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("startMonitoringVisits")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Starts generating events in response to visits.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartRangingBeacons">
      <MemberSignature Language="C#" Value="public virtual void StartRangingBeacons (CoreLocation.CLBeaconRegion region);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void StartRangingBeacons(class CoreLocation.CLBeaconRegion region) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("startRangingBeaconsInRegion:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="region" Type="CoreLocation.CLBeaconRegion" />
      </Parameters>
      <Docs>
        <param name="region">The region being checked.</param>
        <summary>Starts delivering notifications about beacons in <paramref name="region" />.</summary>
        <remarks>
          <para>Prior to calling this method, application developers must assign to <see cref="P:CoreLocation.CLLocationManager.Delegate" /> an object that implements the <see cref="M:CoreLocation.CLLocationManagerDelegate.DidRangeBeacons" /> and <see cref="M:CoreLocation.CLLocationManagerDelegate.RangingBeaconsDidFailForRegion" /> methods.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StartUpdatingHeading">
      <MemberSignature Language="C#" Value="public virtual void StartUpdatingHeading ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void StartUpdatingHeading() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("startUpdatingHeading")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Starts updating the heading.</summary>
        <remarks>
          <para>Heading information is only available on devices with a hardware magnetometer. (See <see cref="P:CoreLocation.CLLocationManager.HeadingAvailable" />.)</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StartUpdatingLocation">
      <MemberSignature Language="C#" Value="public virtual void StartUpdatingLocation ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void StartUpdatingLocation() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("startUpdatingLocation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.WatchOS, 3, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Starts updating the location</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Status">
      <MemberSignature Language="C#" Value="public static CoreLocation.CLAuthorizationStatus Status { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype CoreLocation.CLAuthorizationStatus Status" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 4, 2, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.MacOSX, 10, 7, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("authorizationStatus")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 4, 2, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.MacOSX, 10, 7, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>CoreLocation.CLAuthorizationStatus</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The authorization status of the app (e.g., if the app is denied access to location services).</summary>
        <value>The value is determined by the user's interaction with the standard permissions dialog.</value>
        <remarks>
          <para>See the "Requesting Authorization" discussion in the class-level remarks: <see cref="T:CoreLocation.CLLocationManager" />.</para>
        </remarks>
        <altmember cref="M:CoreLocation.AuthorizationChanged" />
      </Docs>
    </Member>
    <Member MemberName="StopMonitoring">
      <MemberSignature Language="C#" Value="public virtual void StopMonitoring (CoreLocation.CLRegion region);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void StopMonitoring(class CoreLocation.CLRegion region) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("stopMonitoringForRegion:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 4, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.MacOSX, 10, 8, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="region" Type="CoreLocation.CLRegion" />
      </Parameters>
      <Docs>
        <param name="region">To be added.</param>
        <summary>Stops monitoring the <paramref name="region" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StopMonitoringSignificantLocationChanges">
      <MemberSignature Language="C#" Value="public virtual void StopMonitoringSignificantLocationChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void StopMonitoringSignificantLocationChanges() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("stopMonitoringSignificantLocationChanges")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 4, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.MacOSX, 10, 7, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Starts monitoring significant location changes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StopMonitoringVisits">
      <MemberSignature Language="C#" Value="public virtual void StopMonitoringVisits ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void StopMonitoringVisits() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("stopMonitoringVisits")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stops generating events in response to visits.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StopRangingBeacons">
      <MemberSignature Language="C#" Value="public virtual void StopRangingBeacons (CoreLocation.CLBeaconRegion region);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void StopRangingBeacons(class CoreLocation.CLBeaconRegion region) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("stopRangingBeaconsInRegion:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="region" Type="CoreLocation.CLBeaconRegion" />
      </Parameters>
      <Docs>
        <param name="region">To be added.</param>
        <summary>Stops tracking beacons in the <paramref name="region" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StopUpdatingHeading">
      <MemberSignature Language="C#" Value="public virtual void StopUpdatingHeading ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void StopUpdatingHeading() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("stopUpdatingHeading")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stops updating the heading.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StopUpdatingLocation">
      <MemberSignature Language="C#" Value="public virtual void StopUpdatingLocation ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void StopUpdatingLocation() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("stopUpdatingLocation")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stops updating the location.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdatedHeading">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;CoreLocation.CLHeadingUpdatedEventArgs&gt; UpdatedHeading;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class CoreLocation.CLHeadingUpdatedEventArgs&gt; UpdatedHeading" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;CoreLocation.CLHeadingUpdatedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Event raised by the object.</summary>
        <remarks>If developers do not assign a value to this event, this will reset the value for the WeakDelegate property to an internal handler that maps delegates to events.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdatedLocation">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;CoreLocation.CLLocationUpdatedEventArgs&gt; UpdatedLocation;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class CoreLocation.CLLocationUpdatedEventArgs&gt; UpdatedLocation" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;CoreLocation.CLLocationUpdatedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Event raised by the object.</summary>
        <remarks>If developers do not assign a value to this event, this will reset the value for the WeakDelegate property to an internal handler that maps delegates to events.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WeakDelegate">
      <MemberSignature Language="C#" Value="public virtual Foundation.NSObject WeakDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Foundation.NSObject WeakDelegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Foundation.Export("delegate")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setDelegate:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An object that can respond to the delegate protocol for this type</summary>
        <value>
          <para>The instance that will respond to events and data requests.</para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>
          <para>The delegate instance assigned to this object will be used to handle events or provide data on demand to this class.</para>
          <para>When setting the Delegate or WeakDelegate values events will be delivered to the specified instance instead of being delivered to the C#-style events</para>
          <para>   Methods must be decorated with the [Export ("selectorName")] attribute to respond to each method from the protocol.   Alternatively use the Delegate method which is strongly typed and does not require the [Export] attributes on methods.</para>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
