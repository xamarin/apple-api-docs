<Type Name="Runtime" FullName="ObjCRuntime.Runtime">
  <TypeSignature Language="C#" Value="public static class Runtime" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Runtime extends System.Object" />
  <TypeSignature Language="DocId" Value="T:ObjCRuntime.Runtime" />
  <TypeSignature Language="F#" Value="type Runtime = class" />
  <AssemblyInfo>
    <AssemblyName>Xamarin.iOS</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Provides information about the Xamarin.iOS Runtime.</summary>
    <remarks>
    </remarks>
    <related type="sample" href="https://github.com/xamarin/ios-samples/tree/master/SysSound/">SysSound</related>
  </Docs>
  <Members>
    <Member MemberName="Arch">
      <MemberSignature Language="C#" Value="public static ObjCRuntime.Arch Arch;" />
      <MemberSignature Language="ILAsm" Value=".field public static valuetype ObjCRuntime.Arch Arch" />
      <MemberSignature Language="DocId" Value="F:ObjCRuntime.Runtime.Arch" />
      <MemberSignature Language="F#" Value=" staticval mutable Arch : ObjCRuntime.Arch" Usage="ObjCRuntime.Runtime.Arch" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>ObjCRuntime.Arch</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The architecture where the code is currently running.</summary>
        <remarks>Use this to determine the architecture on which the program is currently running (device or simulator).</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConnectMethod">
      <MemberSignature Language="C#" Value="public static void ConnectMethod (System.Reflection.MethodInfo method, ObjCRuntime.Selector selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ConnectMethod(class System.Reflection.MethodInfo method, class ObjCRuntime.Selector selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:ObjCRuntime.Runtime.ConnectMethod(System.Reflection.MethodInfo,ObjCRuntime.Selector)" />
      <MemberSignature Language="F#" Value="static member ConnectMethod : System.Reflection.MethodInfo * ObjCRuntime.Selector -&gt; unit" Usage="ObjCRuntime.Runtime.ConnectMethod (method, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="selector" Type="ObjCRuntime.Selector" />
      </Parameters>
      <Docs>
        <param name="method">Method that will be called when Objective-C sends a message to the specified selector.</param>
        <param name="selector">Selector to connect to.</param>
        <summary>This call allows the specified method in this method to respond to message invocations on the specified selector.</summary>
        <remarks>
          <para>The method must be declared on an NSObject-derived class.</para>
          <para>Developers can use this method to dynamically reconfigure which methods on a class should respond to which Objective-C selectors.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConnectMethod">
      <MemberSignature Language="C#" Value="public static void ConnectMethod (Type type, System.Reflection.MethodInfo method, Foundation.ExportAttribute export);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ConnectMethod(class System.Type type, class System.Reflection.MethodInfo method, class Foundation.ExportAttribute export) cil managed" />
      <MemberSignature Language="DocId" Value="M:ObjCRuntime.Runtime.ConnectMethod(System.Type,System.Reflection.MethodInfo,Foundation.ExportAttribute)" />
      <MemberSignature Language="F#" Value="static member ConnectMethod : Type * System.Reflection.MethodInfo * Foundation.ExportAttribute -&gt; unit" Usage="ObjCRuntime.Runtime.ConnectMethod (type, method, export)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="export" Type="Foundation.ExportAttribute" />
      </Parameters>
      <Docs>
        <param name="type">Connect to the selector on this type.</param>
        <param name="method">Method that will be called when Objective-C sends a message to the specified selector.</param>
        <param name="export">An export attribute that specifies the selector to connect to.</param>
        <summary>This call allows the specified method in this method to respond to message invocations on the specified selector.</summary>
        <remarks>
          <para>The method must be declared on an NSObject-derived class.</para>
          <para>Developers can use this method to dynamically reconfigure which methods on a class should respond to which Objective-C selectors.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConnectMethod">
      <MemberSignature Language="C#" Value="public static void ConnectMethod (Type type, System.Reflection.MethodInfo method, ObjCRuntime.Selector selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ConnectMethod(class System.Type type, class System.Reflection.MethodInfo method, class ObjCRuntime.Selector selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:ObjCRuntime.Runtime.ConnectMethod(System.Type,System.Reflection.MethodInfo,ObjCRuntime.Selector)" />
      <MemberSignature Language="F#" Value="static member ConnectMethod : Type * System.Reflection.MethodInfo * ObjCRuntime.Selector -&gt; unit" Usage="ObjCRuntime.Runtime.ConnectMethod (type, method, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="selector" Type="ObjCRuntime.Selector" />
      </Parameters>
      <Docs>
        <param name="type">Connect to the selector on this type.</param>
        <param name="method">Method that will be called when Objective-C sends a message to the specified selector.</param>
        <param name="selector">Selector to connect to.</param>
        <summary>This call allows the specified method in this method to respond to message invocations on the specified selector.</summary>
        <remarks>
          <para>The method must be declared on an NSObject-derived class.</para>
          <para>Developers can use this method to dynamically reconfigure which methods on a class should respond to which Objective-C selectors.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynamicRegistrationSupported">
      <MemberSignature Language="C#" Value="public static bool DynamicRegistrationSupported { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool DynamicRegistrationSupported" />
      <MemberSignature Language="DocId" Value="P:ObjCRuntime.Runtime.DynamicRegistrationSupported" />
      <MemberSignature Language="F#" Value="member this.DynamicRegistrationSupported : bool" Usage="ObjCRuntime.Runtime.DynamicRegistrationSupported" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>If dynamic registration is supported.</summary>
        <value>If dynamic registration is supported.</value>
        <remarks>At build time the managed linker can in some cases determine whether dynamic registration is required or not, and if not, it can optimize away the code to support dynamic registration (to minimize app size). If support for dynamic registration has been removed by the linker, this property will return false.</remarks>
        <related type="article" href="https://docs.microsoft.com/en-us/xamarin/cross-platform/macios/optimizations#remove-the-dynamic-registrar">Build optimizations (removal of the dynamic registrar)</related>
      </Docs>
    </Member>
    <Member MemberName="GetINativeObject&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T GetINativeObject&lt;T&gt; (IntPtr ptr, bool owns) where T : class, ObjCRuntime.INativeObject;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T GetINativeObject&lt;class (class ObjCRuntime.INativeObject) T&gt;(native int ptr, bool owns) cil managed" />
      <MemberSignature Language="DocId" Value="M:ObjCRuntime.Runtime.GetINativeObject``1(System.IntPtr,System.Boolean)" />
      <MemberSignature Language="F#" Value="static member GetINativeObject : nativeint * bool -&gt; 'T (requires 'T : null and 'T :&gt; ObjCRuntime.INativeObject)" Usage="ObjCRuntime.Runtime.GetINativeObject (ptr, owns)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            <InterfaceName>ObjCRuntime.INativeObject</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="owns" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type of the object to return. This can also be an interface corresponding to an Objective-C protocol.</typeparam>
        <param name="ptr">A pointer to a native object.</param>
        <param name="owns">Pass true if the caller has a reference to the native object, and wants to give it to the managed wrapper instance. Otherwise pass false (and the native object will be retained).</param>
        <summary>Wraps an native IntPtr with a managed object of the specified type.</summary>
        <returns>An instance of a class implementing the specified type.</returns>
        <remarks>
          <para>Returns an instance of the specified type even if the native object is not in the class hierarchy of type (there are no type checks).</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNSObject">
      <MemberSignature Language="C#" Value="public static Foundation.NSObject GetNSObject (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Foundation.NSObject GetNSObject(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:ObjCRuntime.Runtime.GetNSObject(System.IntPtr)" />
      <MemberSignature Language="F#" Value="static member GetNSObject : nativeint -&gt; Foundation.NSObject" Usage="ObjCRuntime.Runtime.GetNSObject ptr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Foundation.NSObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">A pointer to an unmanaged NSObject or any class that derives from the Objective-C NSObject class.</param>
        <summary>Wraps an unmanaged IntPtr into a fully typed NSObject, or returns an existing wrapper object if one already exists.</summary>
        <returns>An instance of a class that derives from Foundation.NSObject.</returns>
        <remarks>The runtime create an instance of the most derived class.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNSObject&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T GetNSObject&lt;T&gt; (IntPtr ptr) where T : Foundation.NSObject;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T GetNSObject&lt;(class Foundation.NSObject) T&gt;(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:ObjCRuntime.Runtime.GetNSObject``1(System.IntPtr)" />
      <MemberSignature Language="F#" Value="static member GetNSObject : nativeint -&gt; 'T (requires 'T :&gt; Foundation.NSObject)" Usage="ObjCRuntime.Runtime.GetNSObject ptr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <BaseTypeName>Foundation.NSObject</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <typeparam name="T">Type to wrap the native object as.</typeparam>
        <param name="ptr">A pointer to an unmanaged NSObject or any class that derives from the Objective-C NSObject class.</param>
        <summary>Wraps an unmanaged IntPtr into a fully typed NSObject, or returns an existing wrapper object if one already exists.</summary>
        <returns>An instance of the T class.</returns>
        <remarks>
          <para>Returns an instance of the T class even if the native object is not in the class hierarchy of T (no type checks).</para>
          <para>
          </para>
          <para>This method will fail if there already is a managed wrapper of a different (and incompatible) type for the native object.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNSObject&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T GetNSObject&lt;T&gt; (IntPtr ptr, bool owns) where T : Foundation.NSObject;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T GetNSObject&lt;(class Foundation.NSObject) T&gt;(native int ptr, bool owns) cil managed" />
      <MemberSignature Language="DocId" Value="M:ObjCRuntime.Runtime.GetNSObject``1(System.IntPtr,System.Boolean)" />
      <MemberSignature Language="F#" Value="static member GetNSObject : nativeint * bool -&gt; 'T (requires 'T :&gt; Foundation.NSObject)" Usage="ObjCRuntime.Runtime.GetNSObject (ptr, owns)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <BaseTypeName>Foundation.NSObject</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="owns" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="T">Type to wrap the native object as.</typeparam>
        <param name="ptr">A pointer to an unmanaged NSObject or any class that derives from the Objective-C NSObject class.</param>
        <param name="owns">Pass true if the caller has a reference to the native object, and wants to give it to the managed wrapper instance. Otherwise pass false (and the native object will be retained).</param>
        <summary>Wraps an unmanaged IntPtr into a fully typed NSObject, or returns an existing wrapper object if one already exists.</summary>
        <returns>An instance of the T class.</returns>
        <remarks>
          <para>Returns an instance of the T class even if the native object is not in the class hierarchy of T (no type checks).</para>
          <para>
          </para>
          <para>This method will fail if there already is a managed wrapper of a different (and incompatible) type for the native object.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProtocol">
      <MemberSignature Language="C#" Value="public static IntPtr GetProtocol (string protocol);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetProtocol(string protocol) cil managed" />
      <MemberSignature Language="DocId" Value="M:ObjCRuntime.Runtime.GetProtocol(System.String)" />
      <MemberSignature Language="F#" Value="static member GetProtocol : string -&gt; nativeint" Usage="ObjCRuntime.Runtime.GetProtocol protocol" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="protocol" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="protocol">Name of the Objective-C protocol.</param>
        <summary>Returns the handle of the Objective-C protocol descriptor for the given protocol name.</summary>
        <returns>The protocol handle for the given protocol name.</returns>
        <remarks>This is the equivalent of the objc_getProtocol function call.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSurfacedObjects">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.List&lt;WeakReference&gt; GetSurfacedObjects ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.List`1&lt;class System.WeakReference&gt; GetSurfacedObjects() cil managed" />
      <MemberSignature Language="DocId" Value="M:ObjCRuntime.Runtime.GetSurfacedObjects" />
      <MemberSignature Language="F#" Value="static member GetSurfacedObjects : unit -&gt; System.Collections.Generic.List&lt;WeakReference&gt;" Usage="ObjCRuntime.Runtime.GetSurfacedObjects " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;System.WeakReference&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retrieves a list of all the Objective-C objects that have been surfaced to the managed world.</summary>
        <returns />
        <remarks>
          <para>The list contains weak references, to allow GC to take place.</para>
          <para>This method is only for diagnostic purposes, and should not be relied upon.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MarshalManagedException">
      <MemberSignature Language="C#" Value="public static event ObjCRuntime.MarshalManagedExceptionHandler MarshalManagedException;" />
      <MemberSignature Language="ILAsm" Value=".event class ObjCRuntime.MarshalManagedExceptionHandler MarshalManagedException" />
      <MemberSignature Language="DocId" Value="E:ObjCRuntime.Runtime.MarshalManagedException" />
      <MemberSignature Language="F#" Value="member this.MarshalManagedException : ObjCRuntime.MarshalManagedExceptionHandler " Usage="member this.MarshalManagedException : ObjCRuntime.MarshalManagedExceptionHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>ObjCRuntime.MarshalManagedExceptionHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>This event is raised when a managed exception needs to be marshalled to native code.</summary>
        <remarks>
        </remarks>
        <related type="article" href="https://developer.xamarin.com/guides/ios/advanced_topics/exception_marshaling/">Exception marshaling</related>
      </Docs>
    </Member>
    <Member MemberName="MarshalObjectiveCException">
      <MemberSignature Language="C#" Value="public static event ObjCRuntime.MarshalObjectiveCExceptionHandler MarshalObjectiveCException;" />
      <MemberSignature Language="ILAsm" Value=".event class ObjCRuntime.MarshalObjectiveCExceptionHandler MarshalObjectiveCException" />
      <MemberSignature Language="DocId" Value="E:ObjCRuntime.Runtime.MarshalObjectiveCException" />
      <MemberSignature Language="F#" Value="member this.MarshalObjectiveCException : ObjCRuntime.MarshalObjectiveCExceptionHandler " Usage="member this.MarshalObjectiveCException : ObjCRuntime.MarshalObjectiveCExceptionHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>ObjCRuntime.MarshalObjectiveCExceptionHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>This event is raised when an Objective-C exception needs to be marshalled to managed code.</summary>
        <remarks>
        </remarks>
        <related type="article" href="https://developer.xamarin.com/guides/ios/advanced_topics/exception_marshaling/">Exception marshaling</related>
      </Docs>
    </Member>
    <Member MemberName="RegisterAssembly">
      <MemberSignature Language="C#" Value="public static void RegisterAssembly (System.Reflection.Assembly a);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterAssembly(class System.Reflection.Assembly a) cil managed" />
      <MemberSignature Language="DocId" Value="M:ObjCRuntime.Runtime.RegisterAssembly(System.Reflection.Assembly)" />
      <MemberSignature Language="F#" Value="static member RegisterAssembly : System.Reflection.Assembly -&gt; unit" Usage="ObjCRuntime.Runtime.RegisterAssembly a" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="a">The assembly to process.</param>
        <summary>Registers all of the classes in the specified assembly.</summary>
        <remarks>This iterates over all the types that derive from NSObject in the specified assembly and registers them with the runtime.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseBlockOnMainThread">
      <MemberSignature Language="C#" Value="public static void ReleaseBlockOnMainThread (IntPtr block);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;__Internal&quot; as &quot;xamarin_release_block_on_main_thread&quot; winapi)void ReleaseBlockOnMainThread(native int block) cil managed" />
      <MemberSignature Language="DocId" Value="M:ObjCRuntime.Runtime.ReleaseBlockOnMainThread(System.IntPtr)" />
      <MemberSignature Language="F#" Value="static member ReleaseBlockOnMainThread : nativeint -&gt; unit" Usage="ObjCRuntime.Runtime.ReleaseBlockOnMainThread block" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="block" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="block">The block to release.</param>
        <summary>Calls _Block_release on the specified block on the main thread.</summary>
        <remarks>Developers should not call this method, it's called by generated binding code.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartWWAN">
      <MemberSignature Language="C#" Value="public static void StartWWAN (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void StartWWAN(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:ObjCRuntime.Runtime.StartWWAN(System.Uri)" />
      <MemberSignature Language="F#" Value="static member StartWWAN : Uri -&gt; unit" Usage="ObjCRuntime.Runtime.StartWWAN uri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">Uri to probe to start the WWAN connection.</param>
        <summary>This method forces the WAN network access to be woken up.</summary>
        <remarks>When the phone is not on WiFi, this will force the networking stack to start.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartWWAN">
      <MemberSignature Language="C#" Value="public static void StartWWAN (Uri uri, Action&lt;Exception&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void StartWWAN(class System.Uri uri, class System.Action`1&lt;class System.Exception&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:ObjCRuntime.Runtime.StartWWAN(System.Uri,System.Action{System.Exception})" />
      <MemberSignature Language="F#" Value="static member StartWWAN : Uri * Action&lt;Exception&gt; -&gt; unit" Usage="ObjCRuntime.Runtime.StartWWAN (uri, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
        <Parameter Name="callback" Type="System.Action&lt;System.Exception&gt;" />
      </Parameters>
      <Docs>
        <param name="uri">Uri to probe to start the WWAN connection.</param>
        <param name="callback">Callback that will be called when the WWAN connection has been started up. This callback will be invoked on the main thread. If there was an exception while trying to start the WWAN, it will be passed to the callback, otherwise null is passed.</param>
        <summary>This method forces the WAN network access to be woken up asynchronously.</summary>
        <remarks>When the phone is not on WiFi, this will force the networking stack to start.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetNSObject">
      <MemberSignature Language="C#" Value="public static Foundation.NSObject TryGetNSObject (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Foundation.NSObject TryGetNSObject(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:ObjCRuntime.Runtime.TryGetNSObject(System.IntPtr)" />
      <MemberSignature Language="F#" Value="static member TryGetNSObject : nativeint -&gt; Foundation.NSObject" Usage="ObjCRuntime.Runtime.TryGetNSObject ptr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Foundation.NSObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">A pointer to an unmanaged NSObject or any class that derives from the Objective-C NSObject class.</param>
        <summary>Looks up an existing wrapper object for an unmanaged IntPtr.</summary>
        <returns>If a managed wrapper exists for the specified IntPtr, that wrapper is returned, otherwise null.</returns>
        <remarks>
          <para>
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UseAutoreleasePoolInThreadPool">
      <MemberSignature Language="C#" Value="public static bool UseAutoreleasePoolInThreadPool { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UseAutoreleasePoolInThreadPool" />
      <MemberSignature Language="DocId" Value="P:ObjCRuntime.Runtime.UseAutoreleasePoolInThreadPool" />
      <MemberSignature Language="F#" Value="member this.UseAutoreleasePoolInThreadPool : bool with get, set" Usage="ObjCRuntime.Runtime.UseAutoreleasePoolInThreadPool" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A value that specifies whether the Mono runtime should automatically create an NSAutoreleasePool for every work items on the threadpool.</summary>
        <value>
          <para>
          </para>
        </value>
        <remarks>This is enabled by default, but since creating an NSAutoreleasePool adds overhead for every work item, it's possible to disable it for apps that find this overhead unacceptable.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
