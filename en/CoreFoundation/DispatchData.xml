<Type Name="DispatchData" FullName="CoreFoundation.DispatchData">
  <TypeSignature Language="C#" Value="public class DispatchData : CoreFoundation.DispatchObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi DispatchData extends CoreFoundation.DispatchObject" />
  <AssemblyInfo>
    <AssemblyName>Xamarin.iOS</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>CoreFoundation.DispatchObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Dispatch data objects describe contiguous or sparse regions of memory that may be managed by the system or by the application.</summary>
    <remarks>
      <para>Dispatch data objects are immutable, any direct access to memory regions represented by dispatch objects must not modify that memory.</para>
      <para>You use one of the static From methods to create the DispatchData from blocks of memory (<see cref="M:CoreFoundation.DispatchData.FromBuffer" />) or byte arrays (<see cref="M:CoreFoundation.DispatchData.FromByteBuffer" />).</para>
      <para>You can combine <see cref="T:CoreFoundation.DispatchData" /> objects by using the <see cref="M:CoreFoundation.DispatchData.Concat" /> method.</para>
      <para>You can create <see cref="T:CoreFoundation.DispatchData" /> objects that represents a region of the original <see cref="T:CoreFoundation.DispatchData" /> by calling the <see cref="M:CoreFoundation.DispatchData.CreateSubrange" /> method.</para>
      <para></para>
      <para>To access the contents of the <see cref="T:CoreFoundation.DispatchData" /> you will want to invoke the <see cref="M:CoreFoundation.DispatchData.CreateMap" /> which creates a new <see cref="T:CoreFoundation.DispatchData" /> object, but also provides the pointer to the underlying data and the size of the underlying data.</para>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DispatchData (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Points to an unmanaged representation of <see cref="T:CoreFoundation.DispatchData" />, a C dispatch_data_t.</param>
        <summary>Low-level API - Internal constructor that creates a managed <see cref="T:CoreFoundation.DispatchData" /> wrapper around the native dispatch_data_t.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DispatchData (IntPtr handle, bool owns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, bool owns) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="owns" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handle">Points to an unmanaged representation of <see cref="T:CoreFoundation.DispatchData" />, a C dispatch_data_t.</param>
        <param name="owns">Pass <paramref name="true" /> to indicate that the code owns the reference tot he underlying dispatch_data_t, or <paramref name="false" /> if it does not.</param>
        <summary>Low-level API - Internal constructor that creates a managed <see cref="T:CoreFoundation.DispatchData" /> wrapper around the native dispatch_data_t.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static CoreFoundation.DispatchData Concat (CoreFoundation.DispatchData data1, CoreFoundation.DispatchData data2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class CoreFoundation.DispatchData Concat(class CoreFoundation.DispatchData data1, class CoreFoundation.DispatchData data2) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>CoreFoundation.DispatchData</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data1" Type="CoreFoundation.DispatchData" />
        <Parameter Name="data2" Type="CoreFoundation.DispatchData" />
      </Parameters>
      <Docs>
        <param name="data1">The first <see cref="T:CoreFoundation.DispatchData" /> object.</param>
        <param name="data2">The second <see cref="T:CoreFoundation.DispatchData" /> object.</param>
        <summary>
          <para>Returns a new dispatch data object representing the concatenation of the specified data objects.</para>
        </summary>
        <returns>A newly created object representing the concatenation of the <paramref name="data1" /> and <paramref name="data2" /> objects.</returns>
        <remarks>
          <para>Those objects may be released by the application after the call returns (however, the system might not deallocate the memory region(s) described by them until the newly created object has also been released).</para>
          <para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateMap">
      <MemberSignature Language="C#" Value="public CoreFoundation.DispatchData CreateMap (out IntPtr bufferPtr, out nuint size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class CoreFoundation.DispatchData CreateMap(native int bufferPtr, valuetype System.nuint size) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>CoreFoundation.DispatchData</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bufferPtr" Type="System.IntPtr&amp;" RefType="out" />
        <Parameter Name="size" Type="System.nuint&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="bufferPtr">This value will return the address where the data is stored.</param>
        <param name="size">This value will be updated with the size of the data that was extracted.</param>
        <summary>
          <para>Maps the memory represented by the specified dispatch data object as a single contiguous memory region and returns a new data object representing it, as well as the address for the buffer in memory and the size of the buffer.</para>
        </summary>
        <returns>A newly created <see cref="T:CoreFoundation.DispatchData" />.</returns>
        <remarks>
          <para>These allow direct read access to the represented memory, but are only valid until the returned object is released. Under ARC, if that object is held in a variable with automatic storage, care needs to be taken to ensure that it is not released by the compiler before memory access via the pointer has been completed.</para>
          <para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSubrange">
      <MemberSignature Language="C#" Value="public CoreFoundation.DispatchData CreateSubrange (nuint offset, nuint size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class CoreFoundation.DispatchData CreateSubrange(valuetype System.nuint offset, valuetype System.nuint size) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>CoreFoundation.DispatchData</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.nuint" />
        <Parameter Name="size" Type="System.nuint" />
      </Parameters>
      <Docs>
        <param name="offset">The offset into the data object where the subrange starts.</param>
        <param name="size">The length of the range.</param>
        <summary>Returns a new dispatch data object representing a subrange of the specified data object, which may be released by the application after the call returns.</summary>
        <returns>A newly created object representing the specified subrange of the data object.</returns>
        <remarks>The system might not deallocate the memory region(s) described by that object until the newly created object has also been released.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FromBuffer">
      <MemberSignature Language="C#" Value="public static CoreFoundation.DispatchData FromBuffer (IntPtr buffer, nuint size);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class CoreFoundation.DispatchData FromBuffer(native int buffer, valuetype System.nuint size) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>CoreFoundation.DispatchData</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.IntPtr" />
        <Parameter Name="size" Type="System.nuint" />
      </Parameters>
      <Docs>
        <param name="buffer">Points to the block of memory to wrap in memory.</param>
        <param name="size">The size of the block.</param>
        <summary>Creates a <see cref="T:CoreFoundation.DispatchData" /> object from a block of memory at buffer with the specified size.   The block of memory is copied before returning.</summary>
        <returns>The DispatchData that has a copy of the contents specified.</returns>
        <remarks>The data provided will be copied into the buffer, so if you can dispose or discard the data after creating the object.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FromByteBuffer">
      <MemberSignature Language="C#" Value="public static CoreFoundation.DispatchData FromByteBuffer (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class CoreFoundation.DispatchData FromByteBuffer(unsigned int8[] buffer) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>CoreFoundation.DispatchData</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Byte array containing the data that you want to wrap into the DispatchData.</param>
        <summary>Creates a <see cref="T:CoreFoundation.DispatchData" /> object from a byte array.</summary>
        <returns>The DispatchData with a copy of the data.</returns>
        <remarks>This API will make a copy of the data, so any changes done to the underlying yte array will not be reflected into the returned <see cref="T:CoreFoundation.DispatchData" />.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FromByteBuffer">
      <MemberSignature Language="C#" Value="public static CoreFoundation.DispatchData FromByteBuffer (byte[] buffer, int start, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class CoreFoundation.DispatchData FromByteBuffer(unsigned int8[] buffer, int32 start, int32 length) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>CoreFoundation.DispatchData</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Byte array containing the data that you want to wrap into the DispatchData.</param>
        <param name="start">The starting offset into the array that will be copied into the <see cref="T:CoreFoundation.DispatchData" /> object.</param>
        <param name="length">The number of bytes to copy from the start position into the <see cref="T:CoreFoundation.DispatchData" /> object.</param>
        <summary>Creates a <see cref="T:CoreFoundation.DispatchData" /> object from segment of a byte array.</summary>
        <returns>The DispatchData with a copy of the data.</returns>
        <remarks>
          <para>This API will make a copy of the data, so any changes done to the underlying yte array will not be reflected into the returned <see cref="T:CoreFoundation.DispatchData" />.</para>
          <para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public nuint Size { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.nuint Size" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.nuint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The size in bytes of this <see cref="T:CoreFoundation.DispatchData" /> object.</summary>
        <value>
          <para />
        </value>
        <remarks>
          <para />
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
