<Namespace Name="Contacts">
  <Docs>
    <summary>Provides classes that model a person's contact information.</summary>
    <remarks>
      <para>The Contacts namespace provides classes that model the contact information of people. Since contact data is rarely updated, the namespace is optimized for thread-safe, primarily read-only performance. Because the underlying library is highly optimized, incorrect use (such as attempting to manipulate a field for which the data has not been retrieved) may lead to a crash rather than an exception.</para>
      <para>A <see cref="T:Contacts.CNContact" /> object has a large number of fields. Rather than entirely populate all these fields when retrieiving a <see cref="T:Contacts.CNContact" /> object, the developer creates an array of <see cref="T:Contacts.CNContactKey" /> objects for the fields are of interest.  </para>
      <para>The most common way to retrieve Contacts datastore is done by using a <see cref="T:Foundation.NSPredicate" /> that specifies a string to be matched against the contact's given or family name. The predicate generated by the <see cref="M:Contacts.CNContact.GetPredicateForContacts(string)" /> method will match a substring ("Thom" will match "Thomas") but does not have knowledge of nicknames ("Tom" will not match "Thomas").</para>
      <example>
        <code lang="C#"><![CDATA[
public IEnumerable<CNContact> ContactBirthdaysForName(string givenOrFamilyName)
{
    var fetchKeys = new [] { CNContactKey.GivenName, CNContactKey.FamilyName, CNContactKey.Birthday };
    NSError error;
    using (var predicate = CNContact.GetPredicateForContacts(givenOrFamilyName)) 
    {
        using (var store = new CNContactStore())
        {
            var contacts = store.GetUnifiedContacts(predicate, fetchKeys, out error);
            if (error == null)
            {
                foreach (var contact in contacts)
                {
                    yield return contact;
                }
            } 
            else
            {
                throw new Exception(error.ToString());    
            }
        }
    }
}
    ]]></code>
      </example>
      <para>Developers should ensure that they have specified the needed <see cref="T:Contacts.CNContactKey" />keys before manipulating data. As discussed previously, the Contacts runtime functionality is optimized and is more likely to crash than to throw a diagnostic exception. </para>
      <para>
        <see cref="T:Contacts.CNContact" /> objects are immutable. Developers who wish to modify and store contact data must use <see cref="T:Contacts.CNMutableContact" /> objects.</para>
      <para>The <see cref="M:Contacts.CNContactStore.MutableCopy" /> method can be used on a fetched <see cref="T:Contact.CNContact" /> to create a modifiable contact. </para>
      <example>
        <code lang="C#"><![CDATA[
//contact fetched as per previous example
var mutableContact = contact.MutableCopy() as CNMutableContact;
var homeEmail = new CNLabeledValue<NSString>(CNLabelKey.Home, (NSString)"john@appleseed.com");
var emailList = new List<CNLabeledValue<NSString>>(mutableContact.EmailAddresses);
emailList.Add(homeEmail);
mutableContact.EmailAddresses = emailList.ToArray();

var saveRequest = new CNSaveRequest();
saveRequest.UpdateContact(mutableContact);
using(var store = new CNContactStore())
{
    NSError error = null;
    store.ExecuteSaveRequest(saveRequest, out error);
    if(error == null)
    {
//...etc...
    ]]></code>
      </example>
    </remarks>
  </Docs>
</Namespace>