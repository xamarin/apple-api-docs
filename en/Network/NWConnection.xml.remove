<Type Name="NWConnection" FullName="Network.NWConnection">
  <TypeSignature Language="C#" Value="public class NWConnection : CoreFoundation.NativeObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit NWConnection extends CoreFoundation.NativeObject" />
  <AssemblyInfo>
    <AssemblyName>Xamarin.iOS</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>CoreFoundation.NativeObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>ObjCRuntime.TV(12, 0)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents a bidirectional network connection.</summary>
    <remarks>
      <para>The NWConnection represents a network connection that can be used to send and receive data.  </para>
      <para>The <see cref="T:Network.NWConnection" /> constructor can be used to create an outgoing connection to a remote endpoint.</para>
      <para>NWConnection objects are created with an <see cref="T:Network.NWEndpoint" /> to connect to, and take a set of <see cref="T:Network.NWParameters" /> that hold the connection information, this is how you configure whether the connection should be done over TCP (stream of data) or UDP (datagrams), whether the connection should use Transport Layer Security (TLS) or not, and the optional configuration for your TLS connection that you might need.</para>
      <para>Once the object is created, configure the queue on which the callback should be invoked calling <see cref="M:Network.NWConnection.SetQueue" /> method, provide a state change handler with the <see cref="M:Network.NWConnection.SetStateChangeHandler" /> which will contain the bulk of your connecion management and then start the connection process by calling <see cref="M:Network.NWConnection.Start." />    </para>
      <para>
      </para>
      <para>
      </para>
      <code lang="C#"><![CDATA[var endpoint = new NWEndpoint ("www.microsoft.com”, "https");
var parameters = NWParameters.CreateSecureTcp ();
var connection = new NWConnection (endpoint, parameters);
connection.SetQueue (DispatchQueue.MainQueue);
connection.SetStateChangeHandler ((state, error) => {
        var remote = connection.Endpoint;
        var errno = (SslStatus)(error != null ? error.ErrorCode : 0);
        switch (state){
        case NWConnectionState.Waiting:
                warn ($"Connect to {remote.Hostname} port {remote.Port}");
                break;
        case NWConnectionState.Failed:
                warn ($"Connect to {remote.Hostname} port {remote.Port} failed, error {errno}");
                break;
        case NWConnectionState.Ready:
                if (verbose)
                        warn ($"Connect to {remote.Hostname} port {remote.Port} succeeded");
                break;
        case NWConnectionState.Cancelled:
                // Release reference
                connection = null;
                break;
                
        }
});
connection.Start ();]]></code>
      <para>
      </para>
      <para>Once the connection is on the <see cref="E:Network.NWConnectionState.Ready" /> state, you can start sending and receiving data.</para>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NWConnection (Network.NWEndpoint endpoint, Network.NWParameters parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Network.NWEndpoint endpoint, class Network.NWParameters parameters) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="endpoint" Type="Network.NWEndpoint" />
        <Parameter Name="parameters" Type="Network.NWParameters" />
      </Parameters>
      <Docs>
        <param name="endpoint">The endpoint describes where you want this connection to connect to.</param>
        <param name="parameters">The connection parameters control how the connection will behave.</param>
        <summary>Creates an outgoing connection to the specified endpoint using the provided parameters.</summary>
        <remarks>
          <para />
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NWConnection (IntPtr handle, bool owns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, bool owns) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="owns" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handle">To be added.</param>
        <param name="owns">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Batch">
      <MemberSignature Language="C#" Value="public void Batch (Action method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Batch(class System.Action method) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="method">The provided method should perform various Send or Receive operations.</param>
        <summary>Attempt to batch several Send and Receive operations in the provided method, when the method completes, <see cref="T:Network.NWConnection" /> will attempt to batch the operations together.</summary>
        <remarks>
          <para />
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cancel">
      <MemberSignature Language="C#" Value="public void Cancel ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Cancel() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asynchronously cancels the connection - this performs a graceful termination of the connection</summary>
        <remarks>
          <para>Request that the connection be canceled - the state handler defined by <see cref="M:Network.NWConnection.SetStateChangeHandler" /> will receive a <see cref="F:Network.NWConnectionState.Cancelled" /> message.</para>
          <para>
          </para>
          <para>Since this is asynchronously delivered, you should not release any resources associated with the connection until the above message is delivered, as some operations might still be in flight.    Any pending <see cref="M:Network.NWConnection.Send" /> or <see cref="M:Network.NWConnection.Receive" /> operations might return errors.</para>
          <para>This will use the equivalent of Unix’s shutown(2) system call which will perform a graceful TCP termination, by sending a SIN packet and performing the 4-way finalization process.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CancelCurrentEndpoint">
      <MemberSignature Language="C#" Value="public void CancelCurrentEndpoint ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelCurrentEndpoint() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentPath">
      <MemberSignature Language="C#" Value="public Network.NWPath CurrentPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Network.NWPath CurrentPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Network.NWPath</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Description">
      <MemberSignature Language="C#" Value="public string Description { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Description" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Endpoint">
      <MemberSignature Language="C#" Value="public Network.NWEndpoint Endpoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Network.NWEndpoint Endpoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Network.NWEndpoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCancel">
      <MemberSignature Language="C#" Value="public void ForceCancel ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ForceCancel() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asynchronously cancels the connection - there is no attempt to gracefully terminate the connection</summary>
        <remarks>
          <para>Unlike the <see cref="M:Network.NWConnection.Cancel" /> method.   There is no attempt to gracefully terminate the connection, so in TCP’s case, this will use the equivalent of the Unix close(2) call on socket which in turn will send an RST packet and perform a 2-step termination.</para>
          <para>Request that the connection be canceled - the state handler defined by <see cref="M:Network.NWConnection.SetStateChangeHandler" /> will receive a <see cref="F:Network.NWConnectionState.Cancelled" /> message.</para>
          <para>
          </para>
          <para>Since this is asynchronously delivered, you should not release any resources associated with the connection until the above message is delivered, as some operations might still be in flight.    Any pending <see cref="M:Network.NWConnection.Send" /> or <see cref="M:Network.NWConnection.Receive" /> operations might return errors.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProtocolMetadata">
      <MemberSignature Language="C#" Value="public Network.NWProtocolMetadata GetProtocolMetadata (Network.NWProtocolDefinition definition);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Network.NWProtocolMetadata GetProtocolMetadata(class Network.NWProtocolDefinition definition) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Network.NWProtocolMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="definition" Type="Network.NWProtocolDefinition" />
      </Parameters>
      <Docs>
        <param name="definition">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumDatagramSize">
      <MemberSignature Language="C#" Value="public uint MaximumDatagramSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int32 MaximumDatagramSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parameters">
      <MemberSignature Language="C#" Value="public Network.NWParameters Parameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Network.NWParameters Parameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Network.NWParameters</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The parameters for this connection.</summary>
        <value>The current parameters, or <see langword="null" /> on failure.</value>
        <remarks>
          <para />
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public void Receive (uint minimumIncompleteLength, uint maximumLength, Network.NWConnectionReceiveCompletion callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Receive(unsigned int32 minimumIncompleteLength, unsigned int32 maximumLength, class Network.NWConnectionReceiveCompletion callback) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="minimumIncompleteLength" Type="System.UInt32" />
        <Parameter Name="maximumLength" Type="System.UInt32" />
        <Parameter Name="callback" Type="Network.NWConnectionReceiveCompletion" />
      </Parameters>
      <Docs>
        <param name="minimumIncompleteLength">The minimum amount of bytes to retrieve from the connection before the callback is invoked.   If the connection terminates before this minimum is reached, the callback will be invoked with the number of available bytes fetched.</param>
        <param name="maximumLength">Maximum amount of bytes to retrieve from the connection.   You can use UInt32.MaxValue to indicate that it should fetch as many bytes as possible.</param>
        <param name="callback">Method that is invoked when either the minimum amount of bytes is retrieved from the connection or with the amount of bytes read at the time the connection was terminated.   </param>
        <summary>Requests that data be received on the connection and delivered to the provided callnback as a pointer and length, this can be called before the connection is ready.</summary>
        <remarks>
          <para>This version of the <see cref="M:Network.NWConnection.Receive" /> methods delivers the data in the form of an <see cref="T:System.IntPtr" /> with a size parameter.    Alternatively, you can use the <see cref="M:Network.NWConnection.ReceiveData" /> method that delivers a <see cref="T:Foundation.DispatchData" /> parameters if you want to operate on that data type instead.</para>
          <para>
          </para>
          <para>This only retrieves the specified amount of data, if you want to continue reading data, you should call this method again.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReceiveData">
      <MemberSignature Language="C#" Value="public void ReceiveData (uint minimumIncompleteLength, uint maximumLength, Network.NWConnectionReceiveDispatchDataCompletion callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReceiveData(unsigned int32 minimumIncompleteLength, unsigned int32 maximumLength, class Network.NWConnectionReceiveDispatchDataCompletion callback) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="minimumIncompleteLength" Type="System.UInt32" />
        <Parameter Name="maximumLength" Type="System.UInt32" />
        <Parameter Name="callback" Type="Network.NWConnectionReceiveDispatchDataCompletion" />
      </Parameters>
      <Docs>
        <param name="minimumIncompleteLength">The minimum amount of bytes to retrieve from the connection before the callback is invoked.   If the connection terminates before this minimum is reached, the callback will be invoked with the number of available bytes fetched.</param>
        <param name="maximumLength">Maximum amount of bytes to retrieve from the connection.   You can use UInt32.MaxValue to indicate that it should fetch as many bytes as possible.</param>
        <param name="callback">Method that is invoked when either the minimum amount of bytes is retrieved from the connection or with the amount of bytes read at the time the connection was terminated. </param>
        <summary>Requests that data be received on the connection and delivered to the provided callnback as a pointer and length, this can be called before the connection is ready.</summary>
        <remarks>
          <para>This version of the <see cref="M:Network.NWConnection.Receive" /> methods delivers the data in the form of a <see cref="T:Foundation.DispatchData" /> structure.    Alternatively, you can use the <see cref="M:Network.NWConnection.Receive" /> method that delivers a  parameters if you want to receive a  <see cref="T:System.IntPtr" /> block with a size.</para>
          <para>
          </para>
          <para>This only retrieves the specified amount of data, if you want to continue reading data, you should call this method again.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessage">
      <MemberSignature Language="C#" Value="public void ReceiveMessage (Network.NWConnectionReceiveCompletion callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReceiveMessage(class Network.NWConnectionReceiveCompletion callback) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="Network.NWConnectionReceiveCompletion" />
      </Parameters>
      <Docs>
        <param name="callback">Method that is invoked when the message is received</param>
        <summary>Requests that a single atomic message be received on the connection and delivered to the provided callnback as a pointer and length, this can be called before the connection is ready.</summary>
        <remarks>
          <para>This version of the <see cref="M:Network.NWConnection.ReceiveMessage" /> method delivers the data in the form of an <see cref="T:System.IntPtr" /> with a size parameter.    Alternatively, you can use the <see cref="M:Network.NWConnection.ReceiveMessageData" /> method that delivers a <see cref="T:Foundation.DispatchData" /> parameter if you want to operate on that data type instead.</para>
          <para>
          </para>
          <para>This only retrieves the specified amount of data, if you want to continue reading data, you should call this method again.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageData">
      <MemberSignature Language="C#" Value="public void ReceiveMessageData (Network.NWConnectionReceiveDispatchDataCompletion callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReceiveMessageData(class Network.NWConnectionReceiveDispatchDataCompletion callback) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="Network.NWConnectionReceiveDispatchDataCompletion" />
      </Parameters>
      <Docs>
        <param name="callback">Method that is invoked when the message is received</param>
        <summary>Requests that a single atomic message be received on the connection and delivered to the provided callnback as a pointer and length, this can be called before the connection is ready.</summary>
        <remarks>
          <para>This version of the <see cref="M:Network.NWConnection.ReceiveMessageData" /> method delivers the data in the form of a <see cref="T:Foundation.DispatchData" /> structure.    Alternatively, you can use the <see cref="M:Network.NWConnection.ReceiveMessage" /> method that delivers an  <see cref="T:System.IntPtr" /> block with a size.</para>
          <para>
          </para>
          <para>This only retrieves the specified amount of data, if you want to continue reading data, you should call this method again.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Restart">
      <MemberSignature Language="C#" Value="public void Restart ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Restart() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Requests that a connection in the <see cref="F:Network.NWConnectionState.Waiting" /> state retry establishing the network connection.   </summary>
        <remarks>
          <para>While connections automatically will retry the connection as needed, this forces the connection attempt to be retried.</para>
          <para>This is ignored for connections that are not on the waiting state.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (CoreFoundation.DispatchData buffer, Network.NWContentContext context, bool isComplete, Action&lt;Network.NWError&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(class CoreFoundation.DispatchData buffer, class Network.NWContentContext context, bool isComplete, class System.Action`1&lt;class Network.NWError&gt; callback) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="CoreFoundation.DispatchData" />
        <Parameter Name="context" Type="Network.NWContentContext" />
        <Parameter Name="isComplete" Type="System.Boolean" />
        <Parameter Name="callback" Type="System.Action&lt;Network.NWError&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">Buffer to send</param>
        <param name="context">
          <para>Provides additional information to the networking stack on how to send the data based on flags in the context, or the <see cref="T:Network.NWProtocolMetadata" /> associated to the <see cref="P:Network.NWContentContext" />’s metadata.</para>
          <para>
          </para>
          <para>There are some special contexts that you can use for sending information:</para>
          <para>
          </para>
          <list type="bullet">
            <item>
              <term>
                <see cref="P:Network.NWContentContext.DefaultStream" /> - use this to send data on a stream (TCP connections) and only set <paramref name="isComplete" /> to <see langword="true" /> for the last message that you send.</term>
            </item>
            <item>
              <term>
                <see cref="P:Network.NWContentContext.FinalMessage" /> - use this context to perform a graceful close, alternatively, for TCP connections you can set <paramref name="isComplete" /> to true, which will have the same effect.</term>
            </item>
            <item>
              <term>
                <see cref="P:Network.NWContentContext.DefaultMessage" /> - Pass this parameter to send datagrams over UDP, and make sure you set <paramref name="isComplete" /> is always set to <see langword="true" />.   </term>
            </item>
          </list>
          <para>The use of the context allows some messages to be reordered based on <see cref="P:Network.NWContentContext.RelativePriority" />, <see cref="P:Network.NWContentContext.ExpirationMilliseconds" /> and <see cref="P:Network.NWContentContext.Antecedent" />.</para>
          <para>
          </para>
          <para>
          </para>
        </param>
        <param name="isComplete">Indicates that the connection is complete.   For TCP this means that no more data is available in the stream, for UDP this only indicates that the datagram is complete, but more data can be send over the connection.</param>
        <param name="callback">Method to be invoked when the information has been queued for sending.   The error parameter will be <see langword="null" /> if the operation succeeded, otherwise it will contain the details of the error.</param>
        <summary>Queues <see cref="T:CoreFoundation.DispatchData" /> to be sent on the connection.</summary>
        <remarks>
          <para>This method can be invoked before the connection has been established and the data will be queued for delivery.</para>
          <para>
          </para>
          <para>All invocations to Send will be queued and processed when the Network framework is ready to deliver them to the remote endpoint.</para>
          <para>
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (byte[] buffer, Network.NWContentContext context, bool isComplete, Action&lt;Network.NWError&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(unsigned int8[] buffer, class Network.NWContentContext context, bool isComplete, class System.Action`1&lt;class Network.NWError&gt; callback) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="context" Type="Network.NWContentContext" />
        <Parameter Name="isComplete" Type="System.Boolean" />
        <Parameter Name="callback" Type="System.Action&lt;Network.NWError&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">Buffer holding the data to be sent.</param>
        <param name="context">
          <para>Provides additional information to the networking stack on how to send the data based on flags in the context, or the <see cref="T:Network.NWProtocolMetadata" /> associated to the <see cref="P:Network.NWContentContext" />’s metadata.</para>
          <para>
          </para>
          <para>There are some special contexts that you can use for sending information:</para>
          <para>
          </para>
          <list type="bullet">
            <item>
              <term>
                <see cref="P:Network.NWContentContext.DefaultStream" /> - use this to send data on a stream (TCP connections) and only set <paramref name="isComplete" /> to <see langword="true" /> for the last message that you send.</term>
            </item>
            <item>
              <term>
                <see cref="P:Network.NWContentContext.FinalMessage" /> - use this context to perform a graceful close, alternatively, for TCP connections you can set <paramref name="isComplete" /> to true, which will have the same effect.</term>
            </item>
            <item>
              <term>
                <see cref="P:Network.NWContentContext.DefaultMessage" /> - Pass this parameter to send datagrams over UDP, and make sure you set <paramref name="isComplete" /> is always set to <see langword="true" />.   </term>
            </item>
          </list>
          <para>The use of the context allows some messages to be reordered based on <see cref="P:Network.NWContentContext.RelativePriority" />, <see cref="P:Network.NWContentContext.ExpirationMilliseconds" /> and <see cref="P:Network.NWContentContext.Antecedent" />.</para>
        </param>
        <param name="isComplete">Indicates that the connection is complete.   For TCP this means that no more data is available in the stream, for UDP this only indicates that the datagram is complete, but more data can be send over the connection.</param>
        <param name="callback">Method to be invoked when the information has been queued for sending.   The error parameter will be <see langword="null" /> if the operation succeeded, otherwise it will contain the details of the error.</param>
        <summary>Queues byte array to be sent on the connection.</summary>
        <remarks>
          <para>This method can be invoked before the connection has been established and the data will be queued for delivery.</para>
          <para>
          </para>
          <para>All invocations to Send will be queued and processed when the Network framework is ready to deliver them to the remote endpoint.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (byte[] buffer, int start, int length, Network.NWContentContext context, bool isComplete, Action&lt;Network.NWError&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(unsigned int8[] buffer, int32 start, int32 length, class Network.NWContentContext context, bool isComplete, class System.Action`1&lt;class Network.NWError&gt; callback) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="context" Type="Network.NWContentContext" />
        <Parameter Name="isComplete" Type="System.Boolean" />
        <Parameter Name="callback" Type="System.Action&lt;Network.NWError&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">Buffer holding the data to be sent.</param>
        <param name="start">Starting offset inside the buffer to send</param>
        <param name="length">Number of bytes to send from the buffer.</param>
        <param name="context">
          <para>Provides additional information to the networking stack on how to send the data based on flags in the context, or the <see cref="T:Network.NWProtocolMetadata" /> associated to the <see cref="P:Network.NWContentContext" />’s metadata.</para>
          <para>
          </para>
          <para>There are some special contexts that you can use for sending information:</para>
          <para>
          </para>
          <list type="bullet">
            <item>
              <term>
                <see cref="P:Network.NWContentContext.DefaultStream" /> - use this to send data on a stream (TCP connections) and only set <paramref name="isComplete" /> to <see langword="true" /> for the last message that you send.</term>
            </item>
            <item>
              <term>
                <see cref="P:Network.NWContentContext.FinalMessage" /> - use this context to perform a graceful close, alternatively, for TCP connections you can set <paramref name="isComplete" /> to true, which will have the same effect.</term>
            </item>
            <item>
              <term>
                <see cref="P:Network.NWContentContext.DefaultMessage" /> - Pass this parameter to send datagrams over UDP, and make sure you set <paramref name="isComplete" /> is always set to <see langword="true" />.   </term>
            </item>
          </list>
          <para>The use of the context allows some messages to be reordered based on <see cref="P:Network.NWContentContext.RelativePriority" />, <see cref="P:Network.NWContentContext.ExpirationMilliseconds" /> and <see cref="P:Network.NWContentContext.Antecedent" />.</para>
        </param>
        <param name="isComplete">Indicates that the connection is complete.   For TCP this means that no more data is available in the stream, for UDP this only indicates that the datagram is complete, but more data can be send over the connection.</param>
        <param name="callback">Method to be invoked when the information has been queued for sending.   The error parameter will be <see langword="null" /> if the operation succeeded, otherwise it will contain the details of the error.</param>
        <summary>Queues a range of a byte array to be sent on the connection.</summary>
        <remarks>
          <para>This method can be invoked before the connection has been established and the data will be queued for delivery.</para>
          <para>
          </para>
          <para>All invocations to Send will be queued and processed when the Network framework is ready to deliver them to the remote endpoint.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SendIdempotent">
      <MemberSignature Language="C#" Value="public void SendIdempotent (CoreFoundation.DispatchData buffer, Network.NWContentContext context, bool isComplete);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendIdempotent(class CoreFoundation.DispatchData buffer, class Network.NWContentContext context, bool isComplete) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="CoreFoundation.DispatchData" />
        <Parameter Name="context" Type="Network.NWContentContext" />
        <Parameter Name="isComplete" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="context">To be added.</param>
        <param name="isComplete">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SendIdempotent">
      <MemberSignature Language="C#" Value="public void SendIdempotent (byte[] buffer, Network.NWContentContext context, bool isComplete);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendIdempotent(unsigned int8[] buffer, class Network.NWContentContext context, bool isComplete) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="context" Type="Network.NWContentContext" />
        <Parameter Name="isComplete" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="context">To be added.</param>
        <param name="isComplete">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBetterPathAvailableHandler">
      <MemberSignature Language="C#" Value="public void SetBetterPathAvailableHandler (Action&lt;bool&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetBetterPathAvailableHandler(class System.Action`1&lt;bool&gt; callback) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action&lt;System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <param name="callback">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBooleanChangeHandler">
      <MemberSignature Language="C#" Value="public void SetBooleanChangeHandler (Action&lt;bool&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetBooleanChangeHandler(class System.Action`1&lt;bool&gt; callback) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action&lt;System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <param name="callback">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetPathChangedHandler">
      <MemberSignature Language="C#" Value="public void SetPathChangedHandler (Action&lt;Network.NWPath&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPathChangedHandler(class System.Action`1&lt;class Network.NWPath&gt; callback) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action&lt;Network.NWPath&gt;" />
      </Parameters>
      <Docs>
        <param name="callback">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetQueue">
      <MemberSignature Language="C#" Value="public void SetQueue (CoreFoundation.DispatchQueue queue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetQueue(class CoreFoundation.DispatchQueue queue) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="queue" Type="CoreFoundation.DispatchQueue" />
      </Parameters>
      <Docs>
        <param name="queue">The queue to use, like DispatchQueue.MainQueue for example.</param>
        <summary>Configures the dispatch queue to use to invoke the handler passed to <see cref="M:Network.NWConnection.SetStateChangeHandler" />.</summary>
        <remarks>
          <para />
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetStateChangeHandler">
      <MemberSignature Language="C#" Value="public void SetStateChangeHandler (Action&lt;Network.NWConnectionState,Network.NWError&gt; stateHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetStateChangeHandler(class System.Action`2&lt;valuetype Network.NWConnectionState, class Network.NWError&gt; stateHandler) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateHandler" Type="System.Action&lt;Network.NWConnectionState,Network.NWError&gt;" />
      </Parameters>
      <Docs>
        <param name="stateHandler">The provided delegate will receive updates on the connection state, and in case of an error, provided an OS-level error code that can be looked up, like <see cref="T:Security.SslStatus" />.   If the provided value is <see langword="null" />, then the state change handler is removed.</param>
        <summary>Configures the state change handler for the connection responsible for monitoring the connection state, and when ready to start the data flow.</summary>
        <remarks>
          <para>You must configure the dispatch queue where the callback will be invoked using the <see cref="M:Network.NWConnection.SetQueue" /> method before you call the <see cref="M:Network.NWConnection.Start" /> method.</para>
          <para>
          </para>
          <para>The following diagram illustrates the state transitions for your connection:</para>
          <para>
            <img href="NWConnectionState.png" />
          </para>
          <para>
          </para>
          <para>You can read the <see cref="T:Network.NWConnectionState" /> documentation for more information on each state.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Starts the process of establishing a connection.</summary>
        <remarks>Before you can call this method, make sure that you configured both the <see cref="M:Network.NWConnection.SetStateChangeHandler" /> to receive the status updates on the connection status, as well as the <see cref="M:Network.NWConnection.SetQueue" /> method to configure the Dispatch Queue on which the state change handler will be invoked.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
