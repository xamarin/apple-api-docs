<Type Name="SecKeyChain" FullName="Security.SecKeyChain">
  <TypeSignature Language="C#" Value="public class SecKeyChain : ObjCRuntime.INativeObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit SecKeyChain extends System.Object implements class ObjCRuntime.INativeObject" />
  <TypeSignature Language="DocId" Value="T:Security.SecKeyChain" />
  <TypeSignature Language="F#" Value="type SecKeyChain = class&#xA;    interface INativeObject" />
  <AssemblyInfo>
    <AssemblyName>Xamarin.iOS</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>Xamarin.Mac</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>ObjCRuntime.INativeObject</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Access to the operating system keychain.</summary>
    <remarks>
      <para>
	This class can be used to add, remove, update or query the iOS
	or MacOS keychain.  MacOS is limited to a single kind of
	password (SecKind.InternetPassword) while iOS offers a wider
	range of options.
      </para>
      <para>
	Use <see cref="M:Security.SecKeyChain.QueryAsData(Security.SecRecord,System.Boolean,System.Int32,Security.SecStatusCode@)" />
	to get values from the keychain as a binary blob.  Some of the
	overloads can also return binary blobs that are suitable to be
	stored on disk, or passed to another process.
      </para>
      <para>
	Use <see cref="M:Security.SecKeyChain.QueryAsConcreteType(Security.SecRecord,Security.SecStatusCode@)" />
	to get a <see cref="T:Security.SecCertificate" />, a
	<see cref="T:Security.SecKey" /> or a <see cref="T:Security.SecIdentity" /> back from the
	keychain.
      </para>
      <para>
	Use <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=Security%20Sec%20Key%20Chain%20Query%20As%20Record&amp;scope=Xamarin" title="M:Security.SecKeyChain.QueryAsRecord*">M:Security.SecKeyChain.QueryAsRecord*</a></format> to get
	a strongly typed SecRecord with the results of your query.
      </para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
var query = new SecRecord (SecKind.InternetPassword) {
   Sever = "bugzilla.novell.com",
   Account = "miguel"
};
var password = SecKeyChain.QueryAsData (query);
Console.WriteLine ("The password for the account is: {0}", password);

  ]]></code>
      </example>
    </remarks>
    <related type="sample" href="https://github.com/xamarin/ios-samples/tree/master/LineLayout/">Keychain</related>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static Security.SecStatusCode Add (Security.SecRecord record);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Security.SecStatusCode Add(class Security.SecRecord record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Security.SecKeyChain.Add(Security.SecRecord)" />
      <MemberSignature Language="F#" Value="static member Add : Security.SecRecord -&gt; Security.SecStatusCode" Usage="Security.SecKeyChain.Add record" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Security.SecStatusCode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="record" Type="Security.SecRecord" />
      </Parameters>
      <Docs>
        <param name="record">A populated record.</param>
        <summary>Adds the specified record to the keychain.</summary>
        <returns>The result of the operation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddGenericPassword">
      <MemberSignature Language="C#" Value="public static Security.SecStatusCode AddGenericPassword (string serviceName, string accountName, byte[] password);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Security.SecStatusCode AddGenericPassword(string serviceName, string accountName, unsigned int8[] password) cil managed" />
      <MemberSignature Language="DocId" Value="M:Security.SecKeyChain.AddGenericPassword(System.String,System.String,System.Byte[])" />
      <MemberSignature Language="F#" Value="static member AddGenericPassword : string * string * byte[] -&gt; Security.SecStatusCode" Usage="Security.SecKeyChain.AddGenericPassword (serviceName, accountName, password)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Security.SecStatusCode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceName" Type="System.String" Index="0" FrameworkAlternate="xamarin-macos-sdk-14;xamarin-mac-sdk-14" />
        <Parameter Name="accountName" Type="System.String" Index="1" FrameworkAlternate="xamarin-macos-sdk-14;xamarin-mac-sdk-14" />
        <Parameter Name="password" Type="System.Byte[]" Index="2" FrameworkAlternate="xamarin-macos-sdk-14;xamarin-mac-sdk-14" />
      </Parameters>
      <Docs>
        <param name="serviceName">To be added.</param>
        <param name="accountName">To be added.</param>
        <param name="password">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddIdentity">
      <MemberSignature Language="C#" Value="public static void AddIdentity (Security.SecIdentity identity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddIdentity(class Security.SecIdentity identity) cil managed" />
      <MemberSignature Language="DocId" Value="M:Security.SecKeyChain.AddIdentity(Security.SecIdentity)" />
      <MemberSignature Language="F#" Value="static member AddIdentity : Security.SecIdentity -&gt; unit" Usage="Security.SecKeyChain.AddIdentity identity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identity" Type="Security.SecIdentity" />
      </Parameters>
      <Docs>
        <param name="identity">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddInternetPassword">
      <MemberSignature Language="C#" Value="public static Security.SecStatusCode AddInternetPassword (string serverName, string accountName, byte[] password, Security.SecProtocol protocolType = Security.SecProtocol.Http, short port = 0, string path = null, Security.SecAuthenticationType authenticationType = Security.SecAuthenticationType.Default, string securityDomain = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Security.SecStatusCode AddInternetPassword(string serverName, string accountName, unsigned int8[] password, valuetype Security.SecProtocol protocolType, int16 port, string path, valuetype Security.SecAuthenticationType authenticationType, string securityDomain) cil managed" />
      <MemberSignature Language="DocId" Value="M:Security.SecKeyChain.AddInternetPassword(System.String,System.String,System.Byte[],Security.SecProtocol,System.Int16,System.String,Security.SecAuthenticationType,System.String)" />
      <MemberSignature Language="F#" Value="static member AddInternetPassword : string * string * byte[] * Security.SecProtocol * int16 * string * Security.SecAuthenticationType * string -&gt; Security.SecStatusCode" Usage="Security.SecKeyChain.AddInternetPassword (serverName, accountName, password, protocolType, port, path, authenticationType, securityDomain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Security.SecStatusCode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverName" Type="System.String" Index="0" FrameworkAlternate="xamarin-macos-sdk-14;xamarin-mac-sdk-14" />
        <Parameter Name="accountName" Type="System.String" Index="1" FrameworkAlternate="xamarin-macos-sdk-14;xamarin-mac-sdk-14" />
        <Parameter Name="password" Type="System.Byte[]" Index="2" FrameworkAlternate="xamarin-macos-sdk-14;xamarin-mac-sdk-14" />
        <Parameter Name="protocolType" Type="Security.SecProtocol" Index="3" FrameworkAlternate="xamarin-macos-sdk-14;xamarin-mac-sdk-14" />
        <Parameter Name="port" Type="System.Int16" Index="4" FrameworkAlternate="xamarin-macos-sdk-14;xamarin-mac-sdk-14" />
        <Parameter Name="path" Type="System.String" Index="5" FrameworkAlternate="xamarin-macos-sdk-14;xamarin-mac-sdk-14" />
        <Parameter Name="authenticationType" Type="Security.SecAuthenticationType" Index="6" FrameworkAlternate="xamarin-macos-sdk-14;xamarin-mac-sdk-14" />
        <Parameter Name="securityDomain" Type="System.String" Index="7" FrameworkAlternate="xamarin-macos-sdk-14;xamarin-mac-sdk-14" />
      </Parameters>
      <Docs>
        <param name="serverName">To be added.</param>
        <param name="accountName">To be added.</param>
        <param name="password">To be added.</param>
        <param name="protocolType">To be added.</param>
        <param name="port">To be added.</param>
        <param name="path">To be added.</param>
        <param name="authenticationType">To be added.</param>
        <param name="securityDomain">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindGenericPassword">
      <MemberSignature Language="C#" Value="public static Security.SecStatusCode FindGenericPassword (string serviceName, string accountName, out byte[] password);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Security.SecStatusCode FindGenericPassword(string serviceName, string accountName, [out] unsigned int8[]&amp; password) cil managed" />
      <MemberSignature Language="DocId" Value="M:Security.SecKeyChain.FindGenericPassword(System.String,System.String,System.Byte[]@)" />
      <MemberSignature Language="F#" Value="static member FindGenericPassword : string * string *  -&gt; Security.SecStatusCode" Usage="Security.SecKeyChain.FindGenericPassword (serviceName, accountName, password)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Security.SecStatusCode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceName" Type="System.String" Index="0" FrameworkAlternate="xamarin-macos-sdk-14;xamarin-mac-sdk-14" />
        <Parameter Name="accountName" Type="System.String" Index="1" FrameworkAlternate="xamarin-macos-sdk-14;xamarin-mac-sdk-14" />
        <Parameter Name="password" Type="System.Byte[]" RefType="out" Index="2" FrameworkAlternate="xamarin-macos-sdk-14;xamarin-mac-sdk-14" />
      </Parameters>
      <Docs>
        <param name="serviceName">To be added.</param>
        <param name="accountName">To be added.</param>
        <param name="password">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindIdentity">
      <MemberSignature Language="C#" Value="public static Security.SecIdentity FindIdentity (Security.SecCertificate certificate, bool throwOnError = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Security.SecIdentity FindIdentity(class Security.SecCertificate certificate, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:Security.SecKeyChain.FindIdentity(Security.SecCertificate,System.Boolean)" />
      <MemberSignature Language="F#" Value="static member FindIdentity : Security.SecCertificate * bool -&gt; Security.SecIdentity" Usage="Security.SecKeyChain.FindIdentity (certificate, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Security.SecIdentity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="certificate" Type="Security.SecCertificate" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="certificate">To be added.</param>
        <param name="throwOnError">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindInternetPassword">
      <MemberSignature Language="C#" Value="public static Security.SecStatusCode FindInternetPassword (string serverName, string accountName, out byte[] password, Security.SecProtocol protocolType = Security.SecProtocol.Http, short port = 0, string path = null, Security.SecAuthenticationType authenticationType = Security.SecAuthenticationType.Default, string securityDomain = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Security.SecStatusCode FindInternetPassword(string serverName, string accountName, [out] unsigned int8[]&amp; password, valuetype Security.SecProtocol protocolType, int16 port, string path, valuetype Security.SecAuthenticationType authenticationType, string securityDomain) cil managed" />
      <MemberSignature Language="DocId" Value="M:Security.SecKeyChain.FindInternetPassword(System.String,System.String,System.Byte[]@,Security.SecProtocol,System.Int16,System.String,Security.SecAuthenticationType,System.String)" />
      <MemberSignature Language="F#" Value="static member FindInternetPassword : string * string *  * Security.SecProtocol * int16 * string * Security.SecAuthenticationType * string -&gt; Security.SecStatusCode" Usage="Security.SecKeyChain.FindInternetPassword (serverName, accountName, password, protocolType, port, path, authenticationType, securityDomain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Security.SecStatusCode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverName" Type="System.String" Index="0" FrameworkAlternate="xamarin-macos-sdk-14;xamarin-mac-sdk-14" />
        <Parameter Name="accountName" Type="System.String" Index="1" FrameworkAlternate="xamarin-macos-sdk-14;xamarin-mac-sdk-14" />
        <Parameter Name="password" Type="System.Byte[]" RefType="out" Index="2" FrameworkAlternate="xamarin-macos-sdk-14;xamarin-mac-sdk-14" />
        <Parameter Name="protocolType" Type="Security.SecProtocol" Index="3" FrameworkAlternate="xamarin-macos-sdk-14;xamarin-mac-sdk-14" />
        <Parameter Name="port" Type="System.Int16" Index="4" FrameworkAlternate="xamarin-macos-sdk-14;xamarin-mac-sdk-14" />
        <Parameter Name="path" Type="System.String" Index="5" FrameworkAlternate="xamarin-macos-sdk-14;xamarin-mac-sdk-14" />
        <Parameter Name="authenticationType" Type="Security.SecAuthenticationType" Index="6" FrameworkAlternate="xamarin-macos-sdk-14;xamarin-mac-sdk-14" />
        <Parameter Name="securityDomain" Type="System.String" Index="7" FrameworkAlternate="xamarin-macos-sdk-14;xamarin-mac-sdk-14" />
      </Parameters>
      <Docs>
        <param name="serverName">To be added.</param>
        <param name="accountName">To be added.</param>
        <param name="password">To be added.</param>
        <param name="protocolType">To be added.</param>
        <param name="port">To be added.</param>
        <param name="path">To be added.</param>
        <param name="authenticationType">To be added.</param>
        <param name="securityDomain">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:Security.SecKeyChain.Handle" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="Security.SecKeyChain.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Handle (pointer) to the unmanaged object representation.</summary>
        <value>A pointer</value>
        <remarks>This IntPtr is a handle to the underlying unmanaged representation for this object.</remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryAsConcreteType">
      <MemberSignature Language="C#" Value="public static object QueryAsConcreteType (Security.SecRecord query, out Security.SecStatusCode result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object QueryAsConcreteType(class Security.SecRecord query, [out] valuetype Security.SecStatusCode&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:Security.SecKeyChain.QueryAsConcreteType(Security.SecRecord,Security.SecStatusCode@)" />
      <MemberSignature Language="F#" Value="static member QueryAsConcreteType : Security.SecRecord *  -&gt; obj" Usage="Security.SecKeyChain.QueryAsConcreteType (query, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="query" Type="Security.SecRecord" Index="0" FrameworkAlternate="xamarin-ios-sdk-12" />
        <Parameter Name="result" Type="Security.SecStatusCode" RefType="out" Index="1" FrameworkAlternate="xamarin-ios-sdk-12" />
      </Parameters>
      <Docs>
        <param name="query">The query used to lookup the value on the keychain.</param>
        <param name="result">Returns the status code from calling SecItemCopyMatching.</param>
        <summary>Use this method to query the KeyChain and get back a <see cref="T:Security.SecCertificate" />, a <see cref="T:Security.SecKey" /> or a <see cref="T:Security.SecIdentity" />.</summary>
        <returns>An object that can be one of <see cref="T:Security.SecCertificate" />, a <see cref="T:Security.SecKey" /> or a <see cref="T:Security.SecIdentity" /> or null if there is no value found. </returns>
        <remarks>
          <para>
	    This method will throw an exception if the KeyChain
	    contains a new data type that you have introduced with a
	    newer version of Xamarin.iOS into the keychain and you
	    then try to use this with an older version that does not
	    have the ability of decoding theve value.
	  </para>
          <para>
	    This is the strongly typed equivalent of calling the
	    Security's framework SecItemCopyMatching method with the
	    kSecReturnRef set to true.
	  </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryAsData">
      <MemberSignature Language="C#" Value="public static Foundation.NSData QueryAsData (Security.SecRecord query);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Foundation.NSData QueryAsData(class Security.SecRecord query) cil managed" />
      <MemberSignature Language="DocId" Value="M:Security.SecKeyChain.QueryAsData(Security.SecRecord)" />
      <MemberSignature Language="F#" Value="static member QueryAsData : Security.SecRecord -&gt; Foundation.NSData" Usage="Security.SecKeyChain.QueryAsData query" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Foundation.NSData</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="query" Type="Security.SecRecord" />
      </Parameters>
      <Docs>
        <param name="query">The query used to lookup the value on the keychain.</param>
        <summary>Fetches an NSData record from the Keychain.</summary>
        <returns>The NSData associated with the given query.</returns>
        <remarks>
          <para>
	    The returned NSData is a binary blob, if you want to get a
	    high-level representation, use <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=Security%20Sec%20Key%20Chain%20Query%20As%20Record&amp;scope=Xamarin" title="M:Security.SecKeyChain.QueryAsRecord*">M:Security.SecKeyChain.QueryAsRecord*</a></format>
	    instead.
	  </para>
          <para>
	    The returned NSData is not suitable for storing on disk or
	    passing to another process.  If you want that, you should
	    use the overload that takes the bool
	    wantPersistentReference parameter and set that to true.
	  </para>
          <para>
	    This is the strongly typed equivalent of calling the
	    Security's framework SecItemCopyMatching method with the
	    kSecReturnData set to true and kSecMatchLimit to 1,
	    forcing a single record to be returned.
	  </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryAsData">
      <MemberSignature Language="C#" Value="public static Foundation.NSData[] QueryAsData (Security.SecRecord query, int max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Foundation.NSData[] QueryAsData(class Security.SecRecord query, int32 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:Security.SecKeyChain.QueryAsData(Security.SecRecord,System.Int32)" />
      <MemberSignature Language="F#" Value="static member QueryAsData : Security.SecRecord * int -&gt; Foundation.NSData[]" Usage="Security.SecKeyChain.QueryAsData (query, max)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Foundation.NSData[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="query" Type="Security.SecRecord" />
        <Parameter Name="max" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="query">The query used to lookup the value on the keychain.</param>
        <param name="max">Maximum number of values to return.</param>
        <summary>Fetches a set of NSData records from the Keychain.</summary>
        <returns>An array of NSData records associated with the given query.</returns>
        <remarks>
          <para>
	    The returned NSData is a binary blob, if you want to get a
	    high-level representation, use <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=Security%20Sec%20Key%20Chain%20Query%20As%20Record&amp;scope=Xamarin" title="M:Security.SecKeyChain.QueryAsRecord*">M:Security.SecKeyChain.QueryAsRecord*</a></format>
	    instead.
	  </para>
          <para>
	    The returned NSData is not suitable for storing on disk or
	    passing to another process.  If you want that, you should
	    use the overload that takes the bool
	    wantPersistentReference parameter and set that to true.
	  </para>
          <para>
	    This is the strongly typed equivalent of calling the
	    Security's framework SecItemCopyMatching method with the
	    kSecReturnData set to true and kSecMatchLimit set to the value of max,
	    forcing that many record to be returned.
	  </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryAsData">
      <MemberSignature Language="C#" Value="public static Foundation.NSData QueryAsData (Security.SecRecord query, bool wantPersistentReference, out Security.SecStatusCode status);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Foundation.NSData QueryAsData(class Security.SecRecord query, bool wantPersistentReference, [out] valuetype Security.SecStatusCode&amp; status) cil managed" />
      <MemberSignature Language="DocId" Value="M:Security.SecKeyChain.QueryAsData(Security.SecRecord,System.Boolean,Security.SecStatusCode@)" />
      <MemberSignature Language="F#" Value="static member QueryAsData : Security.SecRecord * bool *  -&gt; Foundation.NSData" Usage="Security.SecKeyChain.QueryAsData (query, wantPersistentReference, status)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Foundation.NSData</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="query" Type="Security.SecRecord" />
        <Parameter Name="wantPersistentReference" Type="System.Boolean" />
        <Parameter Name="status" Type="Security.SecStatusCode" RefType="out" />
      </Parameters>
      <Docs>
        <param name="query">The query used to lookup the value on the keychain.</param>
        <param name="wantPersistentReference">If set to true, the returned NSData can be stored on disk for later used, or shared between processes.</param>
        <param name="status">Returns the status code from calling SecItemCopyMatching.</param>
        <summary>Fetches a set of NSData records from the Keychain.</summary>
        <summary>Fetches an NSData record from the Keychain.</summary>
        <returns>The NSData associated with the given query.</returns>
        <remarks>
          <para>
	    The returned NSData is a binary blob, if you want to get a
	    high-level representation, use <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=Security%20Sec%20Key%20Chain%20Query%20As%20Record&amp;scope=Xamarin" title="M:Security.SecKeyChain.QueryAsRecord*">M:Security.SecKeyChain.QueryAsRecord*</a></format>
	    instead.
	  </para>
          <para>
	    This is the strongly typed equivalent of calling the
	    Security's framework SecItemCopyMatching method with the
	    kSecReturnData set to true and kSecMatchLimit to 1,
	    forcing a single record to be returned.  If
	    wantPersistentReference is true, this also sets the
	    kSecReturnPersistentRef dictionary key to true.

	  </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryAsData">
      <MemberSignature Language="C#" Value="public static Foundation.NSData[] QueryAsData (Security.SecRecord query, bool wantPersistentReference, int max, out Security.SecStatusCode status);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Foundation.NSData[] QueryAsData(class Security.SecRecord query, bool wantPersistentReference, int32 max, [out] valuetype Security.SecStatusCode&amp; status) cil managed" />
      <MemberSignature Language="DocId" Value="M:Security.SecKeyChain.QueryAsData(Security.SecRecord,System.Boolean,System.Int32,Security.SecStatusCode@)" />
      <MemberSignature Language="F#" Value="static member QueryAsData : Security.SecRecord * bool * int *  -&gt; Foundation.NSData[]" Usage="Security.SecKeyChain.QueryAsData (query, wantPersistentReference, max, status)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Foundation.NSData[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="query" Type="Security.SecRecord" />
        <Parameter Name="wantPersistentReference" Type="System.Boolean" />
        <Parameter Name="max" Type="System.Int32" />
        <Parameter Name="status" Type="Security.SecStatusCode" RefType="out" />
      </Parameters>
      <Docs>
        <param name="query">The query used to lookup the value on the keychain.</param>
        <param name="wantPersistentReference">If set to true, the returned NSData can be stored on disk for later used, or shared between processes.</param>
        <param name="max">Maximum number of values to return.</param>
        <param name="status">Returns the status code from calling SecItemCopyMatching.</param>
        <summary>Fetches a set of NSData records from the Keychain.</summary>
        <returns>An array of NSData records associated with the given query.</returns>
        <remarks>
          <para>
	    The returned NSData is a binary blob, if you want to get a
	    high-level representation, use <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=Security%20Sec%20Key%20Chain%20Query%20As%20Record&amp;scope=Xamarin" title="M:Security.SecKeyChain.QueryAsRecord*">M:Security.SecKeyChain.QueryAsRecord*</a></format>
	    instead.
	  </para>
          <para>
	    This is the strongly typed equivalent of calling the
	    Security's framework SecItemCopyMatching method with the
	    kSecReturnData set to true and kSecMatchLimit set to the value of max,
	    forcing that many record to be returned.  If
	    wantPersistentReference is true, this also sets the
	    kSecReturnPersistentRef dictionary key to true.
	  </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryAsRecord">
      <MemberSignature Language="C#" Value="public static Security.SecRecord QueryAsRecord (Security.SecRecord query, out Security.SecStatusCode result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Security.SecRecord QueryAsRecord(class Security.SecRecord query, [out] valuetype Security.SecStatusCode&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:Security.SecKeyChain.QueryAsRecord(Security.SecRecord,Security.SecStatusCode@)" />
      <MemberSignature Language="F#" Value="static member QueryAsRecord : Security.SecRecord *  -&gt; Security.SecRecord" Usage="Security.SecKeyChain.QueryAsRecord (query, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Security.SecRecord</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="query" Type="Security.SecRecord" />
        <Parameter Name="result" Type="Security.SecStatusCode" RefType="out" />
      </Parameters>
      <Docs>
        <param name="query">The query used to lookup the value on the keychain.</param>
        <param name="result">Returns the status code from calling SecItemCopyMatching.</param>
        <summary>Fetches a single SecRecord.</summary>
        <returns>Returns a stronglty typed SecRecord.</returns>
        <remarks>
          <para>
	    Unlike the <see cref="M:Security.SecKeyChain.QueryAsData(Security.SecRecord,System.Boolean,System.Int32,Security.SecStatusCode@)" />
	    methods which return a binary blob inside an NSData, this
	    returns a strongly typed SecRecord that you can easily
	    inspect.
	  </para>
          <para>
	    This is the strongly typed equivalent of calling the
	    Security's framework SecItemCopyMatching method with the
	    kSecReturnData set to true, kSecReturnAttributes set to
	    true and kSecMatchLimit set to 1, forcing a single record
	    to be returned.
	  </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryAsRecord">
      <MemberSignature Language="C#" Value="public static Security.SecRecord[] QueryAsRecord (Security.SecRecord query, int max, out Security.SecStatusCode result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Security.SecRecord[] QueryAsRecord(class Security.SecRecord query, int32 max, [out] valuetype Security.SecStatusCode&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:Security.SecKeyChain.QueryAsRecord(Security.SecRecord,System.Int32,Security.SecStatusCode@)" />
      <MemberSignature Language="F#" Value="static member QueryAsRecord : Security.SecRecord * int *  -&gt; Security.SecRecord[]" Usage="Security.SecKeyChain.QueryAsRecord (query, max, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Security.SecRecord[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="query" Type="Security.SecRecord" />
        <Parameter Name="max" Type="System.Int32" />
        <Parameter Name="result" Type="Security.SecStatusCode" RefType="out" />
      </Parameters>
      <Docs>
        <param name="query">The query used to lookup the value on the keychain.</param>
        <param name="max">Maximum number of values to return.</param>
        <param name="result">Returns the status code from calling SecItemCopyMatching.</param>
        <summary>Fetches one or more SecRecords.</summary>
        <returns>Returns an array of strongly typed SecRecord objects.</returns>
        <remarks>
          <para>
	    Unlike the <see cref="M:Security.SecKeyChain.QueryAsData(Security.SecRecord,System.Boolean,System.Int32,Security.SecStatusCode@)" />
	    methods which return a binary blob inside an NSData, this
	    returns a strongly typed SecRecord that you can easily
	    inspect.
	  </para>
          <para>
	    This is the strongly typed equivalent of calling the
	    Security's framework SecItemCopyMatching method with the
	    kSecReturnData set to true, kSecReturnAttributes set to
	    true and kSecMatchLimit set to max, which returns at most
	    that many records.
	  </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryAsReference">
      <MemberSignature Language="C#" Value="public static ObjCRuntime.INativeObject[] QueryAsReference (Security.SecRecord query, int max, out Security.SecStatusCode result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class ObjCRuntime.INativeObject[] QueryAsReference(class Security.SecRecord query, int32 max, [out] valuetype Security.SecStatusCode&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:Security.SecKeyChain.QueryAsReference(Security.SecRecord,System.Int32,Security.SecStatusCode@)" />
      <MemberSignature Language="F#" Value="static member QueryAsReference : Security.SecRecord * int *  -&gt; ObjCRuntime.INativeObject[]" Usage="Security.SecKeyChain.QueryAsReference (query, max, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>ObjCRuntime.INativeObject[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="query" Type="Security.SecRecord" />
        <Parameter Name="max" Type="System.Int32" />
        <Parameter Name="result" Type="Security.SecStatusCode" RefType="out" />
      </Parameters>
      <Docs>
        <param name="query">To be added.</param>
        <param name="max">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public static Security.SecStatusCode Remove (Security.SecRecord record);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Security.SecStatusCode Remove(class Security.SecRecord record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Security.SecKeyChain.Remove(Security.SecRecord)" />
      <MemberSignature Language="F#" Value="static member Remove : Security.SecRecord -&gt; Security.SecStatusCode" Usage="Security.SecKeyChain.Remove record" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Security.SecStatusCode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="record" Type="Security.SecRecord" />
      </Parameters>
      <Docs>
        <param name="record">Record to be removed from the keychain.</param>
        <summary>Removes the specified record from the keychain.</summary>
        <returns>The status code from performing the remove operation.</returns>
        <remarks>This calls the SecItemDelete method on the keychain.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveIdentity">
      <MemberSignature Language="C#" Value="public static void RemoveIdentity (Security.SecIdentity identity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveIdentity(class Security.SecIdentity identity) cil managed" />
      <MemberSignature Language="DocId" Value="M:Security.SecKeyChain.RemoveIdentity(Security.SecIdentity)" />
      <MemberSignature Language="F#" Value="static member RemoveIdentity : Security.SecIdentity -&gt; unit" Usage="Security.SecKeyChain.RemoveIdentity identity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identity" Type="Security.SecIdentity" />
      </Parameters>
      <Docs>
        <param name="identity">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public static Security.SecStatusCode Update (Security.SecRecord query, Security.SecRecord newAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Security.SecStatusCode Update(class Security.SecRecord query, class Security.SecRecord newAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Security.SecKeyChain.Update(Security.SecRecord,Security.SecRecord)" />
      <MemberSignature Language="F#" Value="static member Update : Security.SecRecord * Security.SecRecord -&gt; Security.SecStatusCode" Usage="Security.SecKeyChain.Update (query, newAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Security.SecStatusCode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="query" Type="Security.SecRecord" />
        <Parameter Name="newAttributes" Type="Security.SecRecord" />
      </Parameters>
      <Docs>
        <param name="query">The query to use to update the records on the keychain.</param>
        <param name="newAttributes">The updated record value to store.</param>
        <summary>Updates the record matching the query with the provided data.</summary>
        <returns>Status code of calling SecItemUpdate.</returns>
        <remarks>
          <para>
	    This performs an update on the keychain.
	  </para>
          <para>
	    This calls the SecItemUpdate method.
	  </para>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
