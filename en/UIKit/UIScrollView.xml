<Type Name="UIScrollView" FullName="UIKit.UIScrollView">
  <TypeSignature Language="C#" Value="public class UIScrollView : UIKit.UIView" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit UIScrollView extends UIKit.UIView" />
  <AssemblyInfo>
    <AssemblyName>Xamarin.iOS</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>UIKit.UIView</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Foundation.Register("UIScrollView", true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>A <see cref="T:UIKit.UIView" /> that can scroll, pan, and page its children.</summary>
    <remarks>
      <para>
                The <see cref="T:UIKit.UIScrollView" /> class is a container that provides scrolling, zooming, and panning functionality of its content
                view. Because the <see cref="T:UIKit.UIScrollView" /> class provides out-of-the-box functionality for   scrolling and paging, it is generally used as the basis for <see cref="T:UIKit.UIView" />s whose content is larger than the <see cref="T:UIKit.UIScrollView" />'s <see cref="P:UIKit.UIView.Frame" />. The need for and range of scrolling is specified by the application developer setting the <see cref="T:UIKit.UIScrollView" />'s <see cref="P:UIKit.UIScrollView.ContentSize" /> to a <see cref="T:System.Drawing.SizeF" />
                greater than the <see cref="T:UIKit.UIScrollView" />'s <see cref="P:UIKit.UIView.Frame" />.
            </para>
      <para>
                The most common ways to use the <see cref="T:UIKit.UIScrollView" /> are to either:
            </para>
      <list type="bullet">
        <item>
          <term>
                        Add a single large subview, generally with a <see cref="P:UIKit.UIView.Frame" /> whose <see cref="P:System.Drawing.RectangleF.Location" />
                        is [0,0] and whose <see cref="T:System.Drawing.SizeF" /> is the same as the  <see cref="T:UIKit.UIScrollView" />'s <see cref="P:UIKit.UIScrollView.ContentSize" />; or 
                    </term>
        </item>
        <item>
          <term>
                        Arrange multiple subviews within the <see cref="T:UIKit.UIScrollView" />'s 
                        <see cref="P:UIKit.UIScrollView.ContentSize" /> and use the <see cref="T:UIKit.UIScrollView" /> to scroll between them or, by
                        setting <see cref="P:UIKit.UIScrollView.PagingEnabled" /> to <see langword="true" />, to page between them. This is often done in
                        conjunction with a <see cref="T:UIKit.UIPageControl" />; or
                    </term>
        </item>
        <item>
          <term>
                        Subclass <see cref="T:UIKit.UIScrollView" /> and extend it's functionality. In fact, the <see cref="T:UIKit.UIScrollView" /> is
                        the base class of such commonly-used classes as <see cref="T:UIKit.UITextField" /> and <see cref="T:UIKit.UITableView" />.
                    </term>
        </item>
      </list>
      <format type="text/html">
        <h2>Using A Single Large Subview</h2>
      </format>
      <para>
                The following image, drawn from the "Scroll View" demo in the "iOS Standard Controls" sample, illustrates the simplest use-case: a single large subview (in this case, a <see cref="T:UIKit.UIImageView" />) whose image size
                matches the <see cref="T:UIKit.UIScrollView" />'s <see cref="P:UIKit.UIScrollView.ContentSize" />. The <see cref="P:UIKit.UIScrollView.ContentOffset" /> of the  <see cref="T:UIKit.UIScrollView" /> corresponds to the image pixel showing
                at the origin of the <see cref="T:UIKit.UIImageView" /> (e.g., <see cref="T:System.Drawing.PointF" /> [215, 145]). The <see cref="P:UIKit.UIScrollView.ContentSize" /> of the <see cref="T:UIKit.UIScrollView" /> defines the scroll limits. When the <see cref="P:UIKit.UIScrollView.ContentSize" /> is larger than the <see cref="T:UIKit.UIScrollView" />'s <see cref="P:UIKit.UIView.Frame" />, one gets scrolling behavior. If <see cref="P:UIKit.UIScrollView.ContentSize" /> is not set or is
                set to too small a <see cref="T:System.Drawing.RectangleF" />, one doesn't (however, <see cref="P:UIKit.UIScrollView.AlwaysBounceVertical" /> and <see cref="P:UIKit.UIScrollView.AlwaysBounceHorizontal" /> can be used to allow dragging even in this situation.)
            </para>
      <para>
        <img href="UIKit.UIScrollView.Slide2.png" />
      </para>
      <para>
                As the following code shows, it's straightforward to create and use a <see cref="T:UIKit.UIScrollView" /> in this manner. The
                <c>imageView</c> is initialized from a file. The <see cref="T:UIKit.UIScrollView" />'s <see cref="P:UIKit.UIScrollView.ContentSize" /> is set to  the size of the image  (which happens to be 512 x 512 pixels and thus large enough
                to require scrolling unless zoomed out) and the <c>imageView</c> is added as a subview. 
            </para>
      <para>
                The delegate for the <see cref="P:UIKit.UIScrollView.ViewForZoomingInScrollView" /> property allows the <see cref="T:UIKit.UIScrollView" /> to automatically handle pinch-to-zoom gestures: 
            </para>
      <example>
        <code lang="C#"><![CDATA[
// create our scroll view
scrollView = new UIScrollView (
new RectangleF (0, 0, this.View.Frame.Width, this.View.Frame.Height - this.NavigationController.NavigationBar.Frame.Height));
this.View.AddSubview (scrollView);

// create our image view
imageView = new UIImageView (UIImage.FromFile ("Images/Icons/512_icon.png"));
scrollView.ContentSize = imageView.Image.Size;
scrollView.MaximumZoomScale = 3f;
scrollView.MinimumZoomScale = .1f;
scrollView.AddSubview (imageView);

scrollView.ViewForZoomingInScrollView += (UIScrollView sv) => { return imageView; };
                ]]></code>
      </example>
      <para>
                The <see cref="T:UIKit.UIScrollView" /> tracks the location of the application-user's fingers and updates the <see cref="T:UIKit.UIScrollView" />'s <see cref="P:UIKit.UIScrollView.ContentSize" /> and 
                
                <see cref="P:UIKit.UIScrollView.ZoomScale" /> as they drag, swipe, and make pinch-to-zoom gestures. The <see cref="T:UIKit.UIScrollView" /> draws the
                
                briefly-visible scroll-location indicators, shows the content clipped from its subviews, and animates the scrolling, panning, and zooming
                transitions. As the gesture or animation proceeds, the <see cref="T:UIKit.UIScrollView" /> adjusts the <see cref="P:UIKit.UIScrollView.ContentOffset" /> and <see cref="P:UIKit.UIScrollView.ZoomScale" /> appropriately and repeatedly
                fires the <see cref="E:UIKit.UIScrollView.Scrolled" /> event.  
            </para>
      <format type="text/html">
        <h2>Panning and Paging</h2>
      </format>
      <para>
                The next image, from the "Page Control" demo in the iOS Standard Controls sample, illustrates multiple subviews aligned within the
                boundaries of the <see cref="T:UIKit.UIScrollView" />'s <see cref="P:UIKit.UIScrollView.ContentSize" />. The illustration shows
                the application in the middle of a swiping animation; portions of both the white and gray subviews are visible. 
            </para>
      <para>
        <img href="UIKit.UIScrollView.Slide1.png" />
      </para>
      <para>
                If <see cref="P:UIKit.UIScrollView.PagingEnabled" /> is set to <see langword="true" /> or if the gesture attempts to scroll to an area
                outside the <see cref="T:UIKit.UIScrollView" />'s <see cref="P:UIKit.UIScrollView.ContentSize" />, at the end of the gesture the
                selected subview will "bounce" into alignment with the <see cref="T:UIKit.UIScrollView" />'s <see cref="P:UIKit.UIView.Frame" />. 
            </para>
      <para>
                It is up to the application developer to synchronize with the <see cref="T:UIKit.UIPageControl" /> if one is used. A common way to do this
                is to handle the <see cref="T:UIKit.UIScrollView" />'s <see cref="E:UIKit.UIScrollView.Scrolled" /> event and change
                the model value that is observed by the <see cref="T:UIKit.UIPageControl" /> (or one can imperatively set the <see cref="T:UIKit.UIPageControl" />'s <see cref="P:UIKit.UIPageControl.CurrentPage" />).
            </para>
      <para>
                In the paging demo, the <see cref="P:UIKit.UIView.Frame" />s of the individual subviews and the <see cref="P:UIKit.UIScrollView.ContentSize" /> of the <see cref="T:UIKit.UIScrollView" /> are calculated, aligned, and set using the
                following code, taken from the "iOS Standard Controls" sample:
            </para>
      <example>
        <code lang="C#"><![CDATA[
// instantiate and add the controllers to our list
controllers.Add (new Controller_1 ());
controllers.Add (new Controller_2 ());
controllers.Add (new Controller_3 ());

for (int i = 0; i &lt; controllers.Count; i++)
{
	// set their location and size, each one is moved to the 
	// right by the width of the previous
	RectangleF viewFrame = new RectangleF (
	scrlMain.Frame.Width * i,
	scrlMain.Frame.Y,
	scrlMain.Frame.Width,
	scrlMain.Frame.Height);
	controllers[i].View.Frame = viewFrame;

	// add the view to the scrollview
	scrlMain.AddSubview (controllers[i].View);
}

// set our scroll view content size (width = number of pages * scroll view width)
scrlMain.ContentSize = new SizeF (
scrlMain.Frame.Width * controllers.Count, scrlMain.Frame.Height);
                ]]></code>
      </example>
      <format type="text/html">
        <h2>Tap-To-Zoom</h2>
      </format>
      <para>
                The "tap-to-zoom" gesture consists of the application user double-tapping the scrolling area. To enable this, the developer  needs to create a
                <see cref="T:UIKit.UITapGestureRecognizer" />, configure it for two taps, give it a unique <see cref="T:ObjCRuntime.Selector" />, and add it to the <see cref="T:UIKit.UIScrollView" />.
                Then, the developer has to implement a method with an  <see cref="T:Foundation.ExportAttribute" /> configured to the <c>Selector</c> identifier.
            </para>
      <para>
                The following code from the "Implement Tap-To-Zoom Recipe" shows the essential steps:
                
            </para>
      <example>
        <code lang="C#"><![CDATA[
UITapGestureRecognizer doubletap = new UITapGestureRecognizer();
doubletap.NumberOfTapsRequired = 2; // double tap
doubletap.AddTarget (this, new MonoTouch.ObjCRuntime.Selector("DoubleTapSelector"));
scrollView.AddGestureRecognizer(doubletap); // detect when the scrollView is double-tapped
//...etc...

[MonoTouch.Foundation.Export("DoubleTapSelector")]
public void OnDoubleTap (UIGestureRecognizer sender) {
if (scrollView.ZoomScale >= 1)
   scrollView.SetZoomScale(0.25f, true);
else
   scrollView.SetZoomScale(2f, true);
}
                ]]></code>
      </example>
      <format type="text/html">
        <h2>Touch Delays Associated with UIScrollView</h2>
      </format>
      <para> 
                Because scrolling and zooming gestures can begin anywhere on the screen, the <see cref="T:UIKit.UIScrollView" /> intercepts touch events
                and waits briefly to see if the application user is making a scrolling or zooming gesture. This introduces a small delay but the default behavior
                can be customized by overriding the <see cref="T:UIKit.UIScrollView" />'s <see cref="M:UIKit.UIScrollView.TouchesShouldBegin" />
                and <see cref="M:UIKit.UIScrollView.TouchesShouldCancelInContentView" /> methods.
            </para>
      <format type="text/html">
        <h2>Subview Frames</h2>
      </format>
      <para>
                Although generally the <see cref="P:UIKit.UIView.Frame" />s of the content <see cref="T:UIKit.UIView" />s are aligned with the
                extent of the <see cref="T:UIKit.UIScrollView" />'s <see cref="P:UIKit.UIScrollView.ContentSize" /> and each other, this is not
                a requirement. Setting the <see cref="P:UIKit.UIView.Frame" /> so that it extends beyond the boundaries of the <see cref="P:UIKit.UIScrollView.ContentSize" /> may make drawing geometry easier or more consistent. If, by misaligning subviews, one displays
                an area within the <see cref="P:UIKit.UIScrollView.ContentSize" /> of the <see cref="T:UIKit.UIScrollView" /> that does not
                contain a <see cref="T:UIKit.UIView" />, gestures for scrolling and zooming occurring in the blank area will not work: the application
                must have an underlying <see cref="T:UIKit.UIView" /> to get the expected behavior.
            </para>
      <para>
                Some domains, such as maps and gameboards, may seem to suggest a design in which a <see cref="T:UIKit.UIScrollView" /> has a large number
                of tiled subviews. However, all subviews -- whether visible or not -- are rendered and this can be resource- and processor-intensive. In such
                cases, it is the application developer's responsibility to add or remove subviews appropriately.
            </para>
      <format type="text/html">
        <h2>Event Sequence</h2>
      </format>
      <para>
                The following illustration shows the user actions and resulting <see cref="T:UIKit.UIScrollView" /> event sequence associated with a dragging or swiping gesture:
            </para>
      <list type="bullet">
        <item>
          <term>The user touches the screen;</term>
        </item>
        <item>
          <term>The user begins dragging;</term>
        </item>
        <item>
          <term>The <see cref="E:UIKit.UIScrollView.DraggingStarted" /> event is raised;</term>
        </item>
        <item>
          <term>As long as the user continues dragging...</term>
        </item>
        <item>
          <term>The <see cref="E:UIKit.UIScrollView.Scrolled" /> event is raised repeatedly;</term>
        </item>
        <item>
          <term>The user raises their finger...</term>
        </item>
        <item>
          <term>The <see cref="E:UIKit.UIScrollView.WillEndDragging" /> event is raised;</term>
        </item>
        <item>
          <term>The <see cref="E:UIKIt.UIScrollView.DraggingEnded" /> event is raised;</term>
        </item>
        <item>
          <term>The <see cref="E:UIKit.UIScrollView.DecelerationStarted" /> event is raised;</term>
        </item>
        <item>
          <term>As long as the scrolling animation continues...</term>
        </item>
        <item>
          <term>The <see cref="E:UIKit.UIScrollView.Scrolled" /> event is raised repeatedly;</term>
        </item>
        <item>
          <term>The <see cref="E:UIKit.UIScroll.DevelerationEnded" /> event is raised.</term>
        </item>
      </list>
      <para>
        <img href="UIKit.UIScrollView.DragEventSequence.png" />
      </para>
      <para>
                The following illustration shows the user actions and resulting <see cref="T:UIKit.UIScrollView" /> event sequence associated with a pinch-to-zoom gesture:</para>
      <list type="bullet">
        <item>
          <term>The user touches the screen with two fingers;</term>
        </item>
        <item>
          <term>The user begins the pinch-to-zoom gesture;</term>
        </item>
        <item>
          <term>The <see cref="E:UIKit.UIScrollView.ZoomingStarted" /> event is raised;</term>
        </item>
        <item>
          <term>As long as the user continues pinching...</term>
        </item>
        <item>
          <term>The <see cref="E:UIKit.UIScrollView.Scrolled" /> event is raised repeatedly because the zooming is effecting the origin of the displayed content;</term>
        </item>
        <item>
          <term>The <see cref="E:UIKit.UIScrollView.DidZoom" /> event is raised repeatedly;</term>
        </item>
        <item>
          <term>The user raises their fingers...</term>
        </item>
        <item>
          <term>The <see cref="E:UIKit.UIScrollView.ZoomingEnded" /> event is raised;</term>
        </item>
        <item>
          <term>The <see cref="E:UIKIt.UIScrollView.Scrolled" /> event is raised as the content view bounces into alignment;</term>
        </item>
      </list>
      <para>
        <img href="UIKit.UIScrollView.ZoomEventSequence.png" />
      </para>
      <format type="text/html">
        <h2>State Preservation and Restoration</h2>
      </format>
      <para>
                In iOS 6 or later, if the <see cref="P:UIKit.UIView.RestorationIdentifier" /> property is set, on restoration the <see cref="T:UIKit.UIScrollView" />'s <see cref="P:UIKit.UIScrollView.ZoomScale" />, <see cref="P:UIKit.UIScrollView.ContentOffset" />, and <see cref="P:UIKit.UIScrollView.ContentInset" /> properties will be restored. 
            </para>
      <format type="text/html">
        <h2>Event-handling</h2>
      </format>
      <para>
                The Xamarin API supports two styles of event notification: the
                Objective-C style that uses a delegate class or the C# style using event notifications.  
            </para>
      <para>
                The C# style allows the user to add or remove event handlers at runtime by assigning to the events of properties of this class.    Event handlers
                can be anyone of a method, an anonymous methods or a lambda expression.  Using the C# style events or properties will override any manual settings
                to the Objective-C Delegate or <see cref="P:UIKit.UIScrollView.WeakDelegate" /> settings.
            </para>
      <para>
                The Objective-C style requires the user to create a new class derived from <see cref="T:UIKit.UIScrollViewDelegate" /> class and assign it
                to
                the <see cref="P:UIKit.UIScrollView.Delegate" /> property.   Alternatively, for
                low-level control, by creating a class derived from 
                <see cref="T:Foundation.NSObject" /> which has every entry point properly decorated with an [Export] attribute (see <see cref="T:Foundation.ExportAttribute" />).   The instance of this object
                can then be assigned to the <see cref="P:UIKit.UIScrollView.WeakDelegate" /> property.
            </para>
    </remarks>
    <related type="sample" href="http://samples.xamarin.com/iOS/Samples/ByGuid?guid=D307AF95-96A3-4FBC-832A-1FB187936FAB">iOS Standard Controls</related>
    <related type="recipe" href="http://docs.xamarin.com/iOS/Recipes/Content_Controls/Scroll_View/Implement_Tap-to-Zoom">Implement Tap-to-Zoom Recipe</related>
    <related type="sample" href="http://samples.xamarin.com/Samples/ByGuid?guid=556b1b8f-088e-494f-bc1a-bd418c174ba3">ZoomingPdfViewer</related>
    <related type="recipe" href="http://docs.xamarin.com/ios/Recipes/Content_Controls/Scroll_View/Create_a_Horizontal_Scrolling_Button_List">Create a Horizontal Scrolling Button List</related>
    <related type="PlatformDocAPI" href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIScrollView_Class/index.html">Apple documentation for <c>UIScrollView</c></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIScrollView ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("init")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Default constructor that initializes a new instance of this class with no parameters.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIScrollView (CoreGraphics.CGRect frame);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype CoreGraphics.CGRect frame) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("initWithFrame:")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="frame" Type="CoreGraphics.CGRect" />
      </Parameters>
      <Docs>
        <param name="frame">Frame used by the view, expressed in iOS points.</param>
        <summary>Initializes the UIScrollView with the specified frame.</summary>
        <remarks>
          <para>This constructor is used to programmatically create a new instance of UIScrollView with the specified dimension in the frame.   The object will only be displayed once it has been added to a view hierarchy by calling AddSubview in a containing view.</para>
          <para>This constructor is not invoked when deserializing objects from storyboards or XIB filesinstead the constructor that takes an NSCoder parameter is invoked.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIScrollView (Foundation.NSCoder coder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Foundation.NSCoder coder) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("initWithCoder:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.DesignatedInitializer</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="coder" Type="Foundation.NSCoder" />
      </Parameters>
      <Docs>
        <param name="coder">The unarchiver object.</param>
        <summary>A constructor that initializes the object from the data stored in the unarchiver object.</summary>
        <remarks>
          <para>This constructor is provided to allow the class to be initialized from an unarchiver (for example, during NIB deserialization).   This is part of the <see cref="T:Foundation.NSCoding" />  protocol.</para>
          <para>If developers want to create a subclass of this object and continue to support deserialization from an archive, they should implement a constructor with an identical signature: taking a single parameter of type <see cref="T:Foundation.NSCoder" /> and decorate it with the [Export("initWithCoder:"] attribute declaration.</para>
          <para>The state of this object can also be serialized by using the companion method, EncodeTo.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected UIScrollView (Foundation.NSObjectFlag t);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class Foundation.NSObjectFlag t) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="t" Type="Foundation.NSObjectFlag" />
      </Parameters>
      <Docs>
        <param name="t">Unused sentinel value, pass NSObjectFlag.Empty.</param>
        <summary>Constructor to call on derived classes to skip initialization and merely allocate the object.</summary>
        <remarks>
          <para>This constructor should be called by derived classes when they completely construct the object in managed code and merely want the runtime to allocate and initialize the NSObject.   This is required to implement the two-step initialization process that Objective-C uses, the first step is to perform the object allocation, the second step is to initialize the object.   When developers invoke the constructor that takes the NSObjectFlag.Empty they take advantage of a direct path that goes all the way up to NSObject to merely allocate the object's memory and bind the Objective-C and C# objects together.    The actual initialization of the object is up to the developer.</para>
          <para>This constructor is typically used by the binding generator to allocate the object, but prevent the actual initialization to take place.   Once the allocation has taken place, the constructor has to initialize the object.   With constructors generated by the binding generator this means that it manually invokes one of the "init" methods to initialize the object.</para>
          <para>It is the developer's responsibility to completely initialize the object if they chain up using the NSObjectFlag.Empty path.</para>
          <para>In general, if the developer's constructor invokes the NSObjectFlag.Empty base implementation, then it should be calling an Objective-C init method.   If this is not the case, developers should instead chain to the proper constructor in their class. </para>
          <para>The argument value is ignored and merely ensures that the only code that is executed is the construction phase is the basic NSObject allocation and runtime type registration.  Typically the chaining would look like this:</para>
          <example>
            <code lang="C#"><![CDATA[
//
// The NSObjectFlag merely allocates the object and registers the
// C# class with the Objective-C runtime if necessary, but no actual
// initXxx method is invoked, that is done later in the constructor
//
// This is taken from Xamarin.iOS's source code:
//
[Export ("initWithFrame:")]
public UIView (System.Drawing.RectangleF frame) : base (NSObjectFlag.Empty)
{
// Invoke the init method now.
	var initWithFrame = new Selector ("initWithFrame:").Handle;
	if (IsDirectBinding)
		Handle = ObjCRuntime.Messaging.IntPtr_objc_msgSend_CGRect (this.Handle, initWithFrame, frame);
	else
		Handle = ObjCRuntime.Messaging.IntPtr_objc_msgSendSuper_CGRect (this.SuperHandle, initWithFrame, frame);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected UIScrollView (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig specialname rtspecialname instance void .ctor(native int handle) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Pointer (handle) to the unmanaged object.</param>
        <summary>A constructor used when creating managed representations of unmanaged objects;  Called by the runtime.</summary>
        <remarks>
          <para>This constructor is invoked by the runtime infrastructure (<see cref="M:ObjCRuntime.Runtime.GetNSObject(System.IntPtr)" />) to create a new managed representation for a pointer to an unmanaged Objective-C object.    Developers should not invoke this method directly, instead they should call the GetNSObject method as it will prevent two instances of a managed object to point to the same native object.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AdjustedContentInset">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIEdgeInsets AdjustedContentInset { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype UIKit.UIEdgeInsets AdjustedContentInset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("adjustedContentInset")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIEdgeInsets</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the insets that consider the content insets and the scroll view safe area.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AdjustedContentInsetDidChange">
      <MemberSignature Language="C#" Value="public virtual void AdjustedContentInsetDidChange ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AdjustedContentInsetDidChange() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("You must call the base method when overriding.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Export("adjustedContentInsetDidChange")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Method that is called when <see cref="P:UIKit.UIScrollView.AdjustedContentInset" /> changes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AlwaysBounceHorizontal">
      <MemberSignature Language="C#" Value="public virtual bool AlwaysBounceHorizontal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AlwaysBounceHorizontal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Foundation.Export("alwaysBounceHorizontal")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setAlwaysBounceHorizontal:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>If set to <see langword="true" /> and <see cref="P:UIKit.UIScrollView.Bounces" /> is <see langword="true" />, then bouncing will occur when horizontal scrolling reaches the end of the view.</summary>
        <value>The default value is <see langword="false" /></value>
        <remarks>
          <para>
                        If set to <see langword="true" />, horizontal dragging is enabled even if the <see cref="P:UIKit.UIScrollView.ContentSize" /> property is smaller than the <see cref="T:UIKit.UIScrollView" />'s '<see cref="P:UIKit.UIView.Bounds" />.
                    </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AlwaysBounceVertical">
      <MemberSignature Language="C#" Value="public virtual bool AlwaysBounceVertical { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AlwaysBounceVertical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Foundation.Export("alwaysBounceVertical")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setAlwaysBounceVertical:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>If set to <see langword="true" /> and <see cref="P:UIKit.UIScrollView.Bounces" /> is <see langword="true" />, then bouncing will occur when vertical scrolling reaches the end of the view.</summary>
        <value>The default value is <see langword="false" />.
                </value>
        <remarks>
          <para>
                        If set to <see langword="true" />, vertical dragging is enabled even if the <see cref="P:UIKit.UIScrollView.ContentSize" /> property is smaller than the <see cref="T:UIKit.UIScrollView" />'s '<see cref="P:UIKit.UIView.Bounds" />.
                    </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Appearance">
      <MemberSignature Language="C#" Value="public static UIKit.UIScrollView.UIScrollViewAppearance Appearance { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class UIKit.UIScrollView/UIScrollViewAppearance Appearance" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>UIKit.UIScrollView+UIScrollViewAppearance</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Strongly-typed property that returns the UIAppearance class for this class.</summary>
        <value>
        </value>
        <remarks>
          <para>Setting any appearance properties on this instance will affect the appearance of all instances of UIScrollView.</para>
          <para>If developers want to control the appearance of subclasses of UIScrollView, they should use the <see cref="M:UIKit.UIScrollView.GetAppearance" /> method.</para>
        </remarks>
        <altmember cref="T:UIKit.UIScrollView+UIScrollViewAppearance" />
        <altmember cref="P:UIKit.UIScrollView.IndicatorStyle" />
      </Docs>
    </Member>
    <Member MemberName="AppearanceWhenContainedIn">
      <MemberSignature Language="C#" Value="public static UIKit.UIScrollView.UIScrollViewAppearance AppearanceWhenContainedIn (Type[] containers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class UIKit.UIScrollView/UIScrollViewAppearance AppearanceWhenContainedIn(class System.Type[] containers) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>UIKit.UIScrollView+UIScrollViewAppearance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containers" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="containers">List of types that developers want to have as the containers to apply this particular appearance</param>
        <summary>Returns a strongly typed UIAppearance for instances of this class when the view is hosted in the specified hierarchy.</summary>
        <returns>The appearance proxy object that developers can use to set properties when the given container hierarchy is active</returns>
        <remarks>
          <para>The returned object represents the UIAppearance proxy where developers can set appearance properties for instances of UIScrollView when those instances are contained in the hierarchy specified by the <paramref name="containers" /> parameter.</para>
          <para>If developers want to control the appearance of subclasses of UIScrollView, they should use the <see cref="M:UIKit.UIScrollView.GetAppearance" /> method.</para>
          <para>The following example shows how the AppearanceWhenContainedIn method works</para>
          <example>
            <code lang="C#"><![CDATA[
var mySliders = UISlider.AppearanceWhenContainedIn (typeof (UINavigationBar), typeof (UIPopoverController));
mySliders.TintColor = UIColor.Red;
]]></code>
          </example>
          <para>For more information, see the documentation for the <see cref="T:UIKit.UIAppearance" /> class.</para>
        </remarks>
        <altmember cref="P:UIKit.UIScrollView.Appearance" />
        <altmember cref="T:UIKit.UIScrollView+UIScrollViewAppearance" />
        <altmember cref="P:UIKit.UIScrollView.IndicatorStyle" />
      </Docs>
    </Member>
    <Member MemberName="Bounces">
      <MemberSignature Language="C#" Value="public virtual bool Bounces { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Bounces" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Foundation.Export("bounces")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setBounces:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>If set to <see langword="true" />, then the scroll view will bounce at a content boundary.</summary>
        <value>
        </value>
        <remarks>Default value is <see langword="true" />.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BouncesZoom">
      <MemberSignature Language="C#" Value="public virtual bool BouncesZoom { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BouncesZoom" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Foundation.Export("bouncesZoom")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setBouncesZoom:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>If set to <see langword="true" /> and <see cref="P:UIKit.UIScrollView.Bounces" /> is <see langword="true" />, then the scroll view will bounce around a zoom limit once zooming has exceeded that limit.</summary>
        <value>
        </value>
        <remarks>Default value is <see langword="true" />.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanCancelContentTouches">
      <MemberSignature Language="C#" Value="public virtual bool CanCancelContentTouches { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanCancelContentTouches" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Foundation.Export("canCancelContentTouches")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setCanCancelContentTouches:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>If set to <see langword="false" />, then the scroll view will not scroll as a result of finger movement once the tracking has started in the content view.</summary>
        <value>The default value is <see langword="true" />.
                </value>
        <remarks>
          <para>Default value is <see langword="true" />.</para>
          <para>
                        By default, a <see cref="T:UIKit.UIScrollView" /> intercepts touches before they propagate to subviews and, if a scrolling gesture is made, cancels those touches from being passed to the underlying <see cref="T:UIKit.UIView" /> (instead, both the <see cref="T:UIKit.UIScrollView" /> and the <see cref="T:UIKit.UIView" /> subview receive <see cref="M:UIKit.UIResponder.TouchesCancelled" /> events). By setting this property to <see langword="false" />, the application developer specifies that touches immediately propagate to the underlying  <see cref="T:UIKit.UIView" />. This can avoid potentially-perceptible delays in activating subviews, but makes it impossible for the <see cref="T:UIKit.UIScrollView" /> to recognize scrolling and panning gestures. In this situation, it is up to the application developer to develop a logical and consistent model for scrolling. This may involve the use of <see cref="T:UIKit.UIGestureRecognizer" />s, overriding <see cref="M:UIKit.UIScrollView.TouchesShouldBegin" />,  <see cref="M:UIKit.UIScrollView.TouchesShouldCancelInContentView" /></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClassHandle">
      <MemberSignature Language="C#" Value="public override IntPtr ClassHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ClassHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The handle for this class.</summary>
        <value>The pointer to the Objective-C class.</value>
        <remarks>Each Xamarin.iOS class mirrors an unmanaged Objective-C class.   This value contains the pointer to the Objective-C class, it is similar to calling objc_getClass with the object name.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentInset">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIEdgeInsets ContentInset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype UIKit.UIEdgeInsets ContentInset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Foundation.Export("contentInset")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setContentInset:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIEdgeInsets</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The distance, in points, that the content of the scroll view is inset inside of the scroll view.</summary>
        <value>The default value is <see cref="F:UIKit.UIEdgeInsets.Zero" /></value>
        <remarks>This is used to add scrolling area around the content of the a scroll view. Generally, the application developer also sets <see cref="P:UIKit.UIScrollView.ScrollIndicatorInset" /> to the same value, so that the scroll indicators appear near the to-be-scrolled content and do not overlap elements placed in the inset area. </remarks>
        <altmember cref="P:UIKit.UIScrollView.ScrollIndicatorInset" />
      </Docs>
    </Member>
    <Member MemberName="ContentInsetAdjustmentBehavior">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIScrollViewContentInsetAdjustmentBehavior ContentInsetAdjustmentBehavior { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype UIKit.UIScrollViewContentInsetAdjustmentBehavior ContentInsetAdjustmentBehavior" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("contentInsetAdjustmentBehavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setContentInsetAdjustmentBehavior:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIScrollViewContentInsetAdjustmentBehavior</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that controls when safe area insets are added to content insets.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentLayoutGuide">
      <MemberSignature Language="C#" Value="public virtual UIKit.UILayoutGuide ContentLayoutGuide { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UILayoutGuide ContentLayoutGuide" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("contentLayoutGuide")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UILayoutGuide</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the scroll view's content layout guide.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentOffset">
      <MemberSignature Language="C#" Value="public virtual CoreGraphics.CGPoint ContentOffset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype CoreGraphics.CGPoint ContentOffset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Foundation.Export("contentOffset")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setContentOffset:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>CoreGraphics.CGPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The offset for the origin of the content inside of a scroll view, relative to the origin of the scroll view itself.</summary>
        <value>
        </value>
        <remarks>
          <para>By setting the <c>ContentOffset</c> property, the application developer can specify the visible portion of the subview. For instance, compare the appearance of an 800x800 image in a <see cref="T:UIKit.UIScrollView" /> with the <c>ContentOffset</c> property set to <see cref="T:System.Drawing.PointF" />[0,0] (left image) with the appearance when <c>ContentOffset</c> is set to <see cref="T:System.Drawing.PointF" /> [240,170] (right image).</para>
          <para>
            <img href="UIKit.UIScrollView.content_offset.png" />
          </para>
          <example>
            <code lang="C#"><![CDATA[
var scrollView = new UIScrollView ();
scrollView.ContentSize = new SizeF (800, 800);

var imageView = new UIImageView (UIImage.FromFile ("target800.png"));

scrollView.AddSubview (imageView);
scrollView.ContentOffset = new PointF (240, 170);
                            
                        ]]></code>
          </example>
          <para>
                        "An un-official 80cm FITA archery target"  ©2006 Alberto Barbati, used under a Creative Commons Attribution-Share Alike 2.5 Generic license: http://creativecommons.org/licenses/by-sa/2.5/deed.en
                    </para>
          <para>Assignment to this value will move the subview instantaneously. If animation is desired, use  <see cref="M:UIKit.UIScrollView.SetContentOffset" />.
                    </para>
        </remarks>
        <altmember cref="M:UIKit.UIScrollView.SetContentOffset" />
      </Docs>
    </Member>
    <Member MemberName="ContentSize">
      <MemberSignature Language="C#" Value="public virtual CoreGraphics.CGSize ContentSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype CoreGraphics.CGSize ContentSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Foundation.Export("contentSize")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setContentSize:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>CoreGraphics.CGSize</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The size of the content view, as measured in points.</summary>
        <value>
        </value>
        <remarks>
          <para>
                        The <see cref="P:UIKit.UIScrollView.ContentSize" /> property specifies the total scrollable area, visible or not, of the <see cref="T:UIKit.UIScrollView" />. The 
                        application developer must set the <see cref="P:UIKit.UIScrollView.ContentSize" /> property to a value greater than the <see cref="T:UIKit.UIScrollView" />'s 
                        <see cref="P:UIKit.UIView.Frame" /> to get the expected scrolling behavior. The <see cref="P:UIKit.UIScrollView.ContentSize" /> is generally the union of the <see cref="P:UIKit.UIView.Frame" />s of the 
                        <see cref="T:UIKit.UIScrollView" />'s subviews, but this is not necessarily the case (sometimes, drawing geometry can be made easier 
                        or more consistent by having <see cref="P:UIKit.UIView.Frame" />s that are partially unreachable by scrolling).
                    </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Decelerating">
      <MemberSignature Language="C#" Value="public virtual bool Decelerating { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Decelerating" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Foundation.Export("isDecelerating")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>If this property returns <see langword="true" />, then scrolling is still occuring in the scroll view but the user is not dragging their finger.</summary>
        <value>
        </value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DecelerationEnded">
      <MemberSignature Language="C#" Value="public event EventHandler DecelerationEnded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DecelerationEnded" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Event raised by the object.</summary>
        <remarks>If developers do not assign a value to this event, this will reset the value for the WeakDelegate property to an internal handler that maps delegates to events.</remarks>
        <altmember cref="E:UIKit.UIScrollView.DraggingStarted" />
        <altmember cref="E:UIKit.UIScrollView.DraggingEnded" />
        <altmember cref="E:UIKit.UIScrollView.WillEndDragging" />
        <altmember cref="E:UIKit.UIScrollView.Scrolled" />
        <altmember cref="E:UIKit.UIScrollView.DecelerationStarted" />
      </Docs>
    </Member>
    <Member MemberName="DecelerationRate">
      <MemberSignature Language="C#" Value="public virtual nfloat DecelerationRate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.nfloat DecelerationRate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Foundation.Export("decelerationRate")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setDecelerationRate:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.nfloat</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>This property returns a value that represents the deceleration rate once the user lifts their finger. There are two values, <see cref="P:UIKit.UIScrollView.DecelerationRateFast" /> and <see cref="P:UIKit.UIScrollView.DecelerationRateNormal" />, that can serve as reference points for deceleration rates.</summary>
        <value>
        </value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DecelerationRateFast">
      <MemberSignature Language="C#" Value="public static nfloat DecelerationRateFast { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.nfloat DecelerationRateFast" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIScrollViewDecelerationRateFast", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.nfloat</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UIScrollViewDecelerationRateFast</summary>
        <value>
        </value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DecelerationRateNormal">
      <MemberSignature Language="C#" Value="public static nfloat DecelerationRateNormal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.nfloat DecelerationRateNormal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIScrollViewDecelerationRateNormal", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.nfloat</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UIScrollViewDecelerationRateNormal</summary>
        <value>
        </value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DecelerationStarted">
      <MemberSignature Language="C#" Value="public event EventHandler DecelerationStarted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DecelerationStarted" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Event raised by the object.</summary>
        <remarks>If developers do not assign a value to this event, this will reset the value for the WeakDelegate property to an internal handler that maps delegates to events.</remarks>
        <altmember cref="E:UIKit.UIScrollView.DraggingStarted" />
        <altmember cref="E:UIKit.UIScrollView.DraggingEnded" />
        <altmember cref="E:UIKit.UIScrollView.WillEndDragging" />
        <altmember cref="E:UIKit.UIScrollView.Scrolled" />
        <altmember cref="E:UIKit.UIScrollView.DecelerationEnded" />
      </Docs>
    </Member>
    <Member MemberName="DelaysContentTouches">
      <MemberSignature Language="C#" Value="public virtual bool DelaysContentTouches { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DelaysContentTouches" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Foundation.Export("delaysContentTouches")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setDelaysContentTouches:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies whether the <see cref="T:UIKit.UIScrollView" /> can delay input to attempt to determine if a scrolling gesture has been made</summary>
        <value>Default is <see langword="true" /></value>
        <remarks>
          <para>
                        When set to the default value <see langword="true" />, the <see cref="T:UIKit.UIScrollView" /> determines whether a scrolling gesture has been made by triggering a brief timer when the application user touches the screen. If the finger moves before the timer expires, the <see cref="T:UIKit.UIScrollView" /> interprets the gesture as a scrolling gesture and does not forward the event to the underlying content view. This can introduce a noticeable delay when used with components that are expected to be highly responsive (e.g., buttons).
                    </para>
          <para>
                        If set to <see langword="false" />, touches immediately trigger <see cref="M:UIKit.UIScrollView.TouchesShouldBegin" /> and are forwarded to the underlying <see cref="T:UIKit.UIView" /> if one is immediately below the touch location. In this situation, the <see cref="T:UIKit.UIScrollView" /> will not automatically detect and respond appropriately if the touch was the beginning of a scrolling, panning, or pinch-to-zoom gesture. 
                    </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Delegate">
      <MemberSignature Language="C#" Value="public UIKit.IUIScrollViewDelegate Delegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.IUIScrollViewDelegate Delegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>UIKit.IUIScrollViewDelegate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An instance of the UIKit.IUIScrollViewDelegate model class which acts as the class delegate.</summary>
        <value>
          <para>The instance of the UIKit.IUIScrollViewDelegate model class</para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>
          <para>The delegate instance assigned to this object will be used to handle events or provide data on demand to this class.</para>
          <para>When setting the Delegate or WeakDelegate values events will be delivered to the specified instance instead of being delivered to the C#-style events</para>
          <para>This is the strongly typed version of the object, developers should use the WeakDelegate property instead if they want to merely assign a class derived from NSObject that has been decorated with [Export] attributes.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DidChangeAdjustedContentInset">
      <MemberSignature Language="C#" Value="public event EventHandler DidChangeAdjustedContentInset;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DidChangeAdjustedContentInset" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Event raised by the object.</summary>
        <remarks>If developers do not assign a value to this event, this will reset the value for the WeakDelegate property to an internal handler that maps delegates to events.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DidZoom">
      <MemberSignature Language="C#" Value="public event EventHandler DidZoom;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DidZoom" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Event raised by the object.</summary>
        <remarks>If developers do not assign a value to this event, this will reset the value for the WeakDelegate property to an internal handler that maps delegates to events.</remarks>
        <altmember cref="E:UIKit.UIScrollView.ZoomingEnded" />
        <altmember cref="E:UIKit.UIScrollView.ZoomingStarted" />
      </Docs>
    </Member>
    <Member MemberName="DirectionalLockEnabled">
      <MemberSignature Language="C#" Value="public virtual bool DirectionalLockEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DirectionalLockEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Foundation.Export("isDirectionalLockEnabled")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setDirectionalLockEnabled:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>If <see langword="true" />, and the user begins scrolling in one axis (i.e. horizontally) then the scroll view disables scrolling in the other axis (i.e. vertically).</summary>
        <value>
        </value>
        <remarks>If this property is <see langword="false" />, then scrolling is permitted both horizontally and vertically.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DirectionalPressGestureRecognizer">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIGestureRecognizer DirectionalPressGestureRecognizer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIGestureRecognizer DirectionalPressGestureRecognizer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.None, "Configuring the 'PanGestureRecognizer' for indirect scrolling automatically supports directional presses now, so this property is no longer useful.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 9, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("directionalPressGestureRecognizer")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.None, "Configuring the 'PanGestureRecognizer' for indirect scrolling automatically supports directional presses now, so this property is no longer useful.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 9, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIGestureRecognizer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Developers should not use this deprecated property. Configuring the 'PanGestureRecognizer' for indirect scrolling automatically supports directional presses now, so this property is no longer useful.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <para>If set to <see langword="true" />, the method is invoked directly and will dispose manage and unmanaged resources;   If set to <see langword="false" /> the method is being called by the garbage collector finalizer and should only release unmanaged resources.</para>
        </param>
        <summary>Releases the resources used by the UIScrollView object.</summary>
        <remarks>
          <para>This Dispose method releases the resources used by the UIScrollView class.</para>
          <para>This method is called by both the Dispose() method and the object finalizer (Finalize).    When invoked by the Dispose method, the parameter disposing <paramref name="disposing" /> is set to <see langword="true" /> and any managed object references that this object holds are also disposed or released;  when invoked by the object finalizer, on the finalizer thread the value is set to <see langword="false" />. </para>
          <para>Calling the Dispose method when the application is finished using the UIScrollView ensures that all external resources used by this managed object are released as soon as possible.  Once developers have invoked the Dispose method, the object is no longer useful and developers should no longer make any calls to it.</para>
          <para>  For more information on how to override this method and on the Dispose/IDisposable pattern, read the ``Implementing a Dispose Method'' document at http://msdn.microsoft.com/en-us/library/fs2xkftw.aspx</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dragging">
      <MemberSignature Language="C#" Value="public virtual bool Dragging { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Dragging" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Foundation.Export("isDragging")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns <see langword="true" /> if the content has begun scrolling. Read-only.</summary>
        <value>
        </value>
        <remarks>This property can not be depended upon to be updated immediately after the scrolling has started.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DraggingEnded">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;UIKit.DraggingEventArgs&gt; DraggingEnded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class UIKit.DraggingEventArgs&gt; DraggingEnded" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;UIKit.DraggingEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Event raised by the object.</summary>
        <remarks>If developers do not assign a value to this event, this will reset the value for the WeakDelegate property to an internal handler that maps delegates to events.</remarks>
        <altmember cref="E:UIKit.UIScrollView.DraggingStarted" />
        <altmember cref="E:UIKit.UIScrollView.WillEndDragging" />
        <altmember cref="E:UIKit.UIScrollView.Scrolled" />
        <altmember cref="E:UIKit.UIScrollView.DecelerationStarted" />
        <altmember cref="E:UIKit.UIScrollView.DecelerationEnded" />
      </Docs>
    </Member>
    <Member MemberName="DraggingStarted">
      <MemberSignature Language="C#" Value="public event EventHandler DraggingStarted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DraggingStarted" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Event raised by the object.</summary>
        <remarks>If developers do not assign a value to this event, this will reset the value for the WeakDelegate property to an internal handler that maps delegates to events.</remarks>
        <altmember cref="E:UIKit.UIScrollView.DraggingEnded" />
        <altmember cref="E:UIKit.UIScrollView.WillEndDragging" />
        <altmember cref="E:UIKit.UIScrollView.Scrolled" />
        <altmember cref="E:UIKit.UIScrollView.DecelerationStarted" />
        <altmember cref="E:UIKit.UIScrollView.DecelerationEnded" />
      </Docs>
    </Member>
    <Member MemberName="FlashScrollIndicators">
      <MemberSignature Language="C#" Value="public virtual void FlashScrollIndicators ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void FlashScrollIndicators() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("flashScrollIndicators")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>This method will flash the scroll indicators for a short time.</summary>
        <remarks>
          <para>
                        By default, the scroll indicators are only displayed briefly while content is being scrolled. This method allows the application 
                        developer to programmatically display them for a brief amount of time. 
                    </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FrameLayoutGuide">
      <MemberSignature Language="C#" Value="public virtual UIKit.UILayoutGuide FrameLayoutGuide { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UILayoutGuide FrameLayoutGuide" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("frameLayoutGuide")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UILayoutGuide</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the scroll view's content layout guide.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAppearance">
      <MemberSignature Language="C#" Value="public static UIKit.UIScrollView.UIScrollViewAppearance GetAppearance (UIKit.UITraitCollection traits);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class UIKit.UIScrollView/UIScrollViewAppearance GetAppearance(class UIKit.UITraitCollection traits) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>UIKit.UIScrollView+UIScrollViewAppearance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="traits" Type="UIKit.UITraitCollection" />
      </Parameters>
      <Docs>
        <param name="traits">To be added.</param>
        <summary>Returns an appearance proxy for the specified <paramref name="traits" />.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAppearance">
      <MemberSignature Language="C#" Value="public static UIKit.UIScrollView.UIScrollViewAppearance GetAppearance (UIKit.UITraitCollection traits, Type[] containers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class UIKit.UIScrollView/UIScrollViewAppearance GetAppearance(class UIKit.UITraitCollection traits, class System.Type[] containers) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>UIKit.UIScrollView+UIScrollViewAppearance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="traits" Type="UIKit.UITraitCollection" />
        <Parameter Name="containers" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="traits">To be added.</param>
        <param name="containers">To be added.</param>
        <summary>Returns an appearance proxy for the specified <paramref name="traits" /> when found in the <paramref name="containers" /> containment hierarchy.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAppearance&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static UIKit.UIScrollView.UIScrollViewAppearance GetAppearance&lt;T&gt; () where T : UIKit.UIScrollView;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class UIKit.UIScrollView/UIScrollViewAppearance GetAppearance&lt;(class UIKit.UIScrollView) T&gt;() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>UIKit.UIScrollView+UIScrollViewAppearance</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">The type for which the UIAppearance proxy must be returned.  This is a subclass of UIScrollView.</typeparam>
        <summary>
          <para>Obtains the appearance proxy <see cref="T:UIKit.UIScrollView.UIScrollViewAppearance" /> for the subclass of UIScrollView.</para>
        </summary>
        <returns>
          <para>appearance proxy object for the specified type.</para>
        </returns>
        <remarks>
          <para>Setting any appearance properties on the returned object will affect the appearance of all classes and subclasses of the type parameter.</para>
          <para>Unlike the <see cref="P:UIKit.UIScrollView.Appearance" /> property, or the <see cref="M:UIKit.UIScrollViewAppearanceWhenContainedIn" /> method which only work on instances of this particular class, the proxies returned by GetAppearance can be used to change the style of subclasses.</para>
          <para>The following example shows how the GetAppearance method works</para>
          <example>
            <code lang="C#"><![CDATA[
var myTheme = UIScrollView.GetAppearance<MyUIScrollViewSubclass> ();
myTheme.TintColor = UIColor.Red;
]]></code>
          </example>
          <para>For more information, see the documentation for the <see cref="T:UIKit.UIAppearance" /> class.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAppearance&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static UIKit.UIScrollView.UIScrollViewAppearance GetAppearance&lt;T&gt; (UIKit.UITraitCollection traits) where T : UIKit.UIScrollView;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class UIKit.UIScrollView/UIScrollViewAppearance GetAppearance&lt;(class UIKit.UIScrollView) T&gt;(class UIKit.UITraitCollection traits) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>UIKit.UIScrollView+UIScrollViewAppearance</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <BaseTypeName>UIKit.UIScrollView</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="traits" Type="UIKit.UITraitCollection" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type for which the UIAppearance proxy must be returned.  This is a subclass of UIScrollView.</typeparam>
        <param name="traits">Trait collection to match.</param>
        <summary>
          <para>Obtains the appearance proxy <see cref="T:UIKit.UIScrollView.UIScrollViewAppearance" /> for the subclass of UIScrollView.</para>
        </summary>
        <returns>
          <para>appearance proxy object for the specified type.</para>
        </returns>
        <remarks>
          <para>The returned object represents the UIAppearance proxy where developers can set appearance properties for instances of UIScrollView.</para>
          <para>Unlike the <see cref="P:UIKit.UIScrollView.Appearance" /> property, or the <see cref="M:UIKit.UIScrollViewAppearanceWhenContainedIn" /> method which only work on instances of this particular class, the proxies returned by GetAppearance can be used to change the style of subclasses.</para>
          <para>The following example shows how the GetAppearance method works</para>
          <example>
            <code lang="C#"><![CDATA[
var myTheme = UIScrollView.GetAppearance<MyUIScrollViewSubclass> (myTraits, );
myTheme.TintColor = UIColor.Red;
]]></code>
          </example>
          <para>For more information, see the documentation for the <see cref="T:UIKit.UIAppearance" /> class.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAppearance&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static UIKit.UIScrollView.UIScrollViewAppearance GetAppearance&lt;T&gt; (UIKit.UITraitCollection traits, Type[] containers) where T : UIKit.UIScrollView;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class UIKit.UIScrollView/UIScrollViewAppearance GetAppearance&lt;(class UIKit.UIScrollView) T&gt;(class UIKit.UITraitCollection traits, class System.Type[] containers) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>UIKit.UIScrollView+UIScrollViewAppearance</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <BaseTypeName>UIKit.UIScrollView</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="traits" Type="UIKit.UITraitCollection" />
        <Parameter Name="containers" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">The type for which the UIAppearance proxy must be returned.  This is a subclass of UIScrollView.</typeparam>
        <param name="traits">Trait collection to match.</param>
        <param name="containers">List of types that the developer wishes to have as the containers to apply this particular appearance.</param>
        <summary>
          <para>Obtains the appearance proxy <see cref="T:UIKit.UIScrollView.UIScrollViewAppearance" /> for the subclass of UIScrollView that has the specified trait collection when the view is hosted in the specified hierarchy.</para>
        </summary>
        <returns>
          <para>appearance proxy object for the specified type.</para>
        </returns>
        <remarks>
          <para>The returned object represents the UIAppearance proxy where developers can set appearance properties for instances of UIScrollView that has the specified trait collection when the view is hosted in the specified hierarchy when those instances are contained in the hierarchy specified by the <paramref name="containers" /> parameter.</para>
          <para>Unlike the <see cref="P:UIKit.UIScrollView.Appearance" /> property, or the <see cref="M:UIKit.UIScrollViewAppearanceWhenContainedIn" /> method which only work on instances of this particular class, the proxies returned by GetAppearance can be used to change the style of subclasses.</para>
          <para>The following example shows how the GetAppearance method works</para>
          <example>
            <code lang="C#"><![CDATA[
var myTheme = UIScrollView.GetAppearance<MyUIScrollViewSubclass> (myTraits, typeof (UINavigationBar), typeof (UIPopoverController));
myTheme.TintColor = UIColor.Red;
]]></code>
          </example>
          <para>For more information, see the documentation for the <see cref="T:UIKit.UIAppearance" /> class.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexDisplayMode">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIScrollViewIndexDisplayMode IndexDisplayMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype UIKit.UIScrollViewIndexDisplayMode IndexDisplayMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 10, 3, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 10, 2, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("indexDisplayMode")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 10, 3, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 10, 2, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setIndexDisplayMode:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 10, 3, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 10, 2, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIScrollViewIndexDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that controls whether the index is automatically displayed or always hidden while the user scrolls.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndicatorStyle">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIScrollViewIndicatorStyle IndicatorStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype UIKit.UIScrollViewIndicatorStyle IndicatorStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Foundation.Export("indicatorStyle")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setIndicatorStyle:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIScrollViewIndicatorStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The style of the scroll indicators.</summary>
        <value>
          <para>
                        Default value is <see cref="F:UIKit.UIScrollViewIndicatorStyle.Default" /></para>
        </value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyboardDismissMode">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIScrollViewKeyboardDismissMode KeyboardDismissMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype UIKit.UIScrollViewKeyboardDismissMode KeyboardDismissMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("keyboardDismissMode")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setKeyboardDismissMode:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIScrollViewKeyboardDismissMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The manner in which the keyboard is dismissed at the start of dragging.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumZoomScale">
      <MemberSignature Language="C#" Value="public virtual nfloat MaximumZoomScale { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.nfloat MaximumZoomScale" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Foundation.Export("maximumZoomScale")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setMaximumZoomScale:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.nfloat</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The value of the maximum scale factor that can be applied to the content view.</summary>
        <value>The default value is 1.0f
                </value>
        <remarks>
          <para>This value should be greater than the value of <see cref="P:UIKit.UIScrollView.MinimumZoomScale" />.</para>
          <para>If this and <see cref="P:UIKit.UIScrollView.MinimumZoomScale" /> are left at their default values of 1.0, zooming will not appear to work, as the zoom will be constrained to that single value.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinimumZoomScale">
      <MemberSignature Language="C#" Value="public virtual nfloat MinimumZoomScale { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.nfloat MinimumZoomScale" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Foundation.Export("minimumZoomScale")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setMinimumZoomScale:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.nfloat</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The value of the minimum scale factor that can be applied to the content view.</summary>
        <value>The default value is 1.0f
                </value>
        <remarks>
          <para>This value should be smaller than the value of <see cref="P:UIKit.UIScrollView.MaximumZoomScale" />.</para>
          <para>If this and <see cref="P:UIKit.UIScrollView.MaximumZoomScale" /> are left at their default values of 1.0, zooming will not appear to work, as the zoom will be constrained to that single value.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PagingEnabled">
      <MemberSignature Language="C#" Value="public virtual bool PagingEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PagingEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("isPagingEnabled")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setPagingEnabled:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>If <see langword="true" /> then scrolling will stop on paging boundaries of the content view; scrolling occurs a page at a time.</summary>
        <value>
        </value>
        <remarks>
          <para>The default value is <see langword="false" />.</para>
          <para>
                        The following image, from the "Page Control" demo in the "iOS Standard Controls" sample, shows
                        the application in the middle of a swiping animation; portions of both the white and gray subviews are visible. If <see cref="P:UIKit.UIScrollView.PagingEnabled" />
                        were left to the default <see langword="false" /> value, if the application user's finger was lifted at this point, the scrolling would stop with both views
                        partially visible. If it were <see langword="true" />, the closest view would "snap" into alignment (in this case, the white view).
                    </para>
          <para>
            <img href="UIKit.UIScrollView.Slide1.png" />
          </para>
        </remarks>
        <related type="sample" href="http://samples.xamarin.com/iOS/Samples/ByGuid?guid=D307AF95-96A3-4FBC-832A-1FB187936FAB">iOS Standard Controls</related>
      </Docs>
    </Member>
    <Member MemberName="PanGestureRecognizer">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIPanGestureRecognizer PanGestureRecognizer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIPanGestureRecognizer PanGestureRecognizer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 5, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("panGestureRecognizer")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 5, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIPanGestureRecognizer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The gesture recognizer for pan gestures. Read-only.</summary>
        <value>
        </value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PinchGestureRecognizer">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIPinchGestureRecognizer PinchGestureRecognizer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIPinchGestureRecognizer PinchGestureRecognizer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 5, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("pinchGestureRecognizer")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 5, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIPinchGestureRecognizer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The gesture recognizer for pinch gestures. Read-only.</summary>
        <value>
        </value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RefreshControl">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIRefreshControl RefreshControl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIRefreshControl RefreshControl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 10, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("refreshControl")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 10, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setRefreshControl:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 10, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIRefreshControl</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>If not <see langword="null" />, the <see cref="T:UIKit.UIRefreshControl" /> used to update the view contents.</summary>
        <value>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollAnimationEnded">
      <MemberSignature Language="C#" Value="public event EventHandler ScrollAnimationEnded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ScrollAnimationEnded" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Event raised by the object.</summary>
        <remarks>If developers do not assign a value to this event, this will reset the value for the WeakDelegate property to an internal handler that maps delegates to events.</remarks>
        <altmember cref="E:UIKit.UIScrollView.DidZoom" />
        <altmember cref="E:UIKit.UIScrollView.Scrolled" />
      </Docs>
    </Member>
    <Member MemberName="Scrolled">
      <MemberSignature Language="C#" Value="public event EventHandler Scrolled;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Scrolled" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Event raised by the object.</summary>
        <remarks>If developers do not assign a value to this event, this will reset the value for the WeakDelegate property to an internal handler that maps delegates to events.</remarks>
        <altmember cref="E:UIKit.UIScrollView.DraggingStarted" />
        <altmember cref="E:UIKit.UIScrollView.DraggingEnded" />
        <altmember cref="E:UIKit.UIScrollView.WillEndDragging" />
        <altmember cref="E:UIKit.UIScrollView.DecelerationStarted" />
        <altmember cref="E:UIKit.UIScrollView.DecelerationEnded" />
      </Docs>
    </Member>
    <Member MemberName="ScrolledToTop">
      <MemberSignature Language="C#" Value="public event EventHandler ScrolledToTop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ScrolledToTop" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Event raised by the object.</summary>
        <remarks>If developers do not assign a value to this event, this will reset the value for the WeakDelegate property to an internal handler that maps delegates to events.</remarks>
        <altmember cref="E:UIKit.UIScrollView.Scrolled" />
        <altmember cref="P:UIKit.UIScrollView.ScrollsToTop" />
      </Docs>
    </Member>
    <Member MemberName="ScrollEnabled">
      <MemberSignature Language="C#" Value="public virtual bool ScrollEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ScrollEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Foundation.Export("isScrollEnabled")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setScrollEnabled:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>If set to <see langword="true" /> then scrolling is enabled.</summary>
        <value>
        </value>
        <remarks>If <see cref="false" />, then touch events will not be processed by the scroll view. They continue to be forwarded up the responder chain.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollIndicatorInsets">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIEdgeInsets ScrollIndicatorInsets { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype UIKit.UIEdgeInsets ScrollIndicatorInsets" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Foundation.Export("scrollIndicatorInsets")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setScrollIndicatorInsets:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIEdgeInsets</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>How far inset the scroll indicators are from the scroll view's edges.</summary>
        <value>Default value is <see cref="F:UIKit.UIEdgeInsets.Zero" /></value>
        <remarks>
          <para>
                        If the application developer sets the <see cref="P:UIKit.UIScrollView.ContentInset" /> to a value other than the default <see cref="F:UIKit.UIEdgeInsets.Zero" />, the developer will typically also want to set this property to the same <see cref="T:UIKit.UIEdgeInsets" /> value so that the scroll indicators will appear near the scrolling content and not overlap elements placed inside the inset area.
                    </para>
        </remarks>
        <altmember cref="P:UIKit.UIScrollView.ContentInset" />
      </Docs>
    </Member>
    <Member MemberName="ScrollRectToVisible">
      <MemberSignature Language="C#" Value="public virtual void ScrollRectToVisible (CoreGraphics.CGRect rect, bool animated);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ScrollRectToVisible(valuetype CoreGraphics.CGRect rect, bool animated) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("scrollRectToVisible:animated:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="CoreGraphics.CGRect" />
        <Parameter Name="animated" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="rect">To be added.</param>
        <param name="animated">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollsToTop">
      <MemberSignature Language="C#" Value="public virtual bool ScrollsToTop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ScrollsToTop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("scrollsToTop")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setScrollsToTop:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>If <see langword="true" />, then the scroll view will jump to the top of the content when the user taps on the status bar.</summary>
        <value>The default value is <see langword="false" /></value>
        <remarks>
                    If set to <see langword="true" /> and <see cref="P:UIKit.UIScrollView.ShouldScrollToTop" /> returns <see langword="true" />, the scroll-to-tap gesture of a tap on the status bar will jump to the top of the content view and fire the <see cref="E:UIKit.UIScrollView.ScrolledToTop" /> event. 
                </remarks>
        <altmember cref="P:UIKit.UIScrollView.ShouldScrollToTop" />
        <altmember cref="E:UIKit.UIScrollView.ScrolledToTop" />
      </Docs>
    </Member>
    <Member MemberName="SetContentOffset">
      <MemberSignature Language="C#" Value="public virtual void SetContentOffset (CoreGraphics.CGPoint contentOffset, bool animated);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetContentOffset(valuetype CoreGraphics.CGPoint contentOffset, bool animated) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("setContentOffset:animated:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="contentOffset" Type="CoreGraphics.CGPoint" />
        <Parameter Name="animated" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="contentOffset">To be added.</param>
        <param name="animated">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetZoomScale">
      <MemberSignature Language="C#" Value="public virtual void SetZoomScale (nfloat scale, bool animated);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetZoomScale(valuetype System.nfloat scale, bool animated) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("setZoomScale:animated:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scale" Type="System.nfloat" />
        <Parameter Name="animated" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="scale">To be added.</param>
        <param name="animated">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldScrollToTop">
      <MemberSignature Language="C#" Value="public UIKit.UIScrollViewCondition ShouldScrollToTop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIScrollViewCondition ShouldScrollToTop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>UIKit.UIScrollViewCondition</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Delegate invoked by the object to get a value.</summary>
        <value>To be added.</value>
        <remarks>Developers assign a function, delegate or anonymous method to this property to return a value to the object.   If developers assign a value to this property, it this will reset the value for the WeakDelegate property to an internal handler that maps delegates to events.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowsHorizontalScrollIndicator">
      <MemberSignature Language="C#" Value="public virtual bool ShowsHorizontalScrollIndicator { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowsHorizontalScrollIndicator" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Foundation.Export("showsHorizontalScrollIndicator")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setShowsHorizontalScrollIndicator:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>If <see langword="true" />, then the horizontal scroll bar will be visible when tracking.</summary>
        <value>The default value is <see langword="true" />.</value>
        <remarks>
          <para>
                        Setting this value to <see langword="false" /> hides the horizontal scroll bar, but does not constrain horizontal tracking.
                    </para>
        </remarks>
        <altmember cref="P:UIKit.UIScrollView.ShowsVerticalScrollIndicator" />
        <altmember cref="P:UIKit.UIScrollView.DirectionalLockEnabled" />
      </Docs>
    </Member>
    <Member MemberName="ShowsVerticalScrollIndicator">
      <MemberSignature Language="C#" Value="public virtual bool ShowsVerticalScrollIndicator { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowsVerticalScrollIndicator" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Foundation.Export("showsVerticalScrollIndicator")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setShowsVerticalScrollIndicator:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>If <see langword="true" />, then the vertical scroll bar will be visible when tracking.</summary>
        <value>The default value is <see langword="true" />.</value>
        <remarks>
          <para>
                        Setting this value to <see langword="false" /> hides the vertical scroll bar, but does not constrain vertical tracking.
                    </para>
        </remarks>
        <altmember cref="P:UIKit.UIScrollView.ShowsHorizontalScrollIndicator" />
        <altmember cref="P:UIKit.UIScrollView.DirectionalLockEnabled" />
      </Docs>
    </Member>
    <Member MemberName="TouchesShouldBegin">
      <MemberSignature Language="C#" Value="public virtual bool TouchesShouldBegin (Foundation.NSSet touches, UIKit.UIEvent withEvent, UIKit.UIView inContentView);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TouchesShouldBegin(class Foundation.NSSet touches, class UIKit.UIEvent withEvent, class UIKit.UIView inContentView) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("touchesShouldBegin:withEvent:inContentView:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="touches" Type="Foundation.NSSet" />
        <Parameter Name="withEvent" Type="UIKit.UIEvent" />
        <Parameter Name="inContentView" Type="UIKit.UIView" />
      </Parameters>
      <Docs>
        <param name="touches">A collection of <see cref="T:UIKit.UITouch" />es.</param>
        <param name="withEvent">The <see cref="T:UIKit.UIEvent" /> to which <paramref name="touches" /> belongs to.</param>
        <param name="inContentView">This is the subview where the touch-down event occured in.</param>
        <summary>This method is provided so that the behaviour of a touch in the content view may be customized by a subclass.</summary>
        <returns>
          <see langword="true" /> if the scroll view is to send the event messages to <paramref name="inContentView" />.</returns>
        <remarks>This method is meant to be override by subclasses of <see cref="T:UIKit.UIScrollView" />.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesShouldCancelInContentView">
      <MemberSignature Language="C#" Value="public virtual bool TouchesShouldCancelInContentView (UIKit.UIView view);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TouchesShouldCancelInContentView(class UIKit.UIView view) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("touchesShouldCancelInContentView:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="view" Type="UIKit.UIView" />
      </Parameters>
      <Docs>
        <param name="view">The view object that was touched.</param>
        <summary>This method controls if the touches of a content subview should be cancelled, which would allow dragging to start.</summary>
        <returns>
          <see langword="true" /> if future touch events to <paramref name="view" /> are to be cancelled.  <see langword="false" /> if <paramref name="view" /> is to receive the touch events.</returns>
        <remarks>
          <para>This method is called by the <see cref="T:UIKit.UIScrollView" /> after the application user touches the screen but before tracking begins. If not overridden, returns <see langword="true" /> if the <paramref name="view" /> is a subtype of <see cref="T:UIKit.UIControl" />, otherwise, it returns <see langword="false" />. This method is not called at all if <see cref="P:UIKit.UIScrollView.CanCancelContentTouches" /> returns <see langword="false" />.  
                    </para>
        </remarks>
        <altmember cref="T:UIKit.UIControl" />
        <altmember cref="P:UIKit.UIScrollView.CanCancelContentTouches" />
      </Docs>
    </Member>
    <Member MemberName="Tracking">
      <MemberSignature Language="C#" Value="public virtual bool Tracking { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Tracking" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Foundation.Export("isTracking")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns <see langword="true" /> if the user has touched the content and scrolling is about to begin.</summary>
        <value>
          <see langword="true" /> while tracking is active, otherwise <see langword="false" />.
                </value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewForZoomingInScrollView">
      <MemberSignature Language="C#" Value="public UIKit.UIScrollViewGetZoomView ViewForZoomingInScrollView { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIScrollViewGetZoomView ViewForZoomingInScrollView" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>UIKit.UIScrollViewGetZoomView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Delegate invoked by the object to get a value.</summary>
        <value>The default value is <see langword="null" /></value>
        <remarks>Developers assign a function, delegate or anonymous method to this property to return a value to the object.   If developers assign a value to this property, it this will reset the value for the WeakDelegate property to an internal handler that maps delegates to events.</remarks>
        <altmember cref="T:UIKit.UIScrollViewGetZoomView" />
        <related type="sample" href="http://samples.xamarin.com/iOS/Samples/ByGuid?guid=D307AF95-96A3-4FBC-832A-1FB187936FAB">iOS Standard Controls</related>
        <related type="sample" href="http://samples.xamarin.com/Samples/ByGuid?guid=556b1b8f-088e-494f-bc1a-bd418c174ba3">Zooming Pdf Viewer</related>
      </Docs>
    </Member>
    <Member MemberName="WeakDelegate">
      <MemberSignature Language="C#" Value="public virtual Foundation.NSObject WeakDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Foundation.NSObject WeakDelegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Foundation.Export("delegate")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setDelegate:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An object that can respond to the delegate protocol for this type</summary>
        <value>
          <para>The instance that will respond to events and data requests.</para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>
          <para>The delegate instance assigned to this object will be used to handle events or provide data on demand to this class.</para>
          <para>When setting the Delegate or WeakDelegate values events will be delivered to the specified instance instead of being delivered to the C#-style events</para>
          <para>   Methods must be decorated with the [Export ("selectorName")] attribute to respond to each method from the protocol.   Alternatively use the Delegate method which is strongly typed and does not require the [Export] attributes on methods.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WillEndDragging">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;UIKit.WillEndDraggingEventArgs&gt; WillEndDragging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class UIKit.WillEndDraggingEventArgs&gt; WillEndDragging" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;UIKit.WillEndDraggingEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Event raised by the object.</summary>
        <remarks>If developers do not assign a value to this event, this will reset the value for the WeakDelegate property to an internal handler that maps delegates to events.</remarks>
        <altmember cref="T:UIKit.WillEndDraggingEventArgs" />
        <altmember cref="P:UIKit.UIScrollView.ContentOffset" />
      </Docs>
    </Member>
    <Member MemberName="ZoomBouncing">
      <MemberSignature Language="C#" Value="public virtual bool ZoomBouncing { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ZoomBouncing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Foundation.Export("isZoomBouncing")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns <see langword="true" /> if the scroll view is bouncing back to the zoom scaling limits specified by<see cref="P:UIKit.UIScrollView.MinimumScrollView" /> and <see cref="P:UIKit.UIScrollView.MaximumScrollView" />. Read-only.</summary>
        <value>
        </value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Zooming">
      <MemberSignature Language="C#" Value="public virtual bool Zooming { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Zooming" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Foundation.Export("isZooming")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns <see langword="true" /> if the content view is zooming in or out. Read-only.</summary>
        <value>
        </value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ZoomingEnded">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;UIKit.ZoomingEndedEventArgs&gt; ZoomingEnded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class UIKit.ZoomingEndedEventArgs&gt; ZoomingEnded" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;UIKit.ZoomingEndedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Event raised by the object.</summary>
        <remarks>If developers do not assign a value to this event, this will reset the value for the WeakDelegate property to an internal handler that maps delegates to events.</remarks>
        <altmember cref="E:UIKit.UIScrollView.ZoomingStarted" />
        <altmember cref="M:CoreAnimation.CALayer.DrawInContext" />
        <altmember cref="E:UIKit.UIScrollView.DidZoom" />
      </Docs>
    </Member>
    <Member MemberName="ZoomingStarted">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;UIKit.UIScrollViewZoomingEventArgs&gt; ZoomingStarted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class UIKit.UIScrollViewZoomingEventArgs&gt; ZoomingStarted" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;UIKit.UIScrollViewZoomingEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Event raised by the object.</summary>
        <remarks>If developers do not assign a value to this event, this will reset the value for the WeakDelegate property to an internal handler that maps delegates to events.</remarks>
        <altmember cref="E:UIKit.UIScrollView.ZoomingEnded" />
        <altmember cref="E:UIKit.UIScrollView.DidZoom" />
      </Docs>
    </Member>
    <Member MemberName="ZoomScale">
      <MemberSignature Language="C#" Value="public virtual nfloat ZoomScale { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.nfloat ZoomScale" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Foundation.Export("zoomScale")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setZoomScale:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.nfloat</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The scale factor that is being applied to the content of a scroll view.</summary>
        <value>The default value is 1.0.
                </value>
        <remarks>
          <para>Zooming scales the content, but does not cause it to be redrawn in a sharper manner. To assure sharpness at higher zoom levels, the application developer should use the <see cref="M:CoreAnimation.CALayer.DrawInContext" /> method.</para>
        </remarks>
        <altmember cref="M:CoreAnimation.CALayer.DrawInContext" />
      </Docs>
    </Member>
    <Member MemberName="ZoomToRect">
      <MemberSignature Language="C#" Value="public virtual void ZoomToRect (CoreGraphics.CGRect rect, bool animated);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ZoomToRect(valuetype CoreGraphics.CGRect rect, bool animated) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("zoomToRect:animated:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="CoreGraphics.CGRect" />
        <Parameter Name="animated" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="rect">To be added.</param>
        <param name="animated">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
