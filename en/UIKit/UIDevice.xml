<Type Name="UIDevice" FullName="UIKit.UIDevice">
  <TypeSignature Language="C#" Value="public class UIDevice : Foundation.NSObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit UIDevice extends Foundation.NSObject" />
  <TypeSignature Language="DocId" Value="T:UIKit.UIDevice" />
  <TypeSignature Language="F#" Value="type UIDevice = class&#xA;    inherit NSObject" />
  <AssemblyInfo>
    <AssemblyName>Xamarin.iOS</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Foundation.NSObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
      <AttributeName>Foundation.Register("UIDevice", true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Device information, provided by the <see cref="P:UIKit.UIDevice.CurrentDevice" /> singleton.</summary>
    <remarks>
      <para>Application developers must use the <see cref="P:UIKit.UIDevice.CurrentDevice" /> singleton to get information on the current hardware platform. </para>
      <para tool="threads">The members of this class can be used from a background thread.</para>
    </remarks>
    <related type="PlatformDocAPI" href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIDevice_Class/index.html">Apple documentation for <c>UIDevice</c></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIDevice ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIDevice.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>Foundation.Export("init")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Default constructor that initializes a new instance of this class with no parameters.</summary>
        <remarks>
          <para>
          </para>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected UIDevice (Foundation.NSObjectFlag t);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class Foundation.NSObjectFlag t) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIDevice.#ctor(Foundation.NSObjectFlag)" />
      <MemberSignature Language="F#" Value="new UIKit.UIDevice : Foundation.NSObjectFlag -&gt; UIKit.UIDevice" Usage="new UIKit.UIDevice t" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="t" Type="Foundation.NSObjectFlag" />
      </Parameters>
      <Docs>
        <param name="t">Unused sentinel value, pass NSObjectFlag.Empty.</param>
        <summary>Constructor to call on derived classes to skip initialization and merely allocate the object.</summary>
        <remarks>
          <para>This constructor should be called by derived classes when they completely construct the object in managed code and merely want the runtime to allocate and initialize the NSObject.   This is required to implement the two-step initialization process that Objective-C uses, the first step is to perform the object allocation, the second step is to initialize the object.   When developers invoke the constructor that takes the NSObjectFlag.Empty they take advantage of a direct path that goes all the way up to NSObject to merely allocate the object's memory and bind the Objective-C and C# objects together.    The actual initialization of the object is up to the developer.</para>
          <para>This constructor is typically used by the binding generator to allocate the object, but prevent the actual initialization to take place.   Once the allocation has taken place, the constructor has to initialize the object.   With constructors generated by the binding generator this means that it manually invokes one of the "init" methods to initialize the object.</para>
          <para>It is the developer's responsibility to completely initialize the object if they chain up using the NSObjectFlag.Empty path.</para>
          <para>In general, if the developer's constructor invokes the NSObjectFlag.Empty base implementation, then it should be calling an Objective-C init method.   If this is not the case, developers should instead chain to the proper constructor in their class. </para>
          <para>The argument value is ignored and merely ensures that the only code that is executed is the construction phase is the basic NSObject allocation and runtime type registration.  Typically the chaining would look like this:</para>
          <example>
            <code lang="C#"><![CDATA[
//
// The NSObjectFlag merely allocates the object and registers the
// C# class with the Objective-C runtime if necessary, but no actual
// initXxx method is invoked, that is done later in the constructor
//
// This is taken from Xamarin.iOS's source code:
//
[Export ("initWithFrame:")]
public UIView (System.Drawing.RectangleF frame) : base (NSObjectFlag.Empty)
{
// Invoke the init method now.
	var initWithFrame = new Selector ("initWithFrame:").Handle;
	if (IsDirectBinding)
		Handle = ObjCRuntime.Messaging.IntPtr_objc_msgSend_CGRect (this.Handle, initWithFrame, frame);
	else
		Handle = ObjCRuntime.Messaging.IntPtr_objc_msgSendSuper_CGRect (this.SuperHandle, initWithFrame, frame);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected internal UIDevice (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig specialname rtspecialname instance void .ctor(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIDevice.#ctor(System.IntPtr)" />
      <MemberSignature Language="F#" Value="new UIKit.UIDevice : nativeint -&gt; UIKit.UIDevice" Usage="new UIKit.UIDevice handle" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Pointer (handle) to the unmanaged object.</param>
        <summary>A constructor used when creating managed representations of unmanaged objects;  Called by the runtime.</summary>
        <remarks>
          <para>This constructor is invoked by the runtime infrastructure (<see cref="M:ObjCRuntime.Runtime.GetNSObject(System.IntPtr)" />) to create a new managed representation for a pointer to an unmanaged Objective-C object.    Developers should not invoke this method directly, instead they should call the GetNSObject method as it will prevent two instances of a managed object to point to the same native object.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BatteryLevel">
      <MemberSignature Language="C#" Value="public virtual float BatteryLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float32 BatteryLevel" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIDevice.BatteryLevel" />
      <MemberSignature Language="F#" Value="member this.BatteryLevel : single" Usage="UIKit.UIDevice.BatteryLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>get: Foundation.Export("batteryLevel")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Battery level indicator.</summary>
        <value>Battery percentage in the range [0..1] if battery monitoring is enabled, otherwise -1.</value>
        <remarks>
          <para>By default, <see cref="P:UIKit.UIDevice.BatteryMonitoringEnabled" /> is <see langword="false" />. In that situation, <see cref="P:UIKit.UIDevice.BatteryLevel" /> will be -1 (and <see cref="P:UIKit.UIDevice.BatteryState" /> will be <see cref="F:UIKit.UIDeviceBatteryState.Unknown" />).</para>
          <para>A value of 1.0 indicates a fully-charged device, while 0.0 indicates an empty battery.</para>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BatteryLevelDidChangeNotification">
      <MemberSignature Language="C#" Value="public static Foundation.NSString BatteryLevelDidChangeNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString BatteryLevelDidChangeNotification" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIDevice.BatteryLevelDidChangeNotification" />
      <MemberSignature Language="F#" Value="member this.BatteryLevelDidChangeNotification : Foundation.NSString" Usage="UIKit.UIDevice.BatteryLevelDidChangeNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>Foundation.Advice("Use UIDevice.Notifications.ObserveBatteryLevelDidChange helper method instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>Foundation.Field("UIDeviceBatteryLevelDidChangeNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for BatteryLevelDidChange</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIKit.UIDevice+Notifications" />.<see cref="M:UIKit.UIDevice+Notifications.ObserveBatteryLevelDidChangeNotification" /> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="C#"><![CDATA[
//
// Lambda style
//

// listening
notification = UIDevice.Notifications.ObserveBatteryLevelDidChange ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, Foundation.NSNotificationEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UIDevice.Notifications.ObserveBatteryLevelDidChange (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIDevice.BatteryLevelDidChangeNotification, (notification) => {Console.WriteLine ("Received the notification UIDevice", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIDevice", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIDevice.BatteryLevelDidChangeNotification, Callback);
}
]]></code>
          </example>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BatteryMonitoringEnabled">
      <MemberSignature Language="C#" Value="public virtual bool BatteryMonitoringEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BatteryMonitoringEnabled" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIDevice.BatteryMonitoringEnabled" />
      <MemberSignature Language="F#" Value="member this.BatteryMonitoringEnabled : bool with get, set" Usage="UIKit.UIDevice.BatteryMonitoringEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>get: Foundation.Export("isBatteryMonitoringEnabled")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>set: Foundation.Export("setBatteryMonitoringEnabled:")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>set: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Controls battery monitoring.   When set, you can receive battery level change events.</summary>
        <value>The default value is <see langword="false" />.</value>
        <remarks>
          <para>When set to the default value of <see langword="false" />, applications cannot read the <see cref="P:UIKit.UIDevice.BatteryLevel" />, <see cref="P:UIKit.UIDevice.BatteryState" />, or receive battery-state change notifications (<see cref="P:UIKit.UIDevice.BatteryStateDidChangeNotification" />). </para>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BatteryState">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIDeviceBatteryState BatteryState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype UIKit.UIDeviceBatteryState BatteryState" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIDevice.BatteryState" />
      <MemberSignature Language="F#" Value="member this.BatteryState : UIKit.UIDeviceBatteryState" Usage="UIKit.UIDevice.BatteryState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>get: Foundation.Export("batteryState")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIDeviceBatteryState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Current battery state if monitoring is enabled.</summary>
        <value>Battery state if battery monitoring is enabled, otherwise <see cref="F:UIKit.UIDeviceBatteryState.Unknown" />.</value>
        <remarks>
          <para>By default, <see cref="P:UIKit.UIDevice.BatteryMonitoringEnabled" /> is <see langword="false" />. In that situation, <see cref="P:UIKit.UIDevice.BatteryState" /> will be <see cref="F:UIKit.UIDeviceBatteryState.Unknown" /> (and <see cref="P:UIKit.UIDevice.BatteryLevel" /> will be -1).</para>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BatteryStateDidChangeNotification">
      <MemberSignature Language="C#" Value="public static Foundation.NSString BatteryStateDidChangeNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString BatteryStateDidChangeNotification" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIDevice.BatteryStateDidChangeNotification" />
      <MemberSignature Language="F#" Value="member this.BatteryStateDidChangeNotification : Foundation.NSString" Usage="UIKit.UIDevice.BatteryStateDidChangeNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>Foundation.Advice("Use UIDevice.Notifications.ObserveBatteryStateDidChange helper method instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>Foundation.Field("UIDeviceBatteryStateDidChangeNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for BatteryStateDidChange</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIKit.UIDevice+Notifications" />.<see cref="M:UIKit.UIDevice+Notifications.ObserveBatteryStateDidChangeNotification" /> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="C#"><![CDATA[
//
// Lambda style
//

// listening
notification = UIDevice.Notifications.ObserveBatteryStateDidChange ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, Foundation.NSNotificationEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UIDevice.Notifications.ObserveBatteryStateDidChange (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIDevice.BatteryStateDidChangeNotification, (notification) => {Console.WriteLine ("Received the notification UIDevice", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIDevice", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIDevice.BatteryStateDidChangeNotification, Callback);
}
]]></code>
          </example>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginGeneratingDeviceOrientationNotifications">
      <MemberSignature Language="C#" Value="public virtual void BeginGeneratingDeviceOrientationNotifications ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginGeneratingDeviceOrientationNotifications() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIDevice.BeginGeneratingDeviceOrientationNotifications" />
      <MemberSignature Language="F#" Value="abstract member BeginGeneratingDeviceOrientationNotifications : unit -&gt; unit&#xA;override this.BeginGeneratingDeviceOrientationNotifications : unit -&gt; unit" Usage="uIDevice.BeginGeneratingDeviceOrientationNotifications " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>Foundation.Export("beginGeneratingDeviceOrientationNotifications")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Initiates posting device orientation notification events.</summary>
        <remarks>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckSystemVersion">
      <MemberSignature Language="C#" Value="public bool CheckSystemVersion (int major, int minor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CheckSystemVersion(int32 major, int32 minor) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIDevice.CheckSystemVersion(System.Int32,System.Int32)" />
      <MemberSignature Language="F#" Value="member this.CheckSystemVersion : int * int -&gt; bool" Usage="uIDevice.CheckSystemVersion (major, minor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="major" Type="System.Int32" />
        <Parameter Name="minor" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="major">To be added.</param>
        <param name="minor">To be added.</param>
        <summary>Whether the system version is greater than or equal to the specified major and minor values.</summary>
        <returns>
          <see langword="true" /> if the current system version is equal or greater than that specified in the arguments.</returns>
        <remarks>
          <para>This method returns <see langword="true" /> if the current version on the device is equal or greater than the version specified by <paramref name="major" /> and <paramref name="minor" />.</para>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClassHandle">
      <MemberSignature Language="C#" Value="public override IntPtr ClassHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ClassHandle" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIDevice.ClassHandle" />
      <MemberSignature Language="F#" Value="member this.ClassHandle : nativeint" Usage="UIKit.UIDevice.ClassHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The handle for this class.</summary>
        <value>The pointer to the Objective-C class.</value>
        <remarks>Each Xamarin.iOS class mirrors an unmanaged Objective-C class.   This value contains the pointer to the Objective-C class, it is similar to calling objc_getClass with the object name.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentDevice">
      <MemberSignature Language="C#" Value="public static UIKit.UIDevice CurrentDevice { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class UIKit.UIDevice CurrentDevice" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIDevice.CurrentDevice" />
      <MemberSignature Language="F#" Value="member this.CurrentDevice : UIKit.UIDevice" Usage="UIKit.UIDevice.CurrentDevice" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>get: Foundation.Export("currentDevice")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIDevice</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns the UIDevice singleton instance.</summary>
        <value />
        <remarks>
          <para>Developers typically use property like this:</para>
          <example>
            <code lang="C#"><![CDATA[
 var device = UIDevice.CurrentDevice;
 Console.WriteLine (device.BatteryLevel);
  ]]></code>
          </example>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndGeneratingDeviceOrientationNotifications">
      <MemberSignature Language="C#" Value="public virtual void EndGeneratingDeviceOrientationNotifications ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndGeneratingDeviceOrientationNotifications() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIDevice.EndGeneratingDeviceOrientationNotifications" />
      <MemberSignature Language="F#" Value="abstract member EndGeneratingDeviceOrientationNotifications : unit -&gt; unit&#xA;override this.EndGeneratingDeviceOrientationNotifications : unit -&gt; unit" Usage="uIDevice.EndGeneratingDeviceOrientationNotifications " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>Foundation.Export("endGeneratingDeviceOrientationNotifications")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stops posting device orientation notification events. </summary>
        <remarks>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GeneratesDeviceOrientationNotifications">
      <MemberSignature Language="C#" Value="public virtual bool GeneratesDeviceOrientationNotifications { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool GeneratesDeviceOrientationNotifications" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIDevice.GeneratesDeviceOrientationNotifications" />
      <MemberSignature Language="F#" Value="member this.GeneratesDeviceOrientationNotifications : bool" Usage="UIKit.UIDevice.GeneratesDeviceOrientationNotifications" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>get: Foundation.Export("isGeneratingDeviceOrientationNotifications")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determines whether device orientation notifications are posted.</summary>
        <value>The default value is based on the device hardware.</value>
        <remarks>
          <para>Note that if the hardware supports orientation notifications, this value will be <see langword="true" /> even if the user has locked the display orientation of the device. 
          </para>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IdentifierForVendor">
      <MemberSignature Language="C#" Value="public virtual Foundation.NSUuid IdentifierForVendor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Foundation.NSUuid IdentifierForVendor" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIDevice.IdentifierForVendor" />
      <MemberSignature Language="F#" Value="member this.IdentifierForVendor : Foundation.NSUuid" Usage="UIKit.UIDevice.IdentifierForVendor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="">
          <AttributeName>get: Foundation.Export("identifierForVendor")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>get: Foundation.Export("identifierForVendor", ObjCRuntime.ArgumentSemantic.Strong)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSUuid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An identifier, unique to the device, based on the App Store vendor or, if not from the App Store, the bundle identifier.</summary>
        <value>To be added.</value>
        <remarks>
          <para>This identifier is the same for a particular device for all apps that come from the same vendor. This identifier is not the same across devices.</para>
          <para>If the app does not come from the App Store, the "vendor" of the device is calculated based on the bundle ID. In iOS 7 and later, the "vendor" is based on all elements of the bundle ID except the last component. In other words, if the bundle ID is <c>com.mycompany.mydivision.app1</c>, the "vendor" will be calculated as <c>com.mycompany.mydivision</c>. On iOS 6 and previous, the "vendor" is calculated from the first two components, so a bundle ID of <c>com.mycompany.mydivision.app1</c> would base the vendor on <c>com.mycompany</c>.</para>
          <para>The <see cref="M:UIKit.Foundation.NSUuid.AsString()" /> method is often used to extract the actual identification, as shown in the following example:</para>
          <example>
            <code lang="C#"><![CDATA[
var nsUid = UIDevice.CurrentDevice.IdentifierForVendor;
var guidElements = nsUid.AsString();
Console.WriteLine("ToString() : {0}\nAsString() : {1}", nsUid, guidElements);
/*
ToString() : <__NSConcreteUUID 0x79ef50> 959E8282-D65E-486C-B1D3-17D720CF668E
AsString() : 959E8282-D65E-486C-B1D3-17D720CF668E
*/              
              ]]></code>
          </example>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMultitaskingSupported">
      <MemberSignature Language="C#" Value="public virtual bool IsMultitaskingSupported { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMultitaskingSupported" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIDevice.IsMultitaskingSupported" />
      <MemberSignature Language="F#" Value="member this.IsMultitaskingSupported : bool" Usage="UIKit.UIDevice.IsMultitaskingSupported" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>get: Foundation.Export("isMultitaskingSupported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determines whether this version of iOS supports multitasking.</summary>
        <value>Determined by the hardware.</value>
        <remarks>
          <para>Unlike the Objective-C version of this method, there is no need to probe whether the operating system supports this selector.   The MonoTouch binding takes care of this automatically.   On older versions of iOS this returns false, in newer versions of iOS, this probes the operating to determine if multi-tasking capabilities are supported.</para>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalizedModel">
      <MemberSignature Language="C#" Value="public virtual string LocalizedModel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LocalizedModel" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIDevice.LocalizedModel" />
      <MemberSignature Language="F#" Value="member this.LocalizedModel : string" Usage="UIKit.UIDevice.LocalizedModel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="">
          <AttributeName>get: Foundation.Export("localizedModel")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>get: Foundation.Export("localizedModel", ObjCRuntime.ArgumentSemantic.Strong)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A localized string describing the current iOS device.</summary>
        <value />
        <remarks>
          <para>Use this property to display the name of the device in the current user selected locale.</para>
          <para>Note that this property is quite generic (e.g., "iPhone", "iPad")</para>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
        <altmember cref="P:UIDevice.Model" />
        <altmember cref="P:UIDevice.SystemName" />
        <altmember cref="P:UIDevice.SystemVersion" />
      </Docs>
    </Member>
    <Member MemberName="Model">
      <MemberSignature Language="C#" Value="public virtual string Model { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Model" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIDevice.Model" />
      <MemberSignature Language="F#" Value="member this.Model : string" Usage="UIKit.UIDevice.Model" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="">
          <AttributeName>get: Foundation.Export("model")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>get: Foundation.Export("model", ObjCRuntime.ArgumentSemantic.Strong)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The device model, in English.</summary>
        <value>To be added.</value>
        <remarks>
          <para>Note that this property is quite generic (e.g., "iPhone", "iPad")</para>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
        <altmember cref="P:UIKit.UIDevice.LocalizedModel" />
        <altmember cref="P:UIKit.UIDevice.SystemName" />
        <altmember cref="P:UIKit.UIDevice.SystemVersion" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public virtual string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIDevice.Name" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="UIKit.UIDevice.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="">
          <AttributeName>get: Foundation.Export("name")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>get: Foundation.Export("name", ObjCRuntime.ArgumentSemantic.Strong)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The device name set by the user.</summary>
        <value>Set by the user in Settings/General/Name</value>
        <remarks>
          <para>This is the device name set by the user in Settings/General/Name. Since it can be changed by the users, application developers should prefer the use of <see cref="P:UIKit.UIDevice.IdentifierForVendor" /> as a long-lasting device identifier.</para>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
        <altmember cref="P:UIKit.UIDevice.IdentifierForVendor" />
        <altmember cref="P:UIKit.UIDevice.SystemName" />
        <altmember cref="P:UIKit.UIDevice.Model" />
      </Docs>
    </Member>
    <Member MemberName="Orientation">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIDeviceOrientation Orientation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype UIKit.UIDeviceOrientation Orientation" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIDevice.Orientation" />
      <MemberSignature Language="F#" Value="member this.Orientation : UIKit.UIDeviceOrientation" Usage="UIKit.UIDevice.Orientation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>get: Foundation.Export("orientation")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIDeviceOrientation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Current device orientation.</summary>
        <value />
        <remarks>
          <para>
          </para>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OrientationDidChangeNotification">
      <MemberSignature Language="C#" Value="public static Foundation.NSString OrientationDidChangeNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString OrientationDidChangeNotification" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIDevice.OrientationDidChangeNotification" />
      <MemberSignature Language="F#" Value="member this.OrientationDidChangeNotification : Foundation.NSString" Usage="UIKit.UIDevice.OrientationDidChangeNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>Foundation.Advice("Use UIDevice.Notifications.ObserveOrientationDidChange helper method instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>Foundation.Field("UIDeviceOrientationDidChangeNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for OrientationDidChange</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIKit.UIDevice+Notifications" />.<see cref="M:UIKit.UIDevice+Notifications.ObserveOrientationDidChangeNotification" /> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="C#"><![CDATA[
//
// Lambda style
//

// listening
notification = UIDevice.Notifications.ObserveOrientationDidChange ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, Foundation.NSNotificationEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UIDevice.Notifications.ObserveOrientationDidChange (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIDevice.OrientationDidChangeNotification, (notification) => {Console.WriteLine ("Received the notification UIDevice", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIDevice", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIDevice.OrientationDidChangeNotification, Callback);
}
]]></code>
          </example>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PlayInputClick">
      <MemberSignature Language="C#" Value="public virtual void PlayInputClick ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PlayInputClick() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIDevice.PlayInputClick" />
      <MemberSignature Language="F#" Value="abstract member PlayInputClick : unit -&gt; unit&#xA;override this.PlayInputClick : unit -&gt; unit" Usage="uIDevice.PlayInputClick " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>Foundation.Export("playInputClick")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Plays the system "click" event in response to user taps.</summary>
        <remarks>
          <para>This method plays the standard system "keyboard click" sound when a user taps an input view or keyboard accessory view, with certain restrictions:</para>
          <list type="bullet">
            <item>
              <term>The user has enabled "Keyboard Clicks" in Settings / Sounds</term>
            </item>
            <item>
              <term>The <see cref="T:UIKit.UIView" /> being tapped implements <see cref="T:UIKit.IUIInputViewAudioFeedback" /> and overrides <see cref="P:UIKit.IUIInputViewAudioFeedback.EnableInputClicksWhenVisible" /> to return <see langword="true" />.</term>
            </item>
          </list>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProximityMonitoringEnabled">
      <MemberSignature Language="C#" Value="public virtual bool ProximityMonitoringEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ProximityMonitoringEnabled" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIDevice.ProximityMonitoringEnabled" />
      <MemberSignature Language="F#" Value="member this.ProximityMonitoringEnabled : bool with get, set" Usage="UIKit.UIDevice.ProximityMonitoringEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>get: Foundation.Export("isProximityMonitoringEnabled")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>set: Foundation.Export("setProximityMonitoringEnabled:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether the proximity sensor is available and enabled.</summary>
        <value>The default value is <see langword="false" />.</value>
        <remarks>
          <para>Application developers who wish to monitor proximity should set this property to <see langword="true" /> and then confirm that it has changed. On devices that do not support proximity warning, the setter will execute without raising an exception, but the value will remain <see langword="false" />. </para>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProximityState">
      <MemberSignature Language="C#" Value="public virtual bool ProximityState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ProximityState" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIDevice.ProximityState" />
      <MemberSignature Language="F#" Value="member this.ProximityState : bool" Usage="UIKit.UIDevice.ProximityState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>get: Foundation.Export("proximityState")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determines whether the device is close to the user.</summary>
        <value>
          <see langword="true" /> if the device is close to the user.</value>
        <remarks>
          <para>The proximity sensor is a device that detects when the device is being held close to the head. (It works by detecting infrared light being reflected back into the device.)</para>
          <para>This property represents the current state of the proximity sensor, returning <see langword="true" /> when the device is close to the user (for instance, when held to the ear during a phone call).</para>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProximityStateDidChangeNotification">
      <MemberSignature Language="C#" Value="public static Foundation.NSString ProximityStateDidChangeNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString ProximityStateDidChangeNotification" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIDevice.ProximityStateDidChangeNotification" />
      <MemberSignature Language="F#" Value="member this.ProximityStateDidChangeNotification : Foundation.NSString" Usage="UIKit.UIDevice.ProximityStateDidChangeNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>Foundation.Advice("Use UIDevice.Notifications.ObserveProximityStateDidChange helper method instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>Foundation.Field("UIDeviceProximityStateDidChangeNotification", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for ProximityStateDidChange</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIKit.UIDevice+Notifications" />.<see cref="M:UIKit.UIDevice+Notifications.ObserveProximityStateDidChangeNotification" /> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="C#"><![CDATA[
//
// Lambda style
//

// listening
notification = UIDevice.Notifications.ObserveProximityStateDidChange ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, Foundation.NSNotificationEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UIDevice.Notifications.ObserveProximityStateDidChange (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIDevice.ProximityStateDidChangeNotification, (notification) => {Console.WriteLine ("Received the notification UIDevice", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIDevice", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIDevice.ProximityStateDidChangeNotification, Callback);
}
]]></code>
          </example>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SystemName">
      <MemberSignature Language="C#" Value="public virtual string SystemName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SystemName" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIDevice.SystemName" />
      <MemberSignature Language="F#" Value="member this.SystemName : string" Usage="UIKit.UIDevice.SystemName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="">
          <AttributeName>get: Foundation.Export("systemName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>get: Foundation.Export("systemName", ObjCRuntime.ArgumentSemantic.Strong)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Operating system name on the device.</summary>
        <value>A value such as "iPhone OS".</value>
        <remarks>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SystemVersion">
      <MemberSignature Language="C#" Value="public virtual string SystemVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SystemVersion" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIDevice.SystemVersion" />
      <MemberSignature Language="F#" Value="member this.SystemVersion : string" Usage="UIKit.UIDevice.SystemVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="">
          <AttributeName>get: Foundation.Export("systemVersion")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>get: Foundation.Export("systemVersion", ObjCRuntime.ArgumentSemantic.Strong)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Operating system version.</summary>
        <value>The current operating system version.</value>
        <remarks>
          <para>Application developers must not assume that this string can be directly parsed into a floating point number, since iOS versioning often involves multiple delimiters, such as with "7.0.4". </para>
          <para>Application developers can use <see cref="M:UIKit.UIDevice.CheckSystemVersion" /> to ensure that the current operating system is equal to or exceeds a particular major/minor release.</para>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserInterfaceIdiom">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIUserInterfaceIdiom UserInterfaceIdiom { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype UIKit.UIUserInterfaceIdiom UserInterfaceIdiom" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIDevice.UserInterfaceIdiom" />
      <MemberSignature Language="F#" Value="member this.UserInterfaceIdiom : UIKit.UIUserInterfaceIdiom" Usage="UIKit.UIDevice.UserInterfaceIdiom" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
          <AttributeName>get: Foundation.Export("userInterfaceIdiom")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIUserInterfaceIdiom</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Which kind of device the application is running (iPhone or iPad).</summary>
        <value>
        </value>
        <remarks>
          <para>Unlike the Objective-C version of this method, there is no need to probe whether the operating system supports this selector.   The MonoTouch binding takes care of this automatically.   When running on older versions of iOS this returns UIUserInterfaceIdiom.Phon, in newer versions of iOS, this probes the operating system to return the proper idiom.</para>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
