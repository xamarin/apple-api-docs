<Type Name="UIApplicationDelegate" FullName="UIKit.UIApplicationDelegate">
  <TypeSignature Language="C#" Value="public class UIApplicationDelegate : Foundation.NSObject, IDisposable, UIKit.IUIApplicationDelegate" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit UIApplicationDelegate extends Foundation.NSObject implements class ObjCRuntime.INativeObject, class System.IDisposable, class UIKit.IUIApplicationDelegate" />
  <TypeSignature Language="DocId" Value="T:UIKit.UIApplicationDelegate" />
  <TypeSignature Language="F#" Value="type UIApplicationDelegate = class&#xA;    inherit NSObject&#xA;    interface IUIApplicationDelegate&#xA;    interface INativeObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>Xamarin.iOS</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Foundation.NSObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>ObjCRuntime.INativeObject</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>UIKit.IUIApplicationDelegate</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>Foundation.Model</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Foundation.Protocol</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Foundation.Register("UIApplicationDelegate", false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>A class used to receive events raised by a <see cref="T:UIKit.UIApplication" />.</summary>
    <remarks>
      <para>A strongly typed implementation of a class that can be used to respond to events raised by the <see cref="T:UIKit.UIApplication" />.</para>
      <para>
       Application developers will generally override the <see cref="M:UIKit.UIApplicationDelegate_Extensions.FinishedLaunching(UIKit.IUIApplicationDelegate,UIKit.UIApplication,Foundation.NSDictionary)" /> method, configure the application's main <see cref="T:UIKit.UIWindow" />, instantiate the top-level
       <see cref="T:UIKit.UIViewController" />, and assign
       it to the <see cref="P:UIKit.UIWindow.RootViewController" />.

      </para>
      <para>
	This is what a minimal UIApplicationDelegate class looks like:
      </para>
      <example>
        <code lang="C#"><![CDATA[
[Register ("AppDelegate")]
public partial class AppDelegate : UIApplicationDelegate
{
	UIWindow window;

	public override bool FinishedLaunching (UIApplication app, NSDictionary options)
	{
		window = new UIWindow (UIScreen.MainScreen.Bounds);
		window.RootViewController = new UIViewController ();
		window.MakeKeyAndVisible ();
		
		return true;
	}
}
]]></code>
      </example>
      <block subset="none" type="behaviors">UIApplicationDelegate and the Application Lifecycle</block>
      <para>The <see cref="T:UIKit.UIApplicationDelegate" /> provides overridable methods for the entire application lifecycle:</para>
      <para>
        <img href="~/UIKit/_images/UIApplicationDelegate.LifeCycle.png" />
      </para>
      <para>Applications have four major modes:</para>
      <list type="bullet">
        <item>
          <term>Launching, involving the methods <see cref="M:UIKit.UIApplicationDelegate.WillFinishLaunching(UIKit.UIApplication,Foundation.NSDictionary)" />, <see cref="M:UIKit.UIApplicationDelegate_Extensions.FinishedLaunching(UIKit.IUIApplicationDelegate,UIKit.UIApplication,Foundation.NSDictionary)" />, and perhaps <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=UIKit%20UIApplication%20Open%20URL&amp;scope=Xamarin" title="M:UIKit.UIApplication.OpenURL*">M:UIKit.UIApplication.OpenURL*</a></format> (if the application was launched or foregrounded with <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=UIKit%20UIApplication%20Open%20URL&amp;scope=Xamarin" title="M:UIKit.UIApplication.OpenURL*">M:UIKit.UIApplication.OpenURL*</a></format>).</term>
        </item>
        <item>
          <term>Foreground processing, book-ended by the methods <see cref="M:UIKit.UIApplicationDelegate.OnActivated(UIKit.UIApplication)" /> and <see cref="M:UIKit.UIApplicationDelegate.OnResignActivation(UIKit.UIApplication)" />.</term>
        </item>
        <item>
          <term>Background processing or suspension, which begins with a call to <see cref="M:UIKit.UIApplicationDelegate.DidEnterBackground(UIKit.UIApplication)" /> and ends when the application returns to the foreground after executing <see cref="M:UIKit.UIApplicationDelegate.WillEnterForeground(UIKit.UIApplication)" /> or when the application is about to terminate.</term>
        </item>
        <item>
          <term>Terminating, which is preceded by a call to <see cref="M:UIKit.UIApplicationDelegate.WillTerminate(UIKit.UIApplication)" />.</term>
        </item>
      </list>
      <para>As mentioned previously, the most commonly overridden method is <see cref="M:UIKit.UIApplicationDelegate_Extensions.FinishedLaunching(UIKit.IUIApplicationDelegate,UIKit.UIApplication,Foundation.NSDictionary)" />, which is the standard place to initialize the application's <see cref="T:UIKit.UIWindow" /> and that window's <see cref="P:UIKit.UIWindow.RootViewController" />.</para>
      <para>iOS applications should be designed to be long-lived, with many transitions between foreground processing and being suspended or backgrounded. </para>
      <block subset="none" type="Note">Assigning a UIApplicationDelegate</block>
      <para>The <see cref="T:UIKit.UIApplicationDelegate" /> of an application is typically set as one of few, or only, things done by the application's <c>Main</c> method. The <see cref="T:UIKit.UIApplicationDelegate" /> exports a string using the <see cref="T:Foundation.RegisterAttribute" /> and this string is used as the <c>delegateClassName</c> argument to the <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=M:UIKit.UIApplication.Main(string[],string,string)&amp;scope=Xamarin" title="M:UIKit.UIApplication.Main(string[],string,string)">M:UIKit.UIApplication.Main(string[],string,string)</a></format> method, as shown in the following example:</para>
      <example>
        <code lang="C#"><![CDATA[
public class Application 
{
		static void Main(string[] args)
		{
			UIApplication.Main(args, null, "AppDelegate");
		}
	}

[Register ("AppDelegate")]
public partial class AppDelegate : UIApplicationDelegate
{
//...etc
}
]]></code>
      </example>
      <para>Application's that are launched from a XIB or storyboard use the <see cref="T:UIKit.UIApplicationDelegate" /> specified in the XIB or storyboard.</para>
    </remarks>
    <related type="externalDocumentation" href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIApplicationDelegate_Protocol/index.html">Apple documentation for <c>UIApplicationDelegate</c></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIApplicationDelegate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplicationDelegate.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("init")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Default constructor that initializes a new instance of this class with no parameters.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected UIApplicationDelegate (Foundation.NSObjectFlag t);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class Foundation.NSObjectFlag t) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplicationDelegate.#ctor(Foundation.NSObjectFlag)" />
      <MemberSignature Language="F#" Value="new UIKit.UIApplicationDelegate : Foundation.NSObjectFlag -&gt; UIKit.UIApplicationDelegate" Usage="new UIKit.UIApplicationDelegate t" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="t" Type="Foundation.NSObjectFlag" />
      </Parameters>
      <Docs>
        <param name="t">Unused sentinel value, pass NSObjectFlag.Empty.</param>
        <summary>Constructor to call on derived classes to skip initialization and merely allocate the object.</summary>
        <remarks>
          <para>This constructor should be called by derived classes when they completely construct the object in managed code and merely want the runtime to allocate and initialize the NSObject.   This is required to implement the two-step initialization process that Objective-C uses, the first step is to perform the object allocation, the second step is to initialize the object.   When developers invoke the constructor that takes the NSObjectFlag.Empty they take advantage of a direct path that goes all the way up to NSObject to merely allocate the object's memory and bind the Objective-C and C# objects together.    The actual initialization of the object is up to the developer.</para>
          <para>This constructor is typically used by the binding generator to allocate the object, but prevent the actual initialization to take place.   Once the allocation has taken place, the constructor has to initialize the object.   With constructors generated by the binding generator this means that it manually invokes one of the "init" methods to initialize the object.</para>
          <para>It is the developer's responsibility to completely initialize the object if they chain up using the NSObjectFlag.Empty path.</para>
          <para>In general, if the developer's constructor invokes the NSObjectFlag.Empty base implementation, then it should be calling an Objective-C init method.   If this is not the case, developers should instead chain to the proper constructor in their class. </para>
          <para>The argument value is ignored and merely ensures that the only code that is executed is the construction phase is the basic NSObject allocation and runtime type registration.  Typically the chaining would look like this:</para>
          <example>
            <code lang="C#"><![CDATA[
//
// The NSObjectFlag merely allocates the object and registers the
// C# class with the Objective-C runtime if necessary, but no actual
// initXxx method is invoked, that is done later in the constructor
//
// This is taken from Xamarin.iOS's source code:
//
[Export ("initWithFrame:")]
public UIView (System.Drawing.RectangleF frame) : base (NSObjectFlag.Empty)
{
// Invoke the init method now.
	var initWithFrame = new Selector ("initWithFrame:").Handle;
	if (IsDirectBinding)
		Handle = ObjCRuntime.Messaging.IntPtr_objc_msgSend_CGRect (this.Handle, initWithFrame, frame);
	else
		Handle = ObjCRuntime.Messaging.IntPtr_objc_msgSendSuper_CGRect (this.SuperHandle, initWithFrame, frame);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected internal UIApplicationDelegate (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig specialname rtspecialname instance void .ctor(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplicationDelegate.#ctor(System.IntPtr)" />
      <MemberSignature Language="F#" Value="new UIKit.UIApplicationDelegate : nativeint -&gt; UIKit.UIApplicationDelegate" Usage="new UIKit.UIApplicationDelegate handle" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Pointer (handle) to the unmanaged object.</param>
        <summary>A constructor used when creating managed representations of unmanaged objects;  Called by the runtime.</summary>
        <remarks>
          <para>This constructor is invoked by the runtime infrastructure (<see cref="M:ObjCRuntime.Runtime.GetNSObject(System.IntPtr)" />) to create a new managed representation for a pointer to an unmanaged Objective-C object.    Developers should not invoke this method directly, instead they should call the GetNSObject method as it will prevent two instances of a managed object to point to the same native object.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityPerformMagicTap">
      <MemberSignature Language="C#" Value="public virtual bool AccessibilityPerformMagicTap ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool AccessibilityPerformMagicTap() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplicationDelegate.AccessibilityPerformMagicTap" />
      <MemberSignature Language="F#" Value="abstract member AccessibilityPerformMagicTap : unit -&gt; bool&#xA;override this.AccessibilityPerformMagicTap : unit -&gt; bool" Usage="uIApplicationDelegate.AccessibilityPerformMagicTap " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("accessibilityPerformMagicTap")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Performs the most important action of the app. Often, this is toggling the most important state of the app.</summary>
        <returns>By default, returns <see langword="false" />. If overridden, return <see langword="true" /> if the action succeeded.</returns>
        <remarks>
          <para>If the system-wide "Voice Over" Accessibility setting is on, a two-finger double-tap ("Magic Tap") should perform the most-important behavior of the application (e.g., starting or pausing media playback, answering or hanging up a phone call). Application developers can override this method to provide this functionality.</para>
          <para>Application developers should not rely on application users knowing and using the "magic tap" gesture. Applications should always provide a visual UI that provides the same action as the "magic tap."</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationSignificantTimeChange">
      <MemberSignature Language="C#" Value="public virtual void ApplicationSignificantTimeChange (UIKit.UIApplication application);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplicationSignificantTimeChange(class UIKit.UIApplication application) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplicationDelegate.ApplicationSignificantTimeChange(UIKit.UIApplication)" />
      <MemberSignature Language="F#" Value="abstract member ApplicationSignificantTimeChange : UIKit.UIApplication -&gt; unit&#xA;override this.ApplicationSignificantTimeChange : UIKit.UIApplication -&gt; unit" Usage="uIApplicationDelegate.ApplicationSignificantTimeChange application" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("applicationSignificantTimeChange:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="application" Type="UIKit.UIApplication" />
      </Parameters>
      <Docs>
        <param name="application">Reference to the UIApplication that invoked this delegate method.</param>
        <summary>Indicates a significant shift in time, such as midnight, carrier-changed time, or the start or stop of Daylight Savings.</summary>
        <remarks>
          <para>If the application is suspended, this method will be called when the app returns to the foreground. This method will only be called once, even if multiple significant time changes occurred during suspension.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ChangedStatusBarFrame">
      <MemberSignature Language="C#" Value="public virtual void ChangedStatusBarFrame (UIKit.UIApplication application, CoreGraphics.CGRect oldStatusBarFrame);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ChangedStatusBarFrame(class UIKit.UIApplication application, valuetype CoreGraphics.CGRect oldStatusBarFrame) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplicationDelegate.ChangedStatusBarFrame(UIKit.UIApplication,CoreGraphics.CGRect)" />
      <MemberSignature Language="F#" Value="abstract member ChangedStatusBarFrame : UIKit.UIApplication * CoreGraphics.CGRect -&gt; unit&#xA;override this.ChangedStatusBarFrame : UIKit.UIApplication * CoreGraphics.CGRect -&gt; unit" Usage="uIApplicationDelegate.ChangedStatusBarFrame (application, oldStatusBarFrame)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("application:didChangeStatusBarFrame:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="application" Type="UIKit.UIApplication" />
        <Parameter Name="oldStatusBarFrame" Type="CoreGraphics.CGRect" />
      </Parameters>
      <Docs>
        <param name="application">Reference to the UIApplication that invoked this delegate method.</param>
        <param name="oldStatusBarFrame">The status bar's previous Frame.</param>
        <summary>Indicates that the <see cref="P:UIKit.UIView.Frame" /> of the status bar has changed.</summary>
        <remarks>
          <para>After this method ends, the system posts a <c>UIApplicationDidChangeStatusBarFrameNotification</c> (see <see cref="M:UIKit.UIApplication.Notifications.ObserveDidChangeStatusBarFrame*" />).</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContinueUserActivity">
      <MemberSignature Language="C#" Value="public virtual bool ContinueUserActivity (UIKit.UIApplication application, Foundation.NSUserActivity userActivity, UIKit.UIApplicationRestorationHandler completionHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContinueUserActivity(class UIKit.UIApplication application, class Foundation.NSUserActivity userActivity, class UIKit.UIApplicationRestorationHandler completionHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplicationDelegate.ContinueUserActivity(UIKit.UIApplication,Foundation.NSUserActivity,UIKit.UIApplicationRestorationHandler)" />
      <MemberSignature Language="F#" Value="abstract member ContinueUserActivity : UIKit.UIApplication * Foundation.NSUserActivity * UIKit.UIApplicationRestorationHandler -&gt; bool&#xA;override this.ContinueUserActivity : UIKit.UIApplication * Foundation.NSUserActivity * UIKit.UIApplicationRestorationHandler -&gt; bool" Usage="uIApplicationDelegate.ContinueUserActivity (application, userActivity, completionHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("application:continueUserActivity:restorationHandler:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="application" Type="UIKit.UIApplication" />
        <Parameter Name="userActivity" Type="Foundation.NSUserActivity" />
        <Parameter Name="completionHandler" Type="UIKit.UIApplicationRestorationHandler">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDUIApplicationRestorationHandler))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="application">The <see cref="T:UIKit.UIApplication" /> singleton.</param>
        <param name="userActivity">The user activity identifier.</param>
        <param name="completionHandler">System-provided callback that can be called with appropriate <see cref="T:UIKit.UIResponder" /> or <see cref="T:UIKit.UIDocument" /> objects.</param>
        <summary>Informs the app that there is data associated with continuing a task specified as a <see cref="T:Foundation.NSUserActivity" /> object, and then returns whether the app continued the activity.</summary>
        <returns>
          <see langword="true" /> if the app handled the user activity.</returns>
        <remarks>
          <para>The system calls this method if the application has registered its ability to handle the <paramref name="userActivity" /> and <see cref="M:UIKit.UIApplicationDelegate.WillContinueUserActivity(UIKit.UIApplication,System.String)" /> has returned <see langword="true" />.</para>
          <para>An application indicates interest in a particular <paramref name="userActivityType" /> by adding the value to it's <c>info.plist</c> as a <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=System%20String&amp;scope=Xamarin" title="T:System.String">T:System.String</a></format> value in an array called <c>NSUserActivityType</c>. By convention, the activity type begins with a domain-reversed string identifying the developer:</para>
          <example>
            <code lang="xml"><![CDATA[
<key>NSUserActivityTypes</key>
<array>
		<string>com.xamarin.HandOffDemo.verb</string>
</array>              
              ]]></code>
          </example>
          <para>The <paramref name="completionHandler" /> is a system-provided function that takes an array of <see cref="T:UIKit.UIResponder" /> objects that should have an opportunity to handle the <paramref name="userActivity" />. The system will call the <see cref="M:UIKit.UIResponder.RestoreUserActivityState(Foundation.NSUserActivity)" /> method on each of these objects.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DidChangeStatusBarOrientation">
      <MemberSignature Language="C#" Value="public virtual void DidChangeStatusBarOrientation (UIKit.UIApplication application, UIKit.UIInterfaceOrientation oldStatusBarOrientation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DidChangeStatusBarOrientation(class UIKit.UIApplication application, valuetype UIKit.UIInterfaceOrientation oldStatusBarOrientation) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplicationDelegate.DidChangeStatusBarOrientation(UIKit.UIApplication,UIKit.UIInterfaceOrientation)" />
      <MemberSignature Language="F#" Value="abstract member DidChangeStatusBarOrientation : UIKit.UIApplication * UIKit.UIInterfaceOrientation -&gt; unit&#xA;override this.DidChangeStatusBarOrientation : UIKit.UIApplication * UIKit.UIInterfaceOrientation -&gt; unit" Usage="uIApplicationDelegate.DidChangeStatusBarOrientation (application, oldStatusBarOrientation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("application:didChangeStatusBarOrientation:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="application" Type="UIKit.UIApplication" />
        <Parameter Name="oldStatusBarOrientation" Type="UIKit.UIInterfaceOrientation" />
      </Parameters>
      <Docs>
        <param name="application">Reference to the UIApplication that invoked this delegate method.</param>
        <param name="oldStatusBarOrientation">The status bar's previous orientation.</param>
        <summary>Indicates that the orientation of the status bar has changed.</summary>
        <remarks>
          <para>After this method ends, the systems posts a <c>UIApplicationDidChangeStatusBarOrientationNotification</c> (see <see cref="M:UIKit.UIApplication.Notifications.ObserveDidChangeStatusBarOrientation*" />).</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DidDecodeRestorableState">
      <MemberSignature Language="C#" Value="public virtual void DidDecodeRestorableState (UIKit.UIApplication application, Foundation.NSCoder coder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DidDecodeRestorableState(class UIKit.UIApplication application, class Foundation.NSCoder coder) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplicationDelegate.DidDecodeRestorableState(UIKit.UIApplication,Foundation.NSCoder)" />
      <MemberSignature Language="F#" Value="abstract member DidDecodeRestorableState : UIKit.UIApplication * Foundation.NSCoder -&gt; unit&#xA;override this.DidDecodeRestorableState : UIKit.UIApplication * Foundation.NSCoder -&gt; unit" Usage="uIApplicationDelegate.DidDecodeRestorableState (application, coder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("application:didDecodeRestorableStateWithCoder:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="application" Type="UIKit.UIApplication" />
        <Parameter Name="coder" Type="Foundation.NSCoder" />
      </Parameters>
      <Docs>
        <param name="application">Reference to the UIApplication that invoked this delegate method.</param>
        <param name="coder">To be added.</param>
        <summary>Indicates that the app should restore highest-level state.</summary>
        <remarks>
          <para>This is the final method called during state restoration. Application developers can override this method to restore their highest-level application data.</para>
        </remarks>
        <altmember cref="M:UIKit.UIApplicationDelegate.WillEncodeRestorableState" />
      </Docs>
    </Member>
    <Member MemberName="DidEnterBackground">
      <MemberSignature Language="C#" Value="public virtual void DidEnterBackground (UIKit.UIApplication application);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DidEnterBackground(class UIKit.UIApplication application) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplicationDelegate.DidEnterBackground(UIKit.UIApplication)" />
      <MemberSignature Language="F#" Value="abstract member DidEnterBackground : UIKit.UIApplication -&gt; unit&#xA;override this.DidEnterBackground : UIKit.UIApplication -&gt; unit" Usage="uIApplicationDelegate.DidEnterBackground application" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("applicationDidEnterBackground:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="application" Type="UIKit.UIApplication" />
      </Parameters>
      <Docs>
        <param name="application">Reference to the UIApplication that invoked this delegate method.</param>
        <summary>Indicates that the application has entered the background.</summary>
        <remarks>
          <para>Application are allocated approximately 5 seconds to complete this method. Application developers should use this time to save user data and tasks, and remove sensitive information from the screen.</para>
        </remarks>
        <altmember cref="M:UIKit.UIApplicationDelegate.WillEnterForeground" />
        <altmember cref="M:UIKit.UIApplication.WillTerminate" />
      </Docs>
    </Member>
    <Member MemberName="DidFailToContinueUserActivitiy">
      <MemberSignature Language="C#" Value="public virtual void DidFailToContinueUserActivitiy (UIKit.UIApplication application, string userActivityType, Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DidFailToContinueUserActivitiy(class UIKit.UIApplication application, string userActivityType, class Foundation.NSError error) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplicationDelegate.DidFailToContinueUserActivitiy(UIKit.UIApplication,System.String,Foundation.NSError)" />
      <MemberSignature Language="F#" Value="abstract member DidFailToContinueUserActivitiy : UIKit.UIApplication * string * Foundation.NSError -&gt; unit&#xA;override this.DidFailToContinueUserActivitiy : UIKit.UIApplication * string * Foundation.NSError -&gt; unit" Usage="uIApplicationDelegate.DidFailToContinueUserActivitiy (application, userActivityType, error)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("application:didFailToContinueUserActivityWithType:error:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="application" Type="UIKit.UIApplication" />
        <Parameter Name="userActivityType" Type="System.String" />
        <Parameter Name="error" Type="Foundation.NSError" />
      </Parameters>
      <Docs>
        <param name="application">To be added.</param>
        <param name="userActivityType">To be added.</param>
        <param name="error">To be added.</param>
        <summary>Informs the app that the activity of the <paramref name="userActivityType" /> type could not be continued, and specifies a <paramref name="error" /> as the reason for the failure.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DidReceiveRemoteNotification">
      <MemberSignature Language="C#" Value="public virtual void DidReceiveRemoteNotification (UIKit.UIApplication application, Foundation.NSDictionary userInfo, Action&lt;UIKit.UIBackgroundFetchResult&gt; completionHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DidReceiveRemoteNotification(class UIKit.UIApplication application, class Foundation.NSDictionary userInfo, class System.Action`1&lt;valuetype UIKit.UIBackgroundFetchResult&gt; completionHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplicationDelegate.DidReceiveRemoteNotification(UIKit.UIApplication,Foundation.NSDictionary,System.Action{UIKit.UIBackgroundFetchResult})" />
      <MemberSignature Language="F#" Value="abstract member DidReceiveRemoteNotification : UIKit.UIApplication * Foundation.NSDictionary * Action&lt;UIKit.UIBackgroundFetchResult&gt; -&gt; unit&#xA;override this.DidReceiveRemoteNotification : UIKit.UIApplication * Foundation.NSDictionary * Action&lt;UIKit.UIBackgroundFetchResult&gt; -&gt; unit" Usage="uIApplicationDelegate.DidReceiveRemoteNotification (application, userInfo, completionHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("application:didReceiveRemoteNotification:fetchCompletionHandler:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 10, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="application" Type="UIKit.UIApplication" />
        <Parameter Name="userInfo" Type="Foundation.NSDictionary" />
        <Parameter Name="completionHandler" Type="System.Action&lt;UIKit.UIBackgroundFetchResult&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDActionArity1V14))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="application">Handle to the UIApplication.</param>
        <param name="userInfo">To be added.</param>
        <param name="completionHandler">Callback to invoke to notify the operating system of the result of the background fetch operation.</param>
        <summary>Remote background notification support: Invoked by operating system when your application received a remote notification.</summary>
        <remarks>
          <para>
	    This method is part of iOS 7.0 new remote notification
	    support.  This method is invoked if your Entitlements list
	    the "remote-notification" background operation is set, and you receive a remote notification.
	  </para>
          <para>
	    Upon completion, you must notify the operating system of the result of the method by invoking the provided callback.

	  </para>
          <para>
	    Important: failure to call the provided callback method
	    with the result code before this method completes will
	    cause your application to be terminated.

	  </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DidRegisterUserNotificationSettings">
      <MemberSignature Language="C#" Value="public virtual void DidRegisterUserNotificationSettings (UIKit.UIApplication application, UIKit.UIUserNotificationSettings notificationSettings);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DidRegisterUserNotificationSettings(class UIKit.UIApplication application, class UIKit.UIUserNotificationSettings notificationSettings) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplicationDelegate.DidRegisterUserNotificationSettings(UIKit.UIApplication,UIKit.UIUserNotificationSettings)" />
      <MemberSignature Language="F#" Value="abstract member DidRegisterUserNotificationSettings : UIKit.UIApplication * UIKit.UIUserNotificationSettings -&gt; unit&#xA;override this.DidRegisterUserNotificationSettings : UIKit.UIApplication * UIKit.UIUserNotificationSettings -&gt; unit" Usage="uIApplicationDelegate.DidRegisterUserNotificationSettings (application, notificationSettings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("application:didRegisterUserNotificationSettings:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 10, 0, ObjCRuntime.PlatformArchitecture.None, "Use 'UNUserNotificationCenter.RequestAuthorization' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="application" Type="UIKit.UIApplication" />
        <Parameter Name="notificationSettings" Type="UIKit.UIUserNotificationSettings" />
      </Parameters>
      <Docs>
        <param name="application">To be added.</param>
        <param name="notificationSettings">To be added.</param>
        <summary>Developers should not use this deprecated method. Developers should use 'UNUserNotificationCenter.RequestAuthorization' instead.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FailedToRegisterForRemoteNotifications">
      <MemberSignature Language="C#" Value="public virtual void FailedToRegisterForRemoteNotifications (UIKit.UIApplication application, Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void FailedToRegisterForRemoteNotifications(class UIKit.UIApplication application, class Foundation.NSError error) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplicationDelegate.FailedToRegisterForRemoteNotifications(UIKit.UIApplication,Foundation.NSError)" />
      <MemberSignature Language="F#" Value="abstract member FailedToRegisterForRemoteNotifications : UIKit.UIApplication * Foundation.NSError -&gt; unit&#xA;override this.FailedToRegisterForRemoteNotifications : UIKit.UIApplication * Foundation.NSError -&gt; unit" Usage="uIApplicationDelegate.FailedToRegisterForRemoteNotifications (application, error)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("application:didFailToRegisterForRemoteNotificationsWithError:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="application" Type="UIKit.UIApplication" />
        <Parameter Name="error" Type="Foundation.NSError" />
      </Parameters>
      <Docs>
        <param name="application">Reference to the UIApplication that invoked this delegate method.</param>
        <param name="error">To be added.</param>
        <summary>Indicates that a call to <see cref="M:UIKit.UIApplication.RegisterForRemoteNotifications" /> failed.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FinishedLaunching">
      <MemberSignature Language="C#" Value="public virtual void FinishedLaunching (UIKit.UIApplication application);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void FinishedLaunching(class UIKit.UIApplication application) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplicationDelegate.FinishedLaunching(UIKit.UIApplication)" />
      <MemberSignature Language="F#" Value="abstract member FinishedLaunching : UIKit.UIApplication -&gt; unit&#xA;override this.FinishedLaunching : UIKit.UIApplication -&gt; unit" Usage="uIApplicationDelegate.FinishedLaunching application" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("applicationDidFinishLaunching:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="application" Type="UIKit.UIApplication" />
      </Parameters>
      <Docs>
        <param name="application">Reference to the UIApplication that invoked this delegate method.</param>
        <summary>Method invoked after the application has launched to configure the main window and view controller.</summary>
        <remarks>
          <para>
	    This method should create and configure the toplevel window, make it visible.  The toplevel window should have a UIViewController.
	  </para>
          <para>
	    This method is deprecated, you should use the overload that takes a launchOptions instead.
	  </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FinishedLaunching">
      <MemberSignature Language="C#" Value="public virtual bool FinishedLaunching (UIKit.UIApplication application, Foundation.NSDictionary launchOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool FinishedLaunching(class UIKit.UIApplication application, class Foundation.NSDictionary launchOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplicationDelegate.FinishedLaunching(UIKit.UIApplication,Foundation.NSDictionary)" />
      <MemberSignature Language="F#" Value="abstract member FinishedLaunching : UIKit.UIApplication * Foundation.NSDictionary -&gt; bool&#xA;override this.FinishedLaunching : UIKit.UIApplication * Foundation.NSDictionary -&gt; bool" Usage="uIApplicationDelegate.FinishedLaunching (application, launchOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("application:didFinishLaunchingWithOptions:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="application" Type="UIKit.UIApplication" />
        <Parameter Name="launchOptions" Type="Foundation.NSDictionary" />
      </Parameters>
      <Docs>
        <param name="application">Reference to the UIApplication that invoked this delegate method.</param>
        <param name="launchOptions">An NSDictionary with the launch options, can be null.   Possible key values are UIApplication's LaunchOption static properties.</param>
        <summary>Method invoked after the application has launched to configure the main window and view controller.</summary>
        <returns>To be added.</returns>
        <remarks>
          <para>
	    This method should create and configure the toplevel window, make it visible.  The toplevel window should have a UIViewController.
	  </para>
          <para>
	    The following example shows a minimal implementation:
	  </para>
          <example>
            <code lang="C#"><![CDATA[
[Register ("AppDelegate")]
public partial class AppDelegate : UIApplicationDelegate
{
	UIWindow window;

	public override bool FinishedLaunching (UIApplication app, NSDictionary options)
	{
		window = new UIWindow (UIScreen.MainScreen.Bounds);
		window.RootViewController = new UIViewController ();
		window.MakeKeyAndVisible ();
		
		return true;
	}
}
]]></code>
          </example>
          <para>
	    The dictionary launchOptions if set, might contain zero or more information bits.   You can use the following keys to retrieve information from it: 
	  </para>
          <list type="table">
            <listheader>
              <term>Dictionary Key for launchOptions</term>
              <description>Description</description>
            </listheader>
            <item>
              <term>
                <see cref="P:UIKit.UIApplication.LaunchOptionsUrlKey" />
              </term>
              <description>The application was launched in response to open a URL.  the value associated with the key contains the URL to open.</description>
            </item>
            <item>
              <term>
                <see cref="P:UIKit.UIApplication.LaunchOptionsAnnotationKey" />
              </term>
              <description>Use this key to find out if custom data was passed to the program by the opening application.   The value of this key will be a property list. </description>
            </item>
            <item>
              <term>
                <see cref="P:UIKit.UIApplication.LaunchOptionsLocalNotificationKey" />
              </term>
              <description>
                <para>
		  The value of this key will be a <see cref="T:UIKit.UILocalNotification" /> instance.
		</para>
                <para>
		  This key will be present on the launch options if a local notification was delivered and the application was not running.
		</para>
              </description>
            </item>
            <item>
              <term>
                <see cref="P:UIKit.UIApplication.LaunchOptionsLocationKey" />
              </term>
              <description>
                <para>
		  Application was started up in response to a location event.
		</para>
                <para>
		  The value of this key will be an NSNumber.   The application should respond by creating a <see cref="T:CoreLocation.CLLocationManager" /> instance to and get the information from that object.
		</para>
              </description>
            </item>
            <item>
              <term>
                <see cref="P:UIKit.UIApplication.LaunchOptionsNewsstandDownloadsKey" />
              </term>
              <description>
                <para>This key indicates that Newsstand has completed downloading the requested data. </para>
                <para>The value in the dictionary for this key, contains an array of strings that represent <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=T:Newsstand.NKAssetDownload&amp;scope=Xamarin" title="T:Newsstand.NKAssetDownload">T:Newsstand.NKAssetDownload</a></format> objects.</para>
              </description>
            </item>
            <item>
              <term>
                <see cref="P:UIKit.UIApplication.LaunchOptionsRemoteNotificationKey" />
              </term>
              <description>The value associated with this key will be an NSDictionary with the payload from the remote notification that was received. </description>
            </item>
            <item>
              <term>
                <see cref="P:UIKit.UIApplication.LaunchOptionsSourceApplicationKey" />
              </term>
              <description>The value associated with the key is the bundle-id of the application that launched this application.</description>
            </item>
            <item>
              <term>
                <see cref="P:UIKit.UIApplication.LaunchOptionsBluetoothPeripheralsKey" />
              </term>
              <description>
                <para>
		  If this key is present, this means that the
		  Bluetooth subsystem has launched the application to
		  restore a previous operation that was being done by
		  an <see cref="T:CoreBluetooth.CBPeripheralManager" />
		  objects.
		</para>
                <para>
		  The value of the key is an array of strings, each being the keys that you used when you created a CBPeripheralManager.
		</para>
              </description>
            </item>
            <item>
              <term>
                <see cref="P:UIKit.UIApplication.LaunchOptionsBluetoothCentralsKey" />
              </term>
              <description>
                <para>
		  If this key is present, this means that the
		  Bluetooth subsystem has launched the application to
		  restore a previous operation that was being done by
		  an <see cref="T:CoreBluetooth.CBCentralManager" />
		  objects.
		</para>
                <para>
		  The value of the key is an array of strings, each being the keys that you used when you created a CBPeripheralManager.
		</para>
              </description>
            </item>
          </list>
          <para>
	    If the application is designed to handle urls, it should
	    lookup the <see cref="P:UIKit.UIApplication.LaunchOptionsUrlKey" /> key in the launchOptions to extract the url that is
	    being launched, and return true at the end of the method
	    to indicate that the application is able to load that url,
	    or false if it is not.

	  </para>
          <example>
            <code lang="C#"><![CDATA[
[Register ("AppDelegate")]
public partial class AppDelegate : UIApplicationDelegate
{
    UIWindow window;

    public override bool WillFinishLaunching (UIApplication app, NSDictionary options)
    {
        if (options != null){
	    NSObject urlObject;
	    if (options.TryGetValue (UIApplication.LaunchOptionsUrlKey, out urlObject)){
	        var url = urlObject as NSUrl;

		// Examine the url here
		return CanHandle (url);
	    }
        }
    	return true;
    }
}
]]></code>
          </example>
          <para>
	    The following example shows how to retrieve the UILocatioNotification at startup.
	  </para>
          <example>
            <code lang="C#"><![CDATA[
[Register ("AppDelegate")]
public partial class AppDelegate : UIApplicationDelegate
{
	UIWindow window;

	public override bool FinishedLaunching (UIApplication app, NSDictionary options)
	{
		window = new UIWindow (UIScreen.MainScreen.Bounds);
		window.RootViewController = new UIViewController ();
		window.MakeKeyAndVisible ();
		
		if (options != null){
			NSObject result;
			if (options.TryGetValue (UIApplication.LaunchOptionsLocalNotificationKey, out result)){
				UILocalNotification notification = result as UILocalNotification;

				Console.WriteLine ("Got a local notification: {0}", notification);
			}
		}
		return true;
	}
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSupportedInterfaceOrientations">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIInterfaceOrientationMask GetSupportedInterfaceOrientations (UIKit.UIApplication application, UIKit.UIWindow forWindow);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype UIKit.UIInterfaceOrientationMask GetSupportedInterfaceOrientations(class UIKit.UIApplication application, class UIKit.UIWindow forWindow) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplicationDelegate.GetSupportedInterfaceOrientations(UIKit.UIApplication,UIKit.UIWindow)" />
      <MemberSignature Language="F#" Value="abstract member GetSupportedInterfaceOrientations : UIKit.UIApplication * UIKit.UIWindow -&gt; UIKit.UIInterfaceOrientationMask&#xA;override this.GetSupportedInterfaceOrientations : UIKit.UIApplication * UIKit.UIWindow -&gt; UIKit.UIInterfaceOrientationMask" Usage="uIApplicationDelegate.GetSupportedInterfaceOrientations (application, forWindow)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("application:supportedInterfaceOrientationsForWindow:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIInterfaceOrientationMask</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="application" Type="UIKit.UIApplication" />
        <Parameter Name="forWindow" Type="UIKit.UIWindow">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.Transient</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="application">Reference to the UIApplication that invoked this delegate method.</param>
        <param name="forWindow">To be added.</param>
        <summary>Returns a bit-mask of supported orientations for the specified <paramref name="forWindow" />.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetViewController">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIViewController GetViewController (UIKit.UIApplication application, string[] restorationIdentifierComponents, Foundation.NSCoder coder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class UIKit.UIViewController GetViewController(class UIKit.UIApplication application, string[] restorationIdentifierComponents, class Foundation.NSCoder coder) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplicationDelegate.GetViewController(UIKit.UIApplication,System.String[],Foundation.NSCoder)" />
      <MemberSignature Language="F#" Value="abstract member GetViewController : UIKit.UIApplication * string[] * Foundation.NSCoder -&gt; UIKit.UIViewController&#xA;override this.GetViewController : UIKit.UIApplication * string[] * Foundation.NSCoder -&gt; UIKit.UIViewController" Usage="uIApplicationDelegate.GetViewController (application, restorationIdentifierComponents, coder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("application:viewControllerWithRestorationIdentifierPath:coder:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIViewController</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="application" Type="UIKit.UIApplication" />
        <Parameter Name="restorationIdentifierComponents" Type="System.String[]" />
        <Parameter Name="coder" Type="Foundation.NSCoder" />
      </Parameters>
      <Docs>
        <param name="application">Reference to the UIApplication that invoked this delegate method.</param>
        <param name="restorationIdentifierComponents">An array of identifiers that identify the path to the desired view controller, which should be last.</param>
        <param name="coder">To be added.</param>
        <summary>Retrieve the <see cref="T:UIKit.UIViewController" /> identified by the <paramref name="restorationIdentifierComponents" />.</summary>
        <returns>To be added.</returns>
        <remarks>
          <para>To retrieve a specific <see cref="T:UIKit.UIViewController" />, the <paramref name="restorationIdentifierComponents" /> must contain the identifiers of the desired view controller and all its ancestors in the view controller hierarchy. The last value should be that of the desired view contoller, while the first should be the root of the view controller hierarcy.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HandleAction">
      <MemberSignature Language="C#" Value="public virtual void HandleAction (UIKit.UIApplication application, string actionIdentifier, Foundation.NSDictionary remoteNotificationInfo, Action completionHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void HandleAction(class UIKit.UIApplication application, string actionIdentifier, class Foundation.NSDictionary remoteNotificationInfo, class System.Action completionHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplicationDelegate.HandleAction(UIKit.UIApplication,System.String,Foundation.NSDictionary,System.Action)" />
      <MemberSignature Language="F#" Value="abstract member HandleAction : UIKit.UIApplication * string * Foundation.NSDictionary * Action -&gt; unit&#xA;override this.HandleAction : UIKit.UIApplication * string * Foundation.NSDictionary * Action -&gt; unit" Usage="uIApplicationDelegate.HandleAction (application, actionIdentifier, remoteNotificationInfo, completionHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("application:handleActionWithIdentifier:forRemoteNotification:completionHandler:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 10, 0, ObjCRuntime.PlatformArchitecture.None, "Use 'UNUserNotificationCenterDelegate.DidReceiveNotificationResponse' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="application" Type="UIKit.UIApplication" />
        <Parameter Name="actionIdentifier" Type="System.String" />
        <Parameter Name="remoteNotificationInfo" Type="Foundation.NSDictionary" />
        <Parameter Name="completionHandler" Type="System.Action">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="application">To be added.</param>
        <param name="actionIdentifier">To be added.</param>
        <param name="remoteNotificationInfo">To be added.</param>
        <param name="completionHandler">To be added.</param>
        <summary>Informs the app of a custom action to perform based on a push notification, and includes the <paramref name="actionIdentifier" /> value, <paramref name="remoteNoticationInfo" /> data from the notification, and <paramref name="completionHandler" /> for the app developer to run after performing the action.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HandleAction">
      <MemberSignature Language="C#" Value="public virtual void HandleAction (UIKit.UIApplication application, string actionIdentifier, UIKit.UILocalNotification localNotification, Action completionHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void HandleAction(class UIKit.UIApplication application, string actionIdentifier, class UIKit.UILocalNotification localNotification, class System.Action completionHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplicationDelegate.HandleAction(UIKit.UIApplication,System.String,UIKit.UILocalNotification,System.Action)" />
      <MemberSignature Language="F#" Value="abstract member HandleAction : UIKit.UIApplication * string * UIKit.UILocalNotification * Action -&gt; unit&#xA;override this.HandleAction : UIKit.UIApplication * string * UIKit.UILocalNotification * Action -&gt; unit" Usage="uIApplicationDelegate.HandleAction (application, actionIdentifier, localNotification, completionHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("application:handleActionWithIdentifier:forLocalNotification:completionHandler:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 10, 0, ObjCRuntime.PlatformArchitecture.None, "Use 'UNUserNotificationCenterDelegate.DidReceiveNotificationResponse' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="application" Type="UIKit.UIApplication" />
        <Parameter Name="actionIdentifier" Type="System.String" />
        <Parameter Name="localNotification" Type="UIKit.UILocalNotification" />
        <Parameter Name="completionHandler" Type="System.Action">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="application">To be added.</param>
        <param name="actionIdentifier">To be added.</param>
        <param name="localNotification">To be added.</param>
        <param name="completionHandler">To be added.</param>
        <summary>Informs the app that the user selected an action identified by the <paramref name="actionIdentifier" /> value from an alert of a <see cref="T:UIKit.UILocalNotification" /> object, and executes the <paramref name="completionHandler" /> block after it completes the action.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HandleAction">
      <MemberSignature Language="C#" Value="public virtual void HandleAction (UIKit.UIApplication application, string actionIdentifier, Foundation.NSDictionary remoteNotificationInfo, Foundation.NSDictionary responseInfo, Action completionHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void HandleAction(class UIKit.UIApplication application, string actionIdentifier, class Foundation.NSDictionary remoteNotificationInfo, class Foundation.NSDictionary responseInfo, class System.Action completionHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplicationDelegate.HandleAction(UIKit.UIApplication,System.String,Foundation.NSDictionary,Foundation.NSDictionary,System.Action)" />
      <MemberSignature Language="F#" Value="abstract member HandleAction : UIKit.UIApplication * string * Foundation.NSDictionary * Foundation.NSDictionary * Action -&gt; unit&#xA;override this.HandleAction : UIKit.UIApplication * string * Foundation.NSDictionary * Foundation.NSDictionary * Action -&gt; unit" Usage="uIApplicationDelegate.HandleAction (application, actionIdentifier, remoteNotificationInfo, responseInfo, completionHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("application:handleActionWithIdentifier:forRemoteNotification:withResponseInfo:completionHandler:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 10, 0, ObjCRuntime.PlatformArchitecture.None, "Use 'UNUserNotificationCenterDelegate.DidReceiveNotificationResponse' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="application" Type="UIKit.UIApplication" />
        <Parameter Name="actionIdentifier" Type="System.String" />
        <Parameter Name="remoteNotificationInfo" Type="Foundation.NSDictionary" />
        <Parameter Name="responseInfo" Type="Foundation.NSDictionary" />
        <Parameter Name="completionHandler" Type="System.Action">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="application">To be added.</param>
        <param name="actionIdentifier">To be added.</param>
        <param name="remoteNotificationInfo">To be added.</param>
        <param name="responseInfo">To be added.</param>
        <param name="completionHandler">To be added.</param>
        <summary>Informs the app of a custom action to perform based on a remote notification, and includes the <paramref name="actionIdentifier" /> value, <paramref name="remoteNoticationInfo" /> data from the notification, and <paramref name="completionHandler" /> for the app developer to run after performing the action.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HandleAction">
      <MemberSignature Language="C#" Value="public virtual void HandleAction (UIKit.UIApplication application, string actionIdentifier, UIKit.UILocalNotification localNotification, Foundation.NSDictionary responseInfo, Action completionHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void HandleAction(class UIKit.UIApplication application, string actionIdentifier, class UIKit.UILocalNotification localNotification, class Foundation.NSDictionary responseInfo, class System.Action completionHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplicationDelegate.HandleAction(UIKit.UIApplication,System.String,UIKit.UILocalNotification,Foundation.NSDictionary,System.Action)" />
      <MemberSignature Language="F#" Value="abstract member HandleAction : UIKit.UIApplication * string * UIKit.UILocalNotification * Foundation.NSDictionary * Action -&gt; unit&#xA;override this.HandleAction : UIKit.UIApplication * string * UIKit.UILocalNotification * Foundation.NSDictionary * Action -&gt; unit" Usage="uIApplicationDelegate.HandleAction (application, actionIdentifier, localNotification, responseInfo, completionHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("application:handleActionWithIdentifier:forLocalNotification:withResponseInfo:completionHandler:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 10, 0, ObjCRuntime.PlatformArchitecture.None, "Use 'UNUserNotificationCenterDelegate.DidReceiveNotificationResponse' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="application" Type="UIKit.UIApplication" />
        <Parameter Name="actionIdentifier" Type="System.String" />
        <Parameter Name="localNotification" Type="UIKit.UILocalNotification" />
        <Parameter Name="responseInfo" Type="Foundation.NSDictionary" />
        <Parameter Name="completionHandler" Type="System.Action">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="application">To be added.</param>
        <param name="actionIdentifier">To be added.</param>
        <param name="localNotification">To be added.</param>
        <param name="responseInfo">To be added.</param>
        <param name="completionHandler">To be added.</param>
        <summary>Informs the app of a custom action to perform based on a local notification, and includes the <paramref name="actionIdentifier" /> value, <paramref name="responseInfo" /> data from the notification, and <paramref name="completionHandler" /> for the app developer to run after performing the action.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HandleEventsForBackgroundUrl">
      <MemberSignature Language="C#" Value="public virtual void HandleEventsForBackgroundUrl (UIKit.UIApplication application, string sessionIdentifier, Action completionHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void HandleEventsForBackgroundUrl(class UIKit.UIApplication application, string sessionIdentifier, class System.Action completionHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplicationDelegate.HandleEventsForBackgroundUrl(UIKit.UIApplication,System.String,System.Action)" />
      <MemberSignature Language="F#" Value="abstract member HandleEventsForBackgroundUrl : UIKit.UIApplication * string * Action -&gt; unit&#xA;override this.HandleEventsForBackgroundUrl : UIKit.UIApplication * string * Action -&gt; unit" Usage="uIApplicationDelegate.HandleEventsForBackgroundUrl (application, sessionIdentifier, completionHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("application:handleEventsForBackgroundURLSession:completionHandler:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="application" Type="UIKit.UIApplication" />
        <Parameter Name="sessionIdentifier" Type="System.String" />
        <Parameter Name="completionHandler" Type="System.Action">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="application">To be added.</param>
        <param name="sessionIdentifier">To be added.</param>
        <param name="completionHandler">To be added.</param>
        <summary>All background transfers in <paramref name="sessionIdentifier" /> are finished, or authentication is required. The application should update its interface and then run <paramref name="completionHander" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HandleIntent">
      <MemberSignature Language="C#" Value="public virtual void HandleIntent (UIKit.UIApplication application, Intents.INIntent intent, Action&lt;Intents.INIntentResponse&gt; completionHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void HandleIntent(class UIKit.UIApplication application, class Intents.INIntent intent, class System.Action`1&lt;class Intents.INIntentResponse&gt; completionHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplicationDelegate.HandleIntent(UIKit.UIApplication,Intents.INIntent,System.Action{Intents.INIntentResponse})" />
      <MemberSignature Language="F#" Value="abstract member HandleIntent : UIKit.UIApplication * Intents.INIntent * Action&lt;Intents.INIntentResponse&gt; -&gt; unit&#xA;override this.HandleIntent : UIKit.UIApplication * Intents.INIntent * Action&lt;Intents.INIntentResponse&gt; -&gt; unit" Usage="uIApplicationDelegate.HandleIntent (application, intent, completionHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("application:handleIntent:completionHandler:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.WatchOS, 4, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="application" Type="UIKit.UIApplication" />
        <Parameter Name="intent" Type="Intents.INIntent" />
        <Parameter Name="completionHandler" Type="System.Action&lt;Intents.INIntentResponse&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDActionArity1V15))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="application">The application that created the intent.</param>
        <param name="intent">The intent.</param>
        <param name="completionHandler">A handler to run after the operation completes.</param>
        <summary>The system is requesting that the application handle the specified <paramref name="intent" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HandleOpenURL">
      <MemberSignature Language="C#" Value="public virtual bool HandleOpenURL (UIKit.UIApplication application, Foundation.NSUrl url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool HandleOpenURL(class UIKit.UIApplication application, class Foundation.NSUrl url) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplicationDelegate.HandleOpenURL(UIKit.UIApplication,Foundation.NSUrl)" />
      <MemberSignature Language="F#" Value="abstract member HandleOpenURL : UIKit.UIApplication * Foundation.NSUrl -&gt; bool&#xA;override this.HandleOpenURL : UIKit.UIApplication * Foundation.NSUrl -&gt; bool" Usage="uIApplicationDelegate.HandleOpenURL (application, url)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("application:handleOpenURL:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Obsoleted(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, "Override 'OpenUrl (UIApplication, NSUrl, NSDictionary)'. The later will be called if both are implemented.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="application" Type="UIKit.UIApplication" />
        <Parameter Name="url" Type="Foundation.NSUrl" />
      </Parameters>
      <Docs>
        <param name="application">Reference to the UIApplication that invoked this delegate method.</param>
        <param name="url">To be added.</param>
        <summary>Application developers should not use this deprecated method but use <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=UIKit%20UIApplication%20Delegate%20Open%20Url&amp;scope=Xamarin" title="M:UIKit.UIApplicationDelegate.OpenUrl*">M:UIKit.UIApplicationDelegate.OpenUrl*</a></format> instead.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HandleWatchKitExtensionRequest">
      <MemberSignature Language="C#" Value="public virtual void HandleWatchKitExtensionRequest (UIKit.UIApplication application, Foundation.NSDictionary userInfo, Action&lt;Foundation.NSDictionary&gt; reply);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void HandleWatchKitExtensionRequest(class UIKit.UIApplication application, class Foundation.NSDictionary userInfo, class System.Action`1&lt;class Foundation.NSDictionary&gt; reply) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplicationDelegate.HandleWatchKitExtensionRequest(UIKit.UIApplication,Foundation.NSDictionary,System.Action{Foundation.NSDictionary})" />
      <MemberSignature Language="F#" Value="abstract member HandleWatchKitExtensionRequest : UIKit.UIApplication * Foundation.NSDictionary * Action&lt;Foundation.NSDictionary&gt; -&gt; unit&#xA;override this.HandleWatchKitExtensionRequest : UIKit.UIApplication * Foundation.NSDictionary * Action&lt;Foundation.NSDictionary&gt; -&gt; unit" Usage="uIApplicationDelegate.HandleWatchKitExtensionRequest (application, userInfo, reply)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("application:handleWatchKitExtensionRequest:reply:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 2, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="application" Type="UIKit.UIApplication" />
        <Parameter Name="userInfo" Type="Foundation.NSDictionary" />
        <Parameter Name="reply" Type="System.Action&lt;Foundation.NSDictionary&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDActionArity1V16))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="application">To be added.</param>
        <param name="userInfo">To be added.</param>
        <param name="reply">To be added.</param>
        <summary>A watchkit extension has made a request.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnActivated">
      <MemberSignature Language="C#" Value="public virtual void OnActivated (UIKit.UIApplication application);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnActivated(class UIKit.UIApplication application) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplicationDelegate.OnActivated(UIKit.UIApplication)" />
      <MemberSignature Language="F#" Value="abstract member OnActivated : UIKit.UIApplication -&gt; unit&#xA;override this.OnActivated : UIKit.UIApplication -&gt; unit" Usage="uIApplicationDelegate.OnActivated application" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("applicationDidBecomeActive:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="application" Type="UIKit.UIApplication" />
      </Parameters>
      <Docs>
        <param name="application">Reference to the UIApplication that invoked this delegate method.</param>
        <summary>Called when the application is launched and every time the app returns to the foreground.</summary>
        <remarks>
          <para>Because iOS applications should be designed to be long-lived, with many transitions between foreground processing and suspension or background processing, this method is generally the proper place to ensure that all the resources and state information for foreground processing are available and properly configured.</para>
          <para>
            <img href="~/UIKit/_images/UIApplicationDelegate.Lifecycle.png" />
          </para>
        </remarks>
        <altmember cref="M:UIKit.UIApplicationDelegate.OnResignActivation" />
      </Docs>
    </Member>
    <Member MemberName="OnResignActivation">
      <MemberSignature Language="C#" Value="public virtual void OnResignActivation (UIKit.UIApplication application);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnResignActivation(class UIKit.UIApplication application) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplicationDelegate.OnResignActivation(UIKit.UIApplication)" />
      <MemberSignature Language="F#" Value="abstract member OnResignActivation : UIKit.UIApplication -&gt; unit&#xA;override this.OnResignActivation : UIKit.UIApplication -&gt; unit" Usage="uIApplicationDelegate.OnResignActivation application" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("applicationWillResignActive:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="application" Type="UIKit.UIApplication" />
      </Parameters>
      <Docs>
        <param name="application">Reference to the UIApplication that invoked this delegate method.</param>
        <summary>Called when the application is about to enter the background, be suspended, or when the user receives an interruption such as a phone call or text.</summary>
        <remarks>
          <para>Because iOS applications should be designed to be long-lived, with many transitions between foreground processing, suspension or background processing, or interrupted, this method may be a good place to release expensive resources or otherwise ensure that the application is in a consistent, restorable state.</para>
        </remarks>
        <altmember cref="M:UIKit.UIApplicationDelegate.OnActivated" />
      </Docs>
    </Member>
    <Member MemberName="OpenUrl">
      <MemberSignature Language="C#" Value="public virtual bool OpenUrl (UIKit.UIApplication app, Foundation.NSUrl url, Foundation.NSDictionary options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool OpenUrl(class UIKit.UIApplication app, class Foundation.NSUrl url, class Foundation.NSDictionary options) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplicationDelegate.OpenUrl(UIKit.UIApplication,Foundation.NSUrl,Foundation.NSDictionary)" />
      <MemberSignature Language="F#" Value="abstract member OpenUrl : UIKit.UIApplication * Foundation.NSUrl * Foundation.NSDictionary -&gt; bool&#xA;override this.OpenUrl : UIKit.UIApplication * Foundation.NSUrl * Foundation.NSDictionary -&gt; bool" Usage="uIApplicationDelegate.OpenUrl (app, url, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("application:openURL:options:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="app" Type="UIKit.UIApplication" />
        <Parameter Name="url" Type="Foundation.NSUrl" />
        <Parameter Name="options" Type="Foundation.NSDictionary" />
      </Parameters>
      <Docs>
        <param name="app">To be added.</param>
        <param name="url">To be added.</param>
        <param name="options">To be added.</param>
        <summary>Indicates that the application should open the specified <paramref name="url" /> with context from <paramref name="options" />.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenUrl">
      <MemberSignature Language="C#" Value="public bool OpenUrl (UIKit.UIApplication app, Foundation.NSUrl url, UIKit.UIApplicationOpenUrlOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool OpenUrl(class UIKit.UIApplication app, class Foundation.NSUrl url, class UIKit.UIApplicationOpenUrlOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplicationDelegate.OpenUrl(UIKit.UIApplication,Foundation.NSUrl,UIKit.UIApplicationOpenUrlOptions)" />
      <MemberSignature Language="F#" Value="member this.OpenUrl : UIKit.UIApplication * Foundation.NSUrl * UIKit.UIApplicationOpenUrlOptions -&gt; bool" Usage="uIApplicationDelegate.OpenUrl (app, url, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="app" Type="UIKit.UIApplication" />
        <Parameter Name="url" Type="Foundation.NSUrl" />
        <Parameter Name="options" Type="UIKit.UIApplicationOpenUrlOptions" />
      </Parameters>
      <Docs>
        <param name="app">To be added.</param>
        <param name="url">To be added.</param>
        <param name="options">To be added.</param>
        <summary>Indicates that the application should open the specified <paramref name="url" /> according to <paramref name="options" />.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenUrl">
      <MemberSignature Language="C#" Value="public virtual bool OpenUrl (UIKit.UIApplication application, Foundation.NSUrl url, string sourceApplication, Foundation.NSObject annotation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool OpenUrl(class UIKit.UIApplication application, class Foundation.NSUrl url, string sourceApplication, class Foundation.NSObject annotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplicationDelegate.OpenUrl(UIKit.UIApplication,Foundation.NSUrl,System.String,Foundation.NSObject)" />
      <MemberSignature Language="F#" Value="abstract member OpenUrl : UIKit.UIApplication * Foundation.NSUrl * string * Foundation.NSObject -&gt; bool&#xA;override this.OpenUrl : UIKit.UIApplication * Foundation.NSUrl * string * Foundation.NSObject -&gt; bool" Usage="uIApplicationDelegate.OpenUrl (application, url, sourceApplication, annotation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("application:openURL:sourceApplication:annotation:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Obsoleted(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, "Override 'OpenUrl (UIApplication, NSUrl, NSDictionary)'. The later will be called if both are implemented.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="application" Type="UIKit.UIApplication" />
        <Parameter Name="url" Type="Foundation.NSUrl" />
        <Parameter Name="sourceApplication" Type="System.String" />
        <Parameter Name="annotation" Type="Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="application">Reference to this application (<see cref="P:UIKit.UIApplication.SharedApplication" />).</param>
        <param name="url">The <see cref="T:Foundation.NSUrl" /> specified by the calling application.</param>
        <param name="sourceApplication">The bundle ID of the calling application.</param>
        <param name="annotation">Optional property-list data passed by the calling application.</param>
        <summary>Indicates that the application should open the specified <paramref name="url" />.</summary>
        <returns>
          <see langword="true" /> if the application succcessfully handled the <paramref name="url" />.</returns>
        <remarks>
          <para>When overridden, the application should open the <paramref name="url" /> and return a boolean indicating whether the retrieval was successful.</para>
          <para>If the origin of the request was another application, the methods <see cref="M:UIKit.UIApplicationDelegate.WillFinishLaunching(UIKit.UIApplication,Foundation.NSDictionary)" /> and <see cref="M:UIKit.UIApplicationDelegate_Extensions.FinishedLaunching(UIKit.IUIApplicationDelegate,UIKit.UIApplication,Foundation.NSDictionary)" /> will be called prior to this method and can be used to prevent this method from being called.</para>
          <para>If the <paramref name="url" /> originated in a <see cref="T:UIKit.UIDocumentInteractionController" />, the <paramref name="annotation" /> may contain additional information specified by the <paramref name="sourceApplication" />. Files sent via <see cref="T:UIKit.UIDocumentInteractionController" /> will be in the application's <c>Documents/Inbox</c> directory. Applications do not have write access to this directory, so if the file needs to be modified, it must be moved to a write-enabled directory. If the file is protected and the user locks the device, it will be inaccessible. (see <see cref="M:UIKit.UIApplicationDelegate.ProtectedDataDidBecomeAvailable(UIKit.UIApplication)" /> and <see cref="P:UIKit.UIApplication.ProtectedDataAvailable" />).</para>
          <para>Applications that wish to be activated using <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=UIKit%20UIApplication%20Delegate%20Open%20URL&amp;scope=Xamarin" title="M:UIKit.UIApplicationDelegate.OpenURL*">M:UIKit.UIApplicationDelegate.OpenURL*</a></format> must set the <c>CFBundleURLTypes</c> in their <c>Info.plist</c> file, as a child of the <c><![CDATA[<plist><dict>]]></c> element. The following example shows how a viewer to handle the URL scheme <c>foo://host:port/path?query</c> might be declared:</para>
          <example>
            <code lang="XML"><![CDATA[
<key>CFBundleURLTypes</key>
<array>
	<dict>
		<key>CFBundleURLName</key>
		<string>com.xamarin.MyUniqueIdentifier</string>
		<key>CFBundleURLSchemes</key>
		<array>
			<string>foo</string>
		</array>
		<key>CFBundleURLTypes</key>
		<string>Viewer</string>
	</dict>
</array>
              ]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformActionForShortcutItem">
      <MemberSignature Language="C#" Value="public virtual void PerformActionForShortcutItem (UIKit.UIApplication application, UIKit.UIApplicationShortcutItem shortcutItem, UIKit.UIOperationHandler completionHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PerformActionForShortcutItem(class UIKit.UIApplication application, class UIKit.UIApplicationShortcutItem shortcutItem, class UIKit.UIOperationHandler completionHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplicationDelegate.PerformActionForShortcutItem(UIKit.UIApplication,UIKit.UIApplicationShortcutItem,UIKit.UIOperationHandler)" />
      <MemberSignature Language="F#" Value="abstract member PerformActionForShortcutItem : UIKit.UIApplication * UIKit.UIApplicationShortcutItem * UIKit.UIOperationHandler -&gt; unit&#xA;override this.PerformActionForShortcutItem : UIKit.UIApplication * UIKit.UIApplicationShortcutItem * UIKit.UIOperationHandler -&gt; unit" Usage="uIApplicationDelegate.PerformActionForShortcutItem (application, shortcutItem, completionHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("application:performActionForShortcutItem:completionHandler:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="application" Type="UIKit.UIApplication" />
        <Parameter Name="shortcutItem" Type="UIKit.UIApplicationShortcutItem" />
        <Parameter Name="completionHandler" Type="UIKit.UIOperationHandler">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDUIOperationHandler))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="application">To be added.</param>
        <param name="shortcutItem">To be added.</param>
        <param name="completionHandler">To be added.</param>
        <summary>Called by the system when the user initiates a Home screen quick action, unless the interaction was handled in <see cref="M:UIKit.UIApplicationDelegate.WillFinishLaunching(UIKit.UIApplication,Foundation.NSDictionary)" /> or <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=UIKit%20UIApplication%20Delegate%20Did%20Finish%20Launching&amp;scope=Xamarin" title="M:UIKit.UIApplicationDelegate.DidFinishLaunching*">M:UIKit.UIApplicationDelegate.DidFinishLaunching*</a></format>.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformFetch">
      <MemberSignature Language="C#" Value="public virtual void PerformFetch (UIKit.UIApplication application, Action&lt;UIKit.UIBackgroundFetchResult&gt; completionHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PerformFetch(class UIKit.UIApplication application, class System.Action`1&lt;valuetype UIKit.UIBackgroundFetchResult&gt; completionHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplicationDelegate.PerformFetch(UIKit.UIApplication,System.Action{UIKit.UIBackgroundFetchResult})" />
      <MemberSignature Language="F#" Value="abstract member PerformFetch : UIKit.UIApplication * Action&lt;UIKit.UIBackgroundFetchResult&gt; -&gt; unit&#xA;override this.PerformFetch : UIKit.UIApplication * Action&lt;UIKit.UIBackgroundFetchResult&gt; -&gt; unit" Usage="uIApplicationDelegate.PerformFetch (application, completionHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("application:performFetchWithCompletionHandler:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="application" Type="UIKit.UIApplication" />
        <Parameter Name="completionHandler" Type="System.Action&lt;UIKit.UIBackgroundFetchResult&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDActionArity1V14))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="application">Handle to the UIApplication.</param>
        <param name="completionHandler">Callback to invoke to notify the operating system of the result of the background fetch operation.</param>
        <summary>Background support: Invoked by the operating system to allow an application to download data.</summary>
        <remarks>
          <para>
	    This method is part of iOS 7.0 new background fetch
	    support.  This method is invoked if your Entitlements list
	    the "fetch" background operation and after you have
	    enabled fetching by calling the <see cref="M:UIKit.UIApplication.SetMinimumBackgroundFetchInterval(System.Double)" />
	    method.

	  </para>
          <para>
	    Once that happens the operating system will determine the
	    appropriate time to wake up your application to allow it
	    to download data.  When it does that, it will first call
	    the <see cref="M:UIKit.UIApplicationDelegate_Extensions.FinishedLaunching(UIKit.IUIApplicationDelegate,UIKit.UIApplication,Foundation.NSDictionary)" />
	    method and then will invoke this method.

	  </para>
          <para>
	    This method should download the data from the network and
	    before it completes, it must invoke the provided callback
	    with the appropriate status code to notify the operating
	    system of the background fetch operation (new data was
	    downloaded, there was a network connection problem or no
	    new data was found).

	  </para>
          <para>
	    Upon completion, you must notify the operating system of the result of the data transfer by invoking the provided callback.

	  </para>
          <para>
	    Important: failure to call the provided callback method
	    with the result code before this method completes will
	    cause your application to be terminated.

	  </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectedDataDidBecomeAvailable">
      <MemberSignature Language="C#" Value="public virtual void ProtectedDataDidBecomeAvailable (UIKit.UIApplication application);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ProtectedDataDidBecomeAvailable(class UIKit.UIApplication application) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplicationDelegate.ProtectedDataDidBecomeAvailable(UIKit.UIApplication)" />
      <MemberSignature Language="F#" Value="abstract member ProtectedDataDidBecomeAvailable : UIKit.UIApplication -&gt; unit&#xA;override this.ProtectedDataDidBecomeAvailable : UIKit.UIApplication -&gt; unit" Usage="uIApplicationDelegate.ProtectedDataDidBecomeAvailable application" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("applicationProtectedDataDidBecomeAvailable:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="application" Type="UIKit.UIApplication" />
      </Parameters>
      <Docs>
        <param name="application">Reference to the UIApplication that invoked this delegate method.</param>
        <summary>Indicates that the device was unlocked and previously-encrypted data is now available.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectedDataWillBecomeUnavailable">
      <MemberSignature Language="C#" Value="public virtual void ProtectedDataWillBecomeUnavailable (UIKit.UIApplication application);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ProtectedDataWillBecomeUnavailable(class UIKit.UIApplication application) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplicationDelegate.ProtectedDataWillBecomeUnavailable(UIKit.UIApplication)" />
      <MemberSignature Language="F#" Value="abstract member ProtectedDataWillBecomeUnavailable : UIKit.UIApplication -&gt; unit&#xA;override this.ProtectedDataWillBecomeUnavailable : UIKit.UIApplication -&gt; unit" Usage="uIApplicationDelegate.ProtectedDataWillBecomeUnavailable application" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("applicationProtectedDataWillBecomeUnavailable:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="application" Type="UIKit.UIApplication" />
      </Parameters>
      <Docs>
        <param name="application">Reference to the UIApplication that invoked this delegate method.</param>
        <summary>Indicates that the device is being locked and that protected files will become unavailable.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReceivedLocalNotification">
      <MemberSignature Language="C#" Value="public virtual void ReceivedLocalNotification (UIKit.UIApplication application, UIKit.UILocalNotification notification);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReceivedLocalNotification(class UIKit.UIApplication application, class UIKit.UILocalNotification notification) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplicationDelegate.ReceivedLocalNotification(UIKit.UIApplication,UIKit.UILocalNotification)" />
      <MemberSignature Language="F#" Value="abstract member ReceivedLocalNotification : UIKit.UIApplication * UIKit.UILocalNotification -&gt; unit&#xA;override this.ReceivedLocalNotification : UIKit.UIApplication * UIKit.UILocalNotification -&gt; unit" Usage="uIApplicationDelegate.ReceivedLocalNotification (application, notification)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("application:didReceiveLocalNotification:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 10, 0, ObjCRuntime.PlatformArchitecture.None, "Use 'UNUserNotificationCenterDelegate.WillPresentNotification/DidReceiveNotificationResponse' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="application" Type="UIKit.UIApplication" />
        <Parameter Name="notification" Type="UIKit.UILocalNotification" />
      </Parameters>
      <Docs>
        <param name="application">Reference to the UIApplication that invoked this delegate method.</param>
        <param name="notification">To be added.</param>
        <summary>Indicates that the application received a <see cref="T:UIKit.UILocalNotification" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReceivedRemoteNotification">
      <MemberSignature Language="C#" Value="public virtual void ReceivedRemoteNotification (UIKit.UIApplication application, Foundation.NSDictionary userInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReceivedRemoteNotification(class UIKit.UIApplication application, class Foundation.NSDictionary userInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplicationDelegate.ReceivedRemoteNotification(UIKit.UIApplication,Foundation.NSDictionary)" />
      <MemberSignature Language="F#" Value="abstract member ReceivedRemoteNotification : UIKit.UIApplication * Foundation.NSDictionary -&gt; unit&#xA;override this.ReceivedRemoteNotification : UIKit.UIApplication * Foundation.NSDictionary -&gt; unit" Usage="uIApplicationDelegate.ReceivedRemoteNotification (application, userInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("application:didReceiveRemoteNotification:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 10, 0, ObjCRuntime.PlatformArchitecture.None, "Use 'UNUserNotificationCenterDelegate.WillPresentNotification/DidReceiveNotificationResponse' for user visible notifications and 'ReceivedRemoteNotification' for silent remote notifications.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="application" Type="UIKit.UIApplication" />
        <Parameter Name="userInfo" Type="Foundation.NSDictionary" />
      </Parameters>
      <Docs>
        <param name="application">Reference to the UIApplication that invoked this delegate method.</param>
        <param name="userInfo">A dictionary whose "aps" key contains information related to the notification</param>
        <summary>Indicates that the application received a remote notification.</summary>
        <remarks>
          <para>The <paramref name="userInfo" /> dictionary will have a key <c>aps</c> that will return another <see cref="T:Foundation.NSDictionary" />. That dictionary may include the following keys:</para>
          <list type="table">
            <listheader>
              <term>Key</term>
              <description>Type</description>
              <description>Description</description>
            </listheader>
            <item>
              <term>alert</term>
              <description>String or <see cref="T:Foundation.NSDictionary" /></description>
              <description>If the value for the <c>alert</c> key is a <see langword="string" />, that string will be the text of an alert with two buttons: "Close" and "View". If the application user choose "View", the application will launch. If the value is a <see cref="T:Foundation.NSDictionary" />, it will contain a series of keys relating to localization.</description>
            </item>
            <item>
              <term>badge</term>
              <description>Integer</description>
              <description>The number to display on the badge of the app icon. If 0, the badge will be removed. If <see langword="null" />, the badge should not change.</description>
            </item>
            <item>
              <term>sound</term>
              <description>String</description>
              <description>The name of a sound file in the app bundle. If the file doesn't exist or the value is "default", the default alert sound will be played.</description>
            </item>
            <item>
              <term>content-available</term>
              <description>Integer</description>
              <description>A value of 1 indicates that new content is available. This is intended for Newsstand apps and background content downloads.</description>
            </item>
          </list>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReceiveMemoryWarning">
      <MemberSignature Language="C#" Value="public virtual void ReceiveMemoryWarning (UIKit.UIApplication application);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReceiveMemoryWarning(class UIKit.UIApplication application) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplicationDelegate.ReceiveMemoryWarning(UIKit.UIApplication)" />
      <MemberSignature Language="F#" Value="abstract member ReceiveMemoryWarning : UIKit.UIApplication -&gt; unit&#xA;override this.ReceiveMemoryWarning : UIKit.UIApplication -&gt; unit" Usage="uIApplicationDelegate.ReceiveMemoryWarning application" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("applicationDidReceiveMemoryWarning:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="application" Type="UIKit.UIApplication" />
      </Parameters>
      <Docs>
        <param name="application">Reference to the UIApplication that invoked this delegate method.</param>
        <summary>The app has received a low-memory warning from the system.</summary>
        <remarks>
          <para>Subsequent to this call, applications may be terminated by the system. Application developers should override this method and purge their applications of as much cached data as possible.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisteredForRemoteNotifications">
      <MemberSignature Language="C#" Value="public virtual void RegisteredForRemoteNotifications (UIKit.UIApplication application, Foundation.NSData deviceToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisteredForRemoteNotifications(class UIKit.UIApplication application, class Foundation.NSData deviceToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplicationDelegate.RegisteredForRemoteNotifications(UIKit.UIApplication,Foundation.NSData)" />
      <MemberSignature Language="F#" Value="abstract member RegisteredForRemoteNotifications : UIKit.UIApplication * Foundation.NSData -&gt; unit&#xA;override this.RegisteredForRemoteNotifications : UIKit.UIApplication * Foundation.NSData -&gt; unit" Usage="uIApplicationDelegate.RegisteredForRemoteNotifications (application, deviceToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("application:didRegisterForRemoteNotificationsWithDeviceToken:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="application" Type="UIKit.UIApplication" />
        <Parameter Name="deviceToken" Type="Foundation.NSData" />
      </Parameters>
      <Docs>
        <param name="application">Reference to the UIApplication that invoked this delegate method.</param>
        <param name="deviceToken">To be added.</param>
        <summary>Indicates that a call to <see cref="M:UIKit.UIApplication.RegisterForRemoteNotifications" /> succeeded.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldAllowExtensionPointIdentifier">
      <MemberSignature Language="C#" Value="public virtual bool ShouldAllowExtensionPointIdentifier (UIKit.UIApplication application, Foundation.NSString extensionPointIdentifier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ShouldAllowExtensionPointIdentifier(class UIKit.UIApplication application, class Foundation.NSString extensionPointIdentifier) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplicationDelegate.ShouldAllowExtensionPointIdentifier(UIKit.UIApplication,Foundation.NSString)" />
      <MemberSignature Language="F#" Value="abstract member ShouldAllowExtensionPointIdentifier : UIKit.UIApplication * Foundation.NSString -&gt; bool&#xA;override this.ShouldAllowExtensionPointIdentifier : UIKit.UIApplication * Foundation.NSString -&gt; bool" Usage="uIApplicationDelegate.ShouldAllowExtensionPointIdentifier (application, extensionPointIdentifier)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("application:shouldAllowExtensionPointIdentifier:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="application" Type="UIKit.UIApplication" />
        <Parameter Name="extensionPointIdentifier" Type="Foundation.NSString" />
      </Parameters>
      <Docs>
        <param name="application">To be added.</param>
        <param name="extensionPointIdentifier">To be added.</param>
        <summary>Requests permission from the app to run app extensions based on the extension point identified by <paramref name="extensionPointIdentifier" />.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldRequestHealthAuthorization">
      <MemberSignature Language="C#" Value="public virtual void ShouldRequestHealthAuthorization (UIKit.UIApplication application);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ShouldRequestHealthAuthorization(class UIKit.UIApplication application) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplicationDelegate.ShouldRequestHealthAuthorization(UIKit.UIApplication)" />
      <MemberSignature Language="F#" Value="abstract member ShouldRequestHealthAuthorization : UIKit.UIApplication -&gt; unit&#xA;override this.ShouldRequestHealthAuthorization : UIKit.UIApplication -&gt; unit" Usage="uIApplicationDelegate.ShouldRequestHealthAuthorization application" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("applicationShouldRequestHealthAuthorization:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="application" Type="UIKit.UIApplication" />
      </Parameters>
      <Docs>
        <param name="application">To be added.</param>
        <summary>The system calls this method when the developer's app should ask the user for access to HealthKit data.</summary>
        <remarks>
          <para>When overriding this method, developers should call <see cref="M:HealthKit.HKHealthStore.HandleAuthorizationForExtension(System.Action{System.Boolean,Foundation.NSError})" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldRestoreApplicationState">
      <MemberSignature Language="C#" Value="public virtual bool ShouldRestoreApplicationState (UIKit.UIApplication application, Foundation.NSCoder coder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ShouldRestoreApplicationState(class UIKit.UIApplication application, class Foundation.NSCoder coder) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplicationDelegate.ShouldRestoreApplicationState(UIKit.UIApplication,Foundation.NSCoder)" />
      <MemberSignature Language="F#" Value="abstract member ShouldRestoreApplicationState : UIKit.UIApplication * Foundation.NSCoder -&gt; bool&#xA;override this.ShouldRestoreApplicationState : UIKit.UIApplication * Foundation.NSCoder -&gt; bool" Usage="uIApplicationDelegate.ShouldRestoreApplicationState (application, coder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("application:shouldRestoreApplicationState:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="application" Type="UIKit.UIApplication" />
        <Parameter Name="coder" Type="Foundation.NSCoder" />
      </Parameters>
      <Docs>
        <param name="application">Reference to the UIApplication that invoked this delegate method.</param>
        <param name="coder">To be added.</param>
        <summary>Whether the application should restore saved state information.</summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Both this method and <see cref="M:UIKit.UIApplicationDelegate.ShouldSaveApplicationState(UIKit.UIApplication,Foundation.NSCoder)" /> must return <see langword="true" /> for state preservation and restoration to occur. These methods are convenient for testing aspects of the state preservation process. </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSaveApplicationState">
      <MemberSignature Language="C#" Value="public virtual bool ShouldSaveApplicationState (UIKit.UIApplication application, Foundation.NSCoder coder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ShouldSaveApplicationState(class UIKit.UIApplication application, class Foundation.NSCoder coder) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplicationDelegate.ShouldSaveApplicationState(UIKit.UIApplication,Foundation.NSCoder)" />
      <MemberSignature Language="F#" Value="abstract member ShouldSaveApplicationState : UIKit.UIApplication * Foundation.NSCoder -&gt; bool&#xA;override this.ShouldSaveApplicationState : UIKit.UIApplication * Foundation.NSCoder -&gt; bool" Usage="uIApplicationDelegate.ShouldSaveApplicationState (application, coder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("application:shouldSaveApplicationState:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="application" Type="UIKit.UIApplication" />
        <Parameter Name="coder" Type="Foundation.NSCoder" />
      </Parameters>
      <Docs>
        <param name="application">Reference to the UIApplication that invoked this delegate method.</param>
        <param name="coder">To be added.</param>
        <summary>Whether the application should save application state information.</summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Both this method and <see cref="M:UIKit.UIApplicationDelegate.ShouldRestoreApplicationState(UIKit.UIApplication,Foundation.NSCoder)" /> must return <see langword="true" /> for state preservation and restoration to occur. These methods are convenient for testing aspects of the state preservation process. </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserActivityUpdated">
      <MemberSignature Language="C#" Value="public virtual void UserActivityUpdated (UIKit.UIApplication application, Foundation.NSUserActivity userActivity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UserActivityUpdated(class UIKit.UIApplication application, class Foundation.NSUserActivity userActivity) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplicationDelegate.UserActivityUpdated(UIKit.UIApplication,Foundation.NSUserActivity)" />
      <MemberSignature Language="F#" Value="abstract member UserActivityUpdated : UIKit.UIApplication * Foundation.NSUserActivity -&gt; unit&#xA;override this.UserActivityUpdated : UIKit.UIApplication * Foundation.NSUserActivity -&gt; unit" Usage="uIApplicationDelegate.UserActivityUpdated (application, userActivity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("application:didUpdateUserActivity:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="application" Type="UIKit.UIApplication" />
        <Parameter Name="userActivity" Type="Foundation.NSUserActivity" />
      </Parameters>
      <Docs>
        <param name="application">To be added.</param>
        <param name="userActivity">To be added.</param>
        <summary>A user activity was updated.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UserDidAcceptCloudKitShare">
      <MemberSignature Language="C#" Value="public virtual void UserDidAcceptCloudKitShare (UIKit.UIApplication application, CloudKit.CKShareMetadata cloudKitShareMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UserDidAcceptCloudKitShare(class UIKit.UIApplication application, class CloudKit.CKShareMetadata cloudKitShareMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplicationDelegate.UserDidAcceptCloudKitShare(UIKit.UIApplication,CloudKit.CKShareMetadata)" />
      <MemberSignature Language="F#" Value="abstract member UserDidAcceptCloudKitShare : UIKit.UIApplication * CloudKit.CKShareMetadata -&gt; unit&#xA;override this.UserDidAcceptCloudKitShare : UIKit.UIApplication * CloudKit.CKShareMetadata -&gt; unit" Usage="uIApplicationDelegate.UserDidAcceptCloudKitShare (application, cloudKitShareMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("application:userDidAcceptCloudKitShareWithMetadata:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 10, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 10, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="application" Type="UIKit.UIApplication" />
        <Parameter Name="cloudKitShareMetadata" Type="CloudKit.CKShareMetadata" />
      </Parameters>
      <Docs>
        <param name="application">To be added.</param>
        <param name="cloudKitShareMetadata">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WillChangeStatusBarFrame">
      <MemberSignature Language="C#" Value="public virtual void WillChangeStatusBarFrame (UIKit.UIApplication application, CoreGraphics.CGRect newStatusBarFrame);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WillChangeStatusBarFrame(class UIKit.UIApplication application, valuetype CoreGraphics.CGRect newStatusBarFrame) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplicationDelegate.WillChangeStatusBarFrame(UIKit.UIApplication,CoreGraphics.CGRect)" />
      <MemberSignature Language="F#" Value="abstract member WillChangeStatusBarFrame : UIKit.UIApplication * CoreGraphics.CGRect -&gt; unit&#xA;override this.WillChangeStatusBarFrame : UIKit.UIApplication * CoreGraphics.CGRect -&gt; unit" Usage="uIApplicationDelegate.WillChangeStatusBarFrame (application, newStatusBarFrame)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("application:willChangeStatusBarFrame:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="application" Type="UIKit.UIApplication" />
        <Parameter Name="newStatusBarFrame" Type="CoreGraphics.CGRect" />
      </Parameters>
      <Docs>
        <param name="application">Reference to the UIApplication that invoked this delegate method.</param>
        <param name="newStatusBarFrame">To be added.</param>
        <summary>Indicates that the frame of the status bar will change shortly.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WillChangeStatusBarOrientation">
      <MemberSignature Language="C#" Value="public virtual void WillChangeStatusBarOrientation (UIKit.UIApplication application, UIKit.UIInterfaceOrientation newStatusBarOrientation, double duration);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WillChangeStatusBarOrientation(class UIKit.UIApplication application, valuetype UIKit.UIInterfaceOrientation newStatusBarOrientation, float64 duration) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplicationDelegate.WillChangeStatusBarOrientation(UIKit.UIApplication,UIKit.UIInterfaceOrientation,System.Double)" />
      <MemberSignature Language="F#" Value="abstract member WillChangeStatusBarOrientation : UIKit.UIApplication * UIKit.UIInterfaceOrientation * double -&gt; unit&#xA;override this.WillChangeStatusBarOrientation : UIKit.UIApplication * UIKit.UIInterfaceOrientation * double -&gt; unit" Usage="uIApplicationDelegate.WillChangeStatusBarOrientation (application, newStatusBarOrientation, duration)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("application:willChangeStatusBarOrientation:duration:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="application" Type="UIKit.UIApplication" />
        <Parameter Name="newStatusBarOrientation" Type="UIKit.UIInterfaceOrientation" />
        <Parameter Name="duration" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="application">Reference to the UIApplication that invoked this delegate method.</param>
        <param name="newStatusBarOrientation">To be added.</param>
        <param name="duration">To be added.</param>
        <summary>Indicates that the orientation of the status bar will change shortly.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WillContinueUserActivity">
      <MemberSignature Language="C#" Value="public virtual bool WillContinueUserActivity (UIKit.UIApplication application, string userActivityType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WillContinueUserActivity(class UIKit.UIApplication application, string userActivityType) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplicationDelegate.WillContinueUserActivity(UIKit.UIApplication,System.String)" />
      <MemberSignature Language="F#" Value="abstract member WillContinueUserActivity : UIKit.UIApplication * string -&gt; bool&#xA;override this.WillContinueUserActivity : UIKit.UIApplication * string -&gt; bool" Usage="uIApplicationDelegate.WillContinueUserActivity (application, userActivityType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("application:willContinueUserActivityWithType:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="application" Type="UIKit.UIApplication" />
        <Parameter Name="userActivityType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="application">The <see cref="T:UIKit.UIApplication" /> singleton for the app.</param>
        <param name="userActivityType">The user activity identifier.</param>
        <summary>Informs the app that the user is attempting to continue a <paramref name="userActivityType" /> action for which data might not be available, and returns to notify the user that the app will continue the activity.</summary>
        <returns>
          <see langword="true" /> if this app is prepared to continue the activity.</returns>
        <remarks>
          <para>This method is a re-entry point for user activities (e.g., Handoff activities). An application indicates interest in a particular <paramref name="userActivityType" /> by adding the value to it's <c>info.plist</c> as a <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=System%20String&amp;scope=Xamarin" title="T:System.String">T:System.String</a></format> value in an array called <c>NSUserActivityType</c>. By convention, the activity type begins with a domain-reversed string identifying the developer:</para>
          <example>
            <code lang="xml"><![CDATA[
<key>NSUserActivityTypes</key>
<array>
		<string>com.xamarin.HandOffDemo.verb</string>
</array>              
              ]]></code>
          </example>
          <para>A client app initiates a Handoff-related user activity by calling, for instance, <see cref="M:WatchKit.WKInterfaceController.UpdateUserActivity(System.String,Foundation.NSDictionary,Foundation.NSUrl)" /> with a matching <paramref name="userActivityType" />. This <see cref="M:UIKit.UIApplicationDelegate.WillContinueUserActivity(UIKit.UIApplication,System.String)" /> method begins the Handoff-related re-entry to the app.</para>
          <para>App devs should override this method to return a <see cref="T:System.Boolean" /> indicating whether or not the app is capable of completing the user activity. If this method returns <see langword="true" />, the system will shortly call the method <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=UIKit%20UIApplication%20Continue%20User%20Activity&amp;scope=Xamarin" title="M:UIKit.UIApplication.ContinueUserActivity*">M:UIKit.UIApplication.ContinueUserActivity*</a></format>.  </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WillEncodeRestorableState">
      <MemberSignature Language="C#" Value="public virtual void WillEncodeRestorableState (UIKit.UIApplication application, Foundation.NSCoder coder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WillEncodeRestorableState(class UIKit.UIApplication application, class Foundation.NSCoder coder) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplicationDelegate.WillEncodeRestorableState(UIKit.UIApplication,Foundation.NSCoder)" />
      <MemberSignature Language="F#" Value="abstract member WillEncodeRestorableState : UIKit.UIApplication * Foundation.NSCoder -&gt; unit&#xA;override this.WillEncodeRestorableState : UIKit.UIApplication * Foundation.NSCoder -&gt; unit" Usage="uIApplicationDelegate.WillEncodeRestorableState (application, coder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("application:willEncodeRestorableStateWithCoder:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="application" Type="UIKit.UIApplication" />
        <Parameter Name="coder" Type="Foundation.NSCoder" />
      </Parameters>
      <Docs>
        <param name="application">Reference to the UIApplication that invoked this delegate method.</param>
        <param name="coder">To be added.</param>
        <summary>Indicates that the app is about to store application state data.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WillEnterForeground">
      <MemberSignature Language="C#" Value="public virtual void WillEnterForeground (UIKit.UIApplication application);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WillEnterForeground(class UIKit.UIApplication application) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplicationDelegate.WillEnterForeground(UIKit.UIApplication)" />
      <MemberSignature Language="F#" Value="abstract member WillEnterForeground : UIKit.UIApplication -&gt; unit&#xA;override this.WillEnterForeground : UIKit.UIApplication -&gt; unit" Usage="uIApplicationDelegate.WillEnterForeground application" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("applicationWillEnterForeground:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="application" Type="UIKit.UIApplication" />
      </Parameters>
      <Docs>
        <param name="application">Reference to the UIApplication that invoked this delegate method.</param>
        <summary>Called prior to the application returning from a backgrounded state.</summary>
        <remarks>
          <para>Immediately after this call, the application will call <see cref="M:UIKit.UIApplicationDelegate.OnActivated(UIKit.UIApplication)" />.</para>
        </remarks>
        <altmember cref="M:UIKit.UIApplicationDelegate.DidEnterBackground" />
      </Docs>
    </Member>
    <Member MemberName="WillFinishLaunching">
      <MemberSignature Language="C#" Value="public virtual bool WillFinishLaunching (UIKit.UIApplication application, Foundation.NSDictionary launchOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WillFinishLaunching(class UIKit.UIApplication application, class Foundation.NSDictionary launchOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplicationDelegate.WillFinishLaunching(UIKit.UIApplication,Foundation.NSDictionary)" />
      <MemberSignature Language="F#" Value="abstract member WillFinishLaunching : UIKit.UIApplication * Foundation.NSDictionary -&gt; bool&#xA;override this.WillFinishLaunching : UIKit.UIApplication * Foundation.NSDictionary -&gt; bool" Usage="uIApplicationDelegate.WillFinishLaunching (application, launchOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("application:willFinishLaunchingWithOptions:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="application" Type="UIKit.UIApplication" />
        <Parameter Name="launchOptions" Type="Foundation.NSDictionary" />
      </Parameters>
      <Docs>
        <param name="application">Reference to the UIApplication that invoked this delegate method.</param>
        <param name="launchOptions">An NSDictionary with the launch options, can be null.   Possible key values are UIApplication's LaunchOption static properties.</param>
        <summary>Indicates that launching has begun, but state restoration has not yet occurred.</summary>
        <returns>False if the application is unable to handle the specified url, true otherwise.</returns>
        <remarks>
          <para>
	    This is the first method called when your UIApplication
	    has been created, and by the time this is called, the
	    storyboard or NIB files would have been loaded.  When you
	    return from this call, the state restoration protocol will
	    take place, and after that, the <see cref="M:UIKit.UIApplicationDelegate_Extensions.FinishedLaunching(UIKit.IUIApplicationDelegate,UIKit.UIApplication,Foundation.NSDictionary)" />
	    method will be invoked to complete the application
	    startup.
	  </para>
          <para>
	    The dictionary launchOptions if set, might contain zero or more information bits.   You can use the following keys to retrieve information from it: 
	  </para>
          <list type="table">
            <listheader>
              <term>Dictionary Key for launchOptions</term>
              <description>Description</description>
            </listheader>
            <item>
              <term>
                <see cref="P:UIKit.UIApplication.LaunchOptionsUrlKey" />
              </term>
              <description>The application was launched in response to open a URL.  the value associated with the key contains the URL to open.</description>
            </item>
            <item>
              <term>
                <see cref="P:UIKit.UIApplication.LaunchOptionsAnnotationKey" />
              </term>
              <description>Use this key to find out if custom data was passed to the program by the opening application.   The value of this key will be a property list. </description>
            </item>
            <item>
              <term>
                <see cref="P:UIKit.UIApplication.LaunchOptionsLocalNotificationKey" />
              </term>
              <description>
                <para>
		  The value of this key will be a <see cref="T:UIKit.UILocalNotification" /> instance.
		</para>
                <para>
		  This key will be present on the launch options if a local notification was delivered and the application was not running.
		</para>
              </description>
            </item>
            <item>
              <term>
                <see cref="P:UIKit.UIApplication.LaunchOptionsLocationKey" />
              </term>
              <description>
                <para>
		  Application was started up in response to a location event.
		</para>
                <para>
		  The value of this key will be an NSNumber.   The application should respond by creating a <see cref="T:CoreLocation.CLLocationManager" /> instance to and get the information from that object.
		</para>
              </description>
            </item>
            <item>
              <term>
                <see cref="P:UIKit.UIApplication.LaunchOptionsNewsstandDownloadsKey" />
              </term>
              <description>
                <para>This key indicates that Newsstand has completed downloading the requested data. </para>
                <para>The value in the dictionary for this key, contains an array of strings that represent <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=T:Newsstand.NKAssetDownload&amp;scope=Xamarin" title="T:Newsstand.NKAssetDownload">T:Newsstand.NKAssetDownload</a></format> objects.</para>
              </description>
            </item>
            <item>
              <term>
                <see cref="P:UIKit.UIApplication.LaunchOptionsRemoteNotificationKey" />
              </term>
              <description>The value associated with this key will be an NSDictionary with the payload from the remote notification that was received. </description>
            </item>
            <item>
              <term>
                <see cref="P:UIKit.UIApplication.LaunchOptionsSourceApplicationKey" />
              </term>
              <description>The value associated with the key is the bundle-id of the application that launched this application.</description>
            </item>
            <item>
              <term>
                <see cref="P:UIKit.UIApplication.LaunchOptionsBluetoothPeripheralsKey" />
              </term>
              <description>
                <para>
		  If this key is present, this means that the
		  Bluetooth subsystem has launched the application to
		  restore a previous operation that was being done by
		  an <see cref="T:CoreBluetooth.CBPeripheralManager" />
		  objects.
		</para>
                <para>
		  The value of the key is an array of strings, each being the keys that you used when you created a CBPeripheralManager.
		</para>
              </description>
            </item>
            <item>
              <term>
                <see cref="P:UIKit.UIApplication.LaunchOptionsBluetoothCentralsKey" />
              </term>
              <description>
                <para>
		  If this key is present, this means that the
		  Bluetooth subsystem has launched the application to
		  restore a previous operation that was being done by
		  an <see cref="T:CoreBluetooth.CBCentralManager" />
		  objects.
		</para>
                <para>
		  The value of the key is an array of strings, each being the keys that you used when you created a CBPeripheralManager.
		</para>
              </description>
            </item>
          </list>
          <para>
	    If the application is designed to handle urls, it should
	    lookup the <see cref="P:UIKit.UIApplication.LaunchOptionsUrlKey" /> key in the launchOptions to extract the url that is
	    being launched, and return true at the end of the method
	    to indicate that the application is able to load that url,
	    or false if it is not.

	  </para>
          <example>
            <code lang="C#"><![CDATA[
[Register ("AppDelegate")]
public partial class AppDelegate : UIApplicationDelegate
{
    UIWindow window;

    public override bool WillFinishLaunching (UIApplication app, NSDictionary options)
    {
        if (options != null){
	    NSObject urlObject;
	    if (options.TryGetValue (UIApplication.LaunchOptionsUrlKey, out urlObject)){
	        var url = urlObject as NSUrl;

		// Examine the url here
		return CanHandle (url);
	    }
        }
    	return true;
    }
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WillTerminate">
      <MemberSignature Language="C#" Value="public virtual void WillTerminate (UIKit.UIApplication application);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WillTerminate(class UIKit.UIApplication application) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplicationDelegate.WillTerminate(UIKit.UIApplication)" />
      <MemberSignature Language="F#" Value="abstract member WillTerminate : UIKit.UIApplication -&gt; unit&#xA;override this.WillTerminate : UIKit.UIApplication -&gt; unit" Usage="uIApplicationDelegate.WillTerminate application" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("applicationWillTerminate:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="application" Type="UIKit.UIApplication" />
      </Parameters>
      <Docs>
        <param name="application">Reference to the UIApplication that invoked this delegate method.</param>
        <summary>Called if the application is being terminated due to memory constraints or directly by the user.</summary>
        <remarks>
          <para>iOS applications are expected to be long-lived, with many transitions between activated and non-activated states (see <see cref="M:UIKit.UIApplicationDelegate.OnActivated(UIKit.UIApplication)" />, <see cref="M:UIKit.UIApplicationDelegate.OnResignActivation(UIKit.UIApplication)" />) and are typically only terminated by user command or, rarely, due to memory exhaustion (see <see cref="M:UIKit.UIApplicationDelegate.ReceiveMemoryWarning(UIKit.UIApplication)" />).</para>
          <para>
            <img href="~/UIKit/_images/UIApplicationDelegate.Lifecycle.png" />
          </para>
        </remarks>
        <altmember cref="M:UIKit.UIApplicationDelegate.OnResignActivation" />
        <altmember cref="M:UIKit.UIApplicationDelegate.WillEnterBackground" />
      </Docs>
    </Member>
    <Member MemberName="Window">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIWindow Window { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIWindow Window" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplicationDelegate.Window" />
      <MemberSignature Language="F#" Value="member this.Window : UIKit.UIWindow with get, set" Usage="UIKit.UIApplicationDelegate.Window" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("window", ObjCRuntime.ArgumentSemantic.Strong)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setWindow:", ObjCRuntime.ArgumentSemantic.Strong)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIWindow</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The window used to display the app on the device's main screen.</summary>
        <value>
          <para>(More documentation for this node is coming)</para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
