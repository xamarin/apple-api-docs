<Type Name="UIApplication" FullName="UIKit.UIApplication">
  <TypeSignature Language="C#" Value="public class UIApplication : UIKit.UIResponder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit UIApplication extends UIKit.UIResponder" />
  <TypeSignature Language="DocId" Value="T:UIKit.UIApplication" />
  <TypeSignature Language="F#" Value="type UIApplication = class&#xA;    inherit UIResponder" />
  <AssemblyInfo>
    <AssemblyName>Xamarin.iOS</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>UIKit.UIResponder</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Foundation.Register("UIApplication", true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Encapsulates the main processing loop for a MonoTouch application.</summary>
    <remarks>
      <para> 
	The <see cref="T:UIKit.UIApplication" />
	encapsulates the central administrative properties of an
	application running on iOS. Application developers must not
	instantiate new <see cref="T:UIKit.UIApplication" />s using constructors, but instead must use the static <see cref="P:UIKit.UIApplication.SharedApplication" />
        singleton property. Application developers may subclass <see cref="T:UIKit.UIApplication" /> and use the <c>principalClassName</c> argument to the <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=M:UIKit.UIApplication.Main(string[],string,string)&amp;scope=Xamarin" title="M:UIKit.UIApplication.Main(string[],string,string)">M:UIKit.UIApplication.Main(string[],string,string)</a></format> method to specify their subclass. In that situation, developers must create a public constructor for their subclass that the runtime will call appropriately. Subsequently, the <see cref="P:UIKit.UIApplication.SharedApplication" /> singleton will refer to the instance of their subclass.</para>
      <para> 
	Unlike with most classes in the <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=UIKit&amp;scope=Xamarin" title="N:UIKit">N:UIKit</a></format> namespace, events relating to the
        <see cref="T:UIKit.UIApplication" /> cannot be
        handled using C#-style events but rather only by the
        Objective-C style <see cref="T:UIKit.UIApplicationDelegate" /> delegate
        style.  </para>
      <para> 
	The <see cref="T:UIKit.UIApplication" /> object
        is responsible for maintaining the highest-level context of
        the application, such as the <see cref="P:UIKit.UIApplication.ApplicationState" />,
        the set of open windows (<see cref="P:UIKit.UIApplication.Windows" />), and
        functions relating to notifications (see also <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=T:UIKit.UIAppearance+Notifications.xml&amp;scope=Xamarin" title="T:UIKit.UIAppearance+Notifications.xml">T:UIKit.UIAppearance+Notifications.xml</a></format>). Additionally, the <see cref="M:UIKit.UIApplication.#ctor" /> method may
        be used to launch another application.  </para>
      <para> 
	The <see cref="T:UIKit.UIApplication" /> class
        contains methods relating to background processing, such as
        <see cref="M:UIKit.UIApplication.EnsureUIThread" />,
        <see cref="M:UIKit.UIApplication.BeginBackgroundTask(System.String,System.Action)" />,
        and <see cref="M:UIKit.UIApplication.EndBackgroundTask(System.nint)" />.
        </para>
      <format type="text/html">
        <h2>Background Fetch</h2>
      </format>
      <para> 
	Starting with iOS 7, applications can request that they be
	woken up to download data from the server in the background.
	When this feature is enabled, the operating system will resume
	the application or launch the application at some point to
	allow the application to download any new contents it needs
	from the server.

      </para>
      <para>
	To use this, applications need to have the "fetch" background
	operation requested on their requested Entitlements as well as
	calling the <see cref="M:UIKit.UIApplication.SetMinimumBackgroundFetchInterval(System.Double)" />
	method with the desired wake up interval at launch.   

      </para>
      <para>
	When the operating system determines that the application
	should be resumed to download data, the <see cref="M:UIKit.UIApplicationDelegate.PerformFetch(UIKit.UIApplication,System.Action{UIKit.UIBackgroundFetchResult})" />
	method will be invoked.  This method should perform any
	downloads and then notify the operating system of the result
	of the operation.

      </para>
      <para>
	Applications do not really have control of when the
	application will be launched.  The actual launch time is
	determined by a set of heuristics based that the operating
	system tracks based on how the user uses the application, as
	well as tracking the status of previous download operations
	that the application has done.

      </para>
      <format type="text/html">
        <h2>Remote Notifications</h2>
      </format>
      <para> 
	Starting with iOS 7, applications can request that they be
	woken up when a remote notification is received.  When this
	feature is enabled, the operating system will resume the
	application and invoke the <see cref="M:UIKit.UIApplicationDelegate_Extensions.DidReceiveRemoteNotification(UIKit.IUIApplicationDelegate,UIKit.UIApplication,Foundation.NSDictionary,System.Action{UIKit.UIBackgroundFetchResult})" />
	overload that takes a completion handler parameter and let it
	run.

      </para>
      <para>
	To use this, applications need to have the "remote-notification" background
	operation requested on their requested Entitlements as.

      </para>
    </remarks>
    <related type="externalDocumentation" href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIApplication_Class/index.html">Apple documentation for <c>UIApplication</c></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIApplication ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplication.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("init")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Default constructor that initializes a new instance of this class with no parameters.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected UIApplication (Foundation.NSObjectFlag t);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class Foundation.NSObjectFlag t) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplication.#ctor(Foundation.NSObjectFlag)" />
      <MemberSignature Language="F#" Value="new UIKit.UIApplication : Foundation.NSObjectFlag -&gt; UIKit.UIApplication" Usage="new UIKit.UIApplication t" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="t" Type="Foundation.NSObjectFlag" />
      </Parameters>
      <Docs>
        <param name="t">Unused sentinel value, pass NSObjectFlag.Empty.</param>
        <summary>Constructor to call on derived classes to skip initialization and merely allocate the object.</summary>
        <remarks>
          <para>This constructor should be called by derived classes when they completely construct the object in managed code and merely want the runtime to allocate and initialize the NSObject.   This is required to implement the two-step initialization process that Objective-C uses, the first step is to perform the object allocation, the second step is to initialize the object.   When developers invoke the constructor that takes the NSObjectFlag.Empty they take advantage of a direct path that goes all the way up to NSObject to merely allocate the object's memory and bind the Objective-C and C# objects together.    The actual initialization of the object is up to the developer.</para>
          <para>This constructor is typically used by the binding generator to allocate the object, but prevent the actual initialization to take place.   Once the allocation has taken place, the constructor has to initialize the object.   With constructors generated by the binding generator this means that it manually invokes one of the "init" methods to initialize the object.</para>
          <para>It is the developer's responsibility to completely initialize the object if they chain up using the NSObjectFlag.Empty path.</para>
          <para>In general, if the developer's constructor invokes the NSObjectFlag.Empty base implementation, then it should be calling an Objective-C init method.   If this is not the case, developers should instead chain to the proper constructor in their class. </para>
          <para>The argument value is ignored and merely ensures that the only code that is executed is the construction phase is the basic NSObject allocation and runtime type registration.  Typically the chaining would look like this:</para>
          <example>
            <code lang="C#"><![CDATA[
//
// The NSObjectFlag merely allocates the object and registers the
// C# class with the Objective-C runtime if necessary, but no actual
// initXxx method is invoked, that is done later in the constructor
//
// This is taken from Xamarin.iOS's source code:
//
[Export ("initWithFrame:")]
public UIView (System.Drawing.RectangleF frame) : base (NSObjectFlag.Empty)
{
// Invoke the init method now.
	var initWithFrame = new Selector ("initWithFrame:").Handle;
	if (IsDirectBinding)
		Handle = ObjCRuntime.Messaging.IntPtr_objc_msgSend_CGRect (this.Handle, initWithFrame, frame);
	else
		Handle = ObjCRuntime.Messaging.IntPtr_objc_msgSendSuper_CGRect (this.SuperHandle, initWithFrame, frame);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected internal UIApplication (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig specialname rtspecialname instance void .ctor(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplication.#ctor(System.IntPtr)" />
      <MemberSignature Language="F#" Value="new UIKit.UIApplication : nativeint -&gt; UIKit.UIApplication" Usage="new UIKit.UIApplication handle" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Pointer (handle) to the unmanaged object.</param>
        <summary>A constructor used when creating managed representations of unmanaged objects;  Called by the runtime.</summary>
        <remarks>
          <para>This constructor is invoked by the runtime infrastructure (<see cref="M:ObjCRuntime.Runtime.GetNSObject(System.IntPtr)" />) to create a new managed representation for a pointer to an unmanaged Objective-C object.    Developers should not invoke this method directly, instead they should call the GetNSObject method as it will prevent two instances of a managed object to point to the same native object.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AlternateIconName">
      <MemberSignature Language="C#" Value="public virtual string AlternateIconName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AlternateIconName" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.AlternateIconName" />
      <MemberSignature Language="F#" Value="member this.AlternateIconName : string" Usage="UIKit.UIApplication.AlternateIconName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 10, 3, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 10, 2, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("alternateIconName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 10, 3, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 10, 2, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the name of the alternate icon for this application, if present.</summary>
        <value>If <see cref="P:UIKit.UIApplication.SupportsAlternateIcons" /> is <see langword="false" /> then this property returns <see langword="null" />.<para tool="nullallowed">This value can be <see langword="null" />.</para></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationIconBadgeNumber">
      <MemberSignature Language="C#" Value="public virtual nint ApplicationIconBadgeNumber { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.nint ApplicationIconBadgeNumber" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.ApplicationIconBadgeNumber" />
      <MemberSignature Language="F#" Value="member this.ApplicationIconBadgeNumber : nint with get, set" Usage="UIKit.UIApplication.ApplicationIconBadgeNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 10, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("applicationIconBadgeNumber")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 10, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setApplicationIconBadgeNumber:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 10, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.nint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Numeric value to display as the application badge number.</summary>
        <value>
        </value>
        <remarks>
          <para>
          When this value is zero, no badge is displayed.  When this
          value is different than zero, the value is displayed as a
          badge on the application's icon by the operating system.
        </para>
          <para />
          <para>Starting with iOS 8.0, your application needs to register for user notifications to be able to set the application icon badge number.   You do this by calling the <see cref="M:UIKit.UIApplication.RegisterUserNotificationSettings(UIKit.UIUserNotificationSettings)" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationState">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIApplicationState ApplicationState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype UIKit.UIApplicationState ApplicationState" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.ApplicationState" />
      <MemberSignature Language="F#" Value="member this.ApplicationState : UIKit.UIApplicationState" Usage="UIKit.UIApplication.ApplicationState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("applicationState")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIApplicationState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reflects the current application state.</summary>
        <value>The current application state.</value>
        <remarks>
          <para> 
            When the user taps on the app icon, the app briefly
            goes through a transitional state of
            UIApplicationState.Inactive on its way to becoming
            UIApplicationState.Active. This is where the app gets
            itself ready to display to the user.
          </para>
          <para>
            When the app is open, the application state is UIApplicationState.Active.
          </para>
          <para>
            If the user presses the home button, and is returned to
            the springboard (home screen), or the application is
            interrupted by something, such as a phone call, the
            application state transitions back to
            UIApplicationState.Inactive.
          </para>
          <para> 
            For the application state of the app to become <see cref="F:UIKit.UIApplicationState.Background" />
the application would have to register for a background process. 
          </para>
          <para>
            Reference: https://stackoverflow.com/questions/7937400/need-clarification-about-uiapplicationstate
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationSupportsShakeToEdit">
      <MemberSignature Language="C#" Value="public virtual bool ApplicationSupportsShakeToEdit { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ApplicationSupportsShakeToEdit" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.ApplicationSupportsShakeToEdit" />
      <MemberSignature Language="F#" Value="member this.ApplicationSupportsShakeToEdit : bool with get, set" Usage="UIKit.UIApplication.ApplicationSupportsShakeToEdit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("applicationSupportsShakeToEdit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setApplicationSupportsShakeToEdit:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Controls whether shaking the device will bring up the undo/redo buttons.</summary>
        <value>It defaults to true, so all applications by default support undo/redo by shaking.</value>
        <remarks>
          Set this value to false if you want to disable the default behavior that shows an undo/redo dialog box on shake.
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundFetchIntervalMinimum">
      <MemberSignature Language="C#" Value="public static double BackgroundFetchIntervalMinimum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property float64 BackgroundFetchIntervalMinimum" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.BackgroundFetchIntervalMinimum" />
      <MemberSignature Language="F#" Value="member this.BackgroundFetchIntervalMinimum : double" Usage="UIKit.UIApplication.BackgroundFetchIntervalMinimum" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIApplicationBackgroundFetchIntervalMinimum", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UIApplicationBackgroundFetchIntervalMinimum</summary>
        <value>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundFetchIntervalNever">
      <MemberSignature Language="C#" Value="public static double BackgroundFetchIntervalNever { get; }" />
      <MemberSignature Language="ILAsm" Value=".property float64 BackgroundFetchIntervalNever" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.BackgroundFetchIntervalNever" />
      <MemberSignature Language="F#" Value="member this.BackgroundFetchIntervalNever : double" Usage="UIKit.UIApplication.BackgroundFetchIntervalNever" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIApplicationBackgroundFetchIntervalNever", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UIApplicationBackgroundFetchIntervalNever</summary>
        <value>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundRefreshStatus">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIBackgroundRefreshStatus BackgroundRefreshStatus { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype UIKit.UIBackgroundRefreshStatus BackgroundRefreshStatus" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.BackgroundRefreshStatus" />
      <MemberSignature Language="F#" Value="member this.BackgroundRefreshStatus : UIKit.UIBackgroundRefreshStatus" Usage="UIKit.UIApplication.BackgroundRefreshStatus" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("backgroundRefreshStatus")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIBackgroundRefreshStatus</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether background processing is allowed, denied, or restricted.</summary>
        <value>Returns a read-only status that specifies whether the app can be launched into the background to handle background behaviors.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundRefreshStatusDidChangeNotification">
      <MemberSignature Language="C#" Value="public static Foundation.NSString BackgroundRefreshStatusDidChangeNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString BackgroundRefreshStatusDidChangeNotification" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.BackgroundRefreshStatusDidChangeNotification" />
      <MemberSignature Language="F#" Value="member this.BackgroundRefreshStatusDidChangeNotification : Foundation.NSString" Usage="UIKit.UIApplication.BackgroundRefreshStatusDidChangeNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Use UIApplication.Notifications.ObserveBackgroundRefreshStatusDidChange helper method instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Field("UIApplicationBackgroundRefreshStatusDidChangeNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for BackgroundRefreshStatusDidChange</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIKit.UIApplication.Notifications" />.<format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=M:UIKit.UIKit.UIApplication.Notifications.ObserveBackgroundRefreshStatusDidChange*&amp;scope=Xamarin" title="M:UIKit.UIKit.UIApplication.Notifications.ObserveBackgroundRefreshStatusDidChange*">M:UIKit.UIKit.UIApplication.Notifications.ObserveBackgroundRefreshStatusDidChange*</a></format> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="C#"><![CDATA[
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveBackgroundRefreshStatusDidChange ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, Foundation.NSNotificationEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveBackgroundRefreshStatusDidChange (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.BackgroundRefreshStatusDidChangeNotification, (notification) => {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.BackgroundRefreshStatusDidChangeNotification, Callback);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundTaskInvalid">
      <MemberSignature Language="C#" Value="public static nint BackgroundTaskInvalid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.nint BackgroundTaskInvalid" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.BackgroundTaskInvalid" />
      <MemberSignature Language="F#" Value="member this.BackgroundTaskInvalid : nint" Usage="UIKit.UIApplication.BackgroundTaskInvalid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIBackgroundTaskInvalid", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.nint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UIBackgroundTaskInvalid</summary>
        <value>Returns a token that indicates an invalid task request.
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundTimeRemaining">
      <MemberSignature Language="C#" Value="public virtual double BackgroundTimeRemaining { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 BackgroundTimeRemaining" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.BackgroundTimeRemaining" />
      <MemberSignature Language="F#" Value="member this.BackgroundTimeRemaining : double" Usage="UIKit.UIApplication.BackgroundTimeRemaining" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("backgroundTimeRemaining")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The number of seconds that the application has left to run in the background.</summary>
        <value>
        </value>
        <remarks>
          <para>
          </para>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginBackgroundTask">
      <MemberSignature Language="C#" Value="public virtual nint BeginBackgroundTask (Action backgroundTimeExpired);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.nint BeginBackgroundTask(class System.Action backgroundTimeExpired) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplication.BeginBackgroundTask(System.Action)" />
      <MemberSignature Language="F#" Value="abstract member BeginBackgroundTask : Action -&gt; nint&#xA;override this.BeginBackgroundTask : Action -&gt; nint" Usage="uIApplication.BeginBackgroundTask backgroundTimeExpired" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Overriding this method requires a call to the overriden method.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Export("beginBackgroundTaskWithExpirationHandler:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.RequiresSuper</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.nint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backgroundTimeExpired" Type="System.Action">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="backgroundTimeExpired">
          <para>Action that runs when background time expires.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Indicates the inception of a new long-running background task.</summary>
        <returns>An id that, when passed to <see cref="M:UIKit.UIApplication.EndBackgroundTask(System.nint)" />, indicates that background processing has ended.</returns>
        <remarks>
          <para>This method, with <see cref="M:UIKit.UIApplication.EndBackgroundTask(System.nint)" />, bookends code that should be allowed to continue running in the background when another app is in the foreground. The returned <see langword="int" /> should be passed to <see cref="M:UIKit.UIApplication.EndBackgroundTask(System.nint)" /> at the appropriate time. </para>
          <para>This method does not cause the app to enter a background state or launch asynchronous code, despite its name. Rather, it requests that the system make background processing available.</para>
          <para>This method may be called multiple times and may be called from background threads. Background processing will continue either until the allowed background time (generally 3 or 10 minutes total) expires or until <see cref="M:UIKit.UIApplication.EndBackgroundTask(System.nint)" /> has been called for all started tasks.</para>
          <para>The <paramref name="expirationHandler" /> is only called if allowed background time is close to expiring (3-4 seconds).</para>
          <para>
            <see cref="M:UIKit.UIApplication.EndBackgroundTask(System.nint)" /> must be called within the expiration handler, as well as in the normal course of execution.</para>
          <example>
            <code lang="C#"><![CDATA[
Task.Factory.StartNew( () => {
    //expirationHandler only called if background time allowed exceeded
    var taskId = UIApplication.SharedApplication.BeginBackgroundTask(() => {
        Console.WriteLine("Exhausted time");
        UIApplication.SharedApplication.EndBackgroundTask(taskId); 
    });
    while(myFlag == true)
    {
        Console.WriteLine(UIApplication.SharedApplication.TimeRemaining);
        myFlag = SomeCalculationNeedsMoreTime();
    }
    //Only called if loop terminated due to myFlag and not expiration of time
    UIApplication.SharedApplication.EndBackgroundTask(taskId);
});              
              ]]></code>
          </example>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginBackgroundTask">
      <MemberSignature Language="C#" Value="public virtual nint BeginBackgroundTask (string taskName, Action expirationHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.nint BeginBackgroundTask(string taskName, class System.Action expirationHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplication.BeginBackgroundTask(System.String,System.Action)" />
      <MemberSignature Language="F#" Value="abstract member BeginBackgroundTask : string * Action -&gt; nint&#xA;override this.BeginBackgroundTask : string * Action -&gt; nint" Usage="uIApplication.BeginBackgroundTask (taskName, expirationHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Overriding this method requires a call to the overriden method.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Export("beginBackgroundTaskWithName:expirationHandler:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.RequiresSuper</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.nint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="taskName" Type="System.String" />
        <Parameter Name="expirationHandler" Type="System.Action">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="taskName">A name for the task (useful for debugging).</param>
        <param name="expirationHandler">Called shortly before the allowed background time for the app expires.</param>
        <summary>Requests that the app be allowed to process in the background.</summary>
        <returns>An id that, when passed to <see cref="M:UIKit.UIApplication.EndBackgroundTask(System.nint)" />, indicates that background processing has ended.</returns>
        <remarks>
          <para>This method, with <see cref="M:UIKit.UIApplication.EndBackgroundTask(System.nint)" />, bookends code that should be allowed to continue running in the background when another app is in the foreground. The returned <see langword="int" /> should be passed to <see cref="M:UIKit.UIApplication.EndBackgroundTask(System.nint)" /> at the appropriate time. </para>
          <para>This method does not cause the app to enter a background state or launch asynchronous code, despite its name. Rather, it requests that the system make background processing available.</para>
          <para>This method may be called multiple times and may be called from background threads. Background processing will continue either until the allowed background time (generally 3 or 10 minutes total) expires or until <see cref="M:UIKit.UIApplication.EndBackgroundTask(System.nint)" /> has been called for all started tasks.</para>
          <para>The <paramref name="expirationHandler" /> is only called if allowed background time is close to expiring (3-4 seconds).</para>
          <para>
            <see cref="M:UIKit.UIApplication.EndBackgroundTask(System.nint)" /> must be called within the expiration handler, as well as in the normal course of execution.</para>
          <example>
            <code lang="C#"><![CDATA[
Task.Factory.StartNew( () => {
    //expirationHandler only called if background time allowed exceeded
    var taskId = UIApplication.SharedApplication.BeginBackgroundTask("bgTask", () => {
        Console.WriteLine("Exhausted time");
        UIApplication.SharedApplication.EndBackgroundTask(taskId);        
    });
    while(myFlag == true)
    {
        Console.WriteLine(UIApplication.SharedApplication.TimeRemaining);
        myFlag = SomeCalculationNeedsMoreTime();
    }
    //Only called if loop terminated due to myFlag and not expiration of time
    UIApplication.SharedApplication.EndBackgroundTask(taskId);
});              
              ]]></code>
          </example>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginIgnoringInteractionEvents">
      <MemberSignature Language="C#" Value="public virtual void BeginIgnoringInteractionEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginIgnoringInteractionEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplication.BeginIgnoringInteractionEvents" />
      <MemberSignature Language="F#" Value="abstract member BeginIgnoringInteractionEvents : unit -&gt; unit&#xA;override this.BeginIgnoringInteractionEvents : unit -&gt; unit" Usage="uIApplication.BeginIgnoringInteractionEvents " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("beginIgnoringInteractionEvents")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stops the application from receiving touch events.</summary>
        <remarks>
          <para>
            This method is sometimes used by developers that want to
            prevent touch events to be delivered during an animation.
            
          </para>
          <para>
            To resume receiving touch events, call the <see cref="M:UIKit.UIApplication.EndIgnoringInteractionEvents" />.
          </para>
          <para>This method is not available in Extensions.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginReceivingRemoteControlEvents">
      <MemberSignature Language="C#" Value="public virtual void BeginReceivingRemoteControlEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginReceivingRemoteControlEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplication.BeginReceivingRemoteControlEvents" />
      <MemberSignature Language="F#" Value="abstract member BeginReceivingRemoteControlEvents : unit -&gt; unit&#xA;override this.BeginReceivingRemoteControlEvents : unit -&gt; unit" Usage="uIApplication.BeginReceivingRemoteControlEvents " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("beginReceivingRemoteControlEvents")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indicates that the application should start listening for remote-control events.</summary>
        <remarks>
          <para>Remote-control events are generated by external devices such as headsets intended to control multimedia playback.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CancelAllLocalNotifications">
      <MemberSignature Language="C#" Value="public virtual void CancelAllLocalNotifications ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CancelAllLocalNotifications() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplication.CancelAllLocalNotifications" />
      <MemberSignature Language="F#" Value="abstract member CancelAllLocalNotifications : unit -&gt; unit&#xA;override this.CancelAllLocalNotifications : unit -&gt; unit" Usage="uIApplication.CancelAllLocalNotifications " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("cancelAllLocalNotifications")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 10, 0, ObjCRuntime.PlatformArchitecture.None, "Use 'UNUserNotificationCenter.RemoveAllPendingNotificationRequests' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Developers should not use this deprecated method. Developers should use 'UNUserNotificationCenter.RemoveAllPendingNotificationRequests' instead.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CancelLocalNotification">
      <MemberSignature Language="C#" Value="public virtual void CancelLocalNotification (UIKit.UILocalNotification notification);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CancelLocalNotification(class UIKit.UILocalNotification notification) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplication.CancelLocalNotification(UIKit.UILocalNotification)" />
      <MemberSignature Language="F#" Value="abstract member CancelLocalNotification : UIKit.UILocalNotification -&gt; unit&#xA;override this.CancelLocalNotification : UIKit.UILocalNotification -&gt; unit" Usage="uIApplication.CancelLocalNotification notification" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("cancelLocalNotification:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 10, 0, ObjCRuntime.PlatformArchitecture.None, "Use 'UNUserNotificationCenter.RemovePendingNotificationRequests' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="notification" Type="UIKit.UILocalNotification" />
      </Parameters>
      <Docs>
        <param name="notification">The local notification that is cancelled.</param>
        <summary>Cancels a local notification.</summary>
        <remarks>If the notification is currently displayed, it is removed;   If it is not displayed, the queued notification is dropped.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanOpenUrl">
      <MemberSignature Language="C#" Value="public virtual bool CanOpenUrl (Foundation.NSUrl url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanOpenUrl(class Foundation.NSUrl url) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplication.CanOpenUrl(Foundation.NSUrl)" />
      <MemberSignature Language="F#" Value="abstract member CanOpenUrl : Foundation.NSUrl -&gt; bool&#xA;override this.CanOpenUrl : Foundation.NSUrl -&gt; bool" Usage="uIApplication.CanOpenUrl url" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("canOpenURL:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="Foundation.NSUrl" />
      </Parameters>
      <Docs>
        <param name="url">
          <para>The URL to probe.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Determines whether the given URL can be opened by OpenUrl.</summary>
        <returns>true if there is an application registered to open the URL, false if not.</returns>
        <remarks>
          <para>
            This function probes whether there is a handler for the
            provided URL on the system.  For example, if you call this
            function with "tel://555-123-1234" on an iPhone, this will
            return true, but will return false on an iPod Touch.
          </para>
          <para>
            This function does not validate the URL, it merely checks
            whether a handler for this URL has been installed on the system.
            
          </para>
          <para>
            If you want to define your own URL handlers, edit your
            Info.plist file and define a new URL type, you then must
            update your <see cref="M:UIKit.UIApplicationDelegate.FinishedLaunching(UIKit.UIApplication,Foundation.NSDictionary)" />
            method (to handle launching the application if it is not
            already running) and override the <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=UIKit%20UIApplication%20Delegate%20Open%20Url&amp;scope=Xamarin" title="M:UIKit.UIApplicationDelegate.OpenUrl*">M:UIKit.UIApplicationDelegate.OpenUrl*</a></format>
            method to handle the request to open the URL.
            
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckForEventAndDelegateMismatches">
      <MemberSignature Language="C#" Value="public static bool CheckForEventAndDelegateMismatches;" />
      <MemberSignature Language="ILAsm" Value=".field public static bool CheckForEventAndDelegateMismatches" />
      <MemberSignature Language="DocId" Value="F:UIKit.UIApplication.CheckForEventAndDelegateMismatches" />
      <MemberSignature Language="F#" Value=" staticval mutable CheckForEventAndDelegateMismatches : bool" Usage="UIKit.UIApplication.CheckForEventAndDelegateMismatches" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>If <see langword="true" />, the system will try to diagnose potential mistakes where events and delegate-object overrides are in conflict.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckForIllegalCrossThreadCalls">
      <MemberSignature Language="C#" Value="public static bool CheckForIllegalCrossThreadCalls;" />
      <MemberSignature Language="ILAsm" Value=".field public static bool CheckForIllegalCrossThreadCalls" />
      <MemberSignature Language="DocId" Value="F:UIKit.UIApplication.CheckForIllegalCrossThreadCalls" />
      <MemberSignature Language="F#" Value=" staticval mutable CheckForIllegalCrossThreadCalls : bool" Usage="UIKit.UIApplication.CheckForIllegalCrossThreadCalls" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determines whether the debug builds of MonoTouch will enforce that calls done to UIKit are only issued from the UI thread.</summary>
        <remarks>
          <para>
            On debug builds, MonoTouch will enforce that calls made to
            UIKit APIs are only done from the UIKit thread.  This is
            useful to spot code that could inadvertently use UIKit from
            a non-UI thread which can corrupt the UIKit state and could
            lead to very hard to debug problems.
          </para>
          <para>
            But sometimes it might be useful to disable this check,
            either because you can ensure that UIKit is not in use at
            this point or because MonoTouch might be enforcing the
            checks in APIs that might have later been relaxed or made
            thread safe by iOS.
            
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClassHandle">
      <MemberSignature Language="C#" Value="public override IntPtr ClassHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ClassHandle" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.ClassHandle" />
      <MemberSignature Language="F#" Value="member this.ClassHandle : nativeint" Usage="UIKit.UIApplication.ClassHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The handle for this class.</summary>
        <value>The pointer to the Objective-C class.</value>
        <remarks>Each Xamarin.iOS class mirrors an unmanaged Objective-C class.   This value contains the pointer to the Objective-C class, it is similar to calling objc_getClass with the object name.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearKeepAliveTimeout">
      <MemberSignature Language="C#" Value="public virtual void ClearKeepAliveTimeout ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearKeepAliveTimeout() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplication.ClearKeepAliveTimeout" />
      <MemberSignature Language="F#" Value="abstract member ClearKeepAliveTimeout : unit -&gt; unit&#xA;override this.ClearKeepAliveTimeout : unit -&gt; unit" Usage="uIApplication.ClearKeepAliveTimeout " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("clearKeepAliveTimeout")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.None, "Use 'PushKit' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stops invoking the KeepAlive method defined previously with SetKeepAliveTimeout.</summary>
        <remarks>This method is used by Voice over IP applications when they no longer need the keep-alive timeout method handler to be executed.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CompleteStateRestoration">
      <MemberSignature Language="C#" Value="public virtual void CompleteStateRestoration ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CompleteStateRestoration() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplication.CompleteStateRestoration" />
      <MemberSignature Language="F#" Value="abstract member CompleteStateRestoration : unit -&gt; unit&#xA;override this.CompleteStateRestoration : unit -&gt; unit" Usage="uIApplication.CompleteStateRestoration " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("completeStateRestoration")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indicates to the system that state restoration is complete.</summary>
        <remarks>
          <para>Application developers should call this method after they have finished state restoration.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentSizeCategoryChangedNotification">
      <MemberSignature Language="C#" Value="public static Foundation.NSString ContentSizeCategoryChangedNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString ContentSizeCategoryChangedNotification" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.ContentSizeCategoryChangedNotification" />
      <MemberSignature Language="F#" Value="member this.ContentSizeCategoryChangedNotification : Foundation.NSString" Usage="UIKit.UIApplication.ContentSizeCategoryChangedNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Use UIApplication.Notifications.ObserveContentSizeCategoryChanged helper method instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Field("UIContentSizeCategoryDidChangeNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for ContentSizeCategoryChanged</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">To subscribe to this notification, developers can use the convenience <see cref="T:UIKit.UIApplication.Notifications" />.<see cref="M:UIKit.UIApplication.Notifications.ObserveContentSizeCategoryChanged*" /> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="C#"><![CDATA[
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveContentSizeCategoryChanged ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("WeakNewValue", args.WeakNewValue);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, UIKit.UIContentSizeCategoryChangedEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("WeakNewValue", args.WeakNewValue);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveContentSizeCategoryChanged (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.ContentSizeCategoryChangedNotification, (notification) => {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.ContentSizeCategoryChangedNotification, Callback);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentUserNotificationSettings">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIUserNotificationSettings CurrentUserNotificationSettings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIUserNotificationSettings CurrentUserNotificationSettings" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.CurrentUserNotificationSettings" />
      <MemberSignature Language="F#" Value="member this.CurrentUserNotificationSettings : UIKit.UIUserNotificationSettings" Usage="UIKit.UIApplication.CurrentUserNotificationSettings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 10, 0, ObjCRuntime.PlatformArchitecture.None, "Use 'UNUserNotificationCenter.GetNotificationSettings' and 'UNUserNotificationCenter.GetNotificationCategories' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("currentUserNotificationSettings")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 10, 0, ObjCRuntime.PlatformArchitecture.None, "Use 'UNUserNotificationCenter.GetNotificationSettings' and 'UNUserNotificationCenter.GetNotificationCategories' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIUserNotificationSettings</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns current user notification settings for the app.</summary>
        <value>User notification settings that designate the types of notifications that the app is permitted to use.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Delegate">
      <MemberSignature Language="C#" Value="public UIKit.IUIApplicationDelegate Delegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.IUIApplicationDelegate Delegate" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.Delegate" />
      <MemberSignature Language="F#" Value="member this.Delegate : UIKit.IUIApplicationDelegate with get, set" Usage="UIKit.UIApplication.Delegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.IUIApplicationDelegate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An instance of the UIKit.IUIApplicationDelegate model class which acts as the class delegate.</summary>
        <value>The instance of the UIKit.IUIApplicationDelegate model class</value>
        <remarks>
          <para>The delegate instance assigned to this object will be used to handle events or provide data on demand to this class.</para>
          <para>When setting the Delegate or WeakDelegate values events will be delivered to the specified instance instead of being delivered to the C#-style events</para>
          <para>This is the strongly typed version of the object, developers should use the WeakDelegate property instead if they want to merely assign a class derived from NSObject that has been decorated with [Export] attributes.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DidBecomeActiveNotification">
      <MemberSignature Language="C#" Value="public static Foundation.NSString DidBecomeActiveNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString DidBecomeActiveNotification" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.DidBecomeActiveNotification" />
      <MemberSignature Language="F#" Value="member this.DidBecomeActiveNotification : Foundation.NSString" Usage="UIKit.UIApplication.DidBecomeActiveNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Use UIApplication.Notifications.ObserveDidBecomeActive helper method instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Field("UIApplicationDidBecomeActiveNotification", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for DidBecomeActive</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIKit.UIApplication.Notifications" />.<format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=M:UIKit.UIKit.UIApplication.Notifications.ObserveDidBecomeActive*&amp;scope=Xamarin" title="M:UIKit.UIKit.UIApplication.Notifications.ObserveDidBecomeActive*">M:UIKit.UIKit.UIApplication.Notifications.ObserveDidBecomeActive*</a></format> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="C#"><![CDATA[
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveDidBecomeActive ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, Foundation.NSNotificationEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveDidBecomeActive (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.DidBecomeActiveNotification, (notification) => {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.DidBecomeActiveNotification, Callback);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DidChangeStatusBarFrameNotification">
      <MemberSignature Language="C#" Value="public static Foundation.NSString DidChangeStatusBarFrameNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString DidChangeStatusBarFrameNotification" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.DidChangeStatusBarFrameNotification" />
      <MemberSignature Language="F#" Value="member this.DidChangeStatusBarFrameNotification : Foundation.NSString" Usage="UIKit.UIApplication.DidChangeStatusBarFrameNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Use UIApplication.Notifications.ObserveDidChangeStatusBarFrame helper method instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Field("UIApplicationDidChangeStatusBarFrameNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for DidChangeStatusBarFrame</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">To subscribe to this notification, developers can use the convenience <see cref="T:UIKit.UIApplication.Notifications" />.<see cref="M:UIKit.UIApplication.Notifications.ObserveDidChangeStatusBarFrame*" /> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="C#"><![CDATA[
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveDidChangeStatusBarFrame ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("StatusBarFrame", args.StatusBarFrame);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, UIKit.UIStatusBarFrameChangeEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("StatusBarFrame", args.StatusBarFrame);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveDidChangeStatusBarFrame (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.DidChangeStatusBarFrameNotification, (notification) => {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.DidChangeStatusBarFrameNotification, Callback);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DidChangeStatusBarOrientationNotification">
      <MemberSignature Language="C#" Value="public static Foundation.NSString DidChangeStatusBarOrientationNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString DidChangeStatusBarOrientationNotification" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.DidChangeStatusBarOrientationNotification" />
      <MemberSignature Language="F#" Value="member this.DidChangeStatusBarOrientationNotification : Foundation.NSString" Usage="UIKit.UIApplication.DidChangeStatusBarOrientationNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Use UIApplication.Notifications.ObserveDidChangeStatusBarOrientation helper method instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Field("UIApplicationDidChangeStatusBarOrientationNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for DidChangeStatusBarOrientation</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">To subscribe to this notification, developers can use the convenience <see cref="T:UIKit.UIApplication.Notifications" />.<see cref="M:UIKit.UIApplication.Notifications.ObserveDidChangeStatusBarOrientation*" /> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="C#"><![CDATA[
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveDidChangeStatusBarOrientation ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("StatusBarOrientation", args.StatusBarOrientation);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, UIKit.UIStatusBarOrientationChangeEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("StatusBarOrientation", args.StatusBarOrientation);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveDidChangeStatusBarOrientation (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.DidChangeStatusBarOrientationNotification, (notification) => {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.DidChangeStatusBarOrientationNotification, Callback);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DidEnterBackgroundNotification">
      <MemberSignature Language="C#" Value="public static Foundation.NSString DidEnterBackgroundNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString DidEnterBackgroundNotification" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.DidEnterBackgroundNotification" />
      <MemberSignature Language="F#" Value="member this.DidEnterBackgroundNotification : Foundation.NSString" Usage="UIKit.UIApplication.DidEnterBackgroundNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Use UIApplication.Notifications.ObserveDidEnterBackground helper method instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Field("UIApplicationDidEnterBackgroundNotification", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for DidEnterBackground</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIKit.UIApplication.Notifications" />.<format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=M:UIKit.UIKit.UIApplication.Notifications.ObserveDidEnterBackground*&amp;scope=Xamarin" title="M:UIKit.UIKit.UIApplication.Notifications.ObserveDidEnterBackground*">M:UIKit.UIKit.UIApplication.Notifications.ObserveDidEnterBackground*</a></format> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="C#"><![CDATA[
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveDidEnterBackground ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, Foundation.NSNotificationEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveDidEnterBackground (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.DidEnterBackgroundNotification, (notification) => {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.DidEnterBackgroundNotification, Callback);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DidFinishLaunchingNotification">
      <MemberSignature Language="C#" Value="public static Foundation.NSString DidFinishLaunchingNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString DidFinishLaunchingNotification" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.DidFinishLaunchingNotification" />
      <MemberSignature Language="F#" Value="member this.DidFinishLaunchingNotification : Foundation.NSString" Usage="UIKit.UIApplication.DidFinishLaunchingNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Use UIApplication.Notifications.ObserveDidFinishLaunching helper method instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Field("UIApplicationDidFinishLaunchingNotification", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for DidFinishLaunching</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">To subscribe to this notification, developers can use the convenience <see cref="T:UIKit.UIApplication.Notifications" />.<see cref="M:UIKit.UIApplication.Notifications.ObserveDidFinishLaunching*" /> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="C#"><![CDATA[
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveDidFinishLaunching ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("Url", args.Url);
    Console.WriteLine ("SourceApplication", args.SourceApplication);
    Console.WriteLine ("RemoteNotifications", args.RemoteNotifications);
    Console.WriteLine ("LocationLaunch", args.LocationLaunch);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, UIKit.UIApplicationLaunchEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("Url", args.Url);
    Console.WriteLine ("SourceApplication", args.SourceApplication);
    Console.WriteLine ("RemoteNotifications", args.RemoteNotifications);
    Console.WriteLine ("LocationLaunch", args.LocationLaunch);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveDidFinishLaunching (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.DidFinishLaunchingNotification, (notification) => {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.DidFinishLaunchingNotification, Callback);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DidReceiveMemoryWarningNotification">
      <MemberSignature Language="C#" Value="public static Foundation.NSString DidReceiveMemoryWarningNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString DidReceiveMemoryWarningNotification" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.DidReceiveMemoryWarningNotification" />
      <MemberSignature Language="F#" Value="member this.DidReceiveMemoryWarningNotification : Foundation.NSString" Usage="UIKit.UIApplication.DidReceiveMemoryWarningNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Use UIApplication.Notifications.ObserveDidReceiveMemoryWarning helper method instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Field("UIApplicationDidReceiveMemoryWarningNotification", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for DidReceiveMemoryWarning</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIKit.UIApplication.Notifications" />.<format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=M:UIKit.UIKit.UIApplication.Notifications.ObserveDidReceiveMemoryWarning*&amp;scope=Xamarin" title="M:UIKit.UIKit.UIApplication.Notifications.ObserveDidReceiveMemoryWarning*">M:UIKit.UIKit.UIApplication.Notifications.ObserveDidReceiveMemoryWarning*</a></format> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="C#"><![CDATA[
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveDidReceiveMemoryWarning ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, Foundation.NSNotificationEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveDidReceiveMemoryWarning (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.DidReceiveMemoryWarningNotification, (notification) => {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.DidReceiveMemoryWarningNotification, Callback);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplication.Dispose(System.Boolean)" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="uIApplication.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <para>If set to <see langword="true" />, the method is invoked directly and will dispose manage and unmanaged resources;   If set to <see langword="false" /> the method is being called by the garbage collector finalizer and should only release unmanaged resources.</para>
        </param>
        <summary>Releases the resources used by the UIApplication object.</summary>
        <remarks>
          <para>This Dispose method releases the resources used by the UIApplication class.</para>
          <para>This method is called by both the Dispose() method and the object finalizer (Finalize).    When invoked by the Dispose method, the parameter disposing <paramref name="disposing" /> is set to <see langword="true" /> and any managed object references that this object holds are also disposed or released;  when invoked by the object finalizer, on the finalizer thread the value is set to <see langword="false" />. </para>
          <para>Calling the Dispose method when the application is finished using the UIApplication ensures that all external resources used by this managed object are released as soon as possible.  Once developers have invoked the Dispose method, the object is no longer useful and developers should no longer make any calls to it.</para>
          <para>  For more information on how to override this method and on the Dispose/IDisposable pattern, read the ``Implementing a Dispose Method'' document at https://msdn.microsoft.com/en-us/library/fs2xkftw.aspx</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnabledRemoteNotificationTypes">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIRemoteNotificationType EnabledRemoteNotificationTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype UIKit.UIRemoteNotificationType EnabledRemoteNotificationTypes" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.EnabledRemoteNotificationTypes" />
      <MemberSignature Language="F#" Value="member this.EnabledRemoteNotificationTypes : UIKit.UIRemoteNotificationType" Usage="UIKit.UIApplication.EnabledRemoteNotificationTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, "Use 'CurrentUserNotificationSettings' or 'UNUserNotificationCenter.GetNotificationSettings' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("enabledRemoteNotificationTypes")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, "Use 'CurrentUserNotificationSettings' or 'UNUserNotificationCenter.GetNotificationSettings' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIRemoteNotificationType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns a bit-masked <see cref="T:UIKit.UIRemoteNotificationType" /> indicating which types of notifications the app accepts.</summary>
        <value>A bit-masked <see cref="T:UIKit.UIRemoteNotificationType" /> indicating which types of notifications the app accepts.</value>
        <remarks>To be added.</remarks>
        <altmember cref="M:UIKit.UIApplication.RegisterForRemoteNotificationTypes" />
      </Docs>
    </Member>
    <Member MemberName="EndBackgroundTask">
      <MemberSignature Language="C#" Value="public virtual void EndBackgroundTask (nint taskId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndBackgroundTask(valuetype System.nint taskId) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplication.EndBackgroundTask(System.nint)" />
      <MemberSignature Language="F#" Value="abstract member EndBackgroundTask : nint -&gt; unit&#xA;override this.EndBackgroundTask : nint -&gt; unit" Usage="uIApplication.EndBackgroundTask taskId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Overriding this method requires a call to the overriden method.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Export("endBackgroundTask:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.RequiresSuper</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="taskId" Type="System.nint" />
      </Parameters>
      <Docs>
        <param name="taskId">The value returned by the matching <see cref="M:UIKit.UIApplication.BeginBackgroundTask(System.String,System.Action)" /> method.</param>
        <summary>Indicates to the system that background processing has ended for the <paramref name="taskId" />.</summary>
        <remarks>
          <para>This method, with <see cref="M:UIKit.UIApplication.BeginBackgroundTask(System.String,System.Action)" />, bookends code that should be allowed to run in the background. It does not affect the actual state of any threads. (See <see cref="M:UIKit.UIApplication.BeginBackgroundTask(System.String,System.Action)" /> for discussion.)</para>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndIgnoringInteractionEvents">
      <MemberSignature Language="C#" Value="public virtual void EndIgnoringInteractionEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndIgnoringInteractionEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplication.EndIgnoringInteractionEvents" />
      <MemberSignature Language="F#" Value="abstract member EndIgnoringInteractionEvents : unit -&gt; unit&#xA;override this.EndIgnoringInteractionEvents : unit -&gt; unit" Usage="uIApplication.EndIgnoringInteractionEvents " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("endIgnoringInteractionEvents")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resumes receiving touch events for the application.</summary>
        <remarks>
          <para>
          This should be called if you previously disabled receiving events by calling the <see cref="M:UIKit.UIApplication.BeginIgnoringInteractionEvents" />.</para>
          <para>This method is unavailable to Extensions.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndReceivingRemoteControlEvents">
      <MemberSignature Language="C#" Value="public virtual void EndReceivingRemoteControlEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndReceivingRemoteControlEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplication.EndReceivingRemoteControlEvents" />
      <MemberSignature Language="F#" Value="abstract member EndReceivingRemoteControlEvents : unit -&gt; unit&#xA;override this.EndReceivingRemoteControlEvents : unit -&gt; unit" Usage="uIApplication.EndReceivingRemoteControlEvents " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("endReceivingRemoteControlEvents")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indicates that the application should nto receive further remote-control events.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:UIKit.UIApplication.BeginReceivingRemoteControlEvents" />
      </Docs>
    </Member>
    <Member MemberName="EnsureUIThread">
      <MemberSignature Language="C#" Value="public static void EnsureUIThread ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnsureUIThread() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplication.EnsureUIThread" />
      <MemberSignature Language="F#" Value="static member EnsureUIThread : unit -&gt; unit" Usage="UIKit.UIApplication.EnsureUIThread " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Assertion to ensure that this call is being done from the UIKit thread.</summary>
        <remarks>
          <para>
            This method is used internally by MonoTouch to ensure that
            accesses done to UIKit classes and methods are only
            performed from the UIKit thread.  This is necessary because
            the UIKit API is not thread-safe and accessing it from
            multiple threads will corrupt the application state and will
            likely lead to a crash that is hard to identify.
          </para>
          <para>
            MonoTouch only performs the thread checks in debug builds.
            Release builds have this feature disabled.
            
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExtendStateRestoration">
      <MemberSignature Language="C#" Value="public virtual void ExtendStateRestoration ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ExtendStateRestoration() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplication.ExtendStateRestoration" />
      <MemberSignature Language="F#" Value="abstract member ExtendStateRestoration : unit -&gt; unit&#xA;override this.ExtendStateRestoration : unit -&gt; unit" Usage="uIApplication.ExtendStateRestoration " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("extendStateRestoration")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indicates that the application is restoring state asynchronously.</summary>
        <remarks>
          <para>State restoration occurs on the main thread. Application developers who wish to do state restoration asynchronously should call this method and pair it with calls to <see cref="M:UIKit.UIApplication.CompleteStateRestoration" /> to indicate to the system that state restoration is occurring asynchronously.</para>
          <para>If this method is called and the application crashes before the matching <see cref="M:UIKit.UIApplication.CompleteStateRestoration" /> is called, all retained state will be discarded on next startup. This behavior prevents the crash from re-occurring.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IdleTimerDisabled">
      <MemberSignature Language="C#" Value="public virtual bool IdleTimerDisabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IdleTimerDisabled" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.IdleTimerDisabled" />
      <MemberSignature Language="F#" Value="member this.IdleTimerDisabled : bool with get, set" Usage="UIKit.UIApplication.IdleTimerDisabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("isIdleTimerDisabled")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setIdleTimerDisabled:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>If <see langword="true" />, indicates that the screen should not dim even when no input is occurring.</summary>
        <value>The default value is <see langword="false" />.</value>
        <remarks>
          <para>The idle timer dims the screen after some amount of time has passed without user interaction. Application developers who wish to keep the screen fully powered can set this property to <see langword="true" />. For instance, games whose input is restricted to the accelerometer may set this value to <see langword="true" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IgnoreSnapshotOnNextApplicationLaunch">
      <MemberSignature Language="C#" Value="public virtual void IgnoreSnapshotOnNextApplicationLaunch ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void IgnoreSnapshotOnNextApplicationLaunch() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplication.IgnoreSnapshotOnNextApplicationLaunch" />
      <MemberSignature Language="F#" Value="abstract member IgnoreSnapshotOnNextApplicationLaunch : unit -&gt; unit&#xA;override this.IgnoreSnapshotOnNextApplicationLaunch : unit -&gt; unit" Usage="uIApplication.IgnoreSnapshotOnNextApplicationLaunch " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("ignoreSnapshotOnNextApplicationLaunch")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Instructs the system not to use a UI snapshot during relaunch.</summary>
        <remarks>
          <para>This method method be called from within the state-preservation process.</para>
          <para>Normally, the system takes a snapshot of the UI during state-preservation and presents this during state-restoration. Generally, this makes the application user feel that the system is relaunching quickly. App developers can call this method during state-preservation if the UI would not be appropriate during relaunch.</para>
          <para>If this method is called, during state-restoration the app's default launch image will be displayed.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsIgnoringInteractionEvents">
      <MemberSignature Language="C#" Value="public virtual bool IsIgnoringInteractionEvents { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsIgnoringInteractionEvents" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.IsIgnoringInteractionEvents" />
      <MemberSignature Language="F#" Value="member this.IsIgnoringInteractionEvents : bool" Usage="UIKit.UIApplication.IsIgnoringInteractionEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("isIgnoringInteractionEvents")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether the receiver is ignoring touch events.</summary>
        <value>
          <see langword="true" /> if there have been more calls to <see cref="M:UIKit.UIApplication.BeginIgnoringInteractionEvents" /> than calls to <see cref="M:UIKit.UIApplication.EndIgnoringInteractionEvents" />.</value>
        <remarks>
        </remarks>
        <altmember cref="M:UIKit.UIApplication.BeginIgnoringInteractionEvents" />
        <altmember cref="M:UIKit.UIApplication.EndIgnoringInteractionEvents" />
      </Docs>
    </Member>
    <Member MemberName="IsRegisteredForRemoteNotifications">
      <MemberSignature Language="C#" Value="public virtual bool IsRegisteredForRemoteNotifications { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsRegisteredForRemoteNotifications" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.IsRegisteredForRemoteNotifications" />
      <MemberSignature Language="F#" Value="member this.IsRegisteredForRemoteNotifications : bool" Usage="UIKit.UIApplication.IsRegisteredForRemoteNotifications" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("isRegisteredForRemoteNotifications")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indicates whether app is registered for remote notifications.</summary>
        <value>A Boolean that indicates whether the app is currently registered for remote notifications.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyWindow">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIWindow KeyWindow { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIWindow KeyWindow" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.KeyWindow" />
      <MemberSignature Language="F#" Value="member this.KeyWindow : UIKit.UIWindow" Usage="UIKit.UIApplication.KeyWindow" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("keyWindow")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIWindow</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns the application's key window - the window that is currently displayed and receives user input </summary>
        <value>
        </value>
        <remarks>
          
          The key window is the currently visible window that is also
          the one that receives user input.  The key window in turn
          will route input events to the <see cref="T:UIKit.UIViewController" /> that is defined
          in set in the  <see cref="P:UIKit.UIWindow.RootViewController" /> property.
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LaunchOptionsAnnotationKey">
      <MemberSignature Language="C#" Value="public static Foundation.NSString LaunchOptionsAnnotationKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString LaunchOptionsAnnotationKey" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.LaunchOptionsAnnotationKey" />
      <MemberSignature Language="F#" Value="member this.LaunchOptionsAnnotationKey : Foundation.NSString" Usage="UIKit.UIApplication.LaunchOptionsAnnotationKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIApplicationLaunchOptionsAnnotationKey", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Launch Options Key: Use this key to find out if custom data was passed to the program by the opening application. The value of this key will be a property list. </summary>
        <value>
          Represents the value associated with the constant UIApplicationLaunchOptionsAnnotationKey
        </value>
        <remarks>
          <para>This key is used with the <see cref="T:Foundation.NSDictionary" /> passed to <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=M:UIKit.UIApplicationDelegate.FinishedLaunching(UIKit.UIApplication, Foundation.NSDictionary)&amp;scope=Xamarin" title="M:UIKit.UIApplicationDelegate.FinishedLaunching(UIKit.UIApplication, Foundation.NSDictionary)">M:UIKit.UIApplicationDelegate.FinishedLaunching(UIKit.UIApplication, Foundation.NSDictionary)</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LaunchOptionsBluetoothCentralsKey">
      <MemberSignature Language="C#" Value="public static Foundation.NSString LaunchOptionsBluetoothCentralsKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString LaunchOptionsBluetoothCentralsKey" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.LaunchOptionsBluetoothCentralsKey" />
      <MemberSignature Language="F#" Value="member this.LaunchOptionsBluetoothCentralsKey : Foundation.NSString" Usage="UIKit.UIApplication.LaunchOptionsBluetoothCentralsKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIApplicationLaunchOptionsBluetoothCentralsKey", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UIApplicationLaunchOptionsBluetoothCentralsKey</summary>
        <value>
        </value>
        <remarks>
          <para>This key is used with the <see cref="T:Foundation.NSDictionary" /> passed to <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=M:UIKit.UIApplicationDelegate.FinishedLaunching(UIKit.UIApplication, Foundation.NSDictionary)&amp;scope=Xamarin" title="M:UIKit.UIApplicationDelegate.FinishedLaunching(UIKit.UIApplication, Foundation.NSDictionary)">M:UIKit.UIApplicationDelegate.FinishedLaunching(UIKit.UIApplication, Foundation.NSDictionary)</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LaunchOptionsBluetoothPeripheralsKey">
      <MemberSignature Language="C#" Value="public static Foundation.NSString LaunchOptionsBluetoothPeripheralsKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString LaunchOptionsBluetoothPeripheralsKey" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.LaunchOptionsBluetoothPeripheralsKey" />
      <MemberSignature Language="F#" Value="member this.LaunchOptionsBluetoothPeripheralsKey : Foundation.NSString" Usage="UIKit.UIApplication.LaunchOptionsBluetoothPeripheralsKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIApplicationLaunchOptionsBluetoothPeripheralsKey", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UIApplicationLaunchOptionsBluetoothPeripheralsKey</summary>
        <value>
        </value>
        <remarks>
          <para>This key is used with the <see cref="T:Foundation.NSDictionary" /> passed to <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=M:UIKit.UIApplicationDelegate.FinishedLaunching(UIKit.UIApplication, Foundation.NSDictionary)&amp;scope=Xamarin" title="M:UIKit.UIApplicationDelegate.FinishedLaunching(UIKit.UIApplication, Foundation.NSDictionary)">M:UIKit.UIApplicationDelegate.FinishedLaunching(UIKit.UIApplication, Foundation.NSDictionary)</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LaunchOptionsCloudKitShareMetadataKey">
      <MemberSignature Language="C#" Value="public static Foundation.NSString LaunchOptionsCloudKitShareMetadataKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString LaunchOptionsCloudKitShareMetadataKey" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.LaunchOptionsCloudKitShareMetadataKey" />
      <MemberSignature Language="F#" Value="member this.LaunchOptionsCloudKitShareMetadataKey : Foundation.NSString" Usage="UIKit.UIApplication.LaunchOptionsCloudKitShareMetadataKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIApplicationLaunchOptionsCloudKitShareMetadataKey", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 10, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 10, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LaunchOptionsLocalNotificationKey">
      <MemberSignature Language="C#" Value="public static Foundation.NSString LaunchOptionsLocalNotificationKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString LaunchOptionsLocalNotificationKey" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.LaunchOptionsLocalNotificationKey" />
      <MemberSignature Language="F#" Value="member this.LaunchOptionsLocalNotificationKey : Foundation.NSString" Usage="UIKit.UIApplication.LaunchOptionsLocalNotificationKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIApplicationLaunchOptionsLocalNotificationKey", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 10, 0, ObjCRuntime.PlatformArchitecture.None, "Use 'UNUserNotificationCenterDelegate.DidReceiveNotificationResponse' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 10, 0, ObjCRuntime.PlatformArchitecture.None, "Use 'UNUserNotificationCenterDelegate.DidReceiveNotificationResponse' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for LaunchOptionsLocalNot</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para>
            The value of this key will be a <see cref="T:UIKit.UILocalNotification" /> instance.
          </para>
          <para>
            This key will be present on the launch options if a local notification was delivered and the application was not running.
          </para>
          <para>This key is used with the <see cref="T:Foundation.NSDictionary" /> passed to <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=M:UIKit.UIApplicationDelegate.FinishedLaunching(UIKit.UIApplication, Foundation.NSDictionary)&amp;scope=Xamarin" title="M:UIKit.UIApplicationDelegate.FinishedLaunching(UIKit.UIApplication, Foundation.NSDictionary)">M:UIKit.UIApplicationDelegate.FinishedLaunching(UIKit.UIApplication, Foundation.NSDictionary)</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LaunchOptionsLocationKey">
      <MemberSignature Language="C#" Value="public static Foundation.NSString LaunchOptionsLocationKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString LaunchOptionsLocationKey" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.LaunchOptionsLocationKey" />
      <MemberSignature Language="F#" Value="member this.LaunchOptionsLocationKey : Foundation.NSString" Usage="UIKit.UIApplication.LaunchOptionsLocationKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIApplicationLaunchOptionsLocationKey", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Launch Options Key: Application was started up in response to a location event.</summary>
        <value>Represents the value associated with the constant UIApplicationLaunchOptionsLocationKey</value>
        <remarks>
          <para>The value of this key will be an NSNumber.   The application should respond by creating a <see cref="T:CoreLocation.CLLocationManager" /> instance to and get the information from that object.</para>
          <para>This key is used with the <see cref="T:Foundation.NSDictionary" /> passed to <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=M:UIKit.UIApplicationDelegate.FinishedLaunching(UIKit.UIApplication, Foundation.NSDictionary)&amp;scope=Xamarin" title="M:UIKit.UIApplicationDelegate.FinishedLaunching(UIKit.UIApplication, Foundation.NSDictionary)">M:UIKit.UIApplicationDelegate.FinishedLaunching(UIKit.UIApplication, Foundation.NSDictionary)</a></format>.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LaunchOptionsNewsstandDownloadsKey">
      <MemberSignature Language="C#" Value="public static Foundation.NSString LaunchOptionsNewsstandDownloadsKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString LaunchOptionsNewsstandDownloadsKey" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.LaunchOptionsNewsstandDownloadsKey" />
      <MemberSignature Language="F#" Value="member this.LaunchOptionsNewsstandDownloadsKey : Foundation.NSString" Usage="UIKit.UIApplication.LaunchOptionsNewsstandDownloadsKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIApplicationLaunchOptionsNewsstandDownloadsKey", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Launch Options Key: This key indicates that Newsstand has completed downloading the requested data. </summary>
        <value>Represents the value associated with the constant UIApplicationLaunchOptionsNewsstandDownloadsKey
        </value>
        <remarks>
          <para>
          The value in the dictionary for this key, contains an array of strings that represent <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=T:Newsstand.NKAssetDownload&amp;scope=Xamarin" title="T:Newsstand.NKAssetDownload">T:Newsstand.NKAssetDownload</a></format> objects.</para>
          <para>This key is used with the <see cref="T:Foundation.NSDictionary" /> passed to <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=M:UIKit.UIApplicationDelegate.FinishedLaunching(UIKit.UIApplication, Foundation.NSDictionary)&amp;scope=Xamarin" title="M:UIKit.UIApplicationDelegate.FinishedLaunching(UIKit.UIApplication, Foundation.NSDictionary)">M:UIKit.UIApplicationDelegate.FinishedLaunching(UIKit.UIApplication, Foundation.NSDictionary)</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LaunchOptionsRemoteNotificationKey">
      <MemberSignature Language="C#" Value="public static Foundation.NSString LaunchOptionsRemoteNotificationKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString LaunchOptionsRemoteNotificationKey" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.LaunchOptionsRemoteNotificationKey" />
      <MemberSignature Language="F#" Value="member this.LaunchOptionsRemoteNotificationKey : Foundation.NSString" Usage="UIKit.UIApplication.LaunchOptionsRemoteNotificationKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIApplicationLaunchOptionsRemoteNotificationKey", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for LaunchOptionsRemoteNot</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para>The value associated with this key will be an NSDictionary with the payload from the remote notification that was received. </para>
          <para>This key is used with the <see cref="T:Foundation.NSDictionary" /> passed to <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=M:UIKit.UIApplicationDelegate.FinishedLaunching(UIKit.UIApplication, Foundation.NSDictionary)&amp;scope=Xamarin" title="M:UIKit.UIApplicationDelegate.FinishedLaunching(UIKit.UIApplication, Foundation.NSDictionary)">M:UIKit.UIApplicationDelegate.FinishedLaunching(UIKit.UIApplication, Foundation.NSDictionary)</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LaunchOptionsShortcutItemKey">
      <MemberSignature Language="C#" Value="public static Foundation.NSString LaunchOptionsShortcutItemKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString LaunchOptionsShortcutItemKey" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.LaunchOptionsShortcutItemKey" />
      <MemberSignature Language="F#" Value="member this.LaunchOptionsShortcutItemKey : Foundation.NSString" Usage="UIKit.UIApplication.LaunchOptionsShortcutItemKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIApplicationLaunchOptionsShortcutItemKey", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The presence of this key indicates that the application was launched via a shortcut item.</summary>
        <value>To be added.</value>
        <remarks>
          <para>This key is used with the <see cref="T:Foundation.NSDictionary" /> passed to <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=M:UIKit.UIApplicationDelegate.FinishedLaunching(UIKit.UIApplication, Foundation.NSDictionary)&amp;scope=Xamarin" title="M:UIKit.UIApplicationDelegate.FinishedLaunching(UIKit.UIApplication, Foundation.NSDictionary)">M:UIKit.UIApplicationDelegate.FinishedLaunching(UIKit.UIApplication, Foundation.NSDictionary)</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LaunchOptionsSourceApplicationKey">
      <MemberSignature Language="C#" Value="public static Foundation.NSString LaunchOptionsSourceApplicationKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString LaunchOptionsSourceApplicationKey" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.LaunchOptionsSourceApplicationKey" />
      <MemberSignature Language="F#" Value="member this.LaunchOptionsSourceApplicationKey : Foundation.NSString" Usage="UIKit.UIApplication.LaunchOptionsSourceApplicationKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIApplicationLaunchOptionsSourceApplicationKey", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Launch Options Key: the value associated with the key is the bundle-id of the application that launched this application.</summary>
        <value>Represents the value associated with the constant UIApplicationLaunchOptionsSourceApplicationKey
        </value>
        <remarks>
          <para>This key is used with the <see cref="T:Foundation.NSDictionary" /> passed to <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=M:UIKit.UIApplicationDelegate.FinishedLaunching(UIKit.UIApplication, Foundation.NSDictionary)&amp;scope=Xamarin" title="M:UIKit.UIApplicationDelegate.FinishedLaunching(UIKit.UIApplication, Foundation.NSDictionary)">M:UIKit.UIApplicationDelegate.FinishedLaunching(UIKit.UIApplication, Foundation.NSDictionary)</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LaunchOptionsUrlKey">
      <MemberSignature Language="C#" Value="public static Foundation.NSString LaunchOptionsUrlKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString LaunchOptionsUrlKey" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.LaunchOptionsUrlKey" />
      <MemberSignature Language="F#" Value="member this.LaunchOptionsUrlKey : Foundation.NSString" Usage="UIKit.UIApplication.LaunchOptionsUrlKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIApplicationLaunchOptionsURLKey", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Launch Options Key: the application was launched in response to open a URL.  the value associated with the key contains the URL to open.</summary>
        <value>Represents the value associated with the constant UIApplicationLaunchOptionsURLKey.
        </value>
        <remarks>
          <para>This key is used with the <see cref="T:Foundation.NSDictionary" /> passed to <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=M:UIKit.UIApplicationDelegate.FinishedLaunching(UIKit.UIApplication, Foundation.NSDictionary)&amp;scope=Xamarin" title="M:UIKit.UIApplicationDelegate.FinishedLaunching(UIKit.UIApplication, Foundation.NSDictionary)">M:UIKit.UIApplicationDelegate.FinishedLaunching(UIKit.UIApplication, Foundation.NSDictionary)</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LaunchOptionsUserActivityDictionaryKey">
      <MemberSignature Language="C#" Value="public static Foundation.NSString LaunchOptionsUserActivityDictionaryKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString LaunchOptionsUserActivityDictionaryKey" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.LaunchOptionsUserActivityDictionaryKey" />
      <MemberSignature Language="F#" Value="member this.LaunchOptionsUserActivityDictionaryKey : Foundation.NSString" Usage="UIKit.UIApplication.LaunchOptionsUserActivityDictionaryKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIApplicationLaunchOptionsUserActivityDictionaryKey", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UIApplicationLaunchOptionsUserActivityDictionaryKey</summary>
        <value>
        </value>
        <remarks>
          <para>This key is used with the <see cref="T:Foundation.NSDictionary" /> passed to <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=M:UIKit.UIApplicationDelegate.FinishedLaunching(UIKit.UIApplication, Foundation.NSDictionary)&amp;scope=Xamarin" title="M:UIKit.UIApplicationDelegate.FinishedLaunching(UIKit.UIApplication, Foundation.NSDictionary)">M:UIKit.UIApplicationDelegate.FinishedLaunching(UIKit.UIApplication, Foundation.NSDictionary)</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LaunchOptionsUserActivityTypeKey">
      <MemberSignature Language="C#" Value="public static Foundation.NSString LaunchOptionsUserActivityTypeKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString LaunchOptionsUserActivityTypeKey" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.LaunchOptionsUserActivityTypeKey" />
      <MemberSignature Language="F#" Value="member this.LaunchOptionsUserActivityTypeKey : Foundation.NSString" Usage="UIKit.UIApplication.LaunchOptionsUserActivityTypeKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIApplicationLaunchOptionsUserActivityTypeKey", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UIApplicationLaunchOptionsUserActivityTypeKey</summary>
        <value>
        </value>
        <remarks>
          <para>This key is used with the <see cref="T:Foundation.NSDictionary" /> passed to <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=M:UIKit.UIApplicationDelegate.FinishedLaunching(UIKit.UIApplication, Foundation.NSDictionary)&amp;scope=Xamarin" title="M:UIKit.UIApplicationDelegate.FinishedLaunching(UIKit.UIApplication, Foundation.NSDictionary)">M:UIKit.UIApplicationDelegate.FinishedLaunching(UIKit.UIApplication, Foundation.NSDictionary)</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Main">
      <MemberSignature Language="C#" Value="public static void Main (string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Main(string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplication.Main(System.String[])" />
      <MemberSignature Language="F#" Value="static member Main : string[] -&gt; unit" Usage="UIKit.UIApplication.Main args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="args">Command line parameters from the Main program.</param>
        <summary>Launches the main application loop with the given command line parameters.</summary>
        <remarks>This launches the main application loop, assumes that the main application class is UIApplication, and uses the UIApplicationDelegate instance specified in the main NIB file for this program.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Main">
      <MemberSignature Language="C#" Value="public static void Main (string[] args, string principalClassName, string delegateClassName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Main(string[] args, string principalClassName, string delegateClassName) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplication.Main(System.String[],System.String,System.String)" />
      <MemberSignature Language="F#" Value="static member Main : string[] * string * string -&gt; unit" Usage="UIKit.UIApplication.Main (args, principalClassName, delegateClassName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.String[]" />
        <Parameter Name="principalClassName" Type="System.String" />
        <Parameter Name="delegateClassName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="args">Command line parameters from the Main program.</param>
        <param name="principalClassName">The name of the main application class, if you specify null, this uses UIApplication.</param>
        <param name="delegateClassName">The name of the UIApplicationDelegate class, if null, it uses the UIApplicationDelegate instance specified in the main NIB file for this program..</param>
        <summary>Launches the main application loop with the given command line parameters.</summary>
        <remarks>
          <para>The <paramref name="principalClassName" /> is typically only specified if the application developer subclasses <see cref="T:UIKit.UIApplication" />, as shown in the following example:</para>
          <example>
            <code lang="C#"><![CDATA[
public class Application
{
	static void Main(string[] args)
	{
		UIApplication.Main(args, "MyApp", "MyAppDelegate");
	}
}

[Register("MyApp")]
public class MyApp : UIApplication
{
//...etc...
}          

[Register("MyAppDelegate")]
public  class AppDelegate : UIApplicationDelegate
{
//..etc...
}
              ]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Main">
      <MemberSignature Language="C#" Value="public static void Main (string[] args, Type principalClass, Type delegateClass);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Main(string[] args, class System.Type principalClass, class System.Type delegateClass) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplication.Main(System.String[],System.Type,System.Type)" />
      <MemberSignature Language="F#" Value="static member Main : string[] * Type * Type -&gt; unit" Usage="UIKit.UIApplication.Main (args, principalClass, delegateClass)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.String[]" />
        <Parameter Name="principalClass" Type="System.Type" />
        <Parameter Name="delegateClass" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="args">Command line parameters from the Main program.</param>
        <param name="principalClass">The type of the main application class, if you specify null, this uses UIApplication.</param>
        <param name="delegateClass">The type of the UIApplicationDelegate class, if null, it uses the UIApplicationDelegate instance specified in the main NIB file for this program..</param>
        <summary>Launches the main application loop with the given command line parameters.</summary>
        <remarks>
          <para>The <paramref name="principalClassName" /> is typically only specified if the application developer subclasses <see cref="T:UIKit.UIApplication" />, as shown in the following example:</para>
          <example>
            <code lang="C#"><![CDATA[
public class Application
{
  static void Main(string[] args)
  {
    UIApplication.Main(args, typeof (MyApp), typeof (MyAppDelegate));
  }
}

public class MyApp : UIApplication
{
//...etc...
}          

public class MyAppDelegate : UIApplicationDelegate
{
//..etc...
}
              ]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinimumKeepAliveTimeout">
      <MemberSignature Language="C#" Value="public static double MinimumKeepAliveTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property float64 MinimumKeepAliveTimeout" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.MinimumKeepAliveTimeout" />
      <MemberSignature Language="F#" Value="member this.MinimumKeepAliveTimeout : double" Usage="UIKit.UIApplication.MinimumKeepAliveTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIMinimumKeepAliveTimeout", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UIMinimumKeepAliveTimeout</summary>
        <value>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NetworkActivityIndicatorVisible">
      <MemberSignature Language="C#" Value="public virtual bool NetworkActivityIndicatorVisible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NetworkActivityIndicatorVisible" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.NetworkActivityIndicatorVisible" />
      <MemberSignature Language="F#" Value="member this.NetworkActivityIndicatorVisible : bool with get, set" Usage="UIKit.UIApplication.NetworkActivityIndicatorVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("isNetworkActivityIndicatorVisible")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setNetworkActivityIndicatorVisible:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Controls the status of the network activity indicator on the device.</summary>
        <value>A Boolean that switches the indicator of network activity on or off.</value>
        <remarks>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenSettingsUrlString">
      <MemberSignature Language="C#" Value="public static Foundation.NSString OpenSettingsUrlString { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString OpenSettingsUrlString" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.OpenSettingsUrlString" />
      <MemberSignature Language="F#" Value="member this.OpenSettingsUrlString : Foundation.NSString" Usage="UIKit.UIApplication.OpenSettingsUrlString" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIApplicationOpenSettingsURLString", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UIApplicationOpenSettingsURLString</summary>
        <value>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenUrl">
      <MemberSignature Language="C#" Value="public virtual bool OpenUrl (Foundation.NSUrl url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool OpenUrl(class Foundation.NSUrl url) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplication.OpenUrl(Foundation.NSUrl)" />
      <MemberSignature Language="F#" Value="abstract member OpenUrl : Foundation.NSUrl -&gt; bool&#xA;override this.OpenUrl : Foundation.NSUrl -&gt; bool" Usage="uIApplication.OpenUrl url" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("openURL:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 10, 0, ObjCRuntime.PlatformArchitecture.None, "Please use the overload instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="Foundation.NSUrl" />
      </Parameters>
      <Docs>
        <param name="url">Represents a URL.</param>
        <summary>Opens the specified URL, launching the app that's registered to handle the scheme.</summary>
        <returns>
          <see langword="true" /> if the URL was successfully opened.</returns>
        <remarks>
          <para>If another app is registered to handle the URL scheme, calling this method will launch the other application, which may cause the current application to quit or at least be sent to the background.</para>
          <para>This member is not available to Extensions.</para>
        </remarks>
        <altmember cref="M:UIKit.UIApplication.CanOpenUrl" />
        <altmember cref="M:UIKit.UIApplicationDelegate.HandleOpenUrl" />
      </Docs>
    </Member>
    <Member MemberName="OpenUrl">
      <MemberSignature Language="C#" Value="public virtual void OpenUrl (Foundation.NSUrl url, Foundation.NSDictionary options, Action&lt;bool&gt; completion);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OpenUrl(class Foundation.NSUrl url, class Foundation.NSDictionary options, class System.Action`1&lt;bool&gt; completion) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplication.OpenUrl(Foundation.NSUrl,Foundation.NSDictionary,System.Action{System.Boolean})" />
      <MemberSignature Language="F#" Value="abstract member OpenUrl : Foundation.NSUrl * Foundation.NSDictionary * Action&lt;bool&gt; -&gt; unit&#xA;override this.OpenUrl : Foundation.NSUrl * Foundation.NSDictionary * Action&lt;bool&gt; -&gt; unit" Usage="uIApplication.OpenUrl (url, options, completion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("openURL:options:completionHandler:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 10, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 10, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="Foundation.NSUrl" />
        <Parameter Name="options" Type="Foundation.NSDictionary" />
        <Parameter Name="completion" Type="System.Action&lt;System.Boolean&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDActionArity1V2))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="url">The URL to be opened.</param>
        <param name="options">Launch options.</param>
        <param name="completion">
          <para>Asynchronously called after launch.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Opens the specified URL, launching the app that's registered to handle the scheme.</summary>
        <remarks>
          <para>If another app is registered to handle the URL scheme, calling this method will launch the other application, which may cause the current application to quit or at least be sent to the background.</para>
          <para>This member is not available to Extensions.</para>
        </remarks>
        <altmember cref="M:UIKit.UIApplication.CanOpenUrl" />
        <altmember cref="M:UIKit.UIApplicationDelegate.HandleOpenUrl" />
      </Docs>
    </Member>
    <Member MemberName="OpenUrl">
      <MemberSignature Language="C#" Value="public void OpenUrl (Foundation.NSUrl url, UIKit.UIApplicationOpenUrlOptions options, Action&lt;bool&gt; completion);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OpenUrl(class Foundation.NSUrl url, class UIKit.UIApplicationOpenUrlOptions options, class System.Action`1&lt;bool&gt; completion) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplication.OpenUrl(Foundation.NSUrl,UIKit.UIApplicationOpenUrlOptions,System.Action{System.Boolean})" />
      <MemberSignature Language="F#" Value="member this.OpenUrl : Foundation.NSUrl * UIKit.UIApplicationOpenUrlOptions * Action&lt;bool&gt; -&gt; unit" Usage="uIApplication.OpenUrl (url, options, completion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 10, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 10, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="Foundation.NSUrl" />
        <Parameter Name="options" Type="UIKit.UIApplicationOpenUrlOptions" />
        <Parameter Name="completion" Type="System.Action&lt;System.Boolean&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDActionArity1V2))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="url">The URL to be opened.</param>
        <param name="options">Launch options.</param>
        <param name="completion">
          <para>Asynchronously called after launch.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Opens the specified URL, launching the app that is registered to handle the scheme.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenUrlAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;bool&gt; OpenUrlAsync (Foundation.NSUrl url, UIKit.UIApplicationOpenUrlOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;bool&gt; OpenUrlAsync(class Foundation.NSUrl url, class UIKit.UIApplicationOpenUrlOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplication.OpenUrlAsync(Foundation.NSUrl,UIKit.UIApplicationOpenUrlOptions)" />
      <MemberSignature Language="F#" Value="member this.OpenUrlAsync : Foundation.NSUrl * UIKit.UIApplicationOpenUrlOptions -&gt; System.Threading.Tasks.Task&lt;bool&gt;" Usage="uIApplication.OpenUrlAsync (url, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 10, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 10, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="Foundation.NSUrl" />
        <Parameter Name="options" Type="UIKit.UIApplicationOpenUrlOptions" />
      </Parameters>
      <Docs>
        <param name="url">The URL to be opened.</param>
        <param name="options">Launch options.</param>
        <summary>Asynchronously opens the specified URL, launching the app that is registered to handle the scheme, and returns a task the represents success or failure.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreferredContentSizeCategory">
      <MemberSignature Language="C#" Value="public virtual Foundation.NSString PreferredContentSizeCategory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Foundation.NSString PreferredContentSizeCategory" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.PreferredContentSizeCategory" />
      <MemberSignature Language="F#" Value="member this.PreferredContentSizeCategory : Foundation.NSString" Usage="UIKit.UIApplication.PreferredContentSizeCategory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("preferredContentSizeCategory")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The font size preferred by the application user.</summary>
        <value>One of the values defined in <see cref="T:UIKit.UIContentSizeCategory" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PresentLocalNotificationNow">
      <MemberSignature Language="C#" Value="public virtual void PresentLocalNotificationNow (UIKit.UILocalNotification notification);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PresentLocalNotificationNow(class UIKit.UILocalNotification notification) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplication.PresentLocalNotificationNow(UIKit.UILocalNotification)" />
      <MemberSignature Language="F#" Value="abstract member PresentLocalNotificationNow : UIKit.UILocalNotification -&gt; unit&#xA;override this.PresentLocalNotificationNow : UIKit.UILocalNotification -&gt; unit" Usage="uIApplication.PresentLocalNotificationNow notification" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("presentLocalNotificationNow:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 10, 0, ObjCRuntime.PlatformArchitecture.None, "Use 'UNUserNotificationCenter.AddNotificationRequest' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="notification" Type="UIKit.UILocalNotification" />
      </Parameters>
      <Docs>
        <param name="notification">Local notification that the operating system presents immediately for the app.</param>
        <summary>Immediately presents a local notification.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectedDataAvailable">
      <MemberSignature Language="C#" Value="public virtual bool ProtectedDataAvailable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ProtectedDataAvailable" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.ProtectedDataAvailable" />
      <MemberSignature Language="F#" Value="member this.ProtectedDataAvailable : bool" Usage="UIKit.UIApplication.ProtectedDataAvailable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("isProtectedDataAvailable")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether content protection is available.</summary>
        <value>
          <see langword="true" /> if data protection is enabled and the device is locked. Otherwise, <see langword="false" />.</value>
        <remarks>
          <para>If this method returns <see langword="false" />, the application will not be allowed to read or write files whose <see cref="P:Foundation.NSFileManager.FileProtectionKey" /> is <see cref="P:Foundation.NSFileManager.FileProtectionComplete" /> or <see cref="P:Foundation.NSFileManager.FileProtectionCompleteUnlessOpen" />.</para>
        </remarks>
        <altmember cref="P:UIKit.UIApplication.ProtectedDataDidBecomeAvailable" />
      </Docs>
    </Member>
    <Member MemberName="ProtectedDataDidBecomeAvailable">
      <MemberSignature Language="C#" Value="public static Foundation.NSString ProtectedDataDidBecomeAvailable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString ProtectedDataDidBecomeAvailable" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.ProtectedDataDidBecomeAvailable" />
      <MemberSignature Language="F#" Value="member this.ProtectedDataDidBecomeAvailable : Foundation.NSString" Usage="UIKit.UIApplication.ProtectedDataDidBecomeAvailable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Use UIApplication.Notifications.ObserveProtectedDataDidBecomeAvailable helper method instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Field("UIApplicationProtectedDataDidBecomeAvailable", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indicates that the state of protected data has changed.</summary>
        <value>To be added.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIKit.UIApplication.Notifications" />.<format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=M:UIKit.UIKit.UIApplication.Notifications.ObserveProtectedDataDidBecomeAvailable*&amp;scope=Xamarin" title="M:UIKit.UIKit.UIApplication.Notifications.ObserveProtectedDataDidBecomeAvailable*">M:UIKit.UIKit.UIApplication.Notifications.ObserveProtectedDataDidBecomeAvailable*</a></format> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="C#"><![CDATA[
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveProtectedDataDidBecomeAvailable ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, Foundation.NSNotificationEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveProtectedDataDidBecomeAvailable (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.ProtectedDataDidBecomeAvailable, (notification) => {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.ProtectedDataDidBecomeAvailable, Callback);
}
]]></code>
          </example>
        </remarks>
        <altmember cref="P:UIKit.UIApplication.ProtectedDataAvailable" />
      </Docs>
    </Member>
    <Member MemberName="ProtectedDataWillBecomeUnavailable">
      <MemberSignature Language="C#" Value="public static Foundation.NSString ProtectedDataWillBecomeUnavailable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString ProtectedDataWillBecomeUnavailable" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.ProtectedDataWillBecomeUnavailable" />
      <MemberSignature Language="F#" Value="member this.ProtectedDataWillBecomeUnavailable : Foundation.NSString" Usage="UIKit.UIApplication.ProtectedDataWillBecomeUnavailable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Use UIApplication.Notifications.ObserveProtectedDataWillBecomeUnavailable helper method instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Field("UIApplicationProtectedDataWillBecomeUnavailable", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indicates that the state of protected data has changed.</summary>
        <value>To be added.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIKit.UIApplication.Notifications" />.<format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=M:UIKit.UIKit.UIApplication.Notifications.ObserveProtectedDataWillBecomeUnavailable*&amp;scope=Xamarin" title="M:UIKit.UIKit.UIApplication.Notifications.ObserveProtectedDataWillBecomeUnavailable*">M:UIKit.UIKit.UIApplication.Notifications.ObserveProtectedDataWillBecomeUnavailable*</a></format> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="C#"><![CDATA[
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveProtectedDataWillBecomeUnavailable ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, Foundation.NSNotificationEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveProtectedDataWillBecomeUnavailable (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.ProtectedDataWillBecomeUnavailable, (notification) => {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.ProtectedDataWillBecomeUnavailable, Callback);
}
]]></code>
          </example>
        </remarks>
        <altmember cref="P:UIKit.UIApplication.ProtectedDataAvailable" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForRemoteNotifications">
      <MemberSignature Language="C#" Value="public virtual void RegisterForRemoteNotifications ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterForRemoteNotifications() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplication.RegisterForRemoteNotifications" />
      <MemberSignature Language="F#" Value="abstract member RegisterForRemoteNotifications : unit -&gt; unit&#xA;override this.RegisterForRemoteNotifications : unit -&gt; unit" Usage="uIApplication.RegisterForRemoteNotifications " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("registerForRemoteNotifications")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Registers for receipt of push notifications using the Apple Push Service.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterForRemoteNotificationTypes">
      <MemberSignature Language="C#" Value="public virtual void RegisterForRemoteNotificationTypes (UIKit.UIRemoteNotificationType types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterForRemoteNotificationTypes(valuetype UIKit.UIRemoteNotificationType types) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplication.RegisterForRemoteNotificationTypes(UIKit.UIRemoteNotificationType)" />
      <MemberSignature Language="F#" Value="abstract member RegisterForRemoteNotificationTypes : UIKit.UIRemoteNotificationType -&gt; unit&#xA;override this.RegisterForRemoteNotificationTypes : UIKit.UIRemoteNotificationType -&gt; unit" Usage="uIApplication.RegisterForRemoteNotificationTypes types" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("registerForRemoteNotificationTypes:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, "Use 'RegisterUserNotifications', 'RegisterForNotifications'  or 'UNUserNotificationCenter.RequestAuthorization' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="UIKit.UIRemoteNotificationType" />
      </Parameters>
      <Docs>
        <param name="types">The types of notifications that the app wants to employ.</param>
        <summary>Begins the registration of the application to receive the specified types of notification from Apple Push Service.</summary>
        <remarks>
          <para>Only notifications of the types registered by this method will display, even if different types (e.g., an alert) is specified in the notification's payload.</para>
        </remarks>
        <altmember cref="M:UIKit.UIApplicationDelegate.RegisteredForRemoteNotifications" />
        <altmember cref="M:UIKit.UIApplicationDelegate.FailedToRegisterForRemoteNotifications" />
        <altmember cref="P:UIKit.UIApplication.EnabledRemoteNotificationTypes" />
      </Docs>
    </Member>
    <Member MemberName="RegisterObjectForStateRestoration">
      <MemberSignature Language="C#" Value="public static void RegisterObjectForStateRestoration (UIKit.IUIStateRestoring uistateRestoringObject, string restorationIdentifier);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterObjectForStateRestoration(class UIKit.IUIStateRestoring uistateRestoringObject, string restorationIdentifier) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplication.RegisterObjectForStateRestoration(UIKit.IUIStateRestoring,System.String)" />
      <MemberSignature Language="F#" Value="static member RegisterObjectForStateRestoration : UIKit.IUIStateRestoring * string -&gt; unit" Usage="UIKit.UIApplication.RegisterObjectForStateRestoration (uistateRestoringObject, restorationIdentifier)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("registerObjectForStateRestoration:restorationIdentifier:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uistateRestoringObject" Type="UIKit.IUIStateRestoring" />
        <Parameter Name="restorationIdentifier" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uistateRestoringObject">Object that is registered with the restoration archive.</param>
        <param name="restorationIdentifier">Restoration identifier used for the object.</param>
        <summary>Registers the <paramref name="uistateRestoringObject" /> as eligible for state restoration.</summary>
        <remarks>
          <para>Calling this method allows the object to be saved and restored but does not automatically trigger preservation/restoration. Application developers must write the object at the appropriate time, for instance <see cref="M:UIKit.UIViewController.EncodeRestorableState(Foundation.NSCoder)" />. </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterUserNotificationSettings">
      <MemberSignature Language="C#" Value="public virtual void RegisterUserNotificationSettings (UIKit.UIUserNotificationSettings notificationSettings);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterUserNotificationSettings(class UIKit.UIUserNotificationSettings notificationSettings) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplication.RegisterUserNotificationSettings(UIKit.UIUserNotificationSettings)" />
      <MemberSignature Language="F#" Value="abstract member RegisterUserNotificationSettings : UIKit.UIUserNotificationSettings -&gt; unit&#xA;override this.RegisterUserNotificationSettings : UIKit.UIUserNotificationSettings -&gt; unit" Usage="uIApplication.RegisterUserNotificationSettings notificationSettings" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("registerUserNotificationSettings:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 10, 0, ObjCRuntime.PlatformArchitecture.None, "Use 'UNUserNotificationCenter.RequestAuthorization' and 'UNUserNotificationCenter.SetNotificationCategories' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="notificationSettings" Type="UIKit.UIUserNotificationSettings" />
      </Parameters>
      <Docs>
        <param name="notificationSettings">Notification types that the app wants to use.</param>
        <summary>Registers the preferred options for user notification.</summary>
        <remarks>
          <para>
          This displays, if necessary, a standard privacy dialog. Once the user interacts with it, the <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=UIKit%20UIApplication%20Delegate%20Did%20Register%20User%20Notifications&amp;scope=Xamarin" title="M:UIKit.UIApplicationDelegate.DidRegisterUserNotifications*">M:UIKit.UIApplicationDelegate.DidRegisterUserNotifications*</a></format> is called.
        </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScheduledLocalNotifications">
      <MemberSignature Language="C#" Value="public virtual UIKit.UILocalNotification[] ScheduledLocalNotifications { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UILocalNotification[] ScheduledLocalNotifications" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.ScheduledLocalNotifications" />
      <MemberSignature Language="F#" Value="member this.ScheduledLocalNotifications : UIKit.UILocalNotification[] with get, set" Usage="UIKit.UIApplication.ScheduledLocalNotifications" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 10, 0, ObjCRuntime.PlatformArchitecture.None, "Use 'UNUserNotificationCenter.GetPendingNotificationRequests' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 10, 0, ObjCRuntime.PlatformArchitecture.None, "Use 'UNUserNotificationCenter.GetPendingNotificationRequests' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 10, 0, ObjCRuntime.PlatformArchitecture.None, "Use 'UNUserNotificationCenter.GetPendingNotificationRequests' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("scheduledLocalNotifications", ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setScheduledLocalNotifications:", ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UILocalNotification[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An array of <see cref="T:UIKit.UILocalNotification" />s that are currently scheduled.</summary>
        <value>An array of <see cref="T:UIKit.UILocalNotification" /> objects.</value>
        <remarks>
          <para>If application developers set this property, the local notifications are replaced via a series of calls to <see cref="M:UIKit.UIApplication.CancelLocalNotification(UIKit.UILocalNotification)" /> and <see cref="M:UIKit.UIApplication.ScheduleLocalNotification(UIKit.UILocalNotification)" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScheduleLocalNotification">
      <MemberSignature Language="C#" Value="public virtual void ScheduleLocalNotification (UIKit.UILocalNotification notification);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ScheduleLocalNotification(class UIKit.UILocalNotification notification) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplication.ScheduleLocalNotification(UIKit.UILocalNotification)" />
      <MemberSignature Language="F#" Value="abstract member ScheduleLocalNotification : UIKit.UILocalNotification -&gt; unit&#xA;override this.ScheduleLocalNotification : UIKit.UILocalNotification -&gt; unit" Usage="uIApplication.ScheduleLocalNotification notification" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("scheduleLocalNotification:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 10, 0, ObjCRuntime.PlatformArchitecture.None, "Use 'UNUserNotificationCenter.AddNotificationRequest' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="notification" Type="UIKit.UILocalNotification" />
      </Parameters>
      <Docs>
        <param name="notification">The local notification that is going to be scheduled.</param>
        <summary>Schedules the <paramref name="notification" /> for delivery.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SendAction">
      <MemberSignature Language="C#" Value="public virtual bool SendAction (ObjCRuntime.Selector action, Foundation.NSObject target, Foundation.NSObject sender, UIKit.UIEvent forEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool SendAction(class ObjCRuntime.Selector action, class Foundation.NSObject target, class Foundation.NSObject sender, class UIKit.UIEvent forEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplication.SendAction(ObjCRuntime.Selector,Foundation.NSObject,Foundation.NSObject,UIKit.UIEvent)" />
      <MemberSignature Language="F#" Value="abstract member SendAction : ObjCRuntime.Selector * Foundation.NSObject * Foundation.NSObject * UIKit.UIEvent -&gt; bool&#xA;override this.SendAction : ObjCRuntime.Selector * Foundation.NSObject * Foundation.NSObject * UIKit.UIEvent -&gt; bool" Usage="uIApplication.SendAction (action, target, sender, forEvent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("sendAction:to:from:forEvent:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="ObjCRuntime.Selector" />
        <Parameter Name="target" Type="Foundation.NSObject" />
        <Parameter Name="sender" Type="Foundation.NSObject" />
        <Parameter Name="forEvent" Type="UIKit.UIEvent" />
      </Parameters>
      <Docs>
        <param name="action">Selector that identifies an action method.</param>
        <param name="target">
          <para>The object receiving the action message.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <param name="sender">
          <para>To be added.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <param name="forEvent">
          <para>To be added.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Send an action message to the specified <paramref name="target" />.</summary>
        <returns>
          <see langword="true" /> if the responder handled the message.</returns>
        <remarks>
          <para>This method allows application developers to trigger native action methods. </para>
        </remarks>
        <altmember cref="M:UIKit.UIApplication.SendEvent" />
      </Docs>
    </Member>
    <Member MemberName="SendEvent">
      <MemberSignature Language="C#" Value="public virtual void SendEvent (UIKit.UIEvent uievent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SendEvent(class UIKit.UIEvent uievent) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplication.SendEvent(UIKit.UIEvent)" />
      <MemberSignature Language="F#" Value="abstract member SendEvent : UIKit.UIEvent -&gt; unit&#xA;override this.SendEvent : UIKit.UIEvent -&gt; unit" Usage="uIApplication.SendEvent uievent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("sendEvent:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uievent" Type="UIKit.UIEvent" />
      </Parameters>
      <Docs>
        <param name="uievent">Object that encapsulates the event information.</param>
        <summary>Sends an event to the application.</summary>
        <remarks>
          <para>This method allows application developers to create native <see cref="T:UIKit.UIEvent" />s that are then handled normally.</para>
        </remarks>
        <altmember cref="M:UIKit.UIApplication.SendAction" />
      </Docs>
    </Member>
    <Member MemberName="SetAlternateIconName">
      <MemberSignature Language="C#" Value="public virtual void SetAlternateIconName (string alternateIconName, Action&lt;Foundation.NSError&gt; completionHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetAlternateIconName(string alternateIconName, class System.Action`1&lt;class Foundation.NSError&gt; completionHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplication.SetAlternateIconName(System.String,System.Action{Foundation.NSError})" />
      <MemberSignature Language="F#" Value="abstract member SetAlternateIconName : string * Action&lt;Foundation.NSError&gt; -&gt; unit&#xA;override this.SetAlternateIconName : string * Action&lt;Foundation.NSError&gt; -&gt; unit" Usage="uIApplication.SetAlternateIconName (alternateIconName, completionHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("setAlternateIconName:completionHandler:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 10, 3, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 10, 2, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="alternateIconName" Type="System.String" />
        <Parameter Name="completionHandler" Type="System.Action&lt;Foundation.NSError&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDActionArity1V9))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="alternateIconName">
          <para>The name of the new alternate icon. This parameter can be <see langwor="null" />.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <param name="completionHandler">
          <para>A handler to run after the operation completes.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Sets the name of the alternate icon.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAlternateIconNameAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task SetAlternateIconNameAsync (string alternateIconName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task SetAlternateIconNameAsync(string alternateIconName) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplication.SetAlternateIconNameAsync(System.String)" />
      <MemberSignature Language="F#" Value="abstract member SetAlternateIconNameAsync : string -&gt; System.Threading.Tasks.Task&#xA;override this.SetAlternateIconNameAsync : string -&gt; System.Threading.Tasks.Task" Usage="uIApplication.SetAlternateIconNameAsync alternateIconName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 10, 3, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 10, 2, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="alternateIconName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="alternateIconName">The name of the new alternate icon. This parameter can be .This parameter can be .</param>
        <summary>Sets the name of the alternate icon.</summary>
        <returns>A task that represents the asynchronous SetAlternateIconName operation</returns>
        <remarks>
          <para copied="true">The SetAlternateIconNameAsync method is suitable to be used with C# async by returning control to the caller with a Task representing the operation.</para>
          <para copied="true">To be added.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetKeepAliveTimeout">
      <MemberSignature Language="C#" Value="public virtual bool SetKeepAliveTimeout (double timeout, Action handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool SetKeepAliveTimeout(float64 timeout, class System.Action handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplication.SetKeepAliveTimeout(System.Double,System.Action)" />
      <MemberSignature Language="F#" Value="abstract member SetKeepAliveTimeout : double * Action -&gt; bool&#xA;override this.SetKeepAliveTimeout : double * Action -&gt; bool" Usage="uIApplication.SetKeepAliveTimeout (timeout, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("setKeepAliveTimeout:handler:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.None, "Use 'PushKit' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Double" />
        <Parameter Name="handler" Type="System.Action">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="timeout">Maximum interval (in seconds) at which the app should be awakened to check its VoIP connection.</param>
        <param name="handler">
          <para>Action that performs all tasks needed to maintain the VoIP network connection.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>In older iOS versions, this configures a periodic handler for VoIP apps.</summary>
        <returns>
          <see langword="true" /> if installed, <see langword="false" /> if not.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetMinimumBackgroundFetchInterval">
      <MemberSignature Language="C#" Value="public virtual void SetMinimumBackgroundFetchInterval (double minimumBackgroundFetchInterval);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetMinimumBackgroundFetchInterval(float64 minimumBackgroundFetchInterval) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplication.SetMinimumBackgroundFetchInterval(System.Double)" />
      <MemberSignature Language="F#" Value="abstract member SetMinimumBackgroundFetchInterval : double -&gt; unit&#xA;override this.SetMinimumBackgroundFetchInterval : double -&gt; unit" Usage="uIApplication.SetMinimumBackgroundFetchInterval minimumBackgroundFetchInterval" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("setMinimumBackgroundFetchInterval:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="minimumBackgroundFetchInterval" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="minimumBackgroundFetchInterval">The desired minimum background fetch interval.  This constant <see cref="P:UIKit.UIApplication.BackgroundFetchIntervalMinimum" /> cane be used to set the minimum update interval or <see cref="P:UIKit.UIApplication.BackgroundFetchIntervalNever" />) to disable background fetching.</param>
        <summary>Activates backgound fetching.</summary>
        <remarks>
          <para>
	    This method can be used to enable or disable background
	    fetching.  When this is enabled, the operating system will
	    call the application's delegate <see cref="M:UIKit.UIApplicationDelegate.PerformFetch(UIKit.UIApplication,System.Action{UIKit.UIBackgroundFetchResult})" />
	    method at the discretion of the operating system to allow
	    the application to download and request data from a
	    server.
	  </para>
          <para>
	    This requires that the application has the background fetch entitlement activated.   
	  </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetNewsstandIconImage">
      <MemberSignature Language="C#" Value="public virtual void SetNewsstandIconImage (UIKit.UIImage image);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetNewsstandIconImage(class UIKit.UIImage image) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplication.SetNewsstandIconImage(UIKit.UIImage)" />
      <MemberSignature Language="F#" Value="abstract member SetNewsstandIconImage : UIKit.UIImage -&gt; unit&#xA;override this.SetNewsstandIconImage : UIKit.UIImage -&gt; unit" Usage="uIApplication.SetNewsstandIconImage image" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("setNewsstandIconImage:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="UIKit.UIImage" />
      </Parameters>
      <Docs>
        <param name="image">The image to be used, or <see langword="null" /> to set the icon stored in the app bundle.<para tool="nullallowed">This parameter can be <see langword="null" />.</para></param>
        <summary>Sets the icon to be used in Newsstand.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetStatusBarHidden">
      <MemberSignature Language="C#" Value="public virtual void SetStatusBarHidden (bool hidden, bool animated);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetStatusBarHidden(bool hidden, bool animated) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplication.SetStatusBarHidden(System.Boolean,System.Boolean)" />
      <MemberSignature Language="F#" Value="abstract member SetStatusBarHidden : bool * bool -&gt; unit&#xA;override this.SetStatusBarHidden : bool * bool -&gt; unit" Usage="uIApplication.SetStatusBarHidden (hidden, animated)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("setStatusBarHidden:animated:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 3, 2, ObjCRuntime.PlatformArchitecture.All, "Use 'SetStatusBarHidden (bool, UIStatusBarAnimation)' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hidden" Type="System.Boolean" />
        <Parameter Name="animated" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="hidden">
          <see langword="true" /> to hide the status bar, <see langword="false" /> to reveal it.</param>
        <param name="animated">Constant that indicates whether there should be animation, and, if animation is requested, whether it should fade the status bar in or out or slide the status bar in or out.</param>
        <summary>Hides or shows the animation bar, and whether it should be animated.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetStatusBarHidden">
      <MemberSignature Language="C#" Value="public virtual void SetStatusBarHidden (bool state, UIKit.UIStatusBarAnimation animation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetStatusBarHidden(bool state, valuetype UIKit.UIStatusBarAnimation animation) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplication.SetStatusBarHidden(System.Boolean,UIKit.UIStatusBarAnimation)" />
      <MemberSignature Language="F#" Value="abstract member SetStatusBarHidden : bool * UIKit.UIStatusBarAnimation -&gt; unit&#xA;override this.SetStatusBarHidden : bool * UIKit.UIStatusBarAnimation -&gt; unit" Usage="uIApplication.SetStatusBarHidden (state, animation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("setStatusBarHidden:withAnimation:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Boolean" />
        <Parameter Name="animation" Type="UIKit.UIStatusBarAnimation" />
      </Parameters>
      <Docs>
        <param name="state">
          <see langword="true" /> to hide the status bar, <see langword="false" /> to reveal it.</param>
        <param name="animation">The animation to use.</param>
        <summary>Hides or shows the status bar.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetStatusBarOrientation">
      <MemberSignature Language="C#" Value="public virtual void SetStatusBarOrientation (UIKit.UIInterfaceOrientation orientation, bool animated);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetStatusBarOrientation(valuetype UIKit.UIInterfaceOrientation orientation, bool animated) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplication.SetStatusBarOrientation(UIKit.UIInterfaceOrientation,System.Boolean)" />
      <MemberSignature Language="F#" Value="abstract member SetStatusBarOrientation : UIKit.UIInterfaceOrientation * bool -&gt; unit&#xA;override this.SetStatusBarOrientation : UIKit.UIInterfaceOrientation * bool -&gt; unit" Usage="uIApplication.SetStatusBarOrientation (orientation, animated)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("setStatusBarOrientation:animated:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="orientation" Type="UIKit.UIInterfaceOrientation" />
        <Parameter Name="animated" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="orientation">The specific orientation for the status bar.</param>
        <param name="animated">
          <see langword="true" /> if transition to the new orientation should be animated; <see langword="false" /> if transition should be immediate, without any animation.</param>
        <summary>Sets the status bar to <paramref name="orientation" />.</summary>
        <remarks>
          <para>This method should not be used if the application is expected to handle rotation automatically. Once this method is called, the status bar will not change automatically in response to rotation.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetStatusBarStyle">
      <MemberSignature Language="C#" Value="public virtual void SetStatusBarStyle (UIKit.UIStatusBarStyle statusBarStyle, bool animated);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetStatusBarStyle(valuetype UIKit.UIStatusBarStyle statusBarStyle, bool animated) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplication.SetStatusBarStyle(UIKit.UIStatusBarStyle,System.Boolean)" />
      <MemberSignature Language="F#" Value="abstract member SetStatusBarStyle : UIKit.UIStatusBarStyle * bool -&gt; unit&#xA;override this.SetStatusBarStyle : UIKit.UIStatusBarStyle * bool -&gt; unit" Usage="uIApplication.SetStatusBarStyle (statusBarStyle, animated)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("setStatusBarStyle:animated:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="statusBarStyle" Type="UIKit.UIStatusBarStyle" />
        <Parameter Name="animated" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="statusBarStyle">A constant that specifies the style for the status bar.</param>
        <param name="animated">
          <see langword="true" /> if transition to the new orientation should be animated; otherwise <see langword="false" />.</param>
        <summary>Sets the style of the status bar, optionally animating the change.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SharedApplication">
      <MemberSignature Language="C#" Value="public static UIKit.UIApplication SharedApplication { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class UIKit.UIApplication SharedApplication" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.SharedApplication" />
      <MemberSignature Language="F#" Value="member this.SharedApplication : UIKit.UIApplication" Usage="UIKit.UIApplication.SharedApplication" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("sharedApplication")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIApplication</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Points to the main application class.</summary>
        <value>To be added.</value>
        <remarks>
          <para>This member is not available to Extensions.</para>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShortcutItems">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIApplicationShortcutItem[] ShortcutItems { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIApplicationShortcutItem[] ShortcutItems" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.ShortcutItems" />
      <MemberSignature Language="F#" Value="member this.ShortcutItems : UIKit.UIApplicationShortcutItem[] with get, set" Usage="UIKit.UIApplication.ShortcutItems" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("shortcutItems", ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setShortcutItems:", ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIApplicationShortcutItem[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the list of Quick Action shortcuts that the developer defined in code, as distinct from those defined in the <c>Info.plist</c> file.</summary>
        <value>
          <para>The list of force touch Quick Action shortcuts that the developer has defined in code, as distinct from those that are defined in the <c>Info.plist</c> file.</para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>
          <para>Application developers can define Quick Action shortcuts either in their application code (dynamically) or in the <c>Info.plist</c> file in the application bundle (statically). Statically defined Quick Action shortcut items are only available as an argument to the HandleShortcutItem method when the shortcut is selected by the user; they are not available in the <see cref="P:UIKit.UIApplication.ShortcutItems" /> property. Only dynamically created shortcut items appear in <see cref="P:UIKit.UIApplication.ShortcutItems" />.</para>
          <para>Statically defined shortcut items are preferentially displayed by iOS 9. That is, iOS displays as many statically defined shortcut as are allowed by the system first, and only then displays dynamically created quick action shortcuts up to the remainder of the system limit. The list of dynamically created shortcut items is displayed above the statically defined items, starting from the 0th position in <see cref="P:UIKit.UIApplication.ShortcutItems" />, and stacking successive entries above previous ones.</para>
          <para>This list persists across application invocations.</para>
          <para>The following example, when added to the <c>Info.plist</c> file, statically creates a force touch Quick Action shortcut:</para>
          <code><![CDATA[
<key>XSAppIconAssets</key>
<string>Resources/Images.xcassets/AppIcons.appiconset</string>
<key>UIApplicationShortcutItems</key>
<array>
    <dict>
        <key>UIApplicationShortcutItemIconType</key>
        <string>UIApplicationShortcutIconTypeSearch</string>
        <key>UIApplicationShortcutItemSubtitle</key>
        <string>Find something</string>
        <key>UIApplicationShortcutItemTitle</key>
        <string>Search</string>
        <key>UIApplicationShortcutItemType</key>
        <string>PlistShortcut</string>
    </dict>
</array>
]]></code>
          <para>The Quick Action shortcut defined above will not be available in <see cref="P:UIKit.UIApplication.ShortcutItems" />. If the developer places the code below into their <see cref="M:UIKit.UIApplicationDelegate_Extensions.FinishedLaunching(UIKit.IUIApplicationDelegate,UIKit.UIApplication,Foundation.NSDictionary)" /> method, then the dynamically defined shortcut item will be available after the first time the application is launched:</para>
          <code><![CDATA[
application.ShortcutItems = new UIMutableApplicationShortcutItem[] {
    new UIMutableApplicationShortcutItem ("DynamicItem", "Send") {
        LocalizedTitle = "Dynamic Item",
        LocalizedSubtitle = "Send Message",
        Icon = UIApplicationShortcutIcon.FromType
                    (UIApplicationShortcutIconType.Mail)
    }
};
]]></code>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SignificantTimeChangeNotification">
      <MemberSignature Language="C#" Value="public static Foundation.NSString SignificantTimeChangeNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString SignificantTimeChangeNotification" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.SignificantTimeChangeNotification" />
      <MemberSignature Language="F#" Value="member this.SignificantTimeChangeNotification : Foundation.NSString" Usage="UIKit.UIApplication.SignificantTimeChangeNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Use UIApplication.Notifications.ObserveSignificantTimeChange helper method instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Field("UIApplicationSignificantTimeChangeNotification", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for SignificantTimeChange</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIKit.UIApplication.Notifications" />.<format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=M:UIKit.UIKit.UIApplication.Notifications.ObserveSignificantTimeChange*&amp;scope=Xamarin" title="M:UIKit.UIKit.UIApplication.Notifications.ObserveSignificantTimeChange*">M:UIKit.UIKit.UIApplication.Notifications.ObserveSignificantTimeChange*</a></format> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="C#"><![CDATA[
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveSignificantTimeChange ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, Foundation.NSNotificationEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveSignificantTimeChange (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.SignificantTimeChangeNotification, (notification) => {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.SignificantTimeChangeNotification, Callback);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StateRestorationBundleVersionKey">
      <MemberSignature Language="C#" Value="public static Foundation.NSString StateRestorationBundleVersionKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString StateRestorationBundleVersionKey" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.StateRestorationBundleVersionKey" />
      <MemberSignature Language="F#" Value="member this.StateRestorationBundleVersionKey : Foundation.NSString" Usage="UIKit.UIApplication.StateRestorationBundleVersionKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIApplicationStateRestorationBundleVersionKey", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UIApplicationStateRestorationBundleVersionKey</summary>
        <value>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StateRestorationSystemVersionKey">
      <MemberSignature Language="C#" Value="public static Foundation.NSString StateRestorationSystemVersionKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString StateRestorationSystemVersionKey" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.StateRestorationSystemVersionKey" />
      <MemberSignature Language="F#" Value="member this.StateRestorationSystemVersionKey : Foundation.NSString" Usage="UIKit.UIApplication.StateRestorationSystemVersionKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIApplicationStateRestorationSystemVersionKey", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UIApplicationStateRestorationSystemVersionKey</summary>
        <value>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StateRestorationTimestampKey">
      <MemberSignature Language="C#" Value="public static Foundation.NSString StateRestorationTimestampKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString StateRestorationTimestampKey" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.StateRestorationTimestampKey" />
      <MemberSignature Language="F#" Value="member this.StateRestorationTimestampKey : Foundation.NSString" Usage="UIKit.UIApplication.StateRestorationTimestampKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIApplicationStateRestorationTimestampKey", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UIApplicationStateRestorationTimestampKey</summary>
        <value>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StateRestorationUserInterfaceIdiomKey">
      <MemberSignature Language="C#" Value="public static Foundation.NSString StateRestorationUserInterfaceIdiomKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString StateRestorationUserInterfaceIdiomKey" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.StateRestorationUserInterfaceIdiomKey" />
      <MemberSignature Language="F#" Value="member this.StateRestorationUserInterfaceIdiomKey : Foundation.NSString" Usage="UIKit.UIApplication.StateRestorationUserInterfaceIdiomKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIApplicationStateRestorationUserInterfaceIdiomKey", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UIApplicationStateRestorationUserInterfaceIdiomKey</summary>
        <value>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StatusBarFrame">
      <MemberSignature Language="C#" Value="public virtual CoreGraphics.CGRect StatusBarFrame { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype CoreGraphics.CGRect StatusBarFrame" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.StatusBarFrame" />
      <MemberSignature Language="F#" Value="member this.StatusBarFrame : CoreGraphics.CGRect" Usage="UIKit.UIApplication.StatusBarFrame" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("statusBarFrame")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>CoreGraphics.CGRect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The Frame of the status bar.</summary>
        <value>Will be <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=System%20Drawing%20Rectangle%20FZero&amp;scope=Xamarin" title="P:System.Drawing.RectangleF.Zero">P:System.Drawing.RectangleF.Zero</a></format> if the status bar is hidden.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StatusBarFrameUserInfoKey">
      <MemberSignature Language="C#" Value="public static Foundation.NSString StatusBarFrameUserInfoKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString StatusBarFrameUserInfoKey" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.StatusBarFrameUserInfoKey" />
      <MemberSignature Language="F#" Value="member this.StatusBarFrameUserInfoKey : Foundation.NSString" Usage="UIKit.UIApplication.StatusBarFrameUserInfoKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIApplicationStatusBarFrameUserInfoKey", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UIApplicationStatusBarFrameUserInfoKey</summary>
        <value>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StatusBarHidden">
      <MemberSignature Language="C#" Value="public virtual bool StatusBarHidden { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool StatusBarHidden" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.StatusBarHidden" />
      <MemberSignature Language="F#" Value="member this.StatusBarHidden : bool with get, set" Usage="UIKit.UIApplication.StatusBarHidden" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("isStatusBarHidden")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setStatusBarHidden:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether the status bar is visible.</summary>
        <value>Boolean that determines whether the status bar is hidden.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StatusBarOrientation">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIInterfaceOrientation StatusBarOrientation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype UIKit.UIInterfaceOrientation StatusBarOrientation" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.StatusBarOrientation" />
      <MemberSignature Language="F#" Value="member this.StatusBarOrientation : UIKit.UIInterfaceOrientation with get, set" Usage="UIKit.UIApplication.StatusBarOrientation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("statusBarOrientation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setStatusBarOrientation:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIInterfaceOrientation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The orientation of the status bar.</summary>
        <value>Current orientation of the status bar.</value>
        <remarks>To be added.</remarks>
        <altmember cref="M:UIKit.UIApplication.SetStatusBarOrientation" />
      </Docs>
    </Member>
    <Member MemberName="StatusBarOrientationAnimationDuration">
      <MemberSignature Language="C#" Value="public virtual double StatusBarOrientationAnimationDuration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 StatusBarOrientationAnimationDuration" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.StatusBarOrientationAnimationDuration" />
      <MemberSignature Language="F#" Value="member this.StatusBarOrientationAnimationDuration : double" Usage="UIKit.UIApplication.StatusBarOrientationAnimationDuration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("statusBarOrientationAnimationDuration")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The length of the animation used when the status bar rotates.</summary>
        <value>Returns the animation duration in seconds for the status bar during a 90 degree change in orientation.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StatusBarOrientationUserInfoKey">
      <MemberSignature Language="C#" Value="public static Foundation.NSString StatusBarOrientationUserInfoKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString StatusBarOrientationUserInfoKey" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.StatusBarOrientationUserInfoKey" />
      <MemberSignature Language="F#" Value="member this.StatusBarOrientationUserInfoKey : Foundation.NSString" Usage="UIKit.UIApplication.StatusBarOrientationUserInfoKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIApplicationStatusBarOrientationUserInfoKey", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UIApplicationStatusBarOrientationUserInfoKey</summary>
        <value>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StatusBarStyle">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIStatusBarStyle StatusBarStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype UIKit.UIStatusBarStyle StatusBarStyle" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.StatusBarStyle" />
      <MemberSignature Language="F#" Value="member this.StatusBarStyle : UIKit.UIStatusBarStyle with get, set" Usage="UIKit.UIApplication.StatusBarStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("statusBarStyle")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setStatusBarStyle:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIStatusBarStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The current <see cref="T:UIKit.UIStatusBarStyle" />.</summary>
        <value>A constant that indicates the style of the status bar.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportedInterfaceOrientationsForWindow">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIInterfaceOrientationMask SupportedInterfaceOrientationsForWindow (UIKit.UIWindow window);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype UIKit.UIInterfaceOrientationMask SupportedInterfaceOrientationsForWindow(class UIKit.UIWindow window) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplication.SupportedInterfaceOrientationsForWindow(UIKit.UIWindow)" />
      <MemberSignature Language="F#" Value="abstract member SupportedInterfaceOrientationsForWindow : UIKit.UIWindow -&gt; UIKit.UIInterfaceOrientationMask&#xA;override this.SupportedInterfaceOrientationsForWindow : UIKit.UIWindow -&gt; UIKit.UIInterfaceOrientationMask" Usage="uIApplication.SupportedInterfaceOrientationsForWindow window" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("supportedInterfaceOrientationsForWindow:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIInterfaceOrientationMask</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="window" Type="UIKit.UIWindow">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.Transient</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="window">Window from which the default interface orientations are going to be retrieved.</param>
        <summary>The set of interface orientations that are used for the view controllers in the specified window.</summary>
        <returns>A bitmask indicating which orientations are supported.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsAlternateIcons">
      <MemberSignature Language="C#" Value="public virtual bool SupportsAlternateIcons { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsAlternateIcons" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.SupportsAlternateIcons" />
      <MemberSignature Language="F#" Value="member this.SupportsAlternateIcons : bool" Usage="UIKit.UIApplication.SupportsAlternateIcons" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 10, 3, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 10, 2, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("supportsAlternateIcons")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 10, 3, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 10, 2, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UITrackingRunLoopMode">
      <MemberSignature Language="C#" Value="public static Foundation.NSString UITrackingRunLoopMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString UITrackingRunLoopMode" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.UITrackingRunLoopMode" />
      <MemberSignature Language="F#" Value="member this.UITrackingRunLoopMode : Foundation.NSString" Usage="UIKit.UIApplication.UITrackingRunLoopMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UITrackingRunLoopMode", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UITrackingRunLoopMode</summary>
        <value>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterForRemoteNotifications">
      <MemberSignature Language="C#" Value="public virtual void UnregisterForRemoteNotifications ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UnregisterForRemoteNotifications() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIApplication.UnregisterForRemoteNotifications" />
      <MemberSignature Language="F#" Value="abstract member UnregisterForRemoteNotifications : unit -&gt; unit&#xA;override this.UnregisterForRemoteNotifications : unit -&gt; unit" Usage="uIApplication.UnregisterForRemoteNotifications " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("unregisterForRemoteNotifications")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>The application will no longer receive notifications from Apple Push Service.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UserDidTakeScreenshotNotification">
      <MemberSignature Language="C#" Value="public static Foundation.NSString UserDidTakeScreenshotNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString UserDidTakeScreenshotNotification" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.UserDidTakeScreenshotNotification" />
      <MemberSignature Language="F#" Value="member this.UserDidTakeScreenshotNotification : Foundation.NSString" Usage="UIKit.UIApplication.UserDidTakeScreenshotNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Use UIApplication.Notifications.ObserveUserDidTakeScreenshot helper method instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Field("UIApplicationUserDidTakeScreenshotNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for UserDidTakeScreenshot</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIKit.UIApplication.Notifications" />.<format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=M:UIKit.UIKit.UIApplication.Notifications.ObserveUserDidTakeScreenshot*&amp;scope=Xamarin" title="M:UIKit.UIKit.UIApplication.Notifications.ObserveUserDidTakeScreenshot*">M:UIKit.UIKit.UIApplication.Notifications.ObserveUserDidTakeScreenshot*</a></format> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="C#"><![CDATA[
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveUserDidTakeScreenshot ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, Foundation.NSNotificationEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveUserDidTakeScreenshot (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.UserDidTakeScreenshotNotification, (notification) => {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.UserDidTakeScreenshotNotification, Callback);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserInterfaceLayoutDirection">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIUserInterfaceLayoutDirection UserInterfaceLayoutDirection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype UIKit.UIUserInterfaceLayoutDirection UserInterfaceLayoutDirection" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.UserInterfaceLayoutDirection" />
      <MemberSignature Language="F#" Value="member this.UserInterfaceLayoutDirection : UIKit.UIUserInterfaceLayoutDirection" Usage="UIKit.UIApplication.UserInterfaceLayoutDirection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("userInterfaceLayoutDirection")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIUserInterfaceLayoutDirection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The layout direction (right-to-left or left-to-right) of the UI.</summary>
        <value>Returns the read-only layout direction of the user interface.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WeakDelegate">
      <MemberSignature Language="C#" Value="public virtual Foundation.NSObject WeakDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Foundation.NSObject WeakDelegate" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.WeakDelegate" />
      <MemberSignature Language="F#" Value="member this.WeakDelegate : Foundation.NSObject with get, set" Usage="UIKit.UIApplication.WeakDelegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("delegate", ObjCRuntime.ArgumentSemantic.UnsafeUnretained)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setDelegate:", ObjCRuntime.ArgumentSemantic.UnsafeUnretained)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An object that can respond to the delegate protocol for this type</summary>
        <value>The instance that will respond to events and data requests.</value>
        <remarks>
          <para>The delegate instance assigned to this object will be used to handle events or provide data on demand to this class.</para>
          <para>When setting the Delegate or WeakDelegate values events will be delivered to the specified instance instead of being delivered to the C#-style events</para>
          <para>   Methods must be decorated with the [Export ("selectorName")] attribute to respond to each method from the protocol.   Alternatively use the Delegate method which is strongly typed and does not require the [Export] attributes on methods.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WillChangeStatusBarFrameNotification">
      <MemberSignature Language="C#" Value="public static Foundation.NSString WillChangeStatusBarFrameNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString WillChangeStatusBarFrameNotification" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.WillChangeStatusBarFrameNotification" />
      <MemberSignature Language="F#" Value="member this.WillChangeStatusBarFrameNotification : Foundation.NSString" Usage="UIKit.UIApplication.WillChangeStatusBarFrameNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Use UIApplication.Notifications.ObserveWillChangeStatusBarFrame helper method instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Field("UIApplicationWillChangeStatusBarFrameNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for WillChangeStatusBarFrame</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">To subscribe to this notification, developers can use the convenience <see cref="T:UIKit.UIApplication.Notifications" />.<see cref="M:UIKit.UIApplication.Notifications.ObserveWillChangeStatusBarFrame*" /> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="C#"><![CDATA[
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveWillChangeStatusBarFrame ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("StatusBarFrame", args.StatusBarFrame);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, UIKit.UIStatusBarFrameChangeEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("StatusBarFrame", args.StatusBarFrame);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveWillChangeStatusBarFrame (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.WillChangeStatusBarFrameNotification, (notification) => {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.WillChangeStatusBarFrameNotification, Callback);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WillChangeStatusBarOrientationNotification">
      <MemberSignature Language="C#" Value="public static Foundation.NSString WillChangeStatusBarOrientationNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString WillChangeStatusBarOrientationNotification" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.WillChangeStatusBarOrientationNotification" />
      <MemberSignature Language="F#" Value="member this.WillChangeStatusBarOrientationNotification : Foundation.NSString" Usage="UIKit.UIApplication.WillChangeStatusBarOrientationNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Use UIApplication.Notifications.ObserveWillChangeStatusBarOrientation helper method instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Field("UIApplicationWillChangeStatusBarOrientationNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for WillChangeStatusBarOrientation</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">To subscribe to this notification, developers can use the convenience <see cref="T:UIKit.UIApplication.Notifications" />.<see cref="M:UIKit.UIApplication.Notifications.ObserveWillChangeStatusBarOrientation*" /> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="C#"><![CDATA[
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveWillChangeStatusBarOrientation ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("StatusBarOrientation", args.StatusBarOrientation);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, UIKit.UIStatusBarOrientationChangeEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("StatusBarOrientation", args.StatusBarOrientation);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveWillChangeStatusBarOrientation (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.WillChangeStatusBarOrientationNotification, (notification) => {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.WillChangeStatusBarOrientationNotification, Callback);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WillEnterForegroundNotification">
      <MemberSignature Language="C#" Value="public static Foundation.NSString WillEnterForegroundNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString WillEnterForegroundNotification" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.WillEnterForegroundNotification" />
      <MemberSignature Language="F#" Value="member this.WillEnterForegroundNotification : Foundation.NSString" Usage="UIKit.UIApplication.WillEnterForegroundNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Use UIApplication.Notifications.ObserveWillEnterForeground helper method instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Field("UIApplicationWillEnterForegroundNotification", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for WillEnterForeground</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIKit.UIApplication.Notifications" />.<format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=M:UIKit.UIKit.UIApplication.Notifications.ObserveWillEnterForeground*&amp;scope=Xamarin" title="M:UIKit.UIKit.UIApplication.Notifications.ObserveWillEnterForeground*">M:UIKit.UIKit.UIApplication.Notifications.ObserveWillEnterForeground*</a></format> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="C#"><![CDATA[
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveWillEnterForeground ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, Foundation.NSNotificationEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveWillEnterForeground (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.WillEnterForegroundNotification, (notification) => {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.WillEnterForegroundNotification, Callback);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WillResignActiveNotification">
      <MemberSignature Language="C#" Value="public static Foundation.NSString WillResignActiveNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString WillResignActiveNotification" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.WillResignActiveNotification" />
      <MemberSignature Language="F#" Value="member this.WillResignActiveNotification : Foundation.NSString" Usage="UIKit.UIApplication.WillResignActiveNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Use UIApplication.Notifications.ObserveWillResignActive helper method instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Field("UIApplicationWillResignActiveNotification", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for WillResignActive</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIKit.UIApplication.Notifications" />.<format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=M:UIKit.UIKit.UIApplication.Notifications.ObserveWillResignActive*&amp;scope=Xamarin" title="M:UIKit.UIKit.UIApplication.Notifications.ObserveWillResignActive*">M:UIKit.UIKit.UIApplication.Notifications.ObserveWillResignActive*</a></format> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="C#"><![CDATA[
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveWillResignActive ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, Foundation.NSNotificationEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveWillResignActive (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.WillResignActiveNotification, (notification) => {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.WillResignActiveNotification, Callback);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WillTerminateNotification">
      <MemberSignature Language="C#" Value="public static Foundation.NSString WillTerminateNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString WillTerminateNotification" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.WillTerminateNotification" />
      <MemberSignature Language="F#" Value="member this.WillTerminateNotification : Foundation.NSString" Usage="UIKit.UIApplication.WillTerminateNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Use UIApplication.Notifications.ObserveWillTerminate helper method instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Field("UIApplicationWillTerminateNotification", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for WillTerminate</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIKit.UIApplication.Notifications" />.<format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=M:UIKit.UIKit.UIApplication.Notifications.ObserveWillTerminate*&amp;scope=Xamarin" title="M:UIKit.UIKit.UIApplication.Notifications.ObserveWillTerminate*">M:UIKit.UIKit.UIApplication.Notifications.ObserveWillTerminate*</a></format> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="C#"><![CDATA[
//
// Lambda style
//

// listening
notification = UIApplication.Notifications.ObserveWillTerminate ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, Foundation.NSNotificationEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UIApplication.Notifications.ObserveWillTerminate (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIApplication.WillTerminateNotification, (notification) => {Console.WriteLine ("Received the notification UIApplication", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIApplication", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIApplication.WillTerminateNotification, Callback);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Windows">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIWindow[] Windows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIWindow[] Windows" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIApplication.Windows" />
      <MemberSignature Language="F#" Value="member this.Windows : UIKit.UIWindow[]" Usage="UIKit.UIApplication.Windows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("windows")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIWindow[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>All of the application windows.</summary>
        <value>
        </value>
        <remarks>
          Invoking this property will return a list of all the windows created by this application.
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
