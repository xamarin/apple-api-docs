<Type Name="UIKeyboard" FullName="UIKit.UIKeyboard">
  <TypeSignature Language="C#" Value="public static class UIKeyboard" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit UIKeyboard extends System.Object" />
  <TypeSignature Language="DocId" Value="T:UIKit.UIKeyboard" />
  <TypeSignature Language="F#" Value="type UIKeyboard = class" />
  <AssemblyInfo>
    <AssemblyName>Xamarin.iOS</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>The iPhone virtual keyboard.</summary>
    <remarks>
      <para>

	The UIKeyboard class contains constants and methods to track
	the visibility of the iPhone virtual keyboard.  iOS posts a
	number of notifications when the keyboard is shown, hidden or
	moved in the screen.   

      </para>
      <para>

	The preferred way of receiving UIKeyboard notification is to
	use the <see cref="T:UIKit.UIKeyboard.Notifications" /> class,
	which provides a strongly-typed set of APIs to track the
	changes to the keyboard state and provides strongly-typed
	accessors to the various parameters of the keyboard changes.

      </para>
      <example>
        <code lang="C#"><![CDATA[
//
// Lambda style
//

// listening
notification = UIKeyboard.Notifications.ObserveDidChangeFrame ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("FrameBegin", args.FrameBegin);
    Console.WriteLine ("FrameEnd", args.FrameEnd);
    Console.WriteLine ("AnimationDuration", args.AnimationDuration);
    Console.WriteLine ("AnimationCurve", args.AnimationCurve);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, UIKit.UIKeyboardEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("FrameBegin", args.FrameBegin);
    Console.WriteLine ("FrameEnd", args.FrameEnd);
    Console.WriteLine ("AnimationDuration", args.AnimationDuration);
    Console.WriteLine ("AnimationCurve", args.AnimationCurve);
}

void Setup ()
{
    notification = UIKeyboard.Notifications.ObserveDidChangeFrame (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
      </example>
    </remarks>
    <related type="sample" href="https://github.com/xamarin/ios-samples/tree/master/MonoCatalog-MonoDevelop/">monocatalog</related>
  </Docs>
  <Members>
    <Member MemberName="AnimationCurveFromNotification">
      <MemberSignature Language="C#" Value="public static uint AnimationCurveFromNotification (Foundation.NSNotification n);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 AnimationCurveFromNotification(class Foundation.NSNotification n) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIKeyboard.AnimationCurveFromNotification(Foundation.NSNotification)" />
      <MemberSignature Language="F#" Value="static member AnimationCurveFromNotification : Foundation.NSNotification -&gt; uint32" Usage="UIKit.UIKeyboard.AnimationCurveFromNotification n" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="n" Type="Foundation.NSNotification" />
      </Parameters>
      <Docs>
        <param name="n">notification and its payload.</param>
        <summary>Deprecated: helper method to extract the animation curve from a notification.</summary>
        <returns>
        </returns>
        <remarks>Use the <see cref="T:UIKit.UIKeyboard.Notifications" /> strongly typed methods instead.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AnimationCurveUserInfoKey">
      <MemberSignature Language="C#" Value="public static Foundation.NSString AnimationCurveUserInfoKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString AnimationCurveUserInfoKey" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIKeyboard.AnimationCurveUserInfoKey" />
      <MemberSignature Language="F#" Value="member this.AnimationCurveUserInfoKey : Foundation.NSString" Usage="UIKit.UIKeyboard.AnimationCurveUserInfoKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIKeyboardAnimationCurveUserInfoKey", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UIKeyboardAnimationCurveUserInfoKey</summary>
        <value>
        </value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AnimationDurationFromNotification">
      <MemberSignature Language="C#" Value="public static double AnimationDurationFromNotification (Foundation.NSNotification n);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 AnimationDurationFromNotification(class Foundation.NSNotification n) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIKeyboard.AnimationDurationFromNotification(Foundation.NSNotification)" />
      <MemberSignature Language="F#" Value="static member AnimationDurationFromNotification : Foundation.NSNotification -&gt; double" Usage="UIKit.UIKeyboard.AnimationDurationFromNotification n" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="n" Type="Foundation.NSNotification" />
      </Parameters>
      <Docs>
        <param name="n">notification and its payload.</param>
        <summary>Deprecated: helper method to extract the animation duration from a notification.</summary>
        <returns>
        </returns>
        <remarks>Use the <see cref="T:UIKit.UIKeyboard.Notifications" /> strongly typed methods instead.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AnimationDurationUserInfoKey">
      <MemberSignature Language="C#" Value="public static Foundation.NSString AnimationDurationUserInfoKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString AnimationDurationUserInfoKey" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIKeyboard.AnimationDurationUserInfoKey" />
      <MemberSignature Language="F#" Value="member this.AnimationDurationUserInfoKey : Foundation.NSString" Usage="UIKit.UIKeyboard.AnimationDurationUserInfoKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIKeyboardAnimationDurationUserInfoKey", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UIKeyboardAnimationDurationUserInfoKey</summary>
        <value>
        </value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BoundsFromNotification">
      <MemberSignature Language="C#" Value="public static CoreGraphics.CGRect BoundsFromNotification (Foundation.NSNotification n);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype CoreGraphics.CGRect BoundsFromNotification(class Foundation.NSNotification n) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIKeyboard.BoundsFromNotification(Foundation.NSNotification)" />
      <MemberSignature Language="F#" Value="static member BoundsFromNotification : Foundation.NSNotification -&gt; CoreGraphics.CGRect" Usage="UIKit.UIKeyboard.BoundsFromNotification n" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 3, 2, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>CoreGraphics.CGRect</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="n" Type="Foundation.NSNotification" />
      </Parameters>
      <Docs>
        <param name="n">notification and its payload.</param>
        <summary>Developers should not use this deprecated method. </summary>
        <returns>
        </returns>
        <remarks>Use the <see cref="T:UIKit.UIKeyboard.Notifications" /> strongly typed methods instead.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BoundsUserInfoKey">
      <MemberSignature Language="C#" Value="public static Foundation.NSString BoundsUserInfoKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString BoundsUserInfoKey" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIKeyboard.BoundsUserInfoKey" />
      <MemberSignature Language="F#" Value="member this.BoundsUserInfoKey : Foundation.NSString" Usage="UIKit.UIKeyboard.BoundsUserInfoKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIKeyboardBoundsUserInfoKey", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 3, 2, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 3, 2, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UIKeyboardBoundsUserInfoKey</summary>
        <value>
        </value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CenterBeginFromNotification">
      <MemberSignature Language="C#" Value="public static CoreGraphics.CGPoint CenterBeginFromNotification (Foundation.NSNotification n);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype CoreGraphics.CGPoint CenterBeginFromNotification(class Foundation.NSNotification n) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIKeyboard.CenterBeginFromNotification(Foundation.NSNotification)" />
      <MemberSignature Language="F#" Value="static member CenterBeginFromNotification : Foundation.NSNotification -&gt; CoreGraphics.CGPoint" Usage="UIKit.UIKeyboard.CenterBeginFromNotification n" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 3, 2, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>CoreGraphics.CGPoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="n" Type="Foundation.NSNotification" />
      </Parameters>
      <Docs>
        <param name="n">notification and its payload.</param>
        <summary>Deprecated: helper method to extract the center start from a notification</summary>
        <returns>
        </returns>
        <remarks>Use the <see cref="T:UIKit.UIKeyboard.Notifications" /> strongly typed methods instead.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CenterBeginUserInfoKey">
      <MemberSignature Language="C#" Value="public static Foundation.NSString CenterBeginUserInfoKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString CenterBeginUserInfoKey" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIKeyboard.CenterBeginUserInfoKey" />
      <MemberSignature Language="F#" Value="member this.CenterBeginUserInfoKey : Foundation.NSString" Usage="UIKit.UIKeyboard.CenterBeginUserInfoKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIKeyboardCenterBeginUserInfoKey", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 3, 2, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 3, 2, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UIKeyboardCenterBeginUserInfoKey</summary>
        <value>
        </value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CenterEndFromNotification">
      <MemberSignature Language="C#" Value="public static CoreGraphics.CGPoint CenterEndFromNotification (Foundation.NSNotification n);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype CoreGraphics.CGPoint CenterEndFromNotification(class Foundation.NSNotification n) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIKeyboard.CenterEndFromNotification(Foundation.NSNotification)" />
      <MemberSignature Language="F#" Value="static member CenterEndFromNotification : Foundation.NSNotification -&gt; CoreGraphics.CGPoint" Usage="UIKit.UIKeyboard.CenterEndFromNotification n" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 3, 2, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>CoreGraphics.CGPoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="n" Type="Foundation.NSNotification" />
      </Parameters>
      <Docs>
        <param name="n">notification and its payload.</param>
        <summary>Deprecated: helper method to extract the center end from a notification.</summary>
        <returns>
        </returns>
        <remarks>Use the <see cref="T:UIKit.UIKeyboard.Notifications" /> strongly typed methods instead.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CenterEndUserInfoKey">
      <MemberSignature Language="C#" Value="public static Foundation.NSString CenterEndUserInfoKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString CenterEndUserInfoKey" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIKeyboard.CenterEndUserInfoKey" />
      <MemberSignature Language="F#" Value="member this.CenterEndUserInfoKey : Foundation.NSString" Usage="UIKit.UIKeyboard.CenterEndUserInfoKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIKeyboardCenterEndUserInfoKey", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 3, 2, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 3, 2, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UIKeyboardCenterEndUserInfoKey</summary>
        <value>
        </value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DidChangeFrameNotification">
      <MemberSignature Language="C#" Value="public static Foundation.NSString DidChangeFrameNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString DidChangeFrameNotification" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIKeyboard.DidChangeFrameNotification" />
      <MemberSignature Language="F#" Value="member this.DidChangeFrameNotification : Foundation.NSString" Usage="UIKit.UIKeyboard.DidChangeFrameNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Use UIKeyboard.Notifications.ObserveDidChangeFrame helper method instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Field("UIKeyboardDidChangeFrameNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for DidChangeFrame</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIKit.UIKeyboard.Notifications" />.<see cref="M:UIKit.UIKeyboard.Notifications.ObserveDidChangeFrame*" /> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="C#"><![CDATA[
//
// Lambda style
//

// listening
notification = UIKeyboard.Notifications.ObserveDidChangeFrame ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("FrameBegin", args.FrameBegin);
    Console.WriteLine ("FrameEnd", args.FrameEnd);
    Console.WriteLine ("AnimationDuration", args.AnimationDuration);
    Console.WriteLine ("AnimationCurve", args.AnimationCurve);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, UIKit.UIKeyboardEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("FrameBegin", args.FrameBegin);
    Console.WriteLine ("FrameEnd", args.FrameEnd);
    Console.WriteLine ("AnimationDuration", args.AnimationDuration);
    Console.WriteLine ("AnimationCurve", args.AnimationCurve);
}

void Setup ()
{
    notification = UIKeyboard.Notifications.ObserveDidChangeFrame (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIKeyboard.DidChangeFrameNotification, (notification) => {Console.WriteLine ("Received the notification UIKeyboard", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIKeyboard", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIKeyboard.DidChangeFrameNotification, Callback);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DidHideNotification">
      <MemberSignature Language="C#" Value="public static Foundation.NSString DidHideNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString DidHideNotification" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIKeyboard.DidHideNotification" />
      <MemberSignature Language="F#" Value="member this.DidHideNotification : Foundation.NSString" Usage="UIKit.UIKeyboard.DidHideNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Use UIKeyboard.Notifications.ObserveDidHide helper method instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Field("UIKeyboardDidHideNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for DidHide</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIKit.UIKeyboard.Notifications" />.<see cref="M:UIKit.UIKeyboard.Notifications.ObserveDidHide*" /> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="C#"><![CDATA[
//
// Lambda style
//

// listening
notification = UIKeyboard.Notifications.ObserveDidHide ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("FrameBegin", args.FrameBegin);
    Console.WriteLine ("FrameEnd", args.FrameEnd);
    Console.WriteLine ("AnimationDuration", args.AnimationDuration);
    Console.WriteLine ("AnimationCurve", args.AnimationCurve);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, UIKit.UIKeyboardEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("FrameBegin", args.FrameBegin);
    Console.WriteLine ("FrameEnd", args.FrameEnd);
    Console.WriteLine ("AnimationDuration", args.AnimationDuration);
    Console.WriteLine ("AnimationCurve", args.AnimationCurve);
}

void Setup ()
{
    notification = UIKeyboard.Notifications.ObserveDidHide (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIKeyboard.DidHideNotification, (notification) => {Console.WriteLine ("Received the notification UIKeyboard", notification); });


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIKeyboard", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIKeyboard.DidHideNotification, Callback);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DidShowNotification">
      <MemberSignature Language="C#" Value="public static Foundation.NSString DidShowNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString DidShowNotification" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIKeyboard.DidShowNotification" />
      <MemberSignature Language="F#" Value="member this.DidShowNotification : Foundation.NSString" Usage="UIKit.UIKeyboard.DidShowNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Use UIKeyboard.Notifications.ObserveDidShow helper method instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Field("UIKeyboardDidShowNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for DidShow</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIKit.UIKeyboard.Notifications" />.<see cref="M:UIKit.UIKeyboard.Notifications.ObserveDidShow*" /> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="C#"><![CDATA[
//
// Lambda style
//

// listening
notification = UIKeyboard.Notifications.ObserveDidShow ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("FrameBegin", args.FrameBegin);
    Console.WriteLine ("FrameEnd", args.FrameEnd);
    Console.WriteLine ("AnimationDuration", args.AnimationDuration);
    Console.WriteLine ("AnimationCurve", args.AnimationCurve);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, UIKit.UIKeyboardEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("FrameBegin", args.FrameBegin);
    Console.WriteLine ("FrameEnd", args.FrameEnd);
    Console.WriteLine ("AnimationDuration", args.AnimationDuration);
    Console.WriteLine ("AnimationCurve", args.AnimationCurve);
}

void Setup ()
{
    notification = UIKeyboard.Notifications.ObserveDidShow (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIKeyboard.DidShowNotification, (notification) => {Console.WriteLine ("Received the notification UIKeyboard", notification); });


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIKeyboard", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIKeyboard.DidShowNotification, Callback);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FrameBeginFromNotification">
      <MemberSignature Language="C#" Value="public static CoreGraphics.CGRect FrameBeginFromNotification (Foundation.NSNotification n);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype CoreGraphics.CGRect FrameBeginFromNotification(class Foundation.NSNotification n) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIKeyboard.FrameBeginFromNotification(Foundation.NSNotification)" />
      <MemberSignature Language="F#" Value="static member FrameBeginFromNotification : Foundation.NSNotification -&gt; CoreGraphics.CGRect" Usage="UIKit.UIKeyboard.FrameBeginFromNotification n" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>CoreGraphics.CGRect</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="n" Type="Foundation.NSNotification" />
      </Parameters>
      <Docs>
        <param name="n">notification and its payload.</param>
        <summary>Deprecated: helper method to extract the keyboard's starting frame from a notification</summary>
        <returns>
        </returns>
        <remarks>Use the <see cref="T:UIKit.UIKeyboard.Notifications" /> strongly typed methods instead.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FrameBeginUserInfoKey">
      <MemberSignature Language="C#" Value="public static Foundation.NSString FrameBeginUserInfoKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString FrameBeginUserInfoKey" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIKeyboard.FrameBeginUserInfoKey" />
      <MemberSignature Language="F#" Value="member this.FrameBeginUserInfoKey : Foundation.NSString" Usage="UIKit.UIKeyboard.FrameBeginUserInfoKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIKeyboardFrameBeginUserInfoKey", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UIKeyboardFrameBeginUserInfoKey</summary>
        <value>
        </value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FrameEndFromNotification">
      <MemberSignature Language="C#" Value="public static CoreGraphics.CGRect FrameEndFromNotification (Foundation.NSNotification n);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype CoreGraphics.CGRect FrameEndFromNotification(class Foundation.NSNotification n) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIKeyboard.FrameEndFromNotification(Foundation.NSNotification)" />
      <MemberSignature Language="F#" Value="static member FrameEndFromNotification : Foundation.NSNotification -&gt; CoreGraphics.CGRect" Usage="UIKit.UIKeyboard.FrameEndFromNotification n" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>CoreGraphics.CGRect</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="n" Type="Foundation.NSNotification" />
      </Parameters>
      <Docs>
        <param name="n">notification and its payload.</param>
        <summary>Deprecated: helper method to extract the keyboard's ending frame from a notification</summary>
        <returns>
        </returns>
        <remarks>Use the <see cref="T:UIKit.UIKeyboard.Notifications" /> strongly typed methods instead.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FrameEndUserInfoKey">
      <MemberSignature Language="C#" Value="public static Foundation.NSString FrameEndUserInfoKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString FrameEndUserInfoKey" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIKeyboard.FrameEndUserInfoKey" />
      <MemberSignature Language="F#" Value="member this.FrameEndUserInfoKey : Foundation.NSString" Usage="UIKit.UIKeyboard.FrameEndUserInfoKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIKeyboardFrameEndUserInfoKey", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UIKeyboardFrameEndUserInfoKey</summary>
        <value>
        </value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLocalUserInfoKey">
      <MemberSignature Language="C#" Value="public static Foundation.NSString IsLocalUserInfoKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString IsLocalUserInfoKey" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIKeyboard.IsLocalUserInfoKey" />
      <MemberSignature Language="F#" Value="member this.IsLocalUserInfoKey : Foundation.NSString" Usage="UIKit.UIKeyboard.IsLocalUserInfoKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIKeyboardIsLocalUserInfoKey", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WillChangeFrameNotification">
      <MemberSignature Language="C#" Value="public static Foundation.NSString WillChangeFrameNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString WillChangeFrameNotification" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIKeyboard.WillChangeFrameNotification" />
      <MemberSignature Language="F#" Value="member this.WillChangeFrameNotification : Foundation.NSString" Usage="UIKit.UIKeyboard.WillChangeFrameNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Use UIKeyboard.Notifications.ObserveWillChangeFrame helper method instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Field("UIKeyboardWillChangeFrameNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for WillChangeFrame</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIKit.UIKeyboard.Notifications" />.<see cref="M:UIKit.UIKeyboard.Notifications.ObserveWillChangeFrame*" /> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="C#"><![CDATA[
//
// Lambda style
//

// listening
notification = UIKeyboard.Notifications.ObserveWillChangeFrame ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("FrameBegin", args.FrameBegin);
    Console.WriteLine ("FrameEnd", args.FrameEnd);
    Console.WriteLine ("AnimationDuration", args.AnimationDuration);
    Console.WriteLine ("AnimationCurve", args.AnimationCurve);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, UIKit.UIKeyboardEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("FrameBegin", args.FrameBegin);
    Console.WriteLine ("FrameEnd", args.FrameEnd);
    Console.WriteLine ("AnimationDuration", args.AnimationDuration);
    Console.WriteLine ("AnimationCurve", args.AnimationCurve);
}

void Setup ()
{
    notification = UIKeyboard.Notifications.ObserveWillChangeFrame (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIKeyboard.WillChangeFrameNotification, (notification) => {Console.WriteLine ("Received the notification UIKeyboard", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIKeyboard", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIKeyboard.WillChangeFrameNotification, Callback);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WillHideNotification">
      <MemberSignature Language="C#" Value="public static Foundation.NSString WillHideNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString WillHideNotification" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIKeyboard.WillHideNotification" />
      <MemberSignature Language="F#" Value="member this.WillHideNotification : Foundation.NSString" Usage="UIKit.UIKeyboard.WillHideNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Use UIKeyboard.Notifications.ObserveWillHide helper method instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Field("UIKeyboardWillHideNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for WillHide</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIKit.UIKeyboard.Notifications" />.<see cref="M:UIKit.UIKeyboard.Notifications.ObserveWillHide*" /> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="C#"><![CDATA[
//
// Lambda style
//

// listening
notification = UIKeyboard.Notifications.ObserveWillHide ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("FrameBegin", args.FrameBegin);
    Console.WriteLine ("FrameEnd", args.FrameEnd);
    Console.WriteLine ("AnimationDuration", args.AnimationDuration);
    Console.WriteLine ("AnimationCurve", args.AnimationCurve);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, UIKit.UIKeyboardEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("FrameBegin", args.FrameBegin);
    Console.WriteLine ("FrameEnd", args.FrameEnd);
    Console.WriteLine ("AnimationDuration", args.AnimationDuration);
    Console.WriteLine ("AnimationCurve", args.AnimationCurve);
}

void Setup ()
{
    notification = UIKeyboard.Notifications.ObserveWillHide (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}</code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIKeyboard.WillHideNotification, (notification) => {Console.WriteLine ("Received the notification UIKeyboard", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIKeyboard", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIKeyboard.WillHideNotification, Callback);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WillShowNotification">
      <MemberSignature Language="C#" Value="public static Foundation.NSString WillShowNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString WillShowNotification" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIKeyboard.WillShowNotification" />
      <MemberSignature Language="F#" Value="member this.WillShowNotification : Foundation.NSString" Usage="UIKit.UIKeyboard.WillShowNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Use UIKeyboard.Notifications.ObserveWillShow helper method instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Field("UIKeyboardWillShowNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for WillShow</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIKit.UIKeyboard.Notifications" />.<see cref="M:UIKit.UIKeyboard.Notifications.ObserveWillShow*" /> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="C#"><![CDATA[ 
//
// Lambda style
//

// listening
notification = UIKeyboard.Notifications.ObserveWillShow ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("FrameBegin", args.FrameBegin);
    Console.WriteLine ("FrameEnd", args.FrameEnd);
    Console.WriteLine ("AnimationDuration", args.AnimationDuration);
    Console.WriteLine ("AnimationCurve", args.AnimationCurve);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, UIKit.UIKeyboardEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("FrameBegin", args.FrameBegin);
    Console.WriteLine ("FrameEnd", args.FrameEnd);
    Console.WriteLine ("AnimationDuration", args.AnimationDuration);
    Console.WriteLine ("AnimationCurve", args.AnimationCurve);
}

void Setup ()
{
    notification = UIKeyboard.Notifications.ObserveWillShow (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIKeyboard.WillShowNotification, (notification) => {Console.WriteLine ("Received the notification UIKeyboard", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIKeyboard", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIKeyboard.WillShowNotification, Callback);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
