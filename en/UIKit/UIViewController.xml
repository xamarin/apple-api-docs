<Type Name="UIViewController" FullName="UIKit.UIViewController">
  <TypeSignature Language="C#" Value="public class UIViewController : UIKit.UIResponder, Foundation.INSCoding, Foundation.INSExtensionRequestHandling, IDisposable, System.Collections.IEnumerable, UIKit.IUIAppearanceContainer, UIKit.IUIContentContainer, UIKit.IUIFocusEnvironment, UIKit.IUITraitEnvironment" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit UIViewController extends UIKit.UIResponder implements class Foundation.INSCoding, class Foundation.INSExtensionRequestHandling, class ObjCRuntime.INativeObject, class System.Collections.IEnumerable, class System.IDisposable, class UIKit.IUIAppearanceContainer, class UIKit.IUIContentContainer, class UIKit.IUIFocusEnvironment, class UIKit.IUITraitEnvironment" />
  <TypeSignature Language="DocId" Value="T:UIKit.UIViewController" />
  <TypeSignature Language="F#" Value="type UIViewController = class&#xA;    inherit UIResponder&#xA;    interface IEnumerable&#xA;    interface INSCoding&#xA;    interface INativeObject&#xA;    interface IDisposable&#xA;    interface INSExtensionRequestHandling&#xA;    interface IUIAppearanceContainer&#xA;    interface IUIContentContainer&#xA;    interface IUIFocusEnvironment&#xA;    interface IUITraitEnvironment" />
  <AssemblyInfo>
    <AssemblyName>Xamarin.iOS</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>UIKit.UIResponder</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>Foundation.INSCoding</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Foundation.INSExtensionRequestHandling</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>ObjCRuntime.INativeObject</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>UIKit.IUIAppearanceContainer</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>UIKit.IUIContentContainer</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>UIKit.IUIFocusEnvironment</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>UIKit.IUITraitEnvironment</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>Foundation.Register("UIViewController", true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Base class for classes that manage the interaction between Model classes and View classes</summary>
    <remarks>
      <para>
        The <see cref="T:UIKit.UIViewController" /> class is
        the base class of the View Controller hierarchy. View
        Controllers manage <see cref="T:UIKit.UIView" />s
        and other <see cref="T:UIKit.UIViewController" />s. An iOS application has a single window, but many screens,
        each of which may contain several <see cref="T:UIKit.UIView" />s. Managing those screens is
        complex and requires responding to both user input and changes
        in the model (problem domain). This management and
        coordination is the job of the <see cref="T:UIKit.UIViewController" />.
      </para>
      <para>
        A <see cref="T:UIKit.UIViewController" /> has 3 major responsibilities: 
      </para>
      <list type="bullet">
        <item>
          <term>Layout out its component <see cref="T:UIKit.UIView" />s. This includes sizing, responding to orientation changes, etc.</term>
        </item>
        <item>
          <term>Restructure the display in response to input events or the state of Model classes</term>
        </item>
        <item>
          <term>Translate user input into platform-neutral Model service requests</term>
        </item>
      </list>
      <para>
        iOS provides a number of standard view controllers such as
        <see cref="T:UIKit.UINavigationController" />, <see cref="T:UIKit.UITabBarController" />, and <see cref="T:UIKit.UIPageViewController" />. In general,
        the application developer should prefer to use standard view
        controllers to create the overall display structure. Using
        standard view controllers provides consistent, standard
        behavior and makes it easier for the app to conform to the
        <format type="text/html"><a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/MobileHIG/Introduction/Introduction.html#//apple_ref/doc/uid/TP40006556">iOS
        Human Interface Guidelines</a></format>.

      </para>
      <para>
        Additionally, the application developer generally needs to
        implement one or more “Content View Controllers”. These are
        often derived directly from <see cref="T:UIKit.UIViewController" /> or <see cref="T:UIKit.UITableViewController" />. Content
        View Controllers are where the application developer writes
        the custom code to satisfy the <see cref="T:UIKit.UIViewController" />s responsibilities
        described previously. In applications that take advantage of
        Xamarin Studio’s Code Behind facilities for Apple’s Interface
        Builder, much of this custom code will be automatically
        generated by Xamarin Studio. Applications written using
        MonoTouch.Dialog do not generally need a custom-written
        Content View Controller, but may use one for architectural
        consistency.

      </para>
      <para>
        A single View Controller may have many views and
        subcontrollers, but typically a single View Controller will
        have a single root view and be primarily concerned with
        controlling that one view or it will be primarily concerned
        with maintaining a collection of subcontrollers. In the
        following example, taken from the “Hello World iPhone” sample,
        a Content View Controller of type
        <c>HelloWorld_iPhoneViewController</c> is instantiated and set
        to be the <see cref="P:UIKit.UIWindow.RootViewController" /> for
        the application’s window:

      </para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
public override bool FinishedLaunching (UIApplication app, NSDictionary options)
{
       // create a new window instance based on the screen size
       window = new UIWindow (UIScreen.MainScreen.Bounds);
          
       viewController = new HelloWorld_iPhoneViewController ("HelloWorld_iPhoneViewController", null);
       window.RootViewController = viewController;
       window.MakeKeyAndVisible ();
          
       return true;
}
]]></code>
      </example>
      <para>
        By contrast, the following code taken from the "iOS Standard
        Controls" sample demonstrates how a <see cref="T:UIKit.UITableViewController" /> uses an
        application-defined <c>NavItemGroup</c> to manage a series of
        other <see cref="T:UIKit.UIViewController" />s. In
        this code, the second parameter to the <c>NavItem</c>
        constructor is the specific <see cref="T:UIKit.UIViewController" /> subtype desired
        when that item is selected in the table:</para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
navGroup = new NavItemGroup ("Toolbars");
navItems.Add (navGroup);
navGroup.Items.Add (new NavItem ("Toolbar 1", "", typeof(Toolbar.Toolbar1_iPhone)));
navGroup.Items.Add (new NavItem ("Programmatic Toolbar", "", typeof(Toolbar.ProgrammaticToolbar_Controller)));
navGroup.Items.Add (new NavItem ("Toolbar Items", "", typeof(Toolbar.ToolbarItems)));
  
// create a table source from our nav items
tableSource = new NavItemTableSource (this.NavigationController, navItems);
  
// set the source on the table to our data source
base.TableView.Source = tableSource;
]]></code>
      </example>
      <format type="text/html">
        <h2>UIViewController and the MVC Architecture</h2>
      </format>
      <para>
        The following illustration shows the classic relationship
        between Model, View, and Controller classes. The arrows
        indicate dependencies: the View depends on the Model class to
        provide data, the Controller depends on the Model class for
        information about what to display and depends on the View
        class to do the drawing. This diagram is idealized: there
        would be several classes in the Model, several Views, <see cref="T:UIKit.UIView" /> can actually use <see cref="P:UIKit.UIResponder.NextResponder" /> to
        determine their <see cref="T:UIKit.UIViewController" />, etc.

      </para>
      <para>
        <img href="~/UIKit/_images/UIViewController_MVC_Triad.png" alt="Illustrates the roles and responsibilities of models, views, and controllers." />
      </para>
      <list type="bullet">
        <item>
          <term>The Model class has no knowledge of the associated View and Controller classes. This allows the Model to evolve independently and greatly improves maintainability and portability</term>
        </item>
        <item>
          <term>Event handlers are used between the areas of concern. This allows for strongly-typed <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=System%20Event%20Args&amp;scope=Xamarin" title="T:System.EventArgs">T:System.EventArgs</a></format> that only contain the data relating to that event. This improves maintainability by limiting the client object’s access to the event-provider’s scope.</term>
        </item>
        <item>
          <term>
The Controller reacts to events both from the View and from the Model. A <see cref="T:UIKit.UIViewController" /> might, for instance, handle a <see cref="E:UIKit.UIControl.TouchUpInside" /> input event by requesting the Model to convert between Celsius and Fahrenheit temperature units. Conversely it might respond to a Model “too hot” event by changing the display (making visible a warning icon or somesuch).  The View updates its display in reaction to new data provided by Model events. View classes should be as passive as possible. One of the most common mistakes in non-maintainable software is a View class that acts as a Controller or that "reaches into" the Model for data rather than accepting values passed in as event arguments. 
          </term>
        </item>
      </list>
      <format type="text/html">
        <h2>UIViewController, Interface Builder, Storyboards, and Nib files</h2>
      </format>
      <para>
        XCode, Apple’s IDE, contains Interface Builder (“IB”), a tool that allows user interfaces to be created interactively and saved as “Nib” files (these are saved in XML format with the  “.xib” extension). Xamarin Studio generates Code Behind classes for nib files and generally these will be subclasses of <see cref="T:UIKit.UIViewController" />. Starting with iOS 5, application developers can use “Storyboards” to visually specify navigation amongst individual <see cref="T:UIKit.UIViewController" />s.  For more on Storyboards, see <format type="text/html"><a href="https://docs.xamarin.com/ios/Guides/User_Interface/Introduction_to_Storyboards">Introduction to Storyboards</a></format>.
      </para>
      <format type="text/html">
        <h2>Universal applications</h2>
      </format>
      <para>
        Xamarin Studio fully supports universal applications that use a single <see cref="T:UIKit.UIViewController" /> to control multiple <see cref="T:UIKit.UIView" />s customized for the iPad or the iPhone.  As long as the <see cref="T:UIKit.UIView" />s used by the two devices share the same elements, they can share the same Outlets and Actions, as described in the "<format type="text/html"><a href="https://docs.xamarin.com/index.php?title=ios/Guides/Getting_Started/Hello%2C_iPad___Universal_Apps">iPad + Universal (iPhone + iPad) Apps</a></format>" guide. 
      </para>
      <para>It is not necessary for the iPhone and iPad versions to use the same UI elements, however. The application developer may wish to take advantage of the increased screen real-estate and larger set of controls available on the iPad. In such cases, the application developer should create separate <see cref="T:UIKit.UIViewController" />s and load them appropriatel using code similar to the following, again taken from the “<format type="text/html"><a href="https://docs.xamarin.com/index.php?title=ios/Guides/Getting_Started/Hello%2C_iPad___Universal_Apps">iPad + Universal (iPhone + iPad) Apps</a></format>“ guide.  The choice of the <see cref="T:UIKit.UIViewController" /> to be loaded is determined at runtime based on a call to <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=UIKit%20UIDevice%20Current%20Device%20User%20Interface%20Idiom&amp;scope=Xamarin" title="P:UIKit.UIDevice.CurrentDevice.UserInterfaceIdiom">P:UIKit.UIDevice.CurrentDevice.UserInterfaceIdiom</a></format>.
      </para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
if (UIDevice.CurrentDevice.UserInterfaceIdiom == UIUserInterfaceIdiom.Phone) {
    homeScreen = new Screens.HomeScreen_iPhone();
} else {
    homeScreen = new Screens.HomeScreen_iPad();
}
window.RootViewController = homeScreen;
]]></code>
      </example>
      <format type="text/html">
        <h2>State Restoration</h2>
      </format>
      <para>
        If you want to provide state restoration in your class, you
        need to manually add a method with the following signature to
        your class:
        
      </para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
[Adopts ("UIViewControllerRestoration")]
class MyUIViewController : UIViewController {

 [Export ("viewControllerWithRestorationIdentifierPath:")]
 static UIViewController FromIdentifierPath (string [] identifierComponents, NSCoder coder)
 {
    var sb = (UIStoryboard) coder.DecodeObject (UIStateRestoration.ViewControllerStoryboardKey);
    if (sb != null){
       var vc = (MyUIViewController) sb.InstantiateViewController ("MyViewController");
       vc.RestorationIdentifier = identifierComponents [identifierComponents.Length-1];
       vc.RestorationClass = Class.GetHandle (typeof (MyViewController));
    }
 }
}
]]></code>
      </example>
      <para>
      </para>
      <format type="text/html">
        <h2>UIViewController Subclasses</h2>
      </format>
      <para>
        <img href="~/UIKit/_images/UIViewController_hierarchy.png" alt="Class diagram showing the UIViewController hierarchy" />
      </para>
      <para>
        <list type="table">
          <listheader>
            <term>Class</term>
            <description>Use-case</description>
            <description>Example Image</description>
          </listheader>
          <item>
            <term>
              <see cref="T:UIKit.UIActivityViewController" />
            </term>
            <description>Choose from a set of possible activities</description>
            <description>
              <img href="~/UIKit/_images/UIKit.UIActivityViewController.Presentation.png" alt="Screenshot of the view controller" />
            </description>
          </item>
          <item>
            <term>
              <see cref="T:UIKit.UIPageViewController" />
            </term>
            <description>Presents content view controllers as a series of pages</description>
            <description>
              <img href="~/UIKit/_images/UIKit.UIPageViewController.Presentation.png" alt="Screenshot showing the UIPageViewController" />
            </description>
          </item>
          <item>
            <term>
              <see cref="T:UIKit.UINavigationController" />
            </term>
            <description>Presents content view controllers one at a time, with a header and optional toolbar</description>
            <description>
              <img href="~/UIKit/_images/UIKit.UINavigationController.Presentation.png" alt="Screenshot showing the UINavigationController" />
            </description>
          </item>
          <item>
            <term>
              <see cref="T:UIKit.UIImagePickerController" />
            </term>
            <description>A standard <see cref="T:UIKit.UINavigationController" /> for selecting and taking photographs.</description>
            <description>
              <img href="~/UIKit/_images/UIKit.UIImagePickerController.Presentation.png" alt="Screenshot showing the UIImagePickerController" />
            </description>
          </item>
          <item>
            <term>
              <see cref="T:UIKit.UIVideoEditorController" />
            </term>
            <description>A standard <see cref="T:UIKit.UINavigationController" /> for reviewing and editing video and audio files.</description>
            <description>
              <img href="~/UIKit/_images/UIKit.UIVideoEditorController.Presentation.png" alt="Screenshot showing the video editor." />
            </description>
          </item>
          <item>
            <term>
              <see cref="T:UIKit.UITabBarController" />
            </term>
            <description>Top-level controller that presents view controllers one at a time, selected by a toolbar along the bottom of the screen.</description>
            <description>
              <img href="~/UIKit/_images/UIKit.UITabBarController.Presentation.png" alt="Screenshot showing the location of the UITabBarController" />
            </description>
          </item>
          <item>
            <term>
              <see cref="T:UIKit.UIReferenceLibraryViewController" />
            </term>
            <description>A standard view controller that presents a term and it's dictionary definition.</description>
            <description>
              <img href="~/UIKit/_images/UIKit.UIReferenceLibraryViewController.Presentation.png" alt="Screenshot of the UIReferenceLibraryViewController" />
            </description>
          </item>
          <item>
            <term>
              <see cref="T:UIKit.UISplitViewController" />
            </term>
            <description>An iPad-only view controller that presents side-by-side view controllers.</description>
            <description>
              <img href="~/UIKit/_images/UIKit.UISplitViewController.Presentation.png" alt="Screenshot showing the layout of a UISplitViewController" />
            </description>
          </item>
          <item>
            <term>
              <see cref="T:UIKit.UICollectionViewController" />
            </term>
            <description>Efficiently displays a large number of cells, arranged in a flexible manner.</description>
            <description>
              <img href="~/UIKit/_images/UIKit.UICollectionView.CircleLayout.png" alt="Screenshot showing a circular layout" />
            </description>
          </item>
          <item>
            <term>
              <see cref="T:UIKit.UITableViewController" />
            </term>
            <description>Efficiently displays a large number of cells, arranged vertically.</description>
            <description>
              <img href="~/UIKit/_images/UIKit.UITableViewController.Presentation.png" alt="Screenshot showing UITableViewController" />
            </description>
          </item>
        </list>
      </para>
      <format type="text/html">
        <h3>Adaptive Layout and Rotation</h3>
      </format>
      <para>
	Starting with iOS 8 a series of idioms were introduced into
	iOS 8 to assist developers in creating applications and
	UIViewControllers that would work with different form factors,
	like both iPhone and iPad.  
      </para>
      <para>
	This replaces the pre-iOS8 design that focused on supporting
	two different form factors (iPhone or iPad) in a particular
	orientation as well as supporting the transitions from one
	interface orientation to the other.
      </para>
      <para>
	New applications should take a number of variables into
	consideration when laying out the elements on their UI.  These
	include the available size in the canvas, UserInterfaceIdiom
	(iPad or iPhone), the display scale, and both the vertical and
	horizontal size classes.  The first one is the size of your
	main view, while the rest are stored in the  <see cref="P:UIKit.UIViewController.TraitCollection" />.

      </para>
      <para>
	Rotation is now considered a class size change.  For example
	an iPhone held in portrait mode has a regular height and a
	compact width.  When you switch it to landscape, it becomes a
	compact height and a regular width.
      </para>
      <para>
	Applications can override <see cref="M:UIKit.UIViewController.TraitCollectionDidChange(UIKit.UITraitCollection)" />
	to react to changes to any of the user interface traits.  This
	method will be invoked during rotations or changes to the user
	interface that affect the size class of the application.
      </para>
      <para>
	The <see cref="M:UIKit.UIViewController.ViewWillTransitionToSize(CoreGraphics.CGSize,UIKit.IUIViewControllerTransitionCoordinator)" />
	method is invoked when rotation takes place.

      </para>
      <format type="text/html">
        <h3>MVC, MVP, and MVVM</h3>
      </format>
      <para>
        .NET developers will be familiar with Microsoft-promoted architectures that serve the same goal as MVC. Both Model-View-Presenter (MVP) and Model-View-ViewModel (MVVM) strive to maintain the separation between Model classes and display classes. Developers familiar with MVP will be used to Model data flowing through a coordinating Presenter object towards the View rather than MVC’s model in which Views directly subscribe to Model events. It is possible to do an MVP architecture in iOS by increasing the responsibilities of a <see cref="T:UIKit.UIViewController" />. The defining characteristic of MVVM is the use of databinding to ensure that View objects are reactive. iOS controls do not support databinding so MVVM is not possible. MVVM developers will be used to more of a "firewall" between View and Model objects than is available in MVC. MVVM developers should remind themselves to ensure their View objects are as reactive as possible and are not reaching in to the Model for data or taking over Controller responsibilities.
      </para>
      <format type="text/html">
        <h2>UIViewController and MonoTouch.Dialog</h2>
      </format>
      <para>
        <format type="text/html">
          <a href="https://docs.xamarin.com/ios/Guides/User_Interface/MonoTouch.Dialog">MonoTouch.Dialog</a>
        </format> (“MT.D”) allows complex UIs to be rapidly built using declarative statements. As opposed to applications built using Apple’s Interface Builder, most MT.D applications use the predefined <see cref="T:MonoTouch.Dialog.DialogViewController" /> and do not create their own subclass of <see cref="T:UIKit.UIViewController" />. For more information, refer to the <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=Mono%20Touch%20Dialog&amp;scope=Xamarin" title="N:MonoTouch.Dialog">N:MonoTouch.Dialog</a></format> namespace documentation and the article  <format type="text/html"><a href="https://docs.xamarin.com/ios/Guides/User_Interface/MonoTouch.Dialog">Introduction to MonoTouch.Dialog</a></format>.
      </para>
    </remarks>
    <related type="article" href="https://docs.xamarin.com/ios/Guides/User_Interface/MonoTouch.Dialog">Introduction to MonoTouch.Dialog</related>
    <related type="article" href="https://docs.xamarin.com/index.php?title=ios/Guides/Getting_Started/Hello%2C_iPad___Universal_Apps">iPad + Universal (iPhone + iPad) Apps</related>
    <related type="article" href="https://docs.xamarin.com/ios/Guides/User_Interface/Introduction_to_Storyboards">Introduction to Storyboards</related>
    <related type="sample" href="https://github.com/xamarin/ios-samples/tree/master/HelloWorld_iPhone/">Hello World iPhone</related>
    <related type="sample" href="https://github.com/xamarin/ios-samples/tree/master/FrogScroller">iOS Standard Controls</related>
    <altmember cref="T:UIKit.TransitionCoordinator_UIViewController" />
    <related type="externalDocumentation" href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIViewController_Class/index.html">Apple documentation for <c>UIViewController</c></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIViewController ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("init")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Default constructor that initializes a new instance of this class with no parameters.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIViewController (Foundation.NSCoder coder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Foundation.NSCoder coder) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.#ctor(Foundation.NSCoder)" />
      <MemberSignature Language="F#" Value="new UIKit.UIViewController : Foundation.NSCoder -&gt; UIKit.UIViewController" Usage="new UIKit.UIViewController coder" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("initWithCoder:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.DesignatedInitializer</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="coder" Type="Foundation.NSCoder" />
      </Parameters>
      <Docs>
        <param name="coder">The unarchiver object.</param>
        <summary>A constructor that initializes the object from the data stored in the unarchiver object.</summary>
        <remarks>
          <para>This constructor is provided to allow the class to be initialized from an unarchiver (for example, during NIB deserialization).   This is part of the <see cref="T:Foundation.NSCoding" />  protocol.</para>
          <para>If developers want to create a subclass of this object and continue to support deserialization from an archive, they should implement a constructor with an identical signature: taking a single parameter of type <see cref="T:Foundation.NSCoder" /> and decorate it with the [Export("initWithCoder:"] attribute declaration.</para>
          <para>The state of this object can also be serialized by using the companion method, EncodeTo.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected UIViewController (Foundation.NSObjectFlag t);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class Foundation.NSObjectFlag t) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.#ctor(Foundation.NSObjectFlag)" />
      <MemberSignature Language="F#" Value="new UIKit.UIViewController : Foundation.NSObjectFlag -&gt; UIKit.UIViewController" Usage="new UIKit.UIViewController t" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="t" Type="Foundation.NSObjectFlag" />
      </Parameters>
      <Docs>
        <param name="t">Unused sentinel value, pass NSObjectFlag.Empty.</param>
        <summary>Constructor to call on derived classes to skip initialization and merely allocate the object.</summary>
        <remarks>
          <para>This constructor should be called by derived classes when they completely construct the object in managed code and merely want the runtime to allocate and initialize the NSObject.   This is required to implement the two-step initialization process that Objective-C uses, the first step is to perform the object allocation, the second step is to initialize the object.   When developers invoke the constructor that takes the NSObjectFlag.Empty they take advantage of a direct path that goes all the way up to NSObject to merely allocate the object's memory and bind the Objective-C and C# objects together.    The actual initialization of the object is up to the developer.</para>
          <para>This constructor is typically used by the binding generator to allocate the object, but prevent the actual initialization to take place.   Once the allocation has taken place, the constructor has to initialize the object.   With constructors generated by the binding generator this means that it manually invokes one of the "init" methods to initialize the object.</para>
          <para>It is the developer's responsibility to completely initialize the object if they chain up using the NSObjectFlag.Empty path.</para>
          <para>In general, if the developer's constructor invokes the NSObjectFlag.Empty base implementation, then it should be calling an Objective-C init method.   If this is not the case, developers should instead chain to the proper constructor in their class. </para>
          <para>The argument value is ignored and merely ensures that the only code that is executed is the construction phase is the basic NSObject allocation and runtime type registration.  Typically the chaining would look like this:</para>
          <example>
            <code lang="csharp lang-csharp"><![CDATA[
//
// The NSObjectFlag merely allocates the object and registers the
// C# class with the Objective-C runtime if necessary, but no actual
// initXxx method is invoked, that is done later in the constructor
//
// This is taken from Xamarin.iOS's source code:
//
[Export ("initWithFrame:")]
public UIView (System.Drawing.RectangleF frame) : base (NSObjectFlag.Empty)
{
// Invoke the init method now.
	var initWithFrame = new Selector ("initWithFrame:").Handle;
	if (IsDirectBinding)
		Handle = ObjCRuntime.Messaging.IntPtr_objc_msgSend_CGRect (this.Handle, initWithFrame, frame);
	else
		Handle = ObjCRuntime.Messaging.IntPtr_objc_msgSendSuper_CGRect (this.SuperHandle, initWithFrame, frame);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected internal UIViewController (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig specialname rtspecialname instance void .ctor(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.#ctor(System.IntPtr)" />
      <MemberSignature Language="F#" Value="new UIKit.UIViewController : nativeint -&gt; UIKit.UIViewController" Usage="new UIKit.UIViewController handle" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Pointer (handle) to the unmanaged object.</param>
        <summary>A constructor used when creating managed representations of unmanaged objects;  Called by the runtime.</summary>
        <remarks>
          <para>This constructor is invoked by the runtime infrastructure (<see cref="M:ObjCRuntime.Runtime.GetNSObject(System.IntPtr)" />) to create a new managed representation for a pointer to an unmanaged Objective-C object.    Developers should not invoke this method directly, instead they should call the GetNSObject method as it will prevent two instances of a managed object to point to the same native object.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIViewController (string nibName, Foundation.NSBundle bundle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string nibName, class Foundation.NSBundle bundle) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.#ctor(System.String,Foundation.NSBundle)" />
      <MemberSignature Language="F#" Value="new UIKit.UIViewController : string * Foundation.NSBundle -&gt; UIKit.UIViewController" Usage="new UIKit.UIViewController (nibName, bundle)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("initWithNibName:bundle:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.DesignatedInitializer</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="nibName" Type="System.String" />
        <Parameter Name="bundle" Type="Foundation.NSBundle" />
      </Parameters>
      <Docs>
        <param name="nibName">
          <para>The NIB name, or null.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <param name="bundle">
          <para>The bundle where the search for the NIB takes place, if you pass null, this searches for the NIB on the main bundle.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>A constructor used when creating a view controller using the information that is stored in the nib file.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (UIKit.UIView view);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(class UIKit.UIView view) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.Add(UIKit.UIView)" />
      <MemberSignature Language="F#" Value="member this.Add : UIKit.UIView -&gt; unit" Usage="uIViewController.Add view" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="view" Type="UIKit.UIView" />
      </Parameters>
      <Docs>
        <param name="view">The subview to add.</param>
        <summary>This is an alias for <see cref="M:UIKit.UIView.AddSubview(UIKit.UIView)" />, but uses the Add pattern as it allows C# 3.0 constructs to add subviews after creating the object.</summary>
        <remarks>
          <para>
            This method is equivalent to calling <see cref="M:UIKit.UIView.AddSubview(UIKit.UIView)" /> on this <see cref="T:UIKit.UIViewController" />'s <see cref="P:UIKit.UIViewController.View" /> and is present to enable C# 3.0 to add subviews at creation time.
          </para>
          <example>
            <code lang="csharp lang-csharp"><![CDATA[
  var myView = new MyViewController (new RectangleF (0, 0, 320, 320)){
    new ImageGallery (region [0]),
    new ImageGallery (region [1]),
    new UILabel (new RectangleF (10, 10, 200, 200)){
      Text = "Images from our Trip"
    }
  };
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddChildViewController">
      <MemberSignature Language="C#" Value="public virtual void AddChildViewController (UIKit.UIViewController childController);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddChildViewController(class UIKit.UIViewController childController) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.AddChildViewController(UIKit.UIViewController)" />
      <MemberSignature Language="F#" Value="abstract member AddChildViewController : UIKit.UIViewController -&gt; unit&#xA;override this.AddChildViewController : UIKit.UIViewController -&gt; unit" Usage="uIViewController.AddChildViewController childController" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("addChildViewController:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="childController" Type="UIKit.UIViewController" />
      </Parameters>
      <Docs>
        <param name="childController">The <see cref="T:UIKit.UIViewController" /> to be added.</param>
        <summary>Adds a <see cref="T:UIKit.UIViewController" /> as a child.</summary>
        <remarks>
          <para>
            <see cref="T:UIKit.UIViewController" />s that are primarily containers of other <see cref="T:UIKit.UIViewController" />s should use this method to add child view controllers.</para>
          <block subset="none" type="overrides">
            <para>
              Application developers who override this method must call <c>base.AddChildViewController(childController)</c>.
            </para>
          </block>
        </remarks>
        <altmember cref="M:UIKit.UIViewController.RemoveFromParentViewController" />
        <altmember cref="P:UIKit.UIViewController.ChildViewControllers" />
      </Docs>
    </Member>
    <Member MemberName="AdditionalSafeAreaInsets">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIEdgeInsets AdditionalSafeAreaInsets { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype UIKit.UIEdgeInsets AdditionalSafeAreaInsets" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.AdditionalSafeAreaInsets" />
      <MemberSignature Language="F#" Value="member this.AdditionalSafeAreaInsets : UIKit.UIEdgeInsets with get, set" Usage="UIKit.UIViewController.AdditionalSafeAreaInsets" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("additionalSafeAreaInsets", ObjCRuntime.ArgumentSemantic.UnsafeUnretained)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setAdditionalSafeAreaInsets:", ObjCRuntime.ArgumentSemantic.UnsafeUnretained)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIEdgeInsets</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets additional safe area insets to account for app-specific tool bars and other app-specific UI.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddKeyCommand">
      <MemberSignature Language="C#" Value="public virtual void AddKeyCommand (UIKit.UIKeyCommand command);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddKeyCommand(class UIKit.UIKeyCommand command) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.AddKeyCommand(UIKit.UIKeyCommand)" />
      <MemberSignature Language="F#" Value="abstract member AddKeyCommand : UIKit.UIKeyCommand -&gt; unit&#xA;override this.AddKeyCommand : UIKit.UIKeyCommand -&gt; unit" Usage="uIViewController.AddKeyCommand command" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("addKeyCommand:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="UIKit.UIKeyCommand" />
      </Parameters>
      <Docs>
        <param name="command">Definition of the new keyboard action.</param>
        <summary>Adds <paramref name="command" /> as a shortcut available to attached hardware keyboards.</summary>
        <remarks>
          <para>
            <see cref="T:UIKit.UIKeyCommand" /> objects are only generated with an attached hardware keyboard.</para>
          <para>To create keyboard accelerators, developers must create a <see cref="T:ObjCRuntime.Selector" /> that is associated with 
        a method of type <c><![CDATA[Action<UIKeyCommand>]]></c> with an appropriate <see cref="T:Foundation.ExportAttribute" />:</para>
          <example>
            <code lang="csharp lang-csharp"><![CDATA[
[Export("NewFileAccelerator:")]
void NewFileAccelerator(UIKeyCommand cmd)
{
   //etc...
}

public override void ViewDidLoad ()
{
    base.ViewDidLoad ();

    var actionSelector = new Selector("NewFileAccelerator:");
    accelerator = UIKeyCommand.Create((NSString) "N", UIKeyModifierFlags.Command, actionSelector);

    AddKeyCommand(accelerator);
}
    ]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationFinishedRestoringState">
      <MemberSignature Language="C#" Value="public virtual void ApplicationFinishedRestoringState ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplicationFinishedRestoringState() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.ApplicationFinishedRestoringState" />
      <MemberSignature Language="F#" Value="abstract member ApplicationFinishedRestoringState : unit -&gt; unit&#xA;override this.ApplicationFinishedRestoringState : unit -&gt; unit" Usage="uIViewController.ApplicationFinishedRestoringState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("applicationFinishedRestoringState")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Called when object decoding is complete during state restoration.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AttemptRotationToDeviceOrientation">
      <MemberSignature Language="C#" Value="public static void AttemptRotationToDeviceOrientation ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AttemptRotationToDeviceOrientation() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.AttemptRotationToDeviceOrientation" />
      <MemberSignature Language="F#" Value="static member AttemptRotationToDeviceOrientation : unit -&gt; unit" Usage="UIKit.UIViewController.AttemptRotationToDeviceOrientation " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("attemptRotationToDeviceOrientation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Programmatically triggers rotation of views.</summary>
        <remarks>If <see cref="M:UIKit.UIViewController.ShouldAutorotateToInterfaceOrientation(UIKit.UIInterfaceOrientation)" />  returns <see langword="false" />, this method can be used to programmatically trigger view rotation.</remarks>
        <altmember cref="M:UIKit.UIViewController.WillRotate" />
        <altmember cref="M:UIKit.UIViewController.ShouldAutorotateToInterfaceOrientation" />
      </Docs>
    </Member>
    <Member MemberName="AutomaticallyAdjustsScrollViewInsets">
      <MemberSignature Language="C#" Value="public virtual bool AutomaticallyAdjustsScrollViewInsets { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutomaticallyAdjustsScrollViewInsets" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.AutomaticallyAdjustsScrollViewInsets" />
      <MemberSignature Language="F#" Value="member this.AutomaticallyAdjustsScrollViewInsets : bool with get, set" Usage="UIKit.UIViewController.AutomaticallyAdjustsScrollViewInsets" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.None, "Use 'UIScrollView.ContentInsetAdjustmentBehavior' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.None, "Use 'UIScrollView.ContentInsetAdjustmentBehavior' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("automaticallyAdjustsScrollViewInsets")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.None, "Use 'UIScrollView.ContentInsetAdjustmentBehavior' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.None, "Use 'UIScrollView.ContentInsetAdjustmentBehavior' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setAutomaticallyAdjustsScrollViewInsets:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.None, "Use 'UIScrollView.ContentInsetAdjustmentBehavior' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.None, "Use 'UIScrollView.ContentInsetAdjustmentBehavior' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Developers should not use this deprecated property. Developers should use 'UIScrollView.ContentInsetAdjustmentBehavior' instead.</summary>
        <value>Whether or not the specified view controller should make adjustments to its scroll view insets automatically.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AutomaticallyForwardAppearanceAndRotationMethodsToChildViewControllers">
      <MemberSignature Language="C#" Value="public virtual bool AutomaticallyForwardAppearanceAndRotationMethodsToChildViewControllers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutomaticallyForwardAppearanceAndRotationMethodsToChildViewControllers" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.AutomaticallyForwardAppearanceAndRotationMethodsToChildViewControllers" />
      <MemberSignature Language="F#" Value="member this.AutomaticallyForwardAppearanceAndRotationMethodsToChildViewControllers : bool" Usage="UIKit.UIViewController.AutomaticallyForwardAppearanceAndRotationMethodsToChildViewControllers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("automaticallyForwardAppearanceAndRotationMethodsToChildViewControllers")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determines whether the containment events are automatically propagaged to nested view controllers.</summary>
        <value>The default value is <see langword="true" />.</value>
        <remarks>
          <para>This method is deprecated and application developers should instead use <see cref="P:UIKit.UIViewController.ShouldAutomaticallyForwardAppearanceMethods" /> and <see cref="P:UIKit.UIViewController.ShouldAutomaticallyForwardRotationMethods" />.</para>
          <para>
            By default, this setting is <see langword="true" />, and UIKit will invoke the following methods on the nested view controllers automatically: 
            <see cref="M:UIKit.UIViewController.ViewWillAppear(System.Boolean)" />,
            <see cref="M:UIKit.UIViewController.ViewDidAppear(System.Boolean)" />,
            <see cref="M:UIKit.UIViewController.ViewWillDisappear(System.Boolean)" />,
            <see cref="M:UIKit.UIViewController.ViewDidDisappear(System.Boolean)" />,
            <see cref="M:UIKit.UIViewController.WillRotate(UIKit.UIInterfaceOrientation,System.Double)" />,
            <see cref="M:UIKit.UIViewController.WillAnimateRotation(UIKit.UIInterfaceOrientation,System.Double)" /> and 
            <see cref="M:UIKit.UIViewController.DidRotate(UIKit.UIInterfaceOrientation)" />.   
            
            If this value is set to <see langword="false" />, your view controller is
            responsible to forward those events to the nested view
            controllers.
            
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginAppearanceTransition">
      <MemberSignature Language="C#" Value="public virtual void BeginAppearanceTransition (bool isAppearing, bool animated);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginAppearanceTransition(bool isAppearing, bool animated) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.BeginAppearanceTransition(System.Boolean,System.Boolean)" />
      <MemberSignature Language="F#" Value="abstract member BeginAppearanceTransition : bool * bool -&gt; unit&#xA;override this.BeginAppearanceTransition : bool * bool -&gt; unit" Usage="uIViewController.BeginAppearanceTransition (isAppearing, animated)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("beginAppearanceTransition:animated:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isAppearing" Type="System.Boolean" />
        <Parameter Name="animated" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isAppearing">
          <see langword="true" /> if the child <see cref="T:UIKit.UIViewController" />’s views are being shown, <see langword="false" /> if they are being hidden.</param>
        <param name="animated">
          <see langword="true" /> if the transition is being animated.</param>
        <summary>With <see cref="M:UIKit.UIViewController.EndAppearanceTransition" />, tells child <see cref="T:UIKit.UIViewController" />s that their <see cref="T:UIKit.UIView" />s are about to either appear or disappear.</summary>
        <remarks>
          <para>
            This method, along with <see cref="M:UIKit.UIViewController.EndAppearanceTransition" />, should be used to alert child <see cref="T:UIKit.UIViewController" />s that their view or views are about to be shown or hidden. The application developer must invoke these methods and must not call <see cref="M:UIKit.UIViewController.ViewWillAppear(System.Boolean)" />, <see cref="M:UIKit.UIViewController.ViewDidAppear(System.Boolean)" />, <see cref="M:UIKit.UIViewController.ViewWillDisappear(System.Boolean)" />, or <see cref="M:UIKit.UIViewController.ViewDidDisappear(System.Boolean)" /> directly.
          </para>
          <para>
            The following code, from the "Media Notes" sample, demonstrates the use of <see cref="M:UIKit.UIViewController.BeginAppearanceTransition(System.Boolean,System.Boolean)" /> and <see cref="M:UIKit.UIViewController.EndAppearanceTransition" />. The code snippet shows the child <see cref="T:UIKit.UIViewController" /> being removed from the display (<paramref name="isAppearing" /> is <see langword="false" />) in an animated mirror (<paramref name="animated" /> is <see langword="true" />). The call to <see cref="M:UIKit.UIViewController.BeginAppearanceTransition(System.Boolean,System.Boolean)" /> occurs and then <see cref="M:UIKit.UIViewController.EndAppearanceTransition" /> is called at the end of the specified animation.
          </para>
          <example>
            <code lang="csharp lang-csharp"><![CDATA[
commentViewIsVisible = false;
commentViewController.WillMoveToParentViewController (null);
commentViewController.BeginAppearanceTransition (false, true);
UIView.Animate (0.5f, () => {
    commentView.Alpha = 0.5f;
}, () => { 
    commentView.RemoveFromSuperview ();
    commentViewController.EndAppearanceTransition ();
    commentViewController.RemoveFromParentViewController ();
});
              ]]></code>
          </example>
        </remarks>
        <altmember cref="M:UIKit.UIViewController.EndAppearanceTransition" />
        <related type="sample" href="https://github.com/xamarin/ios-samples/tree/master/MediaNotes">Media Notes</related>
      </Docs>
    </Member>
    <Member MemberName="BeginRequestWithExtensionContext">
      <MemberSignature Language="C#" Value="public virtual void BeginRequestWithExtensionContext (Foundation.NSExtensionContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginRequestWithExtensionContext(class Foundation.NSExtensionContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.BeginRequestWithExtensionContext(Foundation.NSExtensionContext)" />
      <MemberSignature Language="F#" Value="abstract member BeginRequestWithExtensionContext : Foundation.NSExtensionContext -&gt; unit&#xA;override this.BeginRequestWithExtensionContext : Foundation.NSExtensionContext -&gt; unit" Usage="uIViewController.BeginRequestWithExtensionContext context" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Foundation.INSExtensionRequestHandling.BeginRequestWithExtensionContext(Foundation.NSExtensionContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("beginRequestWithExtensionContext:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.MacOSX, 10, 10, ObjCRuntime.PlatformArchitecture.Arch64, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="Foundation.NSExtensionContext" />
      </Parameters>
      <Docs>
        <param name="context">A context object that contains data for the request.</param>
        <summary>Method that is called when the host app is about to make a request.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BottomLayoutGuide">
      <MemberSignature Language="C#" Value="public virtual UIKit.IUILayoutSupport BottomLayoutGuide { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.IUILayoutSupport BottomLayoutGuide" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.BottomLayoutGuide" />
      <MemberSignature Language="F#" Value="member this.BottomLayoutGuide : UIKit.IUILayoutSupport" Usage="UIKit.UIViewController.BottomLayoutGuide" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.None, "Use 'UIView.SafeAreaLayoutGuide.BottomAnchor' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.None, "Use 'UIView.SafeAreaLayoutGuide.BottomAnchor' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("bottomLayoutGuide")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.None, "Use 'UIView.SafeAreaLayoutGuide.BottomAnchor' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.None, "Use 'UIView.SafeAreaLayoutGuide.BottomAnchor' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.IUILayoutSupport</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Developers should not use this deprecated property. Instead, they should use <see cref="P:UIKit.UIView.SafeAreaLayoutGuide" />.</summary>
        <value>The length property of the object that is specified when you make a query on this property.</value>
        <remarks>This deprecated property holds the lower vertical extent of the onscreen content. Used by Auto Layout constraints. Read-only.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanPerformUnwind">
      <MemberSignature Language="C#" Value="public virtual bool CanPerformUnwind (ObjCRuntime.Selector segueAction, UIKit.UIViewController fromViewController, Foundation.NSObject sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanPerformUnwind(class ObjCRuntime.Selector segueAction, class UIKit.UIViewController fromViewController, class Foundation.NSObject sender) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.CanPerformUnwind(ObjCRuntime.Selector,UIKit.UIViewController,Foundation.NSObject)" />
      <MemberSignature Language="F#" Value="abstract member CanPerformUnwind : ObjCRuntime.Selector * UIKit.UIViewController * Foundation.NSObject -&gt; bool&#xA;override this.CanPerformUnwind : ObjCRuntime.Selector * UIKit.UIViewController * Foundation.NSObject -&gt; bool" Usage="uIViewController.CanPerformUnwind (segueAction, fromViewController, sender)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("canPerformUnwindSegueAction:fromViewController:withSender:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="segueAction" Type="ObjCRuntime.Selector" />
        <Parameter Name="fromViewController" Type="UIKit.UIViewController" />
        <Parameter Name="sender" Type="Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="segueAction">The action that the target <see cref="T:UIKit.UIViewController" /> should perform immediately prior to the segue executing.</param>
        <param name="fromViewController">The initiating <see cref="T:UIKit.UIViewController" />.</param>
        <param name="sender">The object that sent the action.</param>
        <summary>Specifies whether this <see cref="T:UIKit.UIViewController" /> supports the specific unwind segue</summary>
        <returns>Returns <see langword="true" /> if <c>this</c> supports the specific unwind segue.</returns>
        <remarks>
          <para>
            “Unwind actions” occur when a storyboard segues back through the sequence of <see cref="T:UIKit.UIViewController" />s that brought the application to its current state. This method is called to determine if this <see cref="T:UIKit.UIViewController" /> supports an unwind segue with the specified parameters.
          </para>
        </remarks>
        <altmember cref="M:UIKit.UIViewController.GetSegueForUnwinding" />
      </Docs>
    </Member>
    <Member MemberName="ChildViewControllerForHomeIndicatorAutoHidden">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIViewController ChildViewControllerForHomeIndicatorAutoHidden { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIViewController ChildViewControllerForHomeIndicatorAutoHidden" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.ChildViewControllerForHomeIndicatorAutoHidden" />
      <MemberSignature Language="F#" Value="member this.ChildViewControllerForHomeIndicatorAutoHidden : UIKit.UIViewController" Usage="UIKit.UIViewController.ChildViewControllerForHomeIndicatorAutoHidden" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("childViewControllerForHomeIndicatorAutoHidden")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIViewController</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a child view controller for determining whether to display an indicator for returning to the Home screen.</summary>
        <value>
          <para>(More documentation for this node is coming)</para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ChildViewControllerForScreenEdgesDeferringSystemGestures">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIViewController ChildViewControllerForScreenEdgesDeferringSystemGestures { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIViewController ChildViewControllerForScreenEdgesDeferringSystemGestures" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.ChildViewControllerForScreenEdgesDeferringSystemGestures" />
      <MemberSignature Language="F#" Value="member this.ChildViewControllerForScreenEdgesDeferringSystemGestures : UIKit.UIViewController" Usage="UIKit.UIViewController.ChildViewControllerForScreenEdgesDeferringSystemGestures" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("childViewControllerForScreenEdgesDeferringSystemGestures")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIViewController</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the child view controller that has precedence when processing screen edge gestures, if present.</summary>
        <value>
          <para>(More documentation for this node is coming)</para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ChildViewControllerForStatusBarHidden">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIViewController ChildViewControllerForStatusBarHidden ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class UIKit.UIViewController ChildViewControllerForStatusBarHidden() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.ChildViewControllerForStatusBarHidden" />
      <MemberSignature Language="F#" Value="abstract member ChildViewControllerForStatusBarHidden : unit -&gt; UIKit.UIViewController&#xA;override this.ChildViewControllerForStatusBarHidden : unit -&gt; UIKit.UIViewController" Usage="uIViewController.ChildViewControllerForStatusBarHidden " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("childViewControllerForStatusBarHidden")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIViewController</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>When overridden, returns the UIViewController that determines whether the status bar is hidden or unhidden.</summary>
        <returns>The child view controller whose status should be used. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ChildViewControllerForStatusBarStyle">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIViewController ChildViewControllerForStatusBarStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class UIKit.UIViewController ChildViewControllerForStatusBarStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.ChildViewControllerForStatusBarStyle" />
      <MemberSignature Language="F#" Value="abstract member ChildViewControllerForStatusBarStyle : unit -&gt; UIKit.UIViewController&#xA;override this.ChildViewControllerForStatusBarStyle : unit -&gt; UIKit.UIViewController" Usage="uIViewController.ChildViewControllerForStatusBarStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("childViewControllerForStatusBarStyle")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIViewController</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>When overridden, returns the UIViewController that determines the style of the status bar.</summary>
        <returns>The child view controller that determines the status bar style should be used</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ChildViewControllers">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIViewController[] ChildViewControllers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIViewController[] ChildViewControllers" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.ChildViewControllers" />
      <MemberSignature Language="F#" Value="member this.ChildViewControllers : UIKit.UIViewController[]" Usage="UIKit.UIViewController.ChildViewControllers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("childViewControllers")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIViewController[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An array of <see cref="T:UIKit.UIViewController" />s that are managed by this <see cref="T:UIKit.UIViewController" />.</summary>
        <value>An array of <see cref="T:UIKit.UIViewController" />s.</value>
        <remarks>
          <para>Certain <see cref="T:UIKit.UIViewController" />s (e.g., <see cref="T:UIKit.UINavigationController" />) are primarily concerned with manipulating child controllers. Such controllers are often referred to as “Container View-Controllers.” </para>
          <para>This property does not include <see cref="T:UIKit.UIViewController" />s “presented” using <see cref="M:UIKit.UIViewController.PresentViewController(UIKit.UIViewController,System.Boolean,System.Action)" />, <see cref="M:UIKit.UIViewController.PresentModalViewController(UIKit.UIViewController,System.Boolean)" />, or <see cref="M:UIKit.UIViewController.PresentMoviePlayerViewController(MediaPlayer.MPMoviePlayerViewController)" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClassHandle">
      <MemberSignature Language="C#" Value="public override IntPtr ClassHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ClassHandle" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.ClassHandle" />
      <MemberSignature Language="F#" Value="member this.ClassHandle : nativeint" Usage="UIKit.UIViewController.ClassHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The handle for this class.</summary>
        <value>The pointer to the Objective-C class.</value>
        <remarks>Each Xamarin.iOS class mirrors an unmanaged Objective-C class.   This value contains the pointer to the Objective-C class, it is similar to calling objc_getClass with the object name.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentSizeForViewInPopover">
      <MemberSignature Language="C#" Value="public virtual CoreGraphics.CGSize ContentSizeForViewInPopover { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype CoreGraphics.CGSize ContentSizeForViewInPopover" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.ContentSizeForViewInPopover" />
      <MemberSignature Language="F#" Value="member this.ContentSizeForViewInPopover : CoreGraphics.CGSize with get, set" Usage="UIKit.UIViewController.ContentSizeForViewInPopover" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, "Use 'PreferredContentSize' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("contentSizeForViewInPopover")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, "Use 'PreferredContentSize' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setContentSizeForViewInPopover:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, "Use 'PreferredContentSize' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>CoreGraphics.CGSize</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Default content size for popovers.</summary>
        <value>The default value is [320,1100] points.</value>
        <remarks>
          <para>Unless overridden by <see cref="P:UIKit.UIPopoverController.PopoverContentSize" />, this value specifies the content size of popovers displayed by the <see cref="T:UIKit.UIViewController" />.</para>
          <para>Popovers may be up to 600 points wide, but application developers are recommended to use the standard 320 point width.</para>
        </remarks>
        <related type="sample" href="https://github.com/xamarin/ios-samples/tree/master/Popovers/">Popovers</related>
        <altmember cref="T:UIKit.UIPopoverController" />
      </Docs>
    </Member>
    <Member MemberName="DecodeRestorableState">
      <MemberSignature Language="C#" Value="public virtual void DecodeRestorableState (Foundation.NSCoder coder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DecodeRestorableState(class Foundation.NSCoder coder) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.DecodeRestorableState(Foundation.NSCoder)" />
      <MemberSignature Language="F#" Value="abstract member DecodeRestorableState : Foundation.NSCoder -&gt; unit&#xA;override this.DecodeRestorableState : Foundation.NSCoder -&gt; unit" Usage="uIViewController.DecodeRestorableState coder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("decodeRestorableStateWithCoder:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="coder" Type="Foundation.NSCoder" />
      </Parameters>
      <Docs>
        <param name="coder">The <see cref="T:Foundation.NSCoder" /> that decodes the stored state of the application.</param>
        <summary>With <see cref="M:UIKit.UIViewController.EncodeRestorableState(Foundation.NSCoder)" />, allows custom state restoration.</summary>
        <remarks>
          <para>
            In applications that supports state restoration, this function and <see cref="M:UIKit.UIViewController.EncodeRestorableState(Foundation.NSCoder)" /> may be used to supplement standard state encoding and decoding. If <see cref="M:UIKit.UIViewController.EncodeRestorableState(Foundation.NSCoder)" /> calls <c>base.EncodeRestorableState(coder)</c>, this function should call <c>base.DecodeRestorableState(coder)</c>.
          </para>
        </remarks>
        <altmember cref="M:UIKit.UIViewController.EncodeReusableState" />
      </Docs>
    </Member>
    <Member MemberName="DefinesPresentationContext">
      <MemberSignature Language="C#" Value="public virtual bool DefinesPresentationContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DefinesPresentationContext" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.DefinesPresentationContext" />
      <MemberSignature Language="F#" Value="member this.DefinesPresentationContext : bool with get, set" Usage="UIKit.UIViewController.DefinesPresentationContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("definesPresentationContext")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setDefinesPresentationContext:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies whether this <see cref="T:UIKit.UIViewController" />’s <see cref="P:UIKit.UIViewController.View" /> is shown when presenting another <see cref="T:UIKit.UIViewController" />.</summary>
        <value>The default is <see langword="false" />.</value>
        <remarks>
          <para>
            When an application presents a view (i.e., using <see cref="M:UIKit.UIViewController.PresentViewController(UIKit.UIViewController,System.Boolean,System.Action)" />, <see cref="M:UIKit.UIViewController.PresentModalViewController(UIKit.UIViewController,System.Boolean)" />, or <see cref="M:UIKit.UIViewController.PresentMoviePlayerViewController(MediaPlayer.MPMoviePlayerViewController)" />), iOS calls this method on the presenting <see cref="T:UIKit.UIViewController" />. If this method returns <see langword="false" />, iOS will call this method on <see cref="P:UIKit.UIViewController.ParentViewController" />. If no <see cref="T:UIKit.UIViewController" /> in the chain return <see langword="true" />, the presented <see cref="T:UIKit.UIViewController" /> is presented using the root <see cref="T:UIKit.UIViewController" /> context.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DidAnimateFirstHalfOfRotation">
      <MemberSignature Language="C#" Value="public virtual void DidAnimateFirstHalfOfRotation (UIKit.UIInterfaceOrientation toInterfaceOrientation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DidAnimateFirstHalfOfRotation(valuetype UIKit.UIInterfaceOrientation toInterfaceOrientation) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.DidAnimateFirstHalfOfRotation(UIKit.UIInterfaceOrientation)" />
      <MemberSignature Language="F#" Value="abstract member DidAnimateFirstHalfOfRotation : UIKit.UIInterfaceOrientation -&gt; unit&#xA;override this.DidAnimateFirstHalfOfRotation : UIKit.UIInterfaceOrientation -&gt; unit" Usage="uIViewController.DidAnimateFirstHalfOfRotation toInterfaceOrientation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("didAnimateFirstHalfOfRotationToInterfaceOrientation:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 5, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toInterfaceOrientation" Type="UIKit.UIInterfaceOrientation" />
      </Parameters>
      <Docs>
        <param name="toInterfaceOrientation">
          <para>The <see cref="T:UIKit.UIInterfaceOrientation" /> at which the device will be on completion.</para>
        </param>
        <summary>Deprecated function called at end of first-part of two-step rotation animations.</summary>
        <remarks>
          <para>
            Applications should override the <see cref="M:UIKit.UIViewController.WillAnimateRotation(UIKit.UIInterfaceOrientation,System.Double)" /> method rather than this function, which Apple deprecated in iOS 5.0. 
          </para>
          <para>
            This function is called after the first half of a two-step rotation animation. Application developers can adjust views before the second-step occurs.
          </para>
        </remarks>
        <altmember cref="M:UIKit.WillAnimateRotation" />
        <altmember cref="M:UIKit.WillAnimateFirstHalfOfRotation" />
        <altmember cref="M:UIKit.WillAnimateSecondHalfOfRotation" />
        <!-- TODO: Where is "DidAnimateSecondHalfOfRotation? -->
      </Docs>
    </Member>
    <Member MemberName="DidMoveToParentViewController">
      <MemberSignature Language="C#" Value="public virtual void DidMoveToParentViewController (UIKit.UIViewController parent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DidMoveToParentViewController(class UIKit.UIViewController parent) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.DidMoveToParentViewController(UIKit.UIViewController)" />
      <MemberSignature Language="F#" Value="abstract member DidMoveToParentViewController : UIKit.UIViewController -&gt; unit&#xA;override this.DidMoveToParentViewController : UIKit.UIViewController -&gt; unit" Usage="uIViewController.DidMoveToParentViewController parent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("didMoveToParentViewController:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parent" Type="UIKit.UIViewController" />
      </Parameters>
      <Docs>
        <param name="parent">
          <para>The parent view controller to which this view controller was moved, or <see langword="null" /> if there is no parent.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Called after <c>this</c> is added or removed from a parent <see cref="T:UIKit.UIViewController" />.</summary>
        <remarks>
          <para>Application developers who implement their own container <see cref="T:UIKit.UIViewController" /> must call this method after adding child <see cref="T:UIKit.UIViewController" />s with <see cref="M:UIKit.UIViewController.AddChildViewController(UIKit.UIViewController)" />.</para>
          <para>This method is called automatically by <see cref="M:UIKit.UIViewController.RemoveFromParentViewController" />.</para>
        </remarks>
        <altmember cref="P:UIKit.UIViewController.Parent" />
        <altmember cref="M:UIKit.UIViewController.RemoveFromParentViewController" />
      </Docs>
    </Member>
    <Member MemberName="DidReceiveMemoryWarning">
      <MemberSignature Language="C#" Value="public virtual void DidReceiveMemoryWarning ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DidReceiveMemoryWarning() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.DidReceiveMemoryWarning" />
      <MemberSignature Language="F#" Value="abstract member DidReceiveMemoryWarning : unit -&gt; unit&#xA;override this.DidReceiveMemoryWarning : unit -&gt; unit" Usage="uIViewController.DidReceiveMemoryWarning " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("didReceiveMemoryWarning")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Called when the system is running low on memory.</summary>
        <remarks>
          <para>This method is automatically called when the system is running low on memory. Application developers who override this method in order to release resources must call <c>base.DidReceiveMemoryWarning()</c>, as shown in the following code, taken from the “Media Notes” sample:</para>
          <example>
            <code lang="csharp lang-csharp"><![CDATA[
public override void DidReceiveMemoryWarning ()
{
    photoMap.Clear ();
    View = null;
    photoImageView = null;
    toolbar = null;
    syncIsNeeded = true;
    base.DidReceiveMemoryWarning();
}
  ]]></code>
          </example>
        </remarks>
        <related type="sample" href="https://github.com/xamarin/ios-samples/tree/master/MediaNotes">Media Notes</related>
      </Docs>
    </Member>
    <Member MemberName="DidRotate">
      <MemberSignature Language="C#" Value="public virtual void DidRotate (UIKit.UIInterfaceOrientation fromInterfaceOrientation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DidRotate(valuetype UIKit.UIInterfaceOrientation fromInterfaceOrientation) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.DidRotate(UIKit.UIInterfaceOrientation)" />
      <MemberSignature Language="F#" Value="abstract member DidRotate : UIKit.UIInterfaceOrientation -&gt; unit&#xA;override this.DidRotate : UIKit.UIInterfaceOrientation -&gt; unit" Usage="uIViewController.DidRotate fromInterfaceOrientation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("didRotateFromInterfaceOrientation:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, "Use Adaptive View Controllers instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInterfaceOrientation" Type="UIKit.UIInterfaceOrientation" />
      </Parameters>
      <Docs>
        <param name="fromInterfaceOrientation">
          <para>The prior orientation.</para>
        </param>
        <summary>Called after the UI has rotated.</summary>
        <remarks>
          <para>The application developer can override this method to perform rotation logic beyond what is provided by auto-rotation, for instance, recalculating expensive drawing parameters, modifying and restarting media playback, etc.
          </para>
          <para>
            When this method is called, the <see cref="P:UIKit.UIViewController.InterfaceOrientation" /> property has already been set to the new <see cref="T:UIKit.UIInterfaceOrientation" />.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DidUpdateFocus">
      <MemberSignature Language="C#" Value="public virtual void DidUpdateFocus (UIKit.UIFocusUpdateContext context, UIKit.UIFocusAnimationCoordinator coordinator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DidUpdateFocus(class UIKit.UIFocusUpdateContext context, class UIKit.UIFocusAnimationCoordinator coordinator) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.DidUpdateFocus(UIKit.UIFocusUpdateContext,UIKit.UIFocusAnimationCoordinator)" />
      <MemberSignature Language="F#" Value="abstract member DidUpdateFocus : UIKit.UIFocusUpdateContext * UIKit.UIFocusAnimationCoordinator -&gt; unit&#xA;override this.DidUpdateFocus : UIKit.UIFocusUpdateContext * UIKit.UIFocusAnimationCoordinator -&gt; unit" Usage="uIViewController.DidUpdateFocus (context, coordinator)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:UIKit.IUIFocusEnvironment.DidUpdateFocus(UIKit.UIFocusUpdateContext,UIKit.UIFocusAnimationCoordinator)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("didUpdateFocusInContext:withAnimationCoordinator:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="UIKit.UIFocusUpdateContext" />
        <Parameter Name="coordinator" Type="UIKit.UIFocusAnimationCoordinator" />
      </Parameters>
      <Docs>
        <param name="context">A <see cref="T:UIKit.UIFocusUpdateContext" /> object containing metadata.</param>
        <param name="coordinator">A <see cref="T:UIKit.UIFocusAnimationCoordinator" /> object containing metadata.</param>
        <summary>Indicates that the focus changed as detailed in the <paramref name="context" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DisablesAutomaticKeyboardDismissal">
      <MemberSignature Language="C#" Value="public virtual bool DisablesAutomaticKeyboardDismissal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisablesAutomaticKeyboardDismissal" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.DisablesAutomaticKeyboardDismissal" />
      <MemberSignature Language="F#" Value="member this.DisablesAutomaticKeyboardDismissal : bool" Usage="UIKit.UIViewController.DisablesAutomaticKeyboardDismissal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("disablesAutomaticKeyboardDismissal")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>If <see langword="true" />, input view will remain on-screen even when non-input control is tapped.</summary>
        <value>The default value is <see langword="false" /> unless using a modal form sheet, in which case it is <see langword="true" />.</value>
        <remarks>
          <para>
            The input view (generally the system keyboard) typically disappears when the application user taps on a control which does not reqire the input view. Application developers can override this method so that it returns <see langword="true" />, leaving the input view on the screen in that situation.  
          </para>
          <para>If the <see cref="P:UIKit.UIViewController.ModalPresentationStyle" /> property is set to <see cref="F:UIKit.UIModalPresentationStyle.FormSheet" />, the default value for this method is <see langword="true" />. That is, by default the system leaves the input view on-screen when presenting modal forms.</para>
        </remarks>
        <altmember cref="M:UIKit.UIModalPresentationStyle.UIModalPresentationStyle.FormSheet" />
      </Docs>
    </Member>
    <Member MemberName="DismissModalViewController">
      <MemberSignature Language="C#" Value="public virtual void DismissModalViewController (bool animated);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DismissModalViewController(bool animated) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.DismissModalViewController(System.Boolean)" />
      <MemberSignature Language="F#" Value="abstract member DismissModalViewController : bool -&gt; unit&#xA;override this.DismissModalViewController : bool -&gt; unit" Usage="uIViewController.DismissModalViewController animated" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("dismissModalViewControllerAnimated:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, "Use 'DismissViewController (bool, NSAction)' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="animated" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="animated">Boolean determining whether to animate the presentation or not.</param>
        <summary>Dismisses the modal view controller that was submitted by the receiver.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DismissMoviePlayerViewController">
      <MemberSignature Language="C#" Value="public virtual void DismissMoviePlayerViewController ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DismissMoviePlayerViewController() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.DismissMoviePlayerViewController" />
      <MemberSignature Language="F#" Value="abstract member DismissMoviePlayerViewController : unit -&gt; unit&#xA;override this.DismissMoviePlayerViewController : unit -&gt; unit" Usage="uIViewController.DismissMoviePlayerViewController " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("dismissMoviePlayerViewControllerAnimated")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, "Use 'AVPlayerViewController' (AVKit) instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.MacOSX, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Dismisses the <see cref="T:MediaPlayer.MPMoviePlayerViewController" />.</summary>
        <remarks>
          <para>Along with <see cref="M:UIKit.UIViewController.PresentMoviePlayerViewController(MediaPlayer.MPMoviePlayerViewController)" />, this method can be used to control the presentation and dismissal of a <see cref="T:MediaPlayer.MPMoviePlayerViewController" /></para>
        </remarks>
        <altmember cref="M:UIKit.UIViewController.PresentMoviePlayerViewController" />
      </Docs>
    </Member>
    <Member MemberName="DismissViewController">
      <MemberSignature Language="C#" Value="public virtual void DismissViewController (bool animated, Action completionHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DismissViewController(bool animated, class System.Action completionHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.DismissViewController(System.Boolean,System.Action)" />
      <MemberSignature Language="F#" Value="abstract member DismissViewController : bool * Action -&gt; unit&#xA;override this.DismissViewController : bool * Action -&gt; unit" Usage="uIViewController.DismissViewController (animated, completionHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("dismissViewControllerAnimated:completion:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="animated" Type="System.Boolean" />
        <Parameter Name="completionHandler" Type="System.Action">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="animated">Boolean that determines if the transition is to be animated.</param>
        <param name="completionHandler">
          <para>The method to invoke when the animation completes.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Dismisses the presented view controller.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DismissViewControllerAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task DismissViewControllerAsync (bool animated);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task DismissViewControllerAsync(bool animated) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.DismissViewControllerAsync(System.Boolean)" />
      <MemberSignature Language="F#" Value="abstract member DismissViewControllerAsync : bool -&gt; System.Threading.Tasks.Task&#xA;override this.DismissViewControllerAsync : bool -&gt; System.Threading.Tasks.Task" Usage="uIViewController.DismissViewControllerAsync animated" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="animated" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="animated">Boolean that determines if the transition is to be animated.</param>
        <summary>Dismisses the presented view controller.</summary>
        <returns>A task that represents the asynchronous DismissViewController operation</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.Dispose(System.Boolean)" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="uIViewController.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <para>If set to <see langword="true" />, the method is invoked directly and will dispose manage and unmanaged resources;   If set to <see langword="false" /> the method is being called by the garbage collector finalizer and should only release unmanaged resources.</para>
        </param>
        <summary>Releases the resources used by the UIViewController object.</summary>
        <remarks>
          <para>This Dispose method releases the resources used by the UIViewController class.</para>
          <para>This method is called by both the Dispose() method and the object finalizer (Finalize).    When invoked by the Dispose method, the parameter disposing <paramref name="disposing" /> is set to <see langword="true" /> and any managed object references that this object holds are also disposed or released;  when invoked by the object finalizer, on the finalizer thread the value is set to <see langword="false" />. </para>
          <para>Calling the Dispose method when the application is finished using the UIViewController ensures that all external resources used by this managed object are released as soon as possible.  Once developers have invoked the Dispose method, the object is no longer useful and developers should no longer make any calls to it.</para>
          <para>  For more information on how to override this method and on the Dispose/IDisposable pattern, read the ``Implementing a Dispose Method'' document at https://msdn.microsoft.com/en-us/library/fs2xkftw.aspx</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EdgesForExtendedLayout">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIRectEdge EdgesForExtendedLayout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype UIKit.UIRectEdge EdgesForExtendedLayout" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.EdgesForExtendedLayout" />
      <MemberSignature Language="F#" Value="member this.EdgesForExtendedLayout : UIKit.UIRectEdge with get, set" Usage="UIKit.UIViewController.EdgesForExtendedLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("edgesForExtendedLayout", ObjCRuntime.ArgumentSemantic.UnsafeUnretained)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setEdgesForExtendedLayout:", ObjCRuntime.ArgumentSemantic.UnsafeUnretained)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIRectEdge</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies how the <see cref="P:UIKit.UIViewController.ParentViewController" /> should extend the layout of this <see cref="T:UIKit.UIViewController" />.</summary>
        <value>The default value is <see cref="F:UIKit.UIRectEdge.All" />.</value>
        <remarks>
          <para>Prior to iOS 7, the <see cref="P:UIKit.UIViewController.View" /> did not visually underlap parent elements such as the status bar, navigation bar, or toolbar. In iOS 7, it typically should.</para>
          <para>The <see cref="P:UIKit.UIViewController.EdgesForExtendedLayout" /> specifies to the <see cref="P:UIKit.UIViewController.ParentViewController" /> how the edges of this <see cref="T:UIKit.UIViewController" /> should be extended for underlap. The default value of <see cref="F:UIKit.UIRectEdge.All" /> specifies that all edges should be extended to underlap, while <see cref="F:UIKit.UIRectEdge.None" /> specifies an extent similar to that in iOS 6 or earlier. </para>
          <para>The following image illustrates the difference: when <see cref="P:UIKit.UIViewController.EdgesForExtendedLayout" /> is set to <see cref="F:UIKit.UIRectEdge.All" />, the drawing rectangle of the underlying <see cref="T:UIKit.UIView" /> underlaps, but if <see cref="P:UIKit.UIViewController.EdgesForExtendedLayout" /> is set to <see cref="F:UIKit.UIRectEdge.None" />, the drawing rectangle is restricted to the interior.</para>
          <para>
            <img href="~/UIKit/_images/UIKit.UIViewController.EdgesForExtendedLayout.png" alt="Illustration of the layout for the EdgesForExtendedLayout values" />
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EditButtonItem">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIBarButtonItem EditButtonItem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIBarButtonItem EditButtonItem" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.EditButtonItem" />
      <MemberSignature Language="F#" Value="member this.EditButtonItem : UIKit.UIBarButtonItem" Usage="UIKit.UIViewController.EditButtonItem" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("editButtonItem")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIBarButtonItem</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A <see cref="T:UIKit.UIBarButtonItem" /> that toggles between statees "Edit" and "Done."</summary>
        <value>The standard “Edit” <see cref="T:UIKit.UIBarButtonItem" />.</value>
        <remarks>
          <para>The application developer should take the value returned by this function and apply it to one of the <see cref="T:UIKit.UIBarButtonItem" />s in the <see cref="P:UIKit.UIViewController.NavigationItem" />. The <see cref="T:UIKit.UIBarButtonItem" /> will reflect the value of the <see cref="P:UIKit.UIViewController.Editing" /> property.</para>
        </remarks>
        <altmember cref="T:UIKit.UIBarButtonItem" />
        <altmember cref="P:UIKit.UIViewController.NavigationItem" />
        <altmember cref="P:UIKit.UIViewController.Editing" />
      </Docs>
    </Member>
    <Member MemberName="Editing">
      <MemberSignature Language="C#" Value="public virtual bool Editing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Editing" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.Editing" />
      <MemberSignature Language="F#" Value="member this.Editing : bool with get, set" Usage="UIKit.UIViewController.Editing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("isEditing")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setEditing:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see langword="true" /> if the <see cref="T:UIKit.UIViewController" /> allows the application user to edit the <see cref="T:UIKit.UIView" /> contents.</summary>
        <value>
          <see langword="true" /> if in editing mode, <see langword="false" /> otherwise.</value>
        <remarks>
          <para>
            If the application developer wishes to allow editing in the <see cref="T:UIKit.UIViewController" />, they should set this value to <see langword="true" />. If the <see cref="T:UIKit.UIBarButtonItem" /> retrieved by the <see cref="P:UIKit.UIViewController.EditButtonItem" /> is visible in the <see cref="T:UIKit.UINavigationBar" />, that button’s <see cref="P:UIKit.UIBarItem.Title" /> will reflect this value.
          </para>
        </remarks>
        <altmember cref="P:UIKit.UIViewController.EditButtonItem" />
      </Docs>
    </Member>
    <Member MemberName="EncodeRestorableState">
      <MemberSignature Language="C#" Value="public virtual void EncodeRestorableState (Foundation.NSCoder coder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EncodeRestorableState(class Foundation.NSCoder coder) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.EncodeRestorableState(Foundation.NSCoder)" />
      <MemberSignature Language="F#" Value="abstract member EncodeRestorableState : Foundation.NSCoder -&gt; unit&#xA;override this.EncodeRestorableState : Foundation.NSCoder -&gt; unit" Usage="uIViewController.EncodeRestorableState coder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("encodeRestorableStateWithCoder:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="coder" Type="Foundation.NSCoder" />
      </Parameters>
      <Docs>
        <param name="coder">The <see cref="T:Foundation.NSCoder" /> that encodes the state of the application.</param>
        <summary>With <see cref="M:UIKit.UIViewController.DecodeRestorableState(Foundation.NSCoder)" />, allows custom state restoration.</summary>
        <remarks>
          <para>
            In applications that supports state restoration, this function and <see cref="M:UIKit.UIViewController.DecodeRestorableState(Foundation.NSCoder)" /> may be used to supplement standard state encoding and decoding. If <see cref="M:UIKit.UIViewController.DecodeRestorableState(Foundation.NSCoder)" /> calls <c>base.DecodeRestorableState(coder)</c>, this function should call <c>base.EncodeRestorableState(coder)</c>.
          </para>
        </remarks>
        <altmember cref="M:UIKit.UIViewController.DecodeReusableState" />
      </Docs>
    </Member>
    <Member MemberName="EncodeTo">
      <MemberSignature Language="C#" Value="public virtual void EncodeTo (Foundation.NSCoder encoder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EncodeTo(class Foundation.NSCoder encoder) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.EncodeTo(Foundation.NSCoder)" />
      <MemberSignature Language="F#" Value="abstract member EncodeTo : Foundation.NSCoder -&gt; unit&#xA;override this.EncodeTo : Foundation.NSCoder -&gt; unit" Usage="uIViewController.EncodeTo encoder" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Foundation.INSCoding.EncodeTo(Foundation.NSCoder)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("encodeWithCoder:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="encoder" Type="Foundation.NSCoder" />
      </Parameters>
      <Docs>
        <param name="encoder">The encoder object where the state of the object will be stored</param>
        <summary>Encodes the state of the object on the provided encoder</summary>
        <remarks>
          <para>This method is part of the <see cref="T:Foundation.NSCoding" /> protocol and is used by applications to preserve the state of the object into an archive.</para>
          <para>Users will typically create a <see cref="T:Foundation.NSKeyedArchiver" /> and then invoke the <see cref="M:Foundation.NSKeyedArchiver.ArchiveRootObjectToFile(Foundation.NSObject,System.String)" /> which will call into this method</para>
          <para>If developers want to allow their object to be archived, they should override this method and store their state in using the provided <paramref name="encoder" /> parameter.   In addition, developers should also implement a constructor that takes an NSCoder argument and is exported with [Export ("initWithCoder:")]</para>
          <example>
            <code lang="csharp lang-csharp"><![CDATA[public void override EncodeTo (NSCoder coder){
    coder.Encode (1, key: "version");
    coder.Encode (userName, key: "userName");
    coder.Encode (hostName, key: "hostName");]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndAppearanceTransition">
      <MemberSignature Language="C#" Value="public virtual void EndAppearanceTransition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndAppearanceTransition() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.EndAppearanceTransition" />
      <MemberSignature Language="F#" Value="abstract member EndAppearanceTransition : unit -&gt; unit&#xA;override this.EndAppearanceTransition : unit -&gt; unit" Usage="uIViewController.EndAppearanceTransition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("endAppearanceTransition")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>With <see cref="M:UIKit.UIViewController.BeginAppearanceTransition(System.Boolean,System.Boolean)" />, tells child <see cref="T:UIKit.UIViewController" />s that their child views have just appeared or disappeared.</summary>
        <remarks>
          <para>
            This method, along with <see cref="M:UIKit.UIViewController.BeginAppearanceTransition(System.Boolean,System.Boolean)" />, should be used to alert child <see cref="T:UIKit.UIViewController" />s that their view or views are about to be shown or hidden. The application developer must invoke these methods and must not call <see cref="M:UIKit.UIViewController.ViewWillAppear(System.Boolean)" />, <see cref="M:UIKit.UIViewController.ViewDidAppear(System.Boolean)" />, <see cref="M:UIKit.UIViewController.ViewWillDisappear(System.Boolean)" />, or <see cref="M:UIKit.UIViewController.ViewDidDisappear(System.Boolean)" /> directly.
          </para>
          <para>
            The following code, from the “Media Notes” sample, demonstrates the use of <see cref="M:UIKit.UIViewController.BeginAppearanceTransition(System.Boolean,System.Boolean)" /> and <see cref="M:UIKit.UIViewController.EndAppearanceTransition" />. The code snippet shows the child <see cref="T:UIKit.UIViewController" /> being removed from the display (<paramref name="isAppearing" /> is <see langword="false" />) in an animated mirror (<paramref name="animated" /> is <see langword="true" />). The call to <see cref="M:UIKit.UIViewController.BeginAppearanceTransition(System.Boolean,System.Boolean)" /> occurs and then <see cref="M:UIKit.UIViewController.EndAppearanceTransition" /> is called at the end of the specified animation.
          </para>
          <example>
            <code lang="csharp lang-csharp"><![CDATA[
commentViewIsVisible = false;
commentViewController.WillMoveToParentViewController (null);
commentViewController.BeginAppearanceTransition (false, true);
UIView.Animate (0.5f, () => {
    commentView.Alpha = 0.5f;
}, () => { 
    commentView.RemoveFromSuperview ();
    commentViewController.EndAppearanceTransition ();
    commentViewController.RemoveFromParentViewController ();
});
]]></code>
          </example>
        </remarks>
        <altmember cref="M:UIKit.UIViewController.EndAppearanceTransition" />
        <related type="sample" href="https://github.com/xamarin/ios-samples/tree/master/MediaNotes">Media Notes</related>
      </Docs>
    </Member>
    <Member MemberName="ExtendedLayoutIncludesOpaqueBars">
      <MemberSignature Language="C#" Value="public virtual bool ExtendedLayoutIncludesOpaqueBars { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExtendedLayoutIncludesOpaqueBars" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.ExtendedLayoutIncludesOpaqueBars" />
      <MemberSignature Language="F#" Value="member this.ExtendedLayoutIncludesOpaqueBars : bool with get, set" Usage="UIKit.UIViewController.ExtendedLayoutIncludesOpaqueBars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("extendedLayoutIncludesOpaqueBars")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setExtendedLayoutIncludesOpaqueBars:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether the extended layout includes opaque bars.</summary>
        <value>Returns a Boolean regarding whether or not opaque bars are being included in the extended layout. </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExtensionContext">
      <MemberSignature Language="C#" Value="public virtual Foundation.NSExtensionContext ExtensionContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Foundation.NSExtensionContext ExtensionContext" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.ExtensionContext" />
      <MemberSignature Language="F#" Value="member this.ExtensionContext : Foundation.NSExtensionContext" Usage="UIKit.UIViewController.ExtensionContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("extensionContext")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSExtensionContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the <see cref="T:Foundation.NSExtensionContext" /> for this view controller.</summary>
        <value>If there is no extension context for the current view controller, the system walks up the hierarchy in search of a parent view controller that has a non- <see langword="null" /> ExtensionContext value.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusItemContainer">
      <MemberSignature Language="C#" Value="public virtual UIKit.IUIFocusItemContainer FocusItemContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.IUIFocusItemContainer FocusItemContainer" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.FocusItemContainer" />
      <MemberSignature Language="F#" Value="member this.FocusItemContainer : UIKit.IUIFocusItemContainer" Usage="UIKit.UIViewController.FocusItemContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 12, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 12, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("focusItemContainer")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 12, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 12, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.IUIFocusItemContainer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the container for the focus envirnoment's children.</summary>
        <value>The container for the focus envirnoment's children.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAllowedChildViewControllersForUnwinding">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIViewController[] GetAllowedChildViewControllersForUnwinding (UIKit.UIStoryboardUnwindSegueSource segueSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class UIKit.UIViewController[] GetAllowedChildViewControllersForUnwinding(class UIKit.UIStoryboardUnwindSegueSource segueSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.GetAllowedChildViewControllersForUnwinding(UIKit.UIStoryboardUnwindSegueSource)" />
      <MemberSignature Language="F#" Value="abstract member GetAllowedChildViewControllersForUnwinding : UIKit.UIStoryboardUnwindSegueSource -&gt; UIKit.UIViewController[]&#xA;override this.GetAllowedChildViewControllersForUnwinding : UIKit.UIStoryboardUnwindSegueSource -&gt; UIKit.UIViewController[]" Usage="uIViewController.GetAllowedChildViewControllersForUnwinding segueSource" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("allowedChildViewControllersForUnwindingFromSource:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIViewController[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="segueSource" Type="UIKit.UIStoryboardUnwindSegueSource" />
      </Parameters>
      <Docs>
        <param name="segueSource">The <see cref="T:UIKit.UIStoryboardUnwindSegueSource" /> of the unwind segue.</param>
        <summary>The array of child <see cref="T:UIKit.UIViewController" /> objects that should be searched to determine if they are the unwind segue destination.</summary>
        <returns>A subset of <see cref="P:UIKit.UIViewController.ChildViewControllers" />, ordered by desired search order, and without the controller returned by <see cref="M:UIKit.UIViewController.GetChildViewControllerContainingSegueSource(UIKit.UIStoryboardUnwindSegueSource)" />.</returns>
        <remarks>
          <para>When searching for the destination <see cref="T:UIKit.UIViewController" /> of an unwind segue, the operating system climbs up the <see cref="T:UIKit.UIViewController" /> hierarchy using <see cref="P:UIKit.UIViewController.ParentViewController" /> and <see cref="P:UIKit.UIViewController.PresentingViewController" />, and then searches down the tree using <see cref="M:UIKit.UIViewController.GetAllowedChildViewControllersForUnwinding(UIKit.UIStoryboardUnwindSegueSource)" />, and <see cref="M:UIKit.UIViewController.CanPerformUnwind(ObjCRuntime.Selector,UIKit.UIViewController,Foundation.NSObject)" /> to determine the destination of the unwind segue.</para>
          <para>Developers can override this method to filter or change the order of the <see cref="P:UIKit.UIViewController.ChildViewControllers" />. View controllers are searched in the order of the returned array. The returned array should not contain the <see cref="T:UIKit.UIViewController" /> returned by <see cref="M:UIKit.UIViewController.GetChildViewControllerContainingSegueSource(UIKit.UIStoryboardUnwindSegueSource)" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChildViewControllerContainingSegueSource">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIViewController GetChildViewControllerContainingSegueSource (UIKit.UIStoryboardUnwindSegueSource segueSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class UIKit.UIViewController GetChildViewControllerContainingSegueSource(class UIKit.UIStoryboardUnwindSegueSource segueSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.GetChildViewControllerContainingSegueSource(UIKit.UIStoryboardUnwindSegueSource)" />
      <MemberSignature Language="F#" Value="abstract member GetChildViewControllerContainingSegueSource : UIKit.UIStoryboardUnwindSegueSource -&gt; UIKit.UIViewController&#xA;override this.GetChildViewControllerContainingSegueSource : UIKit.UIStoryboardUnwindSegueSource -&gt; UIKit.UIViewController" Usage="uIViewController.GetChildViewControllerContainingSegueSource segueSource" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("childViewControllerContainingSegueSource:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIViewController</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="segueSource" Type="UIKit.UIStoryboardUnwindSegueSource" />
      </Parameters>
      <Docs>
        <param name="segueSource">To be added.</param>
        <summary>The child <see cref="T:UIKit.UIViewController" /> that is the source of the unwind segue.</summary>
        <returns>To be added.</returns>
        <remarks>This method is typically called by <see cref="M:UIKit.UIViewController.GetAllowedChildViewControllersForUnwinding(UIKit.UIStoryboardUnwindSegueSource)" /> to determine which of the <see cref="P:UIKit.UIViewController.ChildViewControllers" /> should be filtered out of the array returned by that method.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.GetEnumerator" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="uIViewController.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.IteratorStateMachine(typeof(UIKit.UIViewController/&lt;GetEnumerator&gt;d__4))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns an enumerator that lists all of the child <see cref="T:UIKit.UIView" />s</summary>
        <returns>An <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=System%20Collections%20IEnumerator&amp;scope=Xamarin" title="T:System.Collections.IEnumerator">T:System.Collections.IEnumerator</a></format> of the <see cref="T:UIKit.UIView" />s that are children of this <see cref="T:UIKit.UIViewController" />.</returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOverrideTraitCollectionForChildViewController">
      <MemberSignature Language="C#" Value="public virtual UIKit.UITraitCollection GetOverrideTraitCollectionForChildViewController (UIKit.UIViewController childViewController);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class UIKit.UITraitCollection GetOverrideTraitCollectionForChildViewController(class UIKit.UIViewController childViewController) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.GetOverrideTraitCollectionForChildViewController(UIKit.UIViewController)" />
      <MemberSignature Language="F#" Value="abstract member GetOverrideTraitCollectionForChildViewController : UIKit.UIViewController -&gt; UIKit.UITraitCollection&#xA;override this.GetOverrideTraitCollectionForChildViewController : UIKit.UIViewController -&gt; UIKit.UITraitCollection" Usage="uIViewController.GetOverrideTraitCollectionForChildViewController childViewController" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("overrideTraitCollectionForChildViewController:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UITraitCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="childViewController" Type="UIKit.UIViewController" />
      </Parameters>
      <Docs>
        <param name="childViewController">Array of  view controllers that are children of the receiver in a view controller hierarchy.</param>
        <summary>Gets the <see cref="T:UIKit.UITraitCollection" /> for the specified child view controller of this controller.</summary>
        <returns>Gets the specified child view controller.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSegueForUnwinding">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIStoryboardSegue GetSegueForUnwinding (UIKit.UIViewController toViewController, UIKit.UIViewController fromViewController, string identifier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class UIKit.UIStoryboardSegue GetSegueForUnwinding(class UIKit.UIViewController toViewController, class UIKit.UIViewController fromViewController, string identifier) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.GetSegueForUnwinding(UIKit.UIViewController,UIKit.UIViewController,System.String)" />
      <MemberSignature Language="F#" Value="abstract member GetSegueForUnwinding : UIKit.UIViewController * UIKit.UIViewController * string -&gt; UIKit.UIStoryboardSegue&#xA;override this.GetSegueForUnwinding : UIKit.UIViewController * UIKit.UIViewController * string -&gt; UIKit.UIStoryboardSegue" Usage="uIViewController.GetSegueForUnwinding (toViewController, fromViewController, identifier)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("segueForUnwindingToViewController:fromViewController:identifier:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIStoryboardSegue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toViewController" Type="UIKit.UIViewController" />
        <Parameter Name="fromViewController" Type="UIKit.UIViewController" />
        <Parameter Name="identifier" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="toViewController">The <see cref="T:UIKit.UIViewController" /> at which the segue will end.</param>
        <param name="fromViewController">The <see cref="T:UIKit.UIViewController" /> at which the segue began.</param>
        <param name="identifier">The segue’s identifier.</param>
        <summary>Defines the segue to be used between two <see cref="T:UIKit.UIViewController" />s.</summary>
        <returns>The segue to be used.</returns>
        <remarks>
          <para>Application developers that create custom <see cref="T:UIKit.UIViewController" />s that use segue unwinding must implement this method. This method should instantiate and return a <see cref="T:UIKit.UIStoryboardSegue" /> that performs the appropriate animations and application state-manipulation for the specified unwinding.</para>
        </remarks>
        <altmember cref="T:UIKit.UIStoryboardSegue" />
      </Docs>
    </Member>
    <Member MemberName="GetSizeForChildContentContainer">
      <MemberSignature Language="C#" Value="public virtual CoreGraphics.CGSize GetSizeForChildContentContainer (UIKit.IUIContentContainer contentContainer, CoreGraphics.CGSize parentContainerSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype CoreGraphics.CGSize GetSizeForChildContentContainer(class UIKit.IUIContentContainer contentContainer, valuetype CoreGraphics.CGSize parentContainerSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.GetSizeForChildContentContainer(UIKit.IUIContentContainer,CoreGraphics.CGSize)" />
      <MemberSignature Language="F#" Value="abstract member GetSizeForChildContentContainer : UIKit.IUIContentContainer * CoreGraphics.CGSize -&gt; CoreGraphics.CGSize&#xA;override this.GetSizeForChildContentContainer : UIKit.IUIContentContainer * CoreGraphics.CGSize -&gt; CoreGraphics.CGSize" Usage="uIViewController.GetSizeForChildContentContainer (contentContainer, parentContainerSize)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:UIKit.IUIContentContainer.GetSizeForChildContentContainer(UIKit.IUIContentContainer,CoreGraphics.CGSize)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("sizeForChildContentContainer:withParentContainerSize:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>CoreGraphics.CGSize</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="contentContainer" Type="UIKit.IUIContentContainer" />
        <Parameter Name="parentContainerSize" Type="CoreGraphics.CGSize" />
      </Parameters>
      <Docs>
        <param name="contentContainer">The child container whose size is being request.</param>
        <param name="parentContainerSize">The <see cref="T:System.Drawing.SizeF" /> of the <paramref name="contentContainer" />.</param>
        <summary>Gets the size of the content of the specified child <see cref="T:UIKit.IUIContentContainer" /> by using the size of the parent container.</summary>
        <returns>The <see cref="T:System.Drawing.SizeF" /> of the content of the <paramref name="contentContainer" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSupportedInterfaceOrientations">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIInterfaceOrientationMask GetSupportedInterfaceOrientations ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype UIKit.UIInterfaceOrientationMask GetSupportedInterfaceOrientations() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.GetSupportedInterfaceOrientations" />
      <MemberSignature Language="F#" Value="abstract member GetSupportedInterfaceOrientations : unit -&gt; UIKit.UIInterfaceOrientationMask&#xA;override this.GetSupportedInterfaceOrientations : unit -&gt; UIKit.UIInterfaceOrientationMask" Usage="uIViewController.GetSupportedInterfaceOrientations " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("supportedInterfaceOrientations")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIInterfaceOrientationMask</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>The orientations supported by this <see cref="T:UIKit.UIViewController" />.</summary>
        <returns>A <see cref="T:UIKit.UIInterfaceOrientationMask" /> of the orientations supported by this <see cref="T:UIKit.UIViewController" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:UIKit.UIInterfaceOrientationMask" />
      </Docs>
    </Member>
    <Member MemberName="GetTargetViewControllerForAction">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIViewController GetTargetViewControllerForAction (ObjCRuntime.Selector action, Foundation.NSObject sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class UIKit.UIViewController GetTargetViewControllerForAction(class ObjCRuntime.Selector action, class Foundation.NSObject sender) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.GetTargetViewControllerForAction(ObjCRuntime.Selector,Foundation.NSObject)" />
      <MemberSignature Language="F#" Value="abstract member GetTargetViewControllerForAction : ObjCRuntime.Selector * Foundation.NSObject -&gt; UIKit.UIViewController&#xA;override this.GetTargetViewControllerForAction : ObjCRuntime.Selector * Foundation.NSObject -&gt; UIKit.UIViewController" Usage="uIViewController.GetTargetViewControllerForAction (action, sender)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("targetViewControllerForAction:sender:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIViewController</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="ObjCRuntime.Selector" />
        <Parameter Name="sender" Type="Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="action">Specified action.</param>
        <param name="sender">
          <para>The object that sent the action.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Gets the view controller for the specified action and sender.</summary>
        <returns>The view controller that responds to the action.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetViewControllerForUnwind">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIViewController GetViewControllerForUnwind (ObjCRuntime.Selector segueAction, UIKit.UIViewController fromViewController, Foundation.NSObject sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class UIKit.UIViewController GetViewControllerForUnwind(class ObjCRuntime.Selector segueAction, class UIKit.UIViewController fromViewController, class Foundation.NSObject sender) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.GetViewControllerForUnwind(ObjCRuntime.Selector,UIKit.UIViewController,Foundation.NSObject)" />
      <MemberSignature Language="F#" Value="abstract member GetViewControllerForUnwind : ObjCRuntime.Selector * UIKit.UIViewController * Foundation.NSObject -&gt; UIKit.UIViewController&#xA;override this.GetViewControllerForUnwind : ObjCRuntime.Selector * UIKit.UIViewController * Foundation.NSObject -&gt; UIKit.UIViewController" Usage="uIViewController.GetViewControllerForUnwind (segueAction, fromViewController, sender)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("viewControllerForUnwindSegueAction:fromViewController:withSender:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIViewController</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="segueAction" Type="ObjCRuntime.Selector" />
        <Parameter Name="fromViewController" Type="UIKit.UIViewController" />
        <Parameter Name="sender" Type="Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="segueAction">The initiating action.</param>
        <param name="fromViewController">The initial <see cref="T:UIKit.UIViewController" />.</param>
        <param name="sender">The initiating object.</param>
        <summary>Used for searching child <see cref="T:UIKit.UIViewController" />s for a specific unwind segue.</summary>
        <returns>The appropriate <see cref="T:UIKit.UIViewController" /> from amongst the <see cref="P:UIKit.UIViewController.ChildViewControllers" /> or, if none are appropriate, <c>base.GetViewControllerForUnwind(segueAction, fromViewController,sender);</c>.</returns>
        <remarks>
          <para>A custom contain <see cref="T:UIKit.UIViewController" /> should override this method and call <see cref="M:UIKit.UIViewController.CanPerformUnwind(ObjCRuntime.Selector,UIKit.UIViewController,Foundation.NSObject)" /> on the <see cref="T:UIKit.UIViewController" />s returned by the <see cref="P:UIKit.UIViewController.ChildViewControllers" /> property. If none return <see langword="true" />, the application developer should return the value <c>base.GetViewControllerForUnwind(segueAction,fromViewController,sender);</c>.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HidesBottomBarWhenPushed">
      <MemberSignature Language="C#" Value="public virtual bool HidesBottomBarWhenPushed { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HidesBottomBarWhenPushed" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.HidesBottomBarWhenPushed" />
      <MemberSignature Language="F#" Value="member this.HidesBottomBarWhenPushed : bool with get, set" Usage="UIKit.UIViewController.HidesBottomBarWhenPushed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("hidesBottomBarWhenPushed")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setHidesBottomBarWhenPushed:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies whether the toolbar should be visible when this <see cref="T:UIKit.UIViewController" /> is pushed onto a <see cref="T:UIKit.UINavigationController" />.</summary>
        <value>
          <see langword="true" /> if the toolbar should be hidden, <see langword="false" /> if it should be visible.</value>
        <remarks>
          <para>When a <see cref="T:UIKit.UIViewController" /> is a child to a <see cref="T:UIKit.UINavigationController" />, it may display a toolbar at the bottom of the screen. If that is not the desired behavior, the application developer should set this property to <see langword="true" />. 
          </para>
          <para>If a <see cref="T:UIKit.UIViewController" /> sets this to <see langword="true" />, the toolbar remains hidden until the <see cref="T:UIKit.UIViewController" /> is popped from the stack. This will effect other <see cref="T:UIKit.UIViewController" />s that are currently visible.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HierarchyInconsistencyException">
      <MemberSignature Language="C#" Value="public static Foundation.NSString HierarchyInconsistencyException { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString HierarchyInconsistencyException" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.HierarchyInconsistencyException" />
      <MemberSignature Language="F#" Value="member this.HierarchyInconsistencyException : Foundation.NSString" Usage="UIKit.UIViewController.HierarchyInconsistencyException" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIViewControllerHierarchyInconsistencyException", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Constant used to identify broken <see cref="T:UIKit.UIViewController" /> hierarchies.</summary>
        <value>To be added.</value>
        <remarks>
          <para>This identifier is used to identify the exception thrown when a <see cref="T:UIKit.UIView" /> is added to the <see cref="T:UIKit.UIView" /> hierarchy, but that <see cref="T:UIKit.UIView" />'s <see cref="T:UIKit.UIViewController" /> is not part of the <see cref="T:UIKit.UIViewController" /> hierarchy. In other words, the <see cref="T:UIKit.UIView" /> hierarchy and <see cref="T:UIKit.UIViewController" /> hierarchy must be consistent.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InterfaceOrientation">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIInterfaceOrientation InterfaceOrientation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype UIKit.UIInterfaceOrientation InterfaceOrientation" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.InterfaceOrientation" />
      <MemberSignature Language="F#" Value="member this.InterfaceOrientation : UIKit.UIInterfaceOrientation" Usage="UIKit.UIViewController.InterfaceOrientation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, "Use Adaptive View Controllers instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("interfaceOrientation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, "Use Adaptive View Controllers instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIInterfaceOrientation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The current orientation of the interface.</summary>
        <value>The current <see cref="T:UIKit.UIInterfaceOrientation" /> of the device.</value>
        <remarks>
          <para>This value represents the rotation of the interface necessary to keep the interface upright. </para>
          <para>Note that in portrait modes, the <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=UIKit%20UIView%20Controller%20UIInterface%20Orientation&amp;scope=Xamarin" title="P:UIKit.UIViewController.UIInterfaceOrientation">P:UIKit.UIViewController.UIInterfaceOrientation</a></format> will be the opposite of the <see cref="P:UIKit.UIDevice.Orientation" />. For example, if the device is rotated clockwise from upright so that it is in portrait mode with the home button on the left, the value of the <see cref="T:UIKit.UIInterfaceOrientation" /> will be <see cref="F:UIKit.UIInterfaceOrientation.LandscapeLeft" /> but the value of <see cref="P:UIKit.UIDevice.Orientation" /> will be <see cref="F:UIKit.UIDeviceOrientation.LandscapeRight" />.</para>
        </remarks>
        <altmember cref="P:UIKit.UIDevice.Orientation" />
      </Docs>
    </Member>
    <Member MemberName="IsBeingDismissed">
      <MemberSignature Language="C#" Value="public virtual bool IsBeingDismissed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBeingDismissed" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.IsBeingDismissed" />
      <MemberSignature Language="F#" Value="member this.IsBeingDismissed : bool" Usage="UIKit.UIViewController.IsBeingDismissed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("isBeingDismissed")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see langword="true" /> if the current <see cref="T:UIKit.UIViewController" /> is in the process of being dismissed.</summary>
        <value>
          <see langword="true" /> only if called during the execution of <see cref="M:UIKit.UIViewController.ViewWillDisappear(System.Boolean)" /> or <see cref="M:UIKit.UIViewController.ViewDidDisappear(System.Boolean)" /></value>
        <remarks>
          <para>The dismissal process is bookended by the functions <see cref="M:UIKit.UIViewController.ViewWillDisappear(System.Boolean)" /> and <see cref="M:UIKit.UIViewController.ViewDidDisappear(System.Boolean)" />. While those are executing, this property will return <see langword="true" />, at all other times, it will return <see langword="false" />.</para>
        </remarks>
        <altmember cref="M:UIKit.UIViewController.ViewWillDisappear" />
        <altmember cref="M:UIKit.UIViewController.ViewDidDisappear" />
      </Docs>
    </Member>
    <Member MemberName="IsBeingPresented">
      <MemberSignature Language="C#" Value="public virtual bool IsBeingPresented { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBeingPresented" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.IsBeingPresented" />
      <MemberSignature Language="F#" Value="member this.IsBeingPresented : bool" Usage="UIKit.UIViewController.IsBeingPresented" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("isBeingPresented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see langword="true" /> if the current <see cref="T:UIKit.UIViewController" /> is in the process of being presented.</summary>
        <value>
          <see langword="true" /> only if called during the execution of <see cref="M:UIKit.UIViewController.ViewWillAppear(System.Boolean)" /> or <see cref="M:UIKit.UIViewController.ViewDidAppear(System.Boolean)" />.</value>
        <remarks>
          <para>The presentation process is bookended by the functions <see cref="M:UIKit.UIViewController.ViewWillAppear(System.Boolean)" /> and <see cref="M:UIKit.UIViewController.ViewDidAppear(System.Boolean)" />. While those are executing, this property will return <see langword="true" />, at all other times, it will return <see langword="false" />.</para>
        </remarks>
        <altmember cref="M:UIKit.UIViewController.ViewWillAppear" />
        <altmember cref="M:UIKit.UIViewController.ViewDidAppear" />
        <altmember cref="P:UIKit.UIViewController.IsMovingToParentViewController" />
      </Docs>
    </Member>
    <Member MemberName="IsMovingFromParentViewController">
      <MemberSignature Language="C#" Value="public virtual bool IsMovingFromParentViewController { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMovingFromParentViewController" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.IsMovingFromParentViewController" />
      <MemberSignature Language="F#" Value="member this.IsMovingFromParentViewController : bool" Usage="UIKit.UIViewController.IsMovingFromParentViewController" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("isMovingFromParentViewController")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see langword="true" /> if the current <see cref="T:UIKit.UIViewController" /> is in the process of being removed from its parent <see cref="T:UIKit.UIViewController" />.</summary>
        <value>
          <see langword="true" /> only if called during the execution of <see cref="M:UIKit.UIViewController.ViewWillDisappear(System.Boolean)" /> or <see cref="M:UIKit.UIViewController.ViewDidDisappear(System.Boolean)" />.</value>
        <remarks>
          <para>The process of removing a <see cref="T:UIKit.UIViewController" /> from its parent <see cref="T:UIKit.UIViewController" /> is bookended by the functions <see cref="M:UIKit.UIViewController.ViewWillDisappear(System.Boolean)" /> and <see cref="M:UIKit.UIViewController.ViewDidDisappear(System.Boolean)" />. While those are executing, this property will return <see langword="true" />, at all other times, it will return <see langword="false" />.</para>
        </remarks>
        <altmember cref="M:UIKit.UIViewController.ViewWillDisappear" />
        <altmember cref="M:UIKit.UIViewController.ViewDidDisappear" />
        <altmember cref="M:UIKit.UIViewController.RemoveFromParentViewController" />
      </Docs>
    </Member>
    <Member MemberName="IsMovingToParentViewController">
      <MemberSignature Language="C#" Value="public virtual bool IsMovingToParentViewController { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMovingToParentViewController" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.IsMovingToParentViewController" />
      <MemberSignature Language="F#" Value="member this.IsMovingToParentViewController : bool" Usage="UIKit.UIViewController.IsMovingToParentViewController" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("isMovingToParentViewController")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see langword="true" /> if the current <see cref="T:UIKit.UIViewController" /> is in the process of being added to a parent <see cref="T:UIKit.UIViewController" />.</summary>
        <value>
          <see langword="true" /> only if called during the execution of <see cref="M:UIKit.UIViewController.ViewWillAppear(System.Boolean)" /> or <see cref="M:UIKit.UIViewController.ViewDidAppear(System.Boolean)" />.</value>
        <remarks>
          <para>The process of adding a <see cref="T:UIKit.UIViewController" /> to a parent <see cref="T:UIKit.UIViewController" /> is bookended by the functions <see cref="M:UIKit.UIViewController.ViewWillAppear(System.Boolean)" /> and <see cref="M:UIKit.UIViewController.ViewDidAppear(System.Boolean)" />. While those are executing, this property will return <see langword="true" />, at all other times, it will return <see langword="false" />.</para>
        </remarks>
        <altmember cref="M:UIKit.UIViewController.ViewDidAppear" />
        <altmember cref="M:UIKit.UIViewController.ViewDidDisappear" />
        <altmember cref="P:UIKit.UIViewController.IsBeingPresented" />
      </Docs>
    </Member>
    <Member MemberName="IsViewLoaded">
      <MemberSignature Language="C#" Value="public virtual bool IsViewLoaded { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsViewLoaded" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.IsViewLoaded" />
      <MemberSignature Language="F#" Value="member this.IsViewLoaded : bool" Usage="UIKit.UIViewController.IsViewLoaded" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("isViewLoaded")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A <see cref="T:System.Boolean" /> indicating whether the <see cref="P:UIKit.UIViewController.View" /> is loaded into memory.</summary>
        <value>
          <see langword="true" /> if the <see cref="P:UIKit.UIViewController.View" /> is currently loaded into memory.</value>
        <remarks>
          <para>
            The <see cref="P:UIKit.UIViewController.View" /> property may be lazily loaded into memory when accessed. This function may be used to determine if that loading has already taken place. 
          </para>
        </remarks>
        <altmember cref="P:UIKit.UIViewController.View" />
        <altmember cref="M:UIKit.UIViewController.LoadView" />
      </Docs>
    </Member>
    <Member MemberName="LoadView">
      <MemberSignature Language="C#" Value="public virtual void LoadView ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void LoadView() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.LoadView" />
      <MemberSignature Language="F#" Value="abstract member LoadView : unit -&gt; unit&#xA;override this.LoadView : unit -&gt; unit" Usage="uIViewController.LoadView " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("loadView")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Initializes the <see cref="P:UIKit.UIViewController.View" /> property.</summary>
        <remarks>
          <para>
            This method should not be called directly. It is called when the <see cref="P:UIKit.UIViewController.View" /> property is accessed and lazily initialized. Generally, the appropriate <see cref="T:UIKit.UIView" /> will be loaded from a nib file, but application developers may override it to create a custom <see cref="T:UIKit.UIView" />. This method should not be overridden to provide general initialization on loading a view, that belongs in the <see cref="M:UIKit.UIViewController.ViewDidLoad" /> method.         </para>
          <block subset="none" type="overrides">
            <list type="bullet">
              <item>
                <term>Overriders who create a custom <see cref="T:UIKit.UIView" /> should not call <c>base.LoadView()</c>.</term>
              </item>
              <item>
                <term>Overriders should assign the custom <see cref="T:UIKit.UIView" /> to the <see cref="P:UIKit.UIViewController.View" /> property.</term>
              </item>
              <item>
                <term>The <see cref="T:UIKit.UIView" />s created by this method must not be shared with other <see cref="T:UIKit.UIViewController" />s. </term>
              </item>
            </list>
          </block>
        </remarks>
        <altmember cref="P:UIKit.UIViewController.IsViewLoaded" />
        <altmember cref="M:UIKit.UIViewController.ViewDidLoad" />
        <altmember cref="P:UIKit.UIViewController.View" />
        <altmember cref="M:UIKit.UIViewController.LoadViewIfNeeded" />
      </Docs>
    </Member>
    <Member MemberName="LoadViewIfNeeded">
      <MemberSignature Language="C#" Value="public virtual void LoadViewIfNeeded ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void LoadViewIfNeeded() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.LoadViewIfNeeded" />
      <MemberSignature Language="F#" Value="abstract member LoadViewIfNeeded : unit -&gt; unit&#xA;override this.LoadViewIfNeeded : unit -&gt; unit" Usage="uIViewController.LoadViewIfNeeded " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("loadViewIfNeeded")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>If necessary, synchronously loads the <see cref="P:UIKit.UIViewController.View" /> from a Storyboard or NIB.</summary>
        <remarks>
          <para>This method can be used to ensure that the <see cref="P:UIKit.UIViewController.View" /> object has been instantiated, if the <see cref="T:UIKit.UIViewController" /> has an associated Storyboard or NIB. (See also <see cref="P:UIKit.UIViewController.ViewIfLoaded" />.)</para>
          <example>
            <code lang="csharp lang-csharp"><![CDATA[
var newVC = UIStoryboard.FromName("Main", NSBundle.MainBundle).InstantiateInitialViewController();
if (newVC.ViewIfLoaded == null)
{
    //This call blocks until the View is instantiated
    newVC.LoadViewIfNeeded();
}
    ]]></code>
          </example>
        </remarks>
        <altmember cref="P:UIKit.UIViewController.IsViewLoaded" />
        <altmember cref="M:UIKit.UIViewController.ViewDidLoad" />
        <altmember cref="P:UIKit.UIViewController.View" />
      </Docs>
    </Member>
    <Member MemberName="ModalInPopover">
      <MemberSignature Language="C#" Value="public virtual bool ModalInPopover { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ModalInPopover" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.ModalInPopover" />
      <MemberSignature Language="F#" Value="member this.ModalInPopover : bool with get, set" Usage="UIKit.UIViewController.ModalInPopover" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("isModalInPopover")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setModalInPopover:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see langword="true" /> if this <see cref="T:UIKit.UIViewController" /> should be presented modally by a <see cref="T:UIKit.UIPopoverController" />.</summary>
        <value>The default value is <see langword="false" />.</value>
        <remarks>Application developers should set this property to <see langword="true" /> if this <see cref="T:UIKit.UIViewController" /> is intended to be presented modally by a <see cref="T:UIKit.UIPopoverController" />. Setting this property to <see langword="true" /> disallows actions outside this <see cref="T:UIKit.UIViewController" /> when it is displayed.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModalPresentationCapturesStatusBarAppearance">
      <MemberSignature Language="C#" Value="public virtual bool ModalPresentationCapturesStatusBarAppearance { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ModalPresentationCapturesStatusBarAppearance" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.ModalPresentationCapturesStatusBarAppearance" />
      <MemberSignature Language="F#" Value="member this.ModalPresentationCapturesStatusBarAppearance : bool with get, set" Usage="UIKit.UIViewController.ModalPresentationCapturesStatusBarAppearance" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("modalPresentationCapturesStatusBarAppearance")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setModalPresentationCapturesStatusBarAppearance:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether the UIViewController, when presented modally but non-fullscreen, takes over control of the status bar.</summary>
        <value>Boolean indicating whether the modal view controller takes over control of the status bar.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModalPresentationStyle">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIModalPresentationStyle ModalPresentationStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype UIKit.UIModalPresentationStyle ModalPresentationStyle" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.ModalPresentationStyle" />
      <MemberSignature Language="F#" Value="member this.ModalPresentationStyle : UIKit.UIModalPresentationStyle with get, set" Usage="UIKit.UIViewController.ModalPresentationStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("modalPresentationStyle", ObjCRuntime.ArgumentSemantic.UnsafeUnretained)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setModalPresentationStyle:", ObjCRuntime.ArgumentSemantic.UnsafeUnretained)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIModalPresentationStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The <see cref="T:UIKit.UIModalPresentationStyle" /> to be used when presenting <see cref="T:UIKit.UIViewController" />s.</summary>
        <value>The default value is <see cref="F:UIKit.UIModalPresentationStyle.FullScreen" />.</value>
        <remarks>iPhones and iTouches should always use <see cref="F:UIKit.UIModalPresentationStyle.FullScreen" />. iPads may use any value.</remarks>
        <altmember cref="T:UIKit.UIModalPresentationStyle" />
      </Docs>
    </Member>
    <Member MemberName="ModalTransitionStyle">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIModalTransitionStyle ModalTransitionStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype UIKit.UIModalTransitionStyle ModalTransitionStyle" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.ModalTransitionStyle" />
      <MemberSignature Language="F#" Value="member this.ModalTransitionStyle : UIKit.UIModalTransitionStyle with get, set" Usage="UIKit.UIViewController.ModalTransitionStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("modalTransitionStyle", ObjCRuntime.ArgumentSemantic.UnsafeUnretained)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setModalTransitionStyle:", ObjCRuntime.ArgumentSemantic.UnsafeUnretained)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIModalTransitionStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The <see cref="T:UIKit.UIModalTransitionStyle" /> to be used by <see cref="M:UIKit.UIViewController.PresentViewController(UIKit.UIViewController,System.Boolean,System.Action)" />.</summary>
        <value>The default value is <see cref="F:UIKit.UIModalTransitionStyle.CoverVertical" />.</value>
        <remarks>
          <para>
            This property specifies how <see cref="M:UIKit.UIViewController.PresentViewController(UIKit.UIViewController,System.Boolean,System.Action)" /> animates its presentation of a <see cref="T:UIKit.UIViewController" />.
          </para>
        </remarks>
        <altmember cref="T:UIKit.UIModalTransitionStyle" />
        <related type="sample" href="https://github.com/xamarin/ios-samples/tree/master/CoreImage/">Core Image Sample</related>
      </Docs>
    </Member>
    <Member MemberName="ModalViewController">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIViewController ModalViewController { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIViewController ModalViewController" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.ModalViewController" />
      <MemberSignature Language="F#" Value="member this.ModalViewController : UIKit.UIViewController" Usage="UIKit.UIViewController.ModalViewController" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, "Use 'PresentedViewController' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("modalViewController")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, "Use 'PresentedViewController' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIViewController</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Controller for the active presented view.</summary>
        <value>The active presented <see cref="T:UIKit.UIViewController" />.</value>
        <remarks>Application developers should not use this deprecated property. Instead, they should use <see cref="P:UIKit.UIViewController.PresentedViewController" />.</remarks>
        <altmember cref="P:UIKit.UIViewController.PresentedViewController" />
      </Docs>
    </Member>
    <Member MemberName="NavigationController">
      <MemberSignature Language="C#" Value="public virtual UIKit.UINavigationController NavigationController { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UINavigationController NavigationController" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.NavigationController" />
      <MemberSignature Language="F#" Value="member this.NavigationController : UIKit.UINavigationController" Usage="UIKit.UIViewController.NavigationController" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("navigationController", ObjCRuntime.ArgumentSemantic.Strong)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UINavigationController</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The nearest ancestor <see cref="T:UIKit.UINavigationController" /></summary>
        <value>The default value is <see langword="null" />.</value>
        <remarks>This function travels up the ancestore hierarchy (via <see cref="P:UIKit.UIViewController.ParentViewController" />) until it either encounters a <see cref="T:UIKit.UINavigationController" /> or finishes without finding one. It returns the <see cref="T:UIKit.UINavigationController" /> if one exists, <see langword="null" /> otherwise.</remarks>
        <related type="sample" href="https://github.com/xamarin/ios-samples/tree/master/Hello_MultiScreen_iPhone/">Hello Multiscreen iPhone Sample</related>
      </Docs>
    </Member>
    <Member MemberName="NavigationItem">
      <MemberSignature Language="C#" Value="public virtual UIKit.UINavigationItem NavigationItem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UINavigationItem NavigationItem" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.NavigationItem" />
      <MemberSignature Language="F#" Value="member this.NavigationItem : UIKit.UINavigationItem" Usage="UIKit.UIViewController.NavigationItem" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("navigationItem", ObjCRuntime.ArgumentSemantic.Strong)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UINavigationItem</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A <see cref="T:UIKit.UINavigationItem" /> that represents this <see cref="T:UIKit.UIViewController" /> in its parent’s <see cref="T:UIKit.UINavigationController" />’s <see cref="P:UIKit.UINavigationController.NavigationBar" />.</summary>
        <value>By default, the first time this property is accessed, a new <see cref="T:UIKit.UINavigationItem" /> is lazily initialized with a <see cref="P:UIKit.UINavigationItem.Title" /> set to this <see cref="T:UIKit.UIViewController" />’s <see cref="P:UIKit.UIViewController.Title" />.'</value>
        <remarks>
          <para>
            When a <see cref="T:UIKit.UIViewController" /> is a child of a <see cref="T:UIKit.UIViewController" /> that has a <see cref="T:UIKit.UINavigationController" />, the child’s <see cref="P:UIKit.UIViewController.NavigationItem" /> represents the <see cref="T:UIKit.UINavigationItem" /> in the parent’s <see cref="T:UIKit.UINavigationBar" />. The first time this property is accessed, the default behavior is to lazily initialize a <see cref="T:UIKit.UINavigationItem" />, so if the parent <see cref="T:UIKit.UIViewController" /> does not use a <see cref="T:UIKit.UINavigationBar" />, application developers should either not access or override this property.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NibBundle">
      <MemberSignature Language="C#" Value="public virtual Foundation.NSBundle NibBundle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Foundation.NSBundle NibBundle" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.NibBundle" />
      <MemberSignature Language="F#" Value="member this.NibBundle : Foundation.NSBundle" Usage="UIKit.UIViewController.NibBundle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("nibBundle", ObjCRuntime.ArgumentSemantic.Strong)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSBundle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The <see cref="T:Foundation.NSBundle" /> from which this <see cref="T:UIKit.UIViewController" /> was instantiated.</summary>
        <value>File-system values relating to the <see cref="T:Foundation.NSBundle" /> from which this <see cref="T:UIKit.UIViewController" /> was created.</value>
        <remarks>
          <para>This value will be non-<see langword="null" /> even if the <see cref="T:UIKit.UIViewController" /> was not loaded from a nib file. </para>
        </remarks>
        <altmember cref="P:UIKit.UIViewController.NibName" />
      </Docs>
    </Member>
    <Member MemberName="NibName">
      <MemberSignature Language="C#" Value="public virtual string NibName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string NibName" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.NibName" />
      <MemberSignature Language="F#" Value="member this.NibName : string" Usage="UIKit.UIViewController.NibName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("nibName", ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The name of the nib file from which this <see cref="T:UIKit.UIViewController" /> was instantiated, or <see langword="null" />.</summary>
        <value>
          <para>The default value is <see langword="null" />.</para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>
          <para>If this <see cref="T:UIKit.UIViewController" /> was instantiated from a nib file, the <see cref="P:UIKit.UIViewController.NibName" /> property will hold the name of the originating nib file.</para>
        </remarks>
        <altmember cref="P:UIKit.UIViewController.NibBundle" />
      </Docs>
    </Member>
    <Member MemberName="ParentFocusEnvironment">
      <MemberSignature Language="C#" Value="public virtual UIKit.IUIFocusEnvironment ParentFocusEnvironment { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.IUIFocusEnvironment ParentFocusEnvironment" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.ParentFocusEnvironment" />
      <MemberSignature Language="F#" Value="member this.ParentFocusEnvironment : UIKit.IUIFocusEnvironment" Usage="UIKit.UIViewController.ParentFocusEnvironment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 12, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 12, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 12, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 12, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("parentFocusEnvironment", ObjCRuntime.ArgumentSemantic.Weak)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.IUIFocusEnvironment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the focus environment that contains the current focus environment.</summary>
        <value>Tohe focus environment that contains the current focus environment.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ParentViewController">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIViewController ParentViewController { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIViewController ParentViewController" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.ParentViewController" />
      <MemberSignature Language="F#" Value="member this.ParentViewController : UIKit.UIViewController" Usage="UIKit.UIViewController.ParentViewController" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("parentViewController")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIViewController</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The <see cref="T:UIKit.UIViewController" /> that contains this <see cref="T:UIKit.UIViewController" />.</summary>
        <value>
          <para>Container <see cref="T:UIKit.UIViewController" /> that is the parent of this <see cref="T:UIKit.UIViewController" />.</para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>
          <para>Prior to iOS version 5.0, this property would return a presenting <see cref="T:UIKit.UIViewController" /> if it was being presented and was not contained in another <see cref="T:UIKit.UIViewController" />. This is no longer the case; in such a situation, the presenting <see cref="T:UIKit.UIViewController" /> will be available via <see cref="P:UIKit.UIViewController.PresentingViewController" />.</para>
        </remarks>
        <altmember cref="P:UIKit.UIViewController.PresentingViewController" />
      </Docs>
    </Member>
    <Member MemberName="PerformSegue">
      <MemberSignature Language="C#" Value="public virtual void PerformSegue (string identifier, Foundation.NSObject sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PerformSegue(string identifier, class Foundation.NSObject sender) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.PerformSegue(System.String,Foundation.NSObject)" />
      <MemberSignature Language="F#" Value="abstract member PerformSegue : string * Foundation.NSObject -&gt; unit&#xA;override this.PerformSegue : string * Foundation.NSObject -&gt; unit" Usage="uIViewController.PerformSegue (identifier, sender)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("performSegueWithIdentifier:sender:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identifier" Type="System.String" />
        <Parameter Name="sender" Type="Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="identifier">The identifier of the desired <see cref="T:UIKit.UIStoryboardSegue" />.</param>
        <param name="sender">
          <para>The object initiating the segue.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Performs the specified <see cref="T:UIKit.UIStoryboardSegue" />.</summary>
        <remarks>
          <para>
            Typically, segues are specified in the storyboard and do not require the application to directly invoke them.
          </para>
          <para>
            This method will throw an exception if the <see cref="T:UIKit.UIViewController" /> on which it is called was not loaded from a storyboard. 
          </para>
        </remarks>
        <related type="recipe" href="https://developer.xamarin.com/ios/Recipes/General/Storyboard/Storyboard_a_TableView">Storyboard a TableView</related>
      </Docs>
    </Member>
    <Member MemberName="PopoverPresentationController">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIPopoverPresentationController PopoverPresentationController { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIPopoverPresentationController PopoverPresentationController" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.PopoverPresentationController" />
      <MemberSignature Language="F#" Value="member this.PopoverPresentationController : UIKit.UIPopoverPresentationController" Usage="UIKit.UIViewController.PopoverPresentationController" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("popoverPresentationController")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIPopoverPresentationController</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the nearest ancestor in the view hierarchy that is a <see cref="T:UIKit.UIPopoverPresentationController" /> or <see langword="null" /> if there is none.</summary>
        <value>Returns the nearest ancestor that is a popover presentation controller within the specified view controller hierarchy. </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreferredContentSize">
      <MemberSignature Language="C#" Value="public virtual CoreGraphics.CGSize PreferredContentSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype CoreGraphics.CGSize PreferredContentSize" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.PreferredContentSize" />
      <MemberSignature Language="F#" Value="member this.PreferredContentSize : CoreGraphics.CGSize with get, set" Usage="UIKit.UIViewController.PreferredContentSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("preferredContentSize", ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setPreferredContentSize:", ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>CoreGraphics.CGSize</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the preferred size for the content of the container.</summary>
        <value>Used primarily when displaying a view controller’s content.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreferredContentSizeDidChangeForChildContentContainer">
      <MemberSignature Language="C#" Value="public virtual void PreferredContentSizeDidChangeForChildContentContainer (UIKit.IUIContentContainer container);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PreferredContentSizeDidChangeForChildContentContainer(class UIKit.IUIContentContainer container) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.PreferredContentSizeDidChangeForChildContentContainer(UIKit.IUIContentContainer)" />
      <MemberSignature Language="F#" Value="abstract member PreferredContentSizeDidChangeForChildContentContainer : UIKit.IUIContentContainer -&gt; unit&#xA;override this.PreferredContentSizeDidChangeForChildContentContainer : UIKit.IUIContentContainer -&gt; unit" Usage="uIViewController.PreferredContentSizeDidChangeForChildContentContainer container" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:UIKit.IUIContentContainer.PreferredContentSizeDidChangeForChildContentContainer(UIKit.IUIContentContainer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("preferredContentSizeDidChangeForChildContentContainer:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="container" Type="UIKit.IUIContentContainer" />
      </Parameters>
      <Docs>
        <param name="container">The child <see cref="T:UIKit.IUIContentContainer" />.</param>
        <summary>Notifies this controller that the preferred size for content for a specified child container has changed.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreferredFocusedView">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIView PreferredFocusedView { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIView PreferredFocusedView" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.PreferredFocusedView" />
      <MemberSignature Language="F#" Value="member this.PreferredFocusedView : UIKit.UIView" Usage="UIKit.UIViewController.PreferredFocusedView" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:UIKit.IUIFocusEnvironment.PreferredFocusedView</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 10, 0, ObjCRuntime.PlatformArchitecture.All, "Use 'PreferredFocusEnvironments' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 10, 0, ObjCRuntime.PlatformArchitecture.All, "Use 'PreferredFocusEnvironments' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("preferredFocusedView", ObjCRuntime.ArgumentSemantic.Weak)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>If not <see langword="null" />, indicates the child <see cref="T:UIKit.UIView" /> that should receive focus by default.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreferredFocusEnvironments">
      <MemberSignature Language="C#" Value="public virtual UIKit.IUIFocusEnvironment[] PreferredFocusEnvironments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.IUIFocusEnvironment[] PreferredFocusEnvironments" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.PreferredFocusEnvironments" />
      <MemberSignature Language="F#" Value="member this.PreferredFocusEnvironments : UIKit.IUIFocusEnvironment[]" Usage="UIKit.UIViewController.PreferredFocusEnvironments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 10, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 10, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("preferredFocusEnvironments", ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.IUIFocusEnvironment[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An array of <see cref="T:UIKit.IUIFocusEnvironment" />s that are recursively searched by the system to find the default focused view.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreferredInterfaceOrientationForPresentation">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIInterfaceOrientation PreferredInterfaceOrientationForPresentation ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype UIKit.UIInterfaceOrientation PreferredInterfaceOrientationForPresentation() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.PreferredInterfaceOrientationForPresentation" />
      <MemberSignature Language="F#" Value="abstract member PreferredInterfaceOrientationForPresentation : unit -&gt; UIKit.UIInterfaceOrientation&#xA;override this.PreferredInterfaceOrientationForPresentation : unit -&gt; UIKit.UIInterfaceOrientation" Usage="uIViewController.PreferredInterfaceOrientationForPresentation " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("preferredInterfaceOrientationForPresentation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIInterfaceOrientation</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>The orientation that best displays the content of this <see cref="T:UIKit.UIViewController" />.</summary>
        <returns>The default value is the first entry in the “Supported Interface Orientations” list in <c>Info.plist</c> or, in an already running application, the current orientation of the status bar.</returns>
        <remarks>
          <para>
            If an application supports more than one orientation, the system uses this orientation when first presenting the <see cref="T:UIKit.UIViewController" /> in full screen. The application developer should set this to the <see cref="T:UIKit.UIInterfaceOrientation" /> that best displays the content view.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreferredScreenEdgesDeferringSystemGestures">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIRectEdge PreferredScreenEdgesDeferringSystemGestures { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype UIKit.UIRectEdge PreferredScreenEdgesDeferringSystemGestures" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.PreferredScreenEdgesDeferringSystemGestures" />
      <MemberSignature Language="F#" Value="member this.PreferredScreenEdgesDeferringSystemGestures : UIKit.UIRectEdge" Usage="UIKit.UIViewController.PreferredScreenEdgesDeferringSystemGestures" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("preferredScreenEdgesDeferringSystemGestures")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIRectEdge</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the screen edges whose gestures take precedence over system gestures.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreferredStatusBarStyle">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIStatusBarStyle PreferredStatusBarStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype UIKit.UIStatusBarStyle PreferredStatusBarStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.PreferredStatusBarStyle" />
      <MemberSignature Language="F#" Value="abstract member PreferredStatusBarStyle : unit -&gt; UIKit.UIStatusBarStyle&#xA;override this.PreferredStatusBarStyle : unit -&gt; UIKit.UIStatusBarStyle" Usage="uIViewController.PreferredStatusBarStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("preferredStatusBarStyle")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIStatusBarStyle</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>The preferred UIStatusBarStyle for this UIViewController.</summary>
        <returns>A UIStatusBarStyle key that specifies the view controller's preferred status bar style. </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreferredStatusBarUpdateAnimation">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIStatusBarAnimation PreferredStatusBarUpdateAnimation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype UIKit.UIStatusBarAnimation PreferredStatusBarUpdateAnimation" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.PreferredStatusBarUpdateAnimation" />
      <MemberSignature Language="F#" Value="member this.PreferredStatusBarUpdateAnimation : UIKit.UIStatusBarAnimation" Usage="UIKit.UIViewController.PreferredStatusBarUpdateAnimation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("preferredStatusBarUpdateAnimation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIStatusBarAnimation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The preferred animation style for hiding and showing the status bar.</summary>
        <value>The style of status bar animation that is to be employed.</value>
        <remarks>This is one of the constants from the UIStatusBarAnimation enum.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PrefersHomeIndicatorAutoHidden">
      <MemberSignature Language="C#" Value="public virtual bool PrefersHomeIndicatorAutoHidden { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PrefersHomeIndicatorAutoHidden" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.PrefersHomeIndicatorAutoHidden" />
      <MemberSignature Language="F#" Value="member this.PrefersHomeIndicatorAutoHidden : bool" Usage="UIKit.UIViewController.PrefersHomeIndicatorAutoHidden" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("prefersHomeIndicatorAutoHidden")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a Boolean value that tells if it is preferred that the Home indicator be hidden.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PrefersStatusBarHidden">
      <MemberSignature Language="C#" Value="public virtual bool PrefersStatusBarHidden ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool PrefersStatusBarHidden() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.PrefersStatusBarHidden" />
      <MemberSignature Language="F#" Value="abstract member PrefersStatusBarHidden : unit -&gt; bool&#xA;override this.PrefersStatusBarHidden : unit -&gt; bool" Usage="uIViewController.PrefersStatusBarHidden " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("prefersStatusBarHidden")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Whether this UIViewController prefers the status bar to be hidden.</summary>
        <returns>Boolean indicating whether the status bar should be hidden.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PrepareForInterstitialAds">
      <MemberSignature Language="C#" Value="public static void PrepareForInterstitialAds ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrepareForInterstitialAds() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.PrepareForInterstitialAds" />
      <MemberSignature Language="F#" Value="static member PrepareForInterstitialAds : unit -&gt; unit" Usage="UIKit.UIViewController.PrepareForInterstitialAds " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Prepares the view controller to display interstitial ads.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PrepareForSegue">
      <MemberSignature Language="C#" Value="public virtual void PrepareForSegue (UIKit.UIStoryboardSegue segue, Foundation.NSObject sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PrepareForSegue(class UIKit.UIStoryboardSegue segue, class Foundation.NSObject sender) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.PrepareForSegue(UIKit.UIStoryboardSegue,Foundation.NSObject)" />
      <MemberSignature Language="F#" Value="abstract member PrepareForSegue : UIKit.UIStoryboardSegue * Foundation.NSObject -&gt; unit&#xA;override this.PrepareForSegue : UIKit.UIStoryboardSegue * Foundation.NSObject -&gt; unit" Usage="uIViewController.PrepareForSegue (segue, sender)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("prepareForSegue:sender:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="segue" Type="UIKit.UIStoryboardSegue" />
        <Parameter Name="sender" Type="Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="segue">The <see cref="T:UIKit.UIStoryboardSegue" /> that is about to be executed.</param>
        <param name="sender">
          <para>The object that initiated the segue.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Informs the application that a <see cref="T:UIKit.UIStoryboardSegue" /> is about to be executed.</summary>
        <remarks>
          <para>
            Application developers can override this method to send data to the <see cref="T:UIKit.UIViewController" /> that is the <see cref="P:UIKit.UIStoryboardSegue.DestinationViewController" />. Application developers may use the <see cref="P:UIKit.UIStoryboardSegue.SourceViewController" /> or the <paramref name="sender" /> to further determine the context in which the segue is occurring.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PresentationController">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIPresentationController PresentationController { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIPresentationController PresentationController" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.PresentationController" />
      <MemberSignature Language="F#" Value="member this.PresentationController : UIKit.UIPresentationController" Usage="UIKit.UIViewController.PresentationController" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("presentationController")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIPresentationController</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the nearest ancestor in the view hierarchy that is a <see cref="T:UIKit.UIPresentationController" /> or <see langword="null" /> if there is none.</summary>
        <value>Gets the nearest ancestor in a popover presentation controller view controller hierarchy.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PresentedViewController">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIViewController PresentedViewController { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIViewController PresentedViewController" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.PresentedViewController" />
      <MemberSignature Language="F#" Value="member this.PresentedViewController : UIKit.UIViewController" Usage="UIKit.UIViewController.PresentedViewController" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("presentedViewController")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIViewController</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The <see cref="T:UIKit.UIViewController" /> that is being presented by this <see cref="T:UIKit.UIViewController" /> or one of <c>this</c>’s ancestor <see cref="T:UIKit.UIViewController" />s.</summary>
        <value>
          <para>The <see cref="T:UIKit.UIViewController" /> that is being presented.</para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>
          <para>
            This method will return a presented <see cref="T:UIKit.UIViewController" /> even if the presenting <see cref="T:UIKit.UIViewController" /> is an ancestor of this <see cref="T:UIKit.UIViewController" />. Note that this is slightly asymmetrical to <see cref="P:UIKit.UIViewController.PresentingViewController" /> which returns <see langword="null" /> when <c>this</c> is an intermediate <see cref="T:UIKit.UIViewController" />.
          </para>
        </remarks>
        <altmember cref="P:UIKit.UIViewController.ParentViewController" />
        <altmember cref="P:UIKit.UIViewController.PresentingViewController" />
      </Docs>
    </Member>
    <Member MemberName="PresentingViewController">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIViewController PresentingViewController { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIViewController PresentingViewController" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.PresentingViewController" />
      <MemberSignature Language="F#" Value="member this.PresentingViewController : UIKit.UIViewController" Usage="UIKit.UIViewController.PresentingViewController" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("presentingViewController")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIViewController</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The <see cref="T:UIKit.UIViewController" /> that is presenting this <see cref="T:UIKit.UIViewController" />.</summary>
        <value>
          <para>The <see cref="T:UIKit.UIViewController" /> that is presenting this <see cref="T:UIKit.UIViewController" />.</para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>If this <see cref="T:UIKit.UIViewController" /> is being presented, this property holds the <see cref="T:UIKit.UIViewController" /> that is presenting it. Note that this is slightly asymmetrical to <see cref="P:UIKit.UIViewController.PresentedViewController" /> which returns a value even if it is a descendant of <c>this</c> that is being presented.</remarks>
        <altmember cref="P:UIKit.UIViewController.PresentedViewController" />
      </Docs>
    </Member>
    <Member MemberName="PresentModalViewController">
      <MemberSignature Language="C#" Value="public virtual void PresentModalViewController (UIKit.UIViewController modalViewController, bool animated);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PresentModalViewController(class UIKit.UIViewController modalViewController, bool animated) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.PresentModalViewController(UIKit.UIViewController,System.Boolean)" />
      <MemberSignature Language="F#" Value="abstract member PresentModalViewController : UIKit.UIViewController * bool -&gt; unit&#xA;override this.PresentModalViewController : UIKit.UIViewController * bool -&gt; unit" Usage="uIViewController.PresentModalViewController (modalViewController, animated)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("presentModalViewController:animated:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, "Use 'PresentViewController (UIViewController, bool, NSAction)' instead and set the 'ModalViewController' property to true.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="modalViewController" Type="UIKit.UIViewController" />
        <Parameter Name="animated" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="modalViewController">
          <para>The <see cref="T:UIKit.UIViewController" /> to be presented.</para>
        </param>
        <param name="animated">
          <para>
            <see langword="true" /> if the presentation should be animated.</para>
        </param>
        <summary>Application developers should use <see cref="M:UIKit.UIViewController.PresentViewController(UIKit.UIViewController,System.Boolean,System.Action)" /> instead of this deprecated method.</summary>
        <remarks>
          <para>This method is deprecated and application developers should use <see cref="M:UIKit.UIViewController.PresentViewController(UIKit.UIViewController,System.Boolean,System.Action)" /> instead.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PresentMoviePlayerViewController">
      <MemberSignature Language="C#" Value="public virtual void PresentMoviePlayerViewController (MediaPlayer.MPMoviePlayerViewController moviePlayerViewController);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PresentMoviePlayerViewController(class MediaPlayer.MPMoviePlayerViewController moviePlayerViewController) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.PresentMoviePlayerViewController(MediaPlayer.MPMoviePlayerViewController)" />
      <MemberSignature Language="F#" Value="abstract member PresentMoviePlayerViewController : MediaPlayer.MPMoviePlayerViewController -&gt; unit&#xA;override this.PresentMoviePlayerViewController : MediaPlayer.MPMoviePlayerViewController -&gt; unit" Usage="uIViewController.PresentMoviePlayerViewController moviePlayerViewController" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("presentMoviePlayerViewControllerAnimated:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, "Use 'AVPlayerViewController' (AVKit) instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.MacOSX, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="moviePlayerViewController" Type="MediaPlayer.MPMoviePlayerViewController" />
      </Parameters>
      <Docs>
        <param name="moviePlayerViewController">The <see cref="T:MediaPlayer.MPMoviePlayerViewController" /> to be presented.</param>
        <summary>Displays a movie controller using the standard transition.</summary>
        <remarks>Along with <see cref="M:UIKit.UIViewController.DismissMoviePlayerViewController" />, this method can be used to control the presentation and dismissal of a <see cref="T:MediaPlayer.MPMoviePlayerViewController" /></remarks>
      </Docs>
    </Member>
    <Member MemberName="PresentViewController">
      <MemberSignature Language="C#" Value="public virtual void PresentViewController (UIKit.UIViewController viewControllerToPresent, bool animated, Action completionHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PresentViewController(class UIKit.UIViewController viewControllerToPresent, bool animated, class System.Action completionHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.PresentViewController(UIKit.UIViewController,System.Boolean,System.Action)" />
      <MemberSignature Language="F#" Value="abstract member PresentViewController : UIKit.UIViewController * bool * Action -&gt; unit&#xA;override this.PresentViewController : UIKit.UIViewController * bool * Action -&gt; unit" Usage="uIViewController.PresentViewController (viewControllerToPresent, animated, completionHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("presentViewController:animated:completion:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="viewControllerToPresent" Type="UIKit.UIViewController" />
        <Parameter Name="animated" Type="System.Boolean" />
        <Parameter Name="completionHandler" Type="System.Action">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="viewControllerToPresent">View controller that displays over the current view controller content.</param>
        <param name="animated">Boolean indicating whether to animate presentation or not.</param>
        <param name="completionHandler">
          <para>Completion action to execute after the presentation finishes.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Modally presents  a view controller.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PresentViewControllerAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task PresentViewControllerAsync (UIKit.UIViewController viewControllerToPresent, bool animated);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task PresentViewControllerAsync(class UIKit.UIViewController viewControllerToPresent, bool animated) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.PresentViewControllerAsync(UIKit.UIViewController,System.Boolean)" />
      <MemberSignature Language="F#" Value="abstract member PresentViewControllerAsync : UIKit.UIViewController * bool -&gt; System.Threading.Tasks.Task&#xA;override this.PresentViewControllerAsync : UIKit.UIViewController * bool -&gt; System.Threading.Tasks.Task" Usage="uIViewController.PresentViewControllerAsync (viewControllerToPresent, animated)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="viewControllerToPresent" Type="UIKit.UIViewController" />
        <Parameter Name="animated" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="viewControllerToPresent">View controller that displays over the current view controller content.</param>
        <param name="animated">Boolean indicating whether to animate presentation or not.</param>
        <summary>Modally presents  a view controller.</summary>
        <returns>A task that represents the asynchronous PresentViewController operation</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewActionItems">
      <MemberSignature Language="C#" Value="public virtual UIKit.IUIPreviewActionItem[] PreviewActionItems { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.IUIPreviewActionItem[] PreviewActionItems" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.PreviewActionItems" />
      <MemberSignature Language="F#" Value="member this.PreviewActionItems : UIKit.IUIPreviewActionItem[]" Usage="UIKit.UIViewController.PreviewActionItems" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("previewActionItems")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.IUIPreviewActionItem[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the array of <see cref="T:UIKit.IUIPreviewActionItem" /> that are displayed when the user swipes upwards in 3D Touch Preview.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProvidesPresentationContextTransitionStyle">
      <MemberSignature Language="C#" Value="public virtual bool ProvidesPresentationContextTransitionStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ProvidesPresentationContextTransitionStyle" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.ProvidesPresentationContextTransitionStyle" />
      <MemberSignature Language="F#" Value="member this.ProvidesPresentationContextTransitionStyle : bool with get, set" Usage="UIKit.UIViewController.ProvidesPresentationContextTransitionStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("providesPresentationContextTransitionStyle")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setProvidesPresentationContextTransitionStyle:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see langword="true" /> if this <see cref="T:UIKit.UIViewController" /> overrides the transition style of the <see cref="T:UIKit.UIViewController" /> that it presents.</summary>
        <value>The default value is <see langword="false" /></value>
        <remarks>
          <para>If left at it’s default <see langword="false" /> value, the transition style of a presented <see cref="T:UIKit.UIViewController" /> is determined by the presented <see cref="T:UIKit.UIViewController" />’s <see cref="P:UIKit.UIViewController.ModalTransitionStyle" /> property. If this <see cref="P:UIKit.UIViewController.ProvidesPresentationContextTransitionStyle" /> property is set to <see langword="true" />, the transition style is determined by the presenting <see cref="T:UIKit.UIViewController" />’s <see cref="P:UIKit.UIViewController.ModalTransitionStyle" /> property.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterForPreviewingWithDelegate">
      <MemberSignature Language="C#" Value="public virtual UIKit.IUIViewControllerPreviewing RegisterForPreviewingWithDelegate (UIKit.IUIViewControllerPreviewingDelegate previewingDelegate, UIKit.UIView sourceView);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class UIKit.IUIViewControllerPreviewing RegisterForPreviewingWithDelegate(class UIKit.IUIViewControllerPreviewingDelegate previewingDelegate, class UIKit.UIView sourceView) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.RegisterForPreviewingWithDelegate(UIKit.IUIViewControllerPreviewingDelegate,UIKit.UIView)" />
      <MemberSignature Language="F#" Value="abstract member RegisterForPreviewingWithDelegate : UIKit.IUIViewControllerPreviewingDelegate * UIKit.UIView -&gt; UIKit.IUIViewControllerPreviewing&#xA;override this.RegisterForPreviewingWithDelegate : UIKit.IUIViewControllerPreviewingDelegate * UIKit.UIView -&gt; UIKit.IUIViewControllerPreviewing" Usage="uIViewController.RegisterForPreviewingWithDelegate (previewingDelegate, sourceView)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("registerForPreviewingWithDelegate:sourceView:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.IUIViewControllerPreviewing</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="previewingDelegate" Type="UIKit.IUIViewControllerPreviewingDelegate" />
        <Parameter Name="sourceView" Type="UIKit.UIView" />
      </Parameters>
      <Docs>
        <param name="previewingDelegate">The delegate that controls the display of peeks and pops in response to variations in user-applied pressure.</param>
        <param name="sourceView">The view, in the receiver's view hierarchy, that supplies the peek, or preview, view.</param>
        <summary>Registers this view controller for 3D Touch peek and pop operations.</summary>
        <returns>The context for the preview.</returns>
        <remarks>
          <para>
          App developers call this method to register this view controller as the one that displays preview and commit force gestures, specify the source view that will remain visually focused prior to peeking, and specify the delegate that responds to forceful touch from the user. App developers can rely on automatic life cycle management for the context that is returned, or manually release it by calling the <see cref="M:UIKit.UIViewController.UnregisterForPreviewingWithContext(UIKit.IUIViewControllerPreviewing)" /> method.
        </para>
          <para>Application developers who want to preserve the option to unregister for 3D Touch peek and pop must store a reference to the <see cref="T:UIKit.IUIViewControllerPreviewing" /> instance that is returned by <see cref="M:UIKit.UIViewController.RegisterForPreviewingWithDelegate(UIKit.IUIViewControllerPreviewingDelegate,UIKit.UIView)" />, so that they can later pass it to the <see cref="M:UIKit.UIViewController.UnregisterForPreviewingWithContext(UIKit.IUIViewControllerPreviewing)" /> method.</para>
          <para>This method should typically be called in an override of <see cref="M:UIKit.IUITraitEnvironment.TraitCollectionDidChange(UIKit.UITraitCollection)" /> in the initial <see cref="T:UIKit.UIViewController" /> of the app.</para>
          <example>
            <code lang="csharp lang-csharp"><![CDATA[
public override void TraitCollectionDidChange(UITraitCollection previousTraitCollection)
{
    base.TraitCollectionDidChange(previousTraitCollection);

    if (TraitCollection.ForceTouchCapability == UIForceTouchCapability.Available) {
        // Register for 3D Touch Peek and Pop
        RegisterForPreviewingWithDelegate(new PreviewingDelegate(), View);
    }
}
    ]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveFromParentViewController">
      <MemberSignature Language="C#" Value="public virtual void RemoveFromParentViewController ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveFromParentViewController() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.RemoveFromParentViewController" />
      <MemberSignature Language="F#" Value="abstract member RemoveFromParentViewController : unit -&gt; unit&#xA;override this.RemoveFromParentViewController : unit -&gt; unit" Usage="uIViewController.RemoveFromParentViewController " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("removeFromParentViewController")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Removes this <see cref="T:UIKit.UIViewController" /> from its <see cref="P:UIKit.UIViewController.ParentViewController" /><see cref="T:UIKit.UIViewController" />.</summary>
        <remarks>
          <para>This function will trigger the removal of this <see cref="T:UIKit.UIViewController" /> from its parent <see cref="T:UIKit.UIViewController" /> (see <see cref="P:UIKit.UIViewController.ParentViewController" />).</para>
          <para>The removal process will set the <see cref="P:UIKit.UIViewController.IsMovingFromParentViewController" /> property to <see langword="true" /> and call the <see cref="M:UIKit.UIViewController.ViewWillDisappear(System.Boolean)" />, <see cref="M:UIKit.UIViewController.ViewDidDisappear(System.Boolean)" />, and <see cref="M:UIKit.UIViewController.DidMoveToParentViewController(UIKit.UIViewController)" /> methods.</para>
        </remarks>
        <altmember cref="P:UIKit.UIViewController.IsMovingFromParentViewController" />
        <altmember cref="M:UIKit.UIViewController.ViewWillDisappear" />
        <altmember cref="M:UIKit.UIViewController.ViewDidDisappear" />
        <altmember cref="M:UIKit.UIViewController.DidMoveToParentViewController" />
      </Docs>
    </Member>
    <Member MemberName="RemoveKeyCommand">
      <MemberSignature Language="C#" Value="public virtual void RemoveKeyCommand (UIKit.UIKeyCommand command);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveKeyCommand(class UIKit.UIKeyCommand command) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.RemoveKeyCommand(UIKit.UIKeyCommand)" />
      <MemberSignature Language="F#" Value="abstract member RemoveKeyCommand : UIKit.UIKeyCommand -&gt; unit&#xA;override this.RemoveKeyCommand : UIKit.UIKeyCommand -&gt; unit" Usage="uIViewController.RemoveKeyCommand command" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("removeKeyCommand:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="UIKit.UIKeyCommand" />
      </Parameters>
      <Docs>
        <param name="command">The <see cref="T:UIKit.UIKeyCommand" /> to be removed.</param>
        <summary>Removes a previously-added hardware-keyboard accelerator.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:UIKit.UIViewController.AddKeyCommand" />
      </Docs>
    </Member>
    <Member MemberName="RestorationClass">
      <MemberSignature Language="C#" Value="public virtual ObjCRuntime.Class RestorationClass { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class ObjCRuntime.Class RestorationClass" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.RestorationClass" />
      <MemberSignature Language="F#" Value="member this.RestorationClass : ObjCRuntime.Class with get, set" Usage="UIKit.UIViewController.RestorationClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("restorationClass")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setRestorationClass:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>ObjCRuntime.Class</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The class responsible for restoring application state.</summary>
        <value>The default value is a <see cref="T:ObjCRuntime.Class" /> whose <see cref="P:ObjCRuntime.Class.Name" /> is “nil”.<para tool="nullallowed">This value can be <see langword="null" />.</para></value>
        <remarks>To be added.</remarks>
        <altmember cref="P:UIKit.UIViewController.RestorationIdentifier" />
      </Docs>
    </Member>
    <Member MemberName="RestorationIdentifier">
      <MemberSignature Language="C#" Value="public virtual string RestorationIdentifier { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RestorationIdentifier" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.RestorationIdentifier" />
      <MemberSignature Language="F#" Value="member this.RestorationIdentifier : string with get, set" Usage="UIKit.UIViewController.RestorationIdentifier" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("restorationIdentifier", ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setRestorationIdentifier:", ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies the instance of the <see cref="T:UIKit.UIViewController" /> for restoration.</summary>
        <value>
          <para>The default value is <see langword="null" />.</para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>
          <para>This protocol is not currently bound by MonoTouch. </para>
          <para>See the section "State Restoration" in the class documentation for <see cref="T:UIKit.UIViewController" />.</para>
        </remarks>
        <altmember cref="P:UIKit.UIViewController.RestorationClass" />
      </Docs>
    </Member>
    <Member MemberName="RestoresFocusAfterTransition">
      <MemberSignature Language="C#" Value="public virtual bool RestoresFocusAfterTransition { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RestoresFocusAfterTransition" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.RestoresFocusAfterTransition" />
      <MemberSignature Language="F#" Value="member this.RestoresFocusAfterTransition : bool with get, set" Usage="UIKit.UIViewController.RestoresFocusAfterTransition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 10, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 10, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("restoresFocusAfterTransition")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 10, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 10, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setRestoresFocusAfterTransition:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 10, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 10, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets whether this <see cref="T:UIKit.UIViewController" /> restores focus after being transitioned to.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RotatingFooterView">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIView RotatingFooterView { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIView RotatingFooterView" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.RotatingFooterView" />
      <MemberSignature Language="F#" Value="member this.RotatingFooterView : UIKit.UIView" Usage="UIKit.UIViewController.RotatingFooterView" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, "Use Adaptive View Controllers instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("rotatingFooterView")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, "Use Adaptive View Controllers instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The footer view that needs to be transitioned during an interface rotation</summary>
        <value>The default value is the tab bar if one exists, otherwise <see langword="null" /></value>
        <remarks>
          <para>Subtypes of <see cref="T:UIKit.UIViewController" /> that define their own footer view should override this if they support rotation.</para>
          <para>
            <see cref="T:UIKit.UIViewController" />s that contain a tab bar should return the tab bar <see cref="T:UIKit.UIView" /> from this method.</para>
        </remarks>
        <altmember cref="M:UIKit.UIViewController.WillAnimateRotation" />
        <altmember cref="M:UIKit.UIViewController.RotatingHeaderView" />
      </Docs>
    </Member>
    <Member MemberName="RotatingHeaderView">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIView RotatingHeaderView { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIView RotatingHeaderView" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.RotatingHeaderView" />
      <MemberSignature Language="F#" Value="member this.RotatingHeaderView : UIKit.UIView" Usage="UIKit.UIViewController.RotatingHeaderView" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, "Use Adaptive View Controllers instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("rotatingHeaderView")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, "Use Adaptive View Controllers instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The header view that needs to be transitioned during an interface rotation.</summary>
        <value>The default value is the navigation bar if one exists, otherwise <see langword="null" />.</value>
        <remarks>
          <para>Subtypes of <see cref="T:UIKit.UIViewController" /> that define their own header view should override this if they support rotation.</para>
          <para>
            <see cref="T:UIKit.UIViewController" />s that contain a navigation bar should return the navigation bar <see cref="T:UIKit.UIView" /> from this method.</para>
        </remarks>
        <altmember cref="M:UIKit.UIViewController.WillAnimateRotation" />
        <altmember cref="M:UIKit.UIViewController.RotatingFooterView" />
      </Docs>
    </Member>
    <Member MemberName="SearchDisplayController">
      <MemberSignature Language="C#" Value="public virtual UIKit.UISearchDisplayController SearchDisplayController { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UISearchDisplayController SearchDisplayController" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.SearchDisplayController" />
      <MemberSignature Language="F#" Value="member this.SearchDisplayController : UIKit.UISearchDisplayController" Usage="UIKit.UIViewController.SearchDisplayController" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, "Use 'UISearchController' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, "Use 'UISearchController' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("searchDisplayController", ObjCRuntime.ArgumentSemantic.Strong)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UISearchDisplayController</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The <see cref="T:UIKit.UISearchDisplayController" />, if any, associated with this <see cref="T:UIKit.UIViewController" />.</summary>
        <value>The default value is <see langword="null" />.</value>
        <remarks>
          <para>Application developeres may specify a <see cref="T:UIKit.UISearchDisplayController" /> using Interface Builder or programmatically. To assign the <see cref="P:UIKit.UIViewController.SearchDisplayController" /> property, the <see cref="T:UIKit.UIViewController" /> must have a field of type <see cref="T:UIKit.UISearchBar" /> decorated with <c>[Outlet]</c> (<see cref="T:Foundation.OutletAttribute" />) and must initialize a new <see cref="T:UIKit.UISearchDisplayController" /> with a reference to that <see cref="T:UIKit.UISearchBar" />. As shown in the following code, the assignment of the <see cref="T:UIKit.UISearchDisplayController" /> to <see cref="P:UIKit.UIViewController.SearchDisplayController" /> is done implicitly during initialization, and does not involve the application developer assigning the reference to the newly-created <see cref="T:UIKit.UISearchDisplayController" />:</para>
          <example>
            <code lang="csharp lang-csharp"><![CDATA[
public override void ViewDidLoad ()
{
    base.ViewDidLoad ();

    //this.SearchDisplayController == null
    //n.b.: No assignment 
    new UISearchDisplayController (mySearchBar, this);
    //this.SearchDisplayController != null         
    Console.WriteLine ("SearchDisplayController = '{0}'", this.SearchDisplayController);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetEditing">
      <MemberSignature Language="C#" Value="public virtual void SetEditing (bool editing, bool animated);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetEditing(bool editing, bool animated) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.SetEditing(System.Boolean,System.Boolean)" />
      <MemberSignature Language="F#" Value="abstract member SetEditing : bool * bool -&gt; unit&#xA;override this.SetEditing : bool * bool -&gt; unit" Usage="uIViewController.SetEditing (editing, animated)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("setEditing:animated:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="editing" Type="System.Boolean" />
        <Parameter Name="animated" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="editing">
          <para>
            <see langword="true" /> to enter editing mode, <see langword="false" /> to end editing. The default is <see langword="false" />.</para>
        </param>
        <param name="animated">
          <para>
            <see langword="true" /> to animate the transition to or from editingmode, or <see langword="false" /> to change modes immediately.</para>
        </param>
        <summary>Turns editing mode on or off.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetNeedsFocusUpdate">
      <MemberSignature Language="C#" Value="public virtual void SetNeedsFocusUpdate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetNeedsFocusUpdate() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.SetNeedsFocusUpdate" />
      <MemberSignature Language="F#" Value="abstract member SetNeedsFocusUpdate : unit -&gt; unit&#xA;override this.SetNeedsFocusUpdate : unit -&gt; unit" Usage="uIViewController.SetNeedsFocusUpdate " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:UIKit.IUIFocusEnvironment.SetNeedsFocusUpdate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("setNeedsFocusUpdate")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>When <c>this</c> is the active focus environment, requests a focus update, which can potentially change the <see cref="P:UIKit.UIView.PreferredFocusedView" />. (See also <see cref="M:UIKit.UIViewController.UpdateFocusIfNeeded" />.)</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetNeedsStatusBarAppearanceUpdate">
      <MemberSignature Language="C#" Value="public virtual void SetNeedsStatusBarAppearanceUpdate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetNeedsStatusBarAppearanceUpdate() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.SetNeedsStatusBarAppearanceUpdate" />
      <MemberSignature Language="F#" Value="abstract member SetNeedsStatusBarAppearanceUpdate : unit -&gt; unit&#xA;override this.SetNeedsStatusBarAppearanceUpdate : unit -&gt; unit" Usage="uIViewController.SetNeedsStatusBarAppearanceUpdate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("setNeedsStatusBarAppearanceUpdate")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Notifies the system that the attributes of the status bar have been changed.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetNeedsUpdateOfHomeIndicatorAutoHidden">
      <MemberSignature Language="C#" Value="public virtual void SetNeedsUpdateOfHomeIndicatorAutoHidden ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetNeedsUpdateOfHomeIndicatorAutoHidden() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.SetNeedsUpdateOfHomeIndicatorAutoHidden" />
      <MemberSignature Language="F#" Value="abstract member SetNeedsUpdateOfHomeIndicatorAutoHidden : unit -&gt; unit&#xA;override this.SetNeedsUpdateOfHomeIndicatorAutoHidden : unit -&gt; unit" Usage="uIViewController.SetNeedsUpdateOfHomeIndicatorAutoHidden " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("setNeedsUpdateOfHomeIndicatorAutoHidden")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Controls whether the developer's view controller should display the indicator for returning to the Home screen..</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetNeedsUpdateOfScreenEdgesDeferringSystemGestures">
      <MemberSignature Language="C#" Value="public virtual void SetNeedsUpdateOfScreenEdgesDeferringSystemGestures ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetNeedsUpdateOfScreenEdgesDeferringSystemGestures() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.SetNeedsUpdateOfScreenEdgesDeferringSystemGestures" />
      <MemberSignature Language="F#" Value="abstract member SetNeedsUpdateOfScreenEdgesDeferringSystemGestures : unit -&gt; unit&#xA;override this.SetNeedsUpdateOfScreenEdgesDeferringSystemGestures : unit -&gt; unit" Usage="uIViewController.SetNeedsUpdateOfScreenEdgesDeferringSystemGestures " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("setNeedsUpdateOfScreenEdgesDeferringSystemGestures")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Changes the screen edges whose gestures take precedence over system gestures.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetOverrideTraitCollection">
      <MemberSignature Language="C#" Value="public virtual void SetOverrideTraitCollection (UIKit.UITraitCollection collection, UIKit.UIViewController childViewController);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetOverrideTraitCollection(class UIKit.UITraitCollection collection, class UIKit.UIViewController childViewController) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.SetOverrideTraitCollection(UIKit.UITraitCollection,UIKit.UIViewController)" />
      <MemberSignature Language="F#" Value="abstract member SetOverrideTraitCollection : UIKit.UITraitCollection * UIKit.UIViewController -&gt; unit&#xA;override this.SetOverrideTraitCollection : UIKit.UITraitCollection * UIKit.UIViewController -&gt; unit" Usage="uIViewController.SetOverrideTraitCollection (collection, childViewController)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("setOverrideTraitCollection:forChildViewController:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collection" Type="UIKit.UITraitCollection" />
        <Parameter Name="childViewController" Type="UIKit.UIViewController" />
      </Parameters>
      <Docs>
        <param name="collection">New traits that are to be applied to the specified child view controller.</param>
        <param name="childViewController">Child view controller whose trait collection is to be modified.</param>
        <summary>Sets the <see cref="T:UIKit.UITraitCollection" /> object for the specified child view controller of this controller.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetToolbarItems">
      <MemberSignature Language="C#" Value="public virtual void SetToolbarItems (UIKit.UIBarButtonItem[] items, bool animated);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetToolbarItems(class UIKit.UIBarButtonItem[] items, bool animated) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.SetToolbarItems(UIKit.UIBarButtonItem[],System.Boolean)" />
      <MemberSignature Language="F#" Value="abstract member SetToolbarItems : UIKit.UIBarButtonItem[] * bool -&gt; unit&#xA;override this.SetToolbarItems : UIKit.UIBarButtonItem[] * bool -&gt; unit" Usage="uIViewController.SetToolbarItems (items, animated)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("setToolbarItems:animated:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="items" Type="UIKit.UIBarButtonItem[]" />
        <Parameter Name="animated" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="items">
          <para>The array of <see cref="T:UIKit.UIBarButtonItem" />s to be added.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <param name="animated">Whether the addition of the buttons should be animated.</param>
        <summary>Adds <see cref="T:UIKit.UIBarButtonItem" />s to the <see cref="T:UIKit.UIToolbar" /></summary>
        <remarks>
          <para>This method can be used to add <see cref="T:UIKit.UIBarButtonItem" />s to a <see cref="T:UIKit.UINavigationController" />’s <see cref="T:UIKit.UIToolbar" />.</para>
        </remarks>
        <altmember cref="P:UIKit.UIViewController.ToolbarItems" />
        <altmember cref="P:UIKit.UINavigationController.Toolbar" />
      </Docs>
    </Member>
    <Member MemberName="ShouldAutomaticallyForwardAppearanceMethods">
      <MemberSignature Language="C#" Value="public virtual bool ShouldAutomaticallyForwardAppearanceMethods { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShouldAutomaticallyForwardAppearanceMethods" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.ShouldAutomaticallyForwardAppearanceMethods" />
      <MemberSignature Language="F#" Value="member this.ShouldAutomaticallyForwardAppearanceMethods : bool" Usage="UIKit.UIViewController.ShouldAutomaticallyForwardAppearanceMethods" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("shouldAutomaticallyForwardAppearanceMethods")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether appearance methods should be forwarded to child <see cref="T:UIKit.UIViewController" />s.</summary>
        <value>The default value is <see langword="true" />.</value>
        <remarks>
          <para>Application developers who override this member and set it to <see langword="false" /> are responsible for controlling their child <see cref="T:UIKit.UIViewController" />’s <see cref="T:UIKit.UIView" />s appearance. Application developers should call their child <see cref="T:UIKit.UIViewController" />’s <see cref="M:UIKit.UIViewController.BeginAppearanceTransition(System.Boolean,System.Boolean)" /> and <see cref="M:UIKit.UIViewController.EndAppearanceTransition" /> methods as appropriate.</para>
        </remarks>
        <altmember cref="P:UIKit.UIViewController.ChildViewControllers" />
      </Docs>
    </Member>
    <Member MemberName="ShouldAutomaticallyForwardRotationMethods">
      <MemberSignature Language="C#" Value="public virtual bool ShouldAutomaticallyForwardRotationMethods { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShouldAutomaticallyForwardRotationMethods" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.ShouldAutomaticallyForwardRotationMethods" />
      <MemberSignature Language="F#" Value="member this.ShouldAutomaticallyForwardRotationMethods : bool" Usage="UIKit.UIViewController.ShouldAutomaticallyForwardRotationMethods" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, "Use Adaptive View Controllers instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("shouldAutomaticallyForwardRotationMethods")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, "Use Adaptive View Controllers instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether rotation methods should be forwarded to child <see cref="T:UIKit.UIViewController" />s.</summary>
        <value>The default value is <see langword="true" />.</value>
        <remarks>
          <para>Application developers who override this member and set it to <see langword="false" /> are responsible for controlling their child <see cref="T:UIKit.UIViewController" />s rotation-related methods. Application developers should call their child <see cref="T:UIKit.UIViewController" />’s <see cref="M:UIKit.UIViewController.WillRotate(UIKit.UIInterfaceOrientation,System.Double)" />, <see cref="M:UIKit.UIViewController.WillAnimateRotation(UIKit.UIInterfaceOrientation,System.Double)" />, and <see cref="M:UIKit.UIViewController.DidRotate(UIKit.UIInterfaceOrientation)" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldAutorotate">
      <MemberSignature Language="C#" Value="public virtual bool ShouldAutorotate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ShouldAutorotate() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.ShouldAutorotate" />
      <MemberSignature Language="F#" Value="abstract member ShouldAutorotate : unit -&gt; bool&#xA;override this.ShouldAutorotate : unit -&gt; bool" Usage="uIViewController.ShouldAutorotate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("shouldAutorotate")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Turns auto-rotation on or off.</summary>
        <returns>
          <see langword="true" /> if the <see cref="T:UIKit.UIViewController" /> should auto-rotate, <see langword="false" /> otherwise.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldAutorotateToInterfaceOrientation">
      <MemberSignature Language="C#" Value="public virtual bool ShouldAutorotateToInterfaceOrientation (UIKit.UIInterfaceOrientation toInterfaceOrientation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ShouldAutorotateToInterfaceOrientation(valuetype UIKit.UIInterfaceOrientation toInterfaceOrientation) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.ShouldAutorotateToInterfaceOrientation(UIKit.UIInterfaceOrientation)" />
      <MemberSignature Language="F#" Value="abstract member ShouldAutorotateToInterfaceOrientation : UIKit.UIInterfaceOrientation -&gt; bool&#xA;override this.ShouldAutorotateToInterfaceOrientation : UIKit.UIInterfaceOrientation -&gt; bool" Usage="uIViewController.ShouldAutorotateToInterfaceOrientation toInterfaceOrientation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("shouldAutorotateToInterfaceOrientation:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, "Use both 'GetSupportedInterfaceOrientations' and 'PreferredInterfaceOrientationForPresentation' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toInterfaceOrientation" Type="UIKit.UIInterfaceOrientation" />
      </Parameters>
      <Docs>
        <param name="toInterfaceOrientation">
          <para>The final <see cref="T:UIKit.UIInterfaceOrientation" />.</para>
        </param>
        <summary>
          <see langword="true" /> if the <see cref="T:UIKit.UIViewController" /> supports rotation to the specified <see cref="T:UIKit.UIInterfaceOrientation" />.</summary>
        <returns>
          <para>
            <see langword="true" /> if the <see cref="T:UIKit.UIViewController" /> supports rotation to the specified <see cref="T:UIKit.UIInterfaceOrientation" />.</para>
        </returns>
        <remarks>
          <para>Application developers should not use this deprecated method. Instead, they should use <see cref="M:UIKit.UIViewController.ShouldAutorotateToInterfaceOrientation(UIKit.UIInterfaceOrientation)" />, <see cref="M:UIKit.UIViewController.PreferredInterfaceOrientationForPresentation" />, and <see cref="M:UIKit.UIViewController.GetSupportedInterfaceOrientations" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldPerformSegue">
      <MemberSignature Language="C#" Value="public virtual bool ShouldPerformSegue (string segueIdentifier, Foundation.NSObject sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ShouldPerformSegue(string segueIdentifier, class Foundation.NSObject sender) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.ShouldPerformSegue(System.String,Foundation.NSObject)" />
      <MemberSignature Language="F#" Value="abstract member ShouldPerformSegue : string * Foundation.NSObject -&gt; bool&#xA;override this.ShouldPerformSegue : string * Foundation.NSObject -&gt; bool" Usage="uIViewController.ShouldPerformSegue (segueIdentifier, sender)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("shouldPerformSegueWithIdentifier:sender:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="segueIdentifier" Type="System.String" />
        <Parameter Name="sender" Type="Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="segueIdentifier">The segue about to be performed.</param>
        <param name="sender">The object that initiated the segue.</param>
        <summary>Whether the segue should be performed.</summary>
        <returns>
          <see langword="true" /> if the segue should be allowed to perform, <see langword="false" /> if not.</returns>
        <remarks>Application developers may override this function so that it returns <see langword="false" /> in order to disable certain segues from executing.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldUpdateFocus">
      <MemberSignature Language="C#" Value="public virtual bool ShouldUpdateFocus (UIKit.UIFocusUpdateContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ShouldUpdateFocus(class UIKit.UIFocusUpdateContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.ShouldUpdateFocus(UIKit.UIFocusUpdateContext)" />
      <MemberSignature Language="F#" Value="abstract member ShouldUpdateFocus : UIKit.UIFocusUpdateContext -&gt; bool&#xA;override this.ShouldUpdateFocus : UIKit.UIFocusUpdateContext -&gt; bool" Usage="uIViewController.ShouldUpdateFocus context" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:UIKit.IUIFocusEnvironment.ShouldUpdateFocus(UIKit.UIFocusUpdateContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("shouldUpdateFocusInContext:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="UIKit.UIFocusUpdateContext" />
      </Parameters>
      <Docs>
        <param name="context">To be added.</param>
        <summary>Called prior to the <c>this</c> either losing or receiving focus. If either focus environment returns <see langword="false" />, the focus update is canceled.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowDetailTargetDidChangeNotification">
      <MemberSignature Language="C#" Value="public static Foundation.NSString ShowDetailTargetDidChangeNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString ShowDetailTargetDidChangeNotification" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.ShowDetailTargetDidChangeNotification" />
      <MemberSignature Language="F#" Value="member this.ShowDetailTargetDidChangeNotification : Foundation.NSString" Usage="UIKit.UIViewController.ShowDetailTargetDidChangeNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Use UIViewController.Notifications.ObserveShowDetailTargetDidChange helper method instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Field("UIViewControllerShowDetailTargetDidChangeNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for ShowDetailTargetDidChange</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIKit.UIViewController.Notifications" />.<see cref="M:UIKit.UIViewController.Notifications.ObserveShowDetailTargetDidChange*" /> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="csharp lang-csharp"><![CDATA[
//
// Lambda style
//

// listening
notification = UIViewController.Notifications.ObserveShowDetailTargetDidChange ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, Foundation.NSNotificationEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UIViewController.Notifications.ObserveShowDetailTargetDidChange (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="csharp lang-csharp"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIViewController.ShowDetailTargetDidChangeNotification, (notification) => {Console.WriteLine ("Received the notification UIViewController", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIViewController", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIViewController.ShowDetailTargetDidChangeNotification, Callback);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowDetailViewController">
      <MemberSignature Language="C#" Value="public virtual void ShowDetailViewController (UIKit.UIViewController vc, Foundation.NSObject sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ShowDetailViewController(class UIKit.UIViewController vc, class Foundation.NSObject sender) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.ShowDetailViewController(UIKit.UIViewController,Foundation.NSObject)" />
      <MemberSignature Language="F#" Value="abstract member ShowDetailViewController : UIKit.UIViewController * Foundation.NSObject -&gt; unit&#xA;override this.ShowDetailViewController : UIKit.UIViewController * Foundation.NSObject -&gt; unit" Usage="uIViewController.ShowDetailViewController (vc, sender)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("showDetailViewController:sender:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="vc" Type="UIKit.UIViewController" />
        <Parameter Name="sender" Type="Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="vc">Current view controller.</param>
        <param name="sender">
          <para>The object that sent the action.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Shows this view controller in a detail context.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowViewController">
      <MemberSignature Language="C#" Value="public virtual void ShowViewController (UIKit.UIViewController vc, Foundation.NSObject sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ShowViewController(class UIKit.UIViewController vc, class Foundation.NSObject sender) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.ShowViewController(UIKit.UIViewController,Foundation.NSObject)" />
      <MemberSignature Language="F#" Value="abstract member ShowViewController : UIKit.UIViewController * Foundation.NSObject -&gt; unit&#xA;override this.ShowViewController : UIKit.UIViewController * Foundation.NSObject -&gt; unit" Usage="uIViewController.ShowViewController (vc, sender)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("showViewController:sender:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="vc" Type="UIKit.UIViewController" />
        <Parameter Name="sender" Type="Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="vc">Current view controller.</param>
        <param name="sender">
          <para>The object that sent the action.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Shows this view controller.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SplitViewController">
      <MemberSignature Language="C#" Value="public virtual UIKit.UISplitViewController SplitViewController { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UISplitViewController SplitViewController" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.SplitViewController" />
      <MemberSignature Language="F#" Value="member this.SplitViewController : UIKit.UISplitViewController" Usage="UIKit.UIViewController.SplitViewController" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("splitViewController", ObjCRuntime.ArgumentSemantic.Strong)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UISplitViewController</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The nearest ancestor <see cref="T:UIKit.UISplitViewController" /> or <see langword="null" />.</summary>
        <value>The default value is <see langword="null" />.</value>
        <remarks>
          <para>If this <see cref="T:UIKit.UIViewController" /> is a descendant of a <see cref="T:UIKit.UISplitViewController" />, this method will return that <see cref="T:UIKit.UISplitViewController" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Storyboard">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIStoryboard Storyboard { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIStoryboard Storyboard" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.Storyboard" />
      <MemberSignature Language="F#" Value="member this.Storyboard : UIKit.UIStoryboard" Usage="UIKit.UIViewController.Storyboard" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("storyboard", ObjCRuntime.ArgumentSemantic.Strong)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIStoryboard</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The <see cref="T:UIKit.UIStoryboard" /> from which this <see cref="T:UIKit.UIViewController" /> was created, or <see langword="null" />.</summary>
        <value>The default value is <see langword="null" />.</value>
        <remarks>
          <para>If this <see cref="T:UIKit.UIViewController" /> was instantiated by a <see cref="T:UIKit.UIStoryboard" />, this method will return that <see cref="T:UIKit.UIStoryboard" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SystemLayoutFittingSizeDidChangeForChildContentContainer">
      <MemberSignature Language="C#" Value="public virtual void SystemLayoutFittingSizeDidChangeForChildContentContainer (UIKit.IUIContentContainer container);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SystemLayoutFittingSizeDidChangeForChildContentContainer(class UIKit.IUIContentContainer container) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.SystemLayoutFittingSizeDidChangeForChildContentContainer(UIKit.IUIContentContainer)" />
      <MemberSignature Language="F#" Value="abstract member SystemLayoutFittingSizeDidChangeForChildContentContainer : UIKit.IUIContentContainer -&gt; unit&#xA;override this.SystemLayoutFittingSizeDidChangeForChildContentContainer : UIKit.IUIContentContainer -&gt; unit" Usage="uIViewController.SystemLayoutFittingSizeDidChangeForChildContentContainer container" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:UIKit.IUIContentContainer.SystemLayoutFittingSizeDidChangeForChildContentContainer(UIKit.IUIContentContainer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("systemLayoutFittingSizeDidChangeForChildContentContainer:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="container" Type="UIKit.IUIContentContainer" />
      </Parameters>
      <Docs>
        <param name="container">The child <see cref="T:UIKit.IUIContentContainer" />.</param>
        <summary>Notifies this container that auto layout resized a specified child container.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SystemMinimumLayoutMargins">
      <MemberSignature Language="C#" Value="public virtual UIKit.NSDirectionalEdgeInsets SystemMinimumLayoutMargins { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype UIKit.NSDirectionalEdgeInsets SystemMinimumLayoutMargins" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.SystemMinimumLayoutMargins" />
      <MemberSignature Language="F#" Value="member this.SystemMinimumLayoutMargins : UIKit.NSDirectionalEdgeInsets" Usage="UIKit.UIViewController.SystemMinimumLayoutMargins" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("systemMinimumLayoutMargins")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.NSDirectionalEdgeInsets</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the root view's minimum layout margins.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TabBarController">
      <MemberSignature Language="C#" Value="public virtual UIKit.UITabBarController TabBarController { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UITabBarController TabBarController" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.TabBarController" />
      <MemberSignature Language="F#" Value="member this.TabBarController : UIKit.UITabBarController" Usage="UIKit.UIViewController.TabBarController" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("tabBarController", ObjCRuntime.ArgumentSemantic.Strong)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UITabBarController</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The nearest ancestore <see cref="T:UIKit.UITabBarController" /> or <see langword="null" />.</summary>
        <value>The default value is <see langword="null" />.</value>
        <remarks>If this <see cref="T:UIKit.UIViewController" /> is a descendant of a <see cref="T:UIKit.UITabBarController" />, this method will return that <see cref="T:UIKit.UITabBarController" />.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TabBarItem">
      <MemberSignature Language="C#" Value="public virtual UIKit.UITabBarItem TabBarItem { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UITabBarItem TabBarItem" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.TabBarItem" />
      <MemberSignature Language="F#" Value="member this.TabBarItem : UIKit.UITabBarItem with get, set" Usage="UIKit.UIViewController.TabBarItem" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("tabBarItem", ObjCRuntime.ArgumentSemantic.Strong)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setTabBarItem:", ObjCRuntime.ArgumentSemantic.Strong)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UITabBarItem</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A <see cref="T:UIKit.UITabBarItem" /> that represents this <see cref="T:UIKit.UIViewController" /> in its parent’s <see cref="T:UIKit.UITabBarController" />’s <see cref="P:UIKit.UITabBarController.TabBar" />.</summary>
        <value>By default, the first time this property is accessed, a new <see cref="T:UIKit.UITabBarItem" /> is lazily initialized with a <see cref="P:UIKit.UITabBarItem.Title" /> set to this <see cref="T:UIKit.UIViewController" />’s <see cref="P:UIKit.UIViewController.Title" />.'</value>
        <remarks>
          <para>
            When a <see cref="T:UIKit.UIViewController" /> is a descendant of a <see cref="T:UIKit.UITabBarController" />, the child’s <see cref="P:UIKit.UIViewController.TabBarItem" /> represents the <see cref="T:UIKit.UITabBarItem" /> in the ancestor’s <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=UIKit%20UITab%20Bar%20Controller%20UITab%20Bar&amp;scope=Xamarin" title="P:UIKit.UITabBarController.UITabBar">P:UIKit.UITabBarController.UITabBar</a></format>. The first time this property is accessed, the default behavior is to lazily initialize a <see cref="T:UIKit.UITabBarItem" />, so if there is no ancestor <see cref="T:UIKit.UITabBarController" />, application developers should either not access or override this property.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public virtual string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Title" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.Title" />
      <MemberSignature Language="F#" Value="member this.Title : string with get, set" Usage="UIKit.UIViewController.Title" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("title", ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setTitle:", ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A human-meaningful identifier of this <see cref="T:UIKit.UIViewController" />.</summary>
        <value>
          <para>The default value is <see langword="null" />.</para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolbarItems">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIBarButtonItem[] ToolbarItems { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIBarButtonItem[] ToolbarItems" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.ToolbarItems" />
      <MemberSignature Language="F#" Value="member this.ToolbarItems : UIKit.UIBarButtonItem[] with get, set" Usage="UIKit.UIViewController.ToolbarItems" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("toolbarItems", ObjCRuntime.ArgumentSemantic.Strong)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setToolbarItems:", ObjCRuntime.ArgumentSemantic.Strong)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIBarButtonItem[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The array of <see cref="T:UIKit.UIBarButtonItem" />s on a <see cref="T:UIKit.UINavigationController" />’s <see cref="P:UIKit.UINavigationController.Toolbar" /></summary>
        <value>The default value is <see langword="null" />.</value>
        <remarks>
          <para>This property references the <see cref="T:UIKit.UIBarButtonItem" />s on a <see cref="T:UIKit.UINavigationController" />’s <see cref="P:UIKit.UINavigationController.Toolbar" />. If the application developer wishes to animate the addition or removal of <see cref="T:UIKit.UIBarButtonItem" />s, they should use the <see cref="M:UIKit.UIViewController.SetToolbarItems(UIKit.UIBarButtonItem[],System.Boolean)" /> method.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TopLayoutGuide">
      <MemberSignature Language="C#" Value="public virtual UIKit.IUILayoutSupport TopLayoutGuide { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.IUILayoutSupport TopLayoutGuide" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.TopLayoutGuide" />
      <MemberSignature Language="F#" Value="member this.TopLayoutGuide : UIKit.IUILayoutSupport" Usage="UIKit.UIViewController.TopLayoutGuide" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.None, "Use 'UIView.SafeAreaLayoutGuide.TopAnchor' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.None, "Use 'UIView.SafeAreaLayoutGuide.TopAnchor' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("topLayoutGuide")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.None, "Use 'UIView.SafeAreaLayoutGuide.TopAnchor' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.None, "Use 'UIView.SafeAreaLayoutGuide.TopAnchor' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.IUILayoutSupport</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Developers should not use this deprecated property. Instead, they should use <see cref="P:UIKit.UIView.SafeAreaLayoutGuide" />.</summary>
        <value>The top-most extent for the specified onscreen content (read-only).</value>
        <remarks>This deprecated property holds the highest vertical extent of onscreen content. Used by Auto Layout constraints. Read-only.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TraitCollection">
      <MemberSignature Language="C#" Value="public virtual UIKit.UITraitCollection TraitCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UITraitCollection TraitCollection" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.TraitCollection" />
      <MemberSignature Language="F#" Value="member this.TraitCollection : UIKit.UITraitCollection" Usage="UIKit.UIViewController.TraitCollection" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:UIKit.IUITraitEnvironment.TraitCollection</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("traitCollection")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UITraitCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Characteristics of the display, such as it's idiom, scale, and size class.</summary>
        <value>A <see cref="T:UIKit.UITraitCollection" /> that relates to the display.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TraitCollectionDidChange">
      <MemberSignature Language="C#" Value="public virtual void TraitCollectionDidChange (UIKit.UITraitCollection previousTraitCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void TraitCollectionDidChange(class UIKit.UITraitCollection previousTraitCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.TraitCollectionDidChange(UIKit.UITraitCollection)" />
      <MemberSignature Language="F#" Value="abstract member TraitCollectionDidChange : UIKit.UITraitCollection -&gt; unit&#xA;override this.TraitCollectionDidChange : UIKit.UITraitCollection -&gt; unit" Usage="uIViewController.TraitCollectionDidChange previousTraitCollection" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:UIKit.IUITraitEnvironment.TraitCollectionDidChange(UIKit.UITraitCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("traitCollectionDidChange:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="previousTraitCollection" Type="UIKit.UITraitCollection" />
      </Parameters>
      <Docs>
        <param name="previousTraitCollection">The previous set of traits.  When this method is invoked, the <see cref="P:UIKit.UIViewController.TraitCollection" /> property has already been updated to reflect the new active traits.</param>
        <summary>Method invoked when the trait collection for the view controller changed.</summary>
        <remarks>
          <para>
	    Application developers can override this method to adjust the user interface
	    to react to changes to the user interface traits, such as
	    the horizontal and vertical size classes for the
	    application.
          </para>
          <para>Application developers must call the base implementation at the beginning of their override.</para>
          <para>This method is the appropriate place to register for 3D Touch with <see cref="M:UIKit.UIViewController.RegisterForPreviewingWithDelegate(UIKit.IUIViewControllerPreviewingDelegate,UIKit.UIView)" />:</para>
          <example>
            <code lang="csharp lang-csharp"><![CDATA[
public override void TraitCollectionDidChange(UITraitCollection previousTraitCollection)
{
    base.TraitCollectionDidChange(previousTraitCollection);

    if (TraitCollection.ForceTouchCapability == UIForceTouchCapability.Available) {
        // Regiser for Peek and Pop
        RegisterForPreviewingWithDelegate(new PreviewingDelegate(), View);
    }
}
    ]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transition">
      <MemberSignature Language="C#" Value="public virtual void Transition (UIKit.UIViewController fromViewController, UIKit.UIViewController toViewController, double duration, UIKit.UIViewAnimationOptions options, Action animations, UIKit.UICompletionHandler completionHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Transition(class UIKit.UIViewController fromViewController, class UIKit.UIViewController toViewController, float64 duration, valuetype UIKit.UIViewAnimationOptions options, class System.Action animations, class UIKit.UICompletionHandler completionHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.Transition(UIKit.UIViewController,UIKit.UIViewController,System.Double,UIKit.UIViewAnimationOptions,System.Action,UIKit.UICompletionHandler)" />
      <MemberSignature Language="F#" Value="abstract member Transition : UIKit.UIViewController * UIKit.UIViewController * double * UIKit.UIViewAnimationOptions * Action * UIKit.UICompletionHandler -&gt; unit&#xA;override this.Transition : UIKit.UIViewController * UIKit.UIViewController * double * UIKit.UIViewAnimationOptions * Action * UIKit.UICompletionHandler -&gt; unit" Usage="uIViewController.Transition (fromViewController, toViewController, duration, options, animations, completionHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("transitionFromViewController:toViewController:duration:options:animations:completion:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromViewController" Type="UIKit.UIViewController" />
        <Parameter Name="toViewController" Type="UIKit.UIViewController" />
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="options" Type="UIKit.UIViewAnimationOptions" />
        <Parameter Name="animations" Type="System.Action">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="completionHandler" Type="UIKit.UICompletionHandler">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDUICompletionHandler))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="fromViewController">The view controller that initiates the action and which is currently visible in the parent hierarchy.</param>
        <param name="toViewController">The target view controller (not currently visible).</param>
        <param name="duration">Total duration of the animations, measured in seconds.</param>
        <param name="options">A mask of options that determines how you want the animations performed.</param>
        <param name="animations">An action object containing the changes that the application developer wants to commit to the views. Here is where developers can modify any animatable properties of the views.</param>
        <param name="completionHandler">A completion action to be called when the animation completes.</param>
        <summary>Used for transitioning between two view controller's child view controllers.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TransitionAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;bool&gt; TransitionAsync (UIKit.UIViewController fromViewController, UIKit.UIViewController toViewController, double duration, UIKit.UIViewAnimationOptions options, Action animations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;bool&gt; TransitionAsync(class UIKit.UIViewController fromViewController, class UIKit.UIViewController toViewController, float64 duration, valuetype UIKit.UIViewAnimationOptions options, class System.Action animations) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.TransitionAsync(UIKit.UIViewController,UIKit.UIViewController,System.Double,UIKit.UIViewAnimationOptions,System.Action)" />
      <MemberSignature Language="F#" Value="abstract member TransitionAsync : UIKit.UIViewController * UIKit.UIViewController * double * UIKit.UIViewAnimationOptions * Action -&gt; System.Threading.Tasks.Task&lt;bool&gt;&#xA;override this.TransitionAsync : UIKit.UIViewController * UIKit.UIViewController * double * UIKit.UIViewAnimationOptions * Action -&gt; System.Threading.Tasks.Task&lt;bool&gt;" Usage="uIViewController.TransitionAsync (fromViewController, toViewController, duration, options, animations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromViewController" Type="UIKit.UIViewController" />
        <Parameter Name="toViewController" Type="UIKit.UIViewController" />
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="options" Type="UIKit.UIViewAnimationOptions" />
        <Parameter Name="animations" Type="System.Action">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="fromViewController">The view controller that initiates the action and which is currently visible in the parent hierarchy.</param>
        <param name="toViewController">The target view controller (not currently visible).</param>
        <param name="duration">Total duration of the animations, measured in seconds.</param>
        <param name="options">A mask of options that determines how you want the animations performed.</param>
        <param name="animations">An action object containing the changes that the application developer wants to commit to the views. Here is where developers can modify any animatable properties of the views.</param>
        <summary>Used for transitioning between two view controller's child view controllers.</summary>
        <returns>
          <para>A task that represents the asynchronous Transition operation.   The value of the TResult parameter is a UIKit.UICompletionHandler.</para>
        </returns>
        <remarks>
          <para copied="true">The TransitionAsync method is suitable to be used with C# async by returning control to the caller with a Task representing the operation.</para>
          <para copied="true">To be added.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TransitioningDelegate">
      <MemberSignature Language="C#" Value="public UIKit.IUIViewControllerTransitioningDelegate TransitioningDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.IUIViewControllerTransitioningDelegate TransitioningDelegate" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.TransitioningDelegate" />
      <MemberSignature Language="F#" Value="member this.TransitioningDelegate : UIKit.IUIViewControllerTransitioningDelegate with get, set" Usage="UIKit.UIViewController.TransitioningDelegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.IUIViewControllerTransitioningDelegate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A delegate object that is responsible for producing <see cref="T:UIKit.IUIViewControllerAnimatedTransitioning" />s for custom presentation.</summary>
        <value>
          <para>(More documentation for this node is coming)</para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterForPreviewingWithContext">
      <MemberSignature Language="C#" Value="public virtual void UnregisterForPreviewingWithContext (UIKit.IUIViewControllerPreviewing previewing);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UnregisterForPreviewingWithContext(class UIKit.IUIViewControllerPreviewing previewing) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.UnregisterForPreviewingWithContext(UIKit.IUIViewControllerPreviewing)" />
      <MemberSignature Language="F#" Value="abstract member UnregisterForPreviewingWithContext : UIKit.IUIViewControllerPreviewing -&gt; unit&#xA;override this.UnregisterForPreviewingWithContext : UIKit.IUIViewControllerPreviewing -&gt; unit" Usage="uIViewController.UnregisterForPreviewingWithContext previewing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("unregisterForPreviewingWithContext:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="previewing" Type="UIKit.IUIViewControllerPreviewing" />
      </Parameters>
      <Docs>
        <param name="previewing">To be added.</param>
        <summary>Stops <paramref name="previewing" /> from handling 3D Touch peek and pop input.</summary>
        <remarks>
          <para>Application developers who want to preserve the option to unregister for 3D Touch peek and pop must store a reference to the <see cref="T:UIKit.IUIViewControllerPreviewing" /> instance that is returned by <see cref="M:UIKit.UIViewController.RegisterForPreviewingWithDelegate(UIKit.IUIViewControllerPreviewingDelegate,UIKit.UIView)" />, so that they can later pass it to the <see cref="M:UIKit.UIViewController.UnregisterForPreviewingWithContext(UIKit.IUIViewControllerPreviewing)" /> method.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unwind">
      <MemberSignature Language="C#" Value="public virtual void Unwind (UIKit.UIStoryboardSegue unwindSegue, UIKit.UIViewController subsequentVC);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Unwind(class UIKit.UIStoryboardSegue unwindSegue, class UIKit.UIViewController subsequentVC) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.Unwind(UIKit.UIStoryboardSegue,UIKit.UIViewController)" />
      <MemberSignature Language="F#" Value="abstract member Unwind : UIKit.UIStoryboardSegue * UIKit.UIViewController -&gt; unit&#xA;override this.Unwind : UIKit.UIStoryboardSegue * UIKit.UIViewController -&gt; unit" Usage="uIViewController.Unwind (unwindSegue, subsequentVC)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("unwindForSegue:towardsViewController:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unwindSegue" Type="UIKit.UIStoryboardSegue" />
        <Parameter Name="subsequentVC" Type="UIKit.UIViewController" />
      </Parameters>
      <Docs>
        <param name="unwindSegue">Holds the in-process unwind <see cref="T:UIKit.UIStoryboardSegue" />.</param>
        <param name="subsequentVC">The next <see cref="T:UIKit.UIViewController" /> in the direction of the unwind.</param>
        <summary>Called during an unwind segue on any <see cref="T:UIKit.UIViewController" /> objects in the unwind path.</summary>
        <remarks>
          <para>This method is called on each <see cref="T:UIKit.UIViewController" /> in the unwind <see cref="T:UIKit.UIStoryboardSegue" /> path.</para>
          <para>When overridden in container <see cref="T:UIKit.UIViewController" /> classes, this method is responsible for configuring the container to properly display the <paramref name="subsequentVC" />. In a container <see cref="T:UIKit.UIViewController" /> that displayed a tab bar, for instance, this method would be used to set the tab item to match the <paramref name="subsequentVC" />.</para>
          <para>
            <see cref="T:UIKit.UIViewController" /> classes that are not containers should not override this method.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateFocusIfNeeded">
      <MemberSignature Language="C#" Value="public virtual void UpdateFocusIfNeeded ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UpdateFocusIfNeeded() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.UpdateFocusIfNeeded" />
      <MemberSignature Language="F#" Value="abstract member UpdateFocusIfNeeded : unit -&gt; unit&#xA;override this.UpdateFocusIfNeeded : unit -&gt; unit" Usage="uIViewController.UpdateFocusIfNeeded " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:UIKit.IUIFocusEnvironment.UpdateFocusIfNeeded</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("updateFocusIfNeeded")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>If any focus environment has a pending update, this method forces an immediate focus update. Unlike <see cref="M:UIKit.UIViewController.SetNeedsFocusUpdate" />, this method may be called by any <see cref="T:UIKit.UIViewController" />, whether it currently contains focus or not.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateViewConstraints">
      <MemberSignature Language="C#" Value="public virtual void UpdateViewConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UpdateViewConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.UpdateViewConstraints" />
      <MemberSignature Language="F#" Value="abstract member UpdateViewConstraints : unit -&gt; unit&#xA;override this.UpdateViewConstraints : unit -&gt; unit" Usage="uIViewController.UpdateViewConstraints " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("updateViewConstraints")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Called when the <see cref="T:UIKit.UIViewController" /> needs to recalculate its layout constraints.</summary>
        <remarks>
          <para>This method allows application developers to add or remove layout constraints dynamically. Application developers who override this method must call <c>base.UpdateViewConstraints()</c>.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="View">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIView View { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIView View" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.View" />
      <MemberSignature Language="F#" Value="member this.View : UIKit.UIView with get, set" Usage="UIKit.UIViewController.View" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("view", ObjCRuntime.ArgumentSemantic.Strong)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setView:", ObjCRuntime.ArgumentSemantic.Strong)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The view managed by this view controller.</summary>
        <value>
          <para>The <see cref="T:UIKit.UIView" /> that this <see cref="T:UIKit.UIViewController" /> manages.</para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>
          <para>A <see cref="T:UIKit.UIViewController" /> contains a single <see cref="T:UIKit.UIView" /> as the root of its view hierarchy. Such <see cref="T:UIKit.UIView" />s must only be referenced by a single <see cref="T:UIKit.UIViewController" />.</para>
          <para>When accessed for the first time, this property will lazily initialize the <see cref="T:UIKit.UIView" /> by calling the <see cref="M:UIKit.UIViewController.LoadView" /> function. To avoid lazy loading, the application developer should use the <see cref="P:UIKit.UIViewController.IsViewLoaded" /> property, which will return <see langword="false" /> if the <see cref="T:UIKit.UIView" /> has not been instantiated. </para>
          <para>In iOS 6 and later, <see cref="T:UIKit.UIView" />'s with active references are not scavenged in low-memory situations. In earlier versions, during low memory situations, this property may be unloaded and only re-initialized as display conditions warrant. In other words, object identity may not be preserved and the state of the <see cref="T:UIKit.UIView" /> will be lost unless application code takes steps to preserve and restore it. (Prior to unloading, the <see cref="M:UIKit.UIViewController.ViewWillUnload" /> method will be called. That method and <see cref="M:UIKit.UIViewController.ViewDidLoad" /> are the appropriate places to take such steps.)</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewDidAppear">
      <MemberSignature Language="C#" Value="public virtual void ViewDidAppear (bool animated);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ViewDidAppear(bool animated) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.ViewDidAppear(System.Boolean)" />
      <MemberSignature Language="F#" Value="abstract member ViewDidAppear : bool -&gt; unit&#xA;override this.ViewDidAppear : bool -&gt; unit" Usage="uIViewController.ViewDidAppear animated" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("viewDidAppear:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="animated" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="animated">
          <para>
            <see langword="true" /> if the appearance was animated.</para>
        </param>
        <summary>Called after the <see cref="P:UIKit.UIViewController.View" /> is added to the view hierarchy.
        </summary>
        <remarks>
          <para>This method is called after the <see cref="T:UIKit.UIView" /> that is <c>this</c> <see cref="T:UIKit.UIViewController" />’s <see cref="P:UIKit.UIViewController.View" /> property is added to the display <see cref="T:UIKit.UIView" /> hierarchy. </para>
          <para>Application developers who override this method must call <c>base.ViewDidAppear()</c> in their overridden method.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewDidDisappear">
      <MemberSignature Language="C#" Value="public virtual void ViewDidDisappear (bool animated);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ViewDidDisappear(bool animated) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.ViewDidDisappear(System.Boolean)" />
      <MemberSignature Language="F#" Value="abstract member ViewDidDisappear : bool -&gt; unit&#xA;override this.ViewDidDisappear : bool -&gt; unit" Usage="uIViewController.ViewDidDisappear animated" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("viewDidDisappear:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="animated" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="animated">
          <para>
            <see langword="true" /> if the disappearance was animated.</para>
        </param>
        <summary>This method is called after the <see cref="T:UIKit.UIView" />that is <c>this</c> <see cref="T:UIKit.UIViewController" />’s <see cref="P:UIKit.UIViewController.View" /> property is removed from the display <see cref="T:UIKit.UIView" /> hierarchy.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewDidLayoutSubviews">
      <MemberSignature Language="C#" Value="public virtual void ViewDidLayoutSubviews ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ViewDidLayoutSubviews() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.ViewDidLayoutSubviews" />
      <MemberSignature Language="F#" Value="abstract member ViewDidLayoutSubviews : unit -&gt; unit&#xA;override this.ViewDidLayoutSubviews : unit -&gt; unit" Usage="uIViewController.ViewDidLayoutSubviews " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("viewDidLayoutSubviews")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Called after the <see cref="P:UIKit.UIViewController.View" /> has laid out its subviews.</summary>
        <remarks>
          <para>This method is called after  this <see cref="T:UIKit.UIViewController" />’s <see cref="P:UIKit.UIViewController.View" /> has laid out its subviews (which happens when the <see cref="P:UIKit.UIView.Bounds" /> property is modified).</para>
        </remarks>
        <altmember cref="M:UIKit.UIView.LayoutSubviews" />
      </Docs>
    </Member>
    <Member MemberName="ViewDidLoad">
      <MemberSignature Language="C#" Value="public virtual void ViewDidLoad ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ViewDidLoad() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.ViewDidLoad" />
      <MemberSignature Language="F#" Value="abstract member ViewDidLoad : unit -&gt; unit&#xA;override this.ViewDidLoad : unit -&gt; unit" Usage="uIViewController.ViewDidLoad " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("viewDidLoad")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Called after the controller’s <see cref="P:UIKit.UIViewController.View" /> is loaded into memory.</summary>
        <remarks>
          <para>This method is called after <c>this</c> <see cref="T:UIKit.UIViewController" />'s <see cref="P:UIKit.UIViewController.View" /> and its entire view hierarchy have been loaded into memory. This method is called whether the <see cref="T:UIKit.UIView" /> was loaded from a .xib file or programmatically.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewDidUnload">
      <MemberSignature Language="C#" Value="public virtual void ViewDidUnload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ViewDidUnload() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.ViewDidUnload" />
      <MemberSignature Language="F#" Value="abstract member ViewDidUnload : unit -&gt; unit&#xA;override this.ViewDidUnload : unit -&gt; unit" Usage="uIViewController.ViewDidUnload " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("viewDidUnload")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>In iOS 6 and later, this method is never called. In prior versions it was called when the controller’s view was released from memory. </summary>
        <remarks>
          <para>In iOS 6 and later, <see cref="T:UIKit.UIView" />'s that are referenced by live objects are not scavenged during low-memory situations. In other words, in iOS 6 and later, this method is never called. In previous versions, application developers may override this method to ensure that all references to the scavenged <see cref="P:UIKit.UIViewController.View" /> have been removed. When this method is called, <see cref="P:UIKit.UIViewController.View" /> is <see langword="null" />.</para>
        </remarks>
        <altmember cref="M:UIKit.UIViewController.ViewWillUnload" />
      </Docs>
    </Member>
    <Member MemberName="ViewIfLoaded">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIView ViewIfLoaded { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIView ViewIfLoaded" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.ViewIfLoaded" />
      <MemberSignature Language="F#" Value="member this.ViewIfLoaded : UIKit.UIView" Usage="UIKit.UIViewController.ViewIfLoaded" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("viewIfLoaded", ObjCRuntime.ArgumentSemantic.Strong)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns the <see cref="P:UIKit.UIViewController.View" /> if it has been instantiated; otherwise, returns <see langword="null" />.</summary>
        <value>
          <para>A <see langword="null" /> return indicates that the <see cref="P:UIKit.UIViewController.View" /> has not yet been loaded.</para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>
          <para>Because <see cref="T:UIKit.UIView" /> are relatively heavyweight compared to T<see cref="T:UIKit.UIViewController" /> objects, the <see cref="P:UIKit.UIViewController.View" /> object is lazily initialized. Developers can test if the <see cref="P:UIKit.UIViewController.View" /> has been initialized by calling this method, which returns <see langword="null" /> if the <see cref="P:UIKit.UIViewController.View" /> had not yet been loaded. Developers can call <see cref="M:UIKit.UIViewController.LoadViewIfNeeded" /> to force the loading of the <see cref="P:UIKit.UIViewController.View" />.</para>
          <example>
            <code lang="csharp lang-csharp"><![CDATA[
var newVC = UIStoryboard.FromName("Main", NSBundle.MainBundle).InstantiateInitialViewController();
if (newVC.ViewIfLoaded == null)
{
    //This call blocks until the View is instantiated
    newVC.LoadViewIfNeeded();
}
    ]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewLayoutMarginsDidChange">
      <MemberSignature Language="C#" Value="public virtual void ViewLayoutMarginsDidChange ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ViewLayoutMarginsDidChange() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.ViewLayoutMarginsDidChange" />
      <MemberSignature Language="F#" Value="abstract member ViewLayoutMarginsDidChange : unit -&gt; unit&#xA;override this.ViewLayoutMarginsDidChange : unit -&gt; unit" Usage="uIViewController.ViewLayoutMarginsDidChange " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Overriding this method requires a call to the overriden method.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Export("viewLayoutMarginsDidChange")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.RequiresSuper</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Method that is called when the layout margins for the view are changed.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewRespectsSystemMinimumLayoutMargins">
      <MemberSignature Language="C#" Value="public virtual bool ViewRespectsSystemMinimumLayoutMargins { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ViewRespectsSystemMinimumLayoutMargins" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.ViewRespectsSystemMinimumLayoutMargins" />
      <MemberSignature Language="F#" Value="member this.ViewRespectsSystemMinimumLayoutMargins : bool with get, set" Usage="UIKit.UIViewController.ViewRespectsSystemMinimumLayoutMargins" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("viewRespectsSystemMinimumLayoutMargins")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setViewRespectsSystemMinimumLayoutMargins:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a Boolean value that controls whether the view for the view controller respects the minimum layout margins.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewSafeAreaInsetsDidChange">
      <MemberSignature Language="C#" Value="public virtual void ViewSafeAreaInsetsDidChange ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ViewSafeAreaInsetsDidChange() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.ViewSafeAreaInsetsDidChange" />
      <MemberSignature Language="F#" Value="abstract member ViewSafeAreaInsetsDidChange : unit -&gt; unit&#xA;override this.ViewSafeAreaInsetsDidChange : unit -&gt; unit" Usage="uIViewController.ViewSafeAreaInsetsDidChange " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Overriding this method requires a call to the overriden method.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Export("viewSafeAreaInsetsDidChange")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.RequiresSuper</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Method that is called when the safe area insets are changed by size changes to system bars or by changes to the <see cref="P:UIKit.UIViewController.AdditionalSafeAreaInsets" /> property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewWillAppear">
      <MemberSignature Language="C#" Value="public virtual void ViewWillAppear (bool animated);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ViewWillAppear(bool animated) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.ViewWillAppear(System.Boolean)" />
      <MemberSignature Language="F#" Value="abstract member ViewWillAppear : bool -&gt; unit&#xA;override this.ViewWillAppear : bool -&gt; unit" Usage="uIViewController.ViewWillAppear animated" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("viewWillAppear:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="animated" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="animated">
          <para>If the appearance will be animated.</para>
        </param>
        <summary>Called prior to the <see cref="P:UIKit.UIViewController.View" /> being added to the view hierarchy.
        </summary>
        <remarks>
          <para>This method is called prior to the <see cref="T:UIKit.UIView" /> that is this <see cref="T:UIKit.UIViewController" />’s <see cref="P:UIKit.UIViewController.View" /> property being added to the display <see cref="T:UIKit.UIView" /> hierarchy. </para>
          <para>Application developers who override this method must call <c>base.ViewWillAppear()</c> in their overridden method.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewWillDisappear">
      <MemberSignature Language="C#" Value="public virtual void ViewWillDisappear (bool animated);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ViewWillDisappear(bool animated) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.ViewWillDisappear(System.Boolean)" />
      <MemberSignature Language="F#" Value="abstract member ViewWillDisappear : bool -&gt; unit&#xA;override this.ViewWillDisappear : bool -&gt; unit" Usage="uIViewController.ViewWillDisappear animated" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("viewWillDisappear:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="animated" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="animated">
          <para>If the appearance will be animated.</para>
        </param>
        <summary>This method is called prior to the removal of the <see cref="T:UIKit.UIView" />that is this <see cref="T:UIKit.UIViewController" />’s <see cref="P:UIKit.UIViewController.View" /> from the display <see cref="T:UIKit.UIView" /> hierarchy.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewWillLayoutSubviews">
      <MemberSignature Language="C#" Value="public virtual void ViewWillLayoutSubviews ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ViewWillLayoutSubviews() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.ViewWillLayoutSubviews" />
      <MemberSignature Language="F#" Value="abstract member ViewWillLayoutSubviews : unit -&gt; unit&#xA;override this.ViewWillLayoutSubviews : unit -&gt; unit" Usage="uIViewController.ViewWillLayoutSubviews " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("viewWillLayoutSubviews")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Called before the <see cref="P:UIKit.UIViewController.View" /> lays out its subviews.</summary>
        <remarks>
          <para>This method is called before this <see cref="T:UIKit.UIViewController" />’s <see cref="P:UIKit.UIViewController.View" /> lays out its subviews (which is triggered when the <see cref="P:UIKit.UIView.Bounds" /> property is modified).</para>
        </remarks>
        <altmember cref="M:UIKit.UIView.LayoutSubviews" />
        <altmember cref="M:UIKit.UIViewController.ViewDidLayoutSubviews" />
      </Docs>
    </Member>
    <Member MemberName="ViewWillTransitionToSize">
      <MemberSignature Language="C#" Value="public virtual void ViewWillTransitionToSize (CoreGraphics.CGSize toSize, UIKit.IUIViewControllerTransitionCoordinator coordinator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ViewWillTransitionToSize(valuetype CoreGraphics.CGSize toSize, class UIKit.IUIViewControllerTransitionCoordinator coordinator) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.ViewWillTransitionToSize(CoreGraphics.CGSize,UIKit.IUIViewControllerTransitionCoordinator)" />
      <MemberSignature Language="F#" Value="abstract member ViewWillTransitionToSize : CoreGraphics.CGSize * UIKit.IUIViewControllerTransitionCoordinator -&gt; unit&#xA;override this.ViewWillTransitionToSize : CoreGraphics.CGSize * UIKit.IUIViewControllerTransitionCoordinator -&gt; unit" Usage="uIViewController.ViewWillTransitionToSize (toSize, coordinator)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:UIKit.IUIContentContainer.ViewWillTransitionToSize(CoreGraphics.CGSize,UIKit.IUIViewControllerTransitionCoordinator)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("viewWillTransitionToSize:withTransitionCoordinator:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSize" Type="CoreGraphics.CGSize" />
        <Parameter Name="coordinator" Type="UIKit.IUIViewControllerTransitionCoordinator" />
      </Parameters>
      <Docs>
        <param name="toSize">To be added.</param>
        <param name="coordinator">To be added.</param>
        <summary>For <see cref="T:UIKit.UIViewController" /> objects that are part of an app extension, called prior to the <see cref="P:UIKit.UIViewController.View" /> being resized.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewWillUnload">
      <MemberSignature Language="C#" Value="public virtual void ViewWillUnload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ViewWillUnload() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.ViewWillUnload" />
      <MemberSignature Language="F#" Value="abstract member ViewWillUnload : unit -&gt; unit&#xA;override this.ViewWillUnload : unit -&gt; unit" Usage="uIViewController.ViewWillUnload " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("viewWillUnload")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>In iOS 6 and later, this method is never called. In prior versions it was called prior to the controller’s view was released from memory. </summary>
        <remarks>
          <para>In iOS 6 and later, <see cref="T:UIKit.UIView" />'s that are referenced by live objects are not scavenged during low-memory situations. In other words, in iOS 6 and later, this method is never called. In previous versions, application developers may override this method to ensure that the state of the view can be restored when it is re-initialized.</para>
        </remarks>
        <altmember cref="M:UIKit.UIViewController.ViewDidUnload" />
      </Docs>
    </Member>
    <Member MemberName="WantsFullScreenLayout">
      <MemberSignature Language="C#" Value="public virtual bool WantsFullScreenLayout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool WantsFullScreenLayout" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.WantsFullScreenLayout" />
      <MemberSignature Language="F#" Value="member this.WantsFullScreenLayout : bool with get, set" Usage="UIKit.UIViewController.WantsFullScreenLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, "Use 'EdgesForExtendedLayout', 'ExtendedLayoutIncludesOpaqueBars' and 'AutomaticallyAdjustsScrollViewInsets' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("wantsFullScreenLayout")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, "Use 'EdgesForExtendedLayout', 'ExtendedLayoutIncludesOpaqueBars' and 'AutomaticallyAdjustsScrollViewInsets' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setWantsFullScreenLayout:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, "Use 'EdgesForExtendedLayout', 'ExtendedLayoutIncludesOpaqueBars' and 'AutomaticallyAdjustsScrollViewInsets' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see langword="true" /> if the view should overlap the status bar.</summary>
        <value>The default value is <see langword="false" />.</value>
        <remarks>
          <para>When this property is at it's default value of <see langword="false" />, the <see cref="T:UIKit.UIViewController" />'s <see cref="P:UIKit.UIViewController.View" />'s <see cref="P:UIKit.UIView.Frame" /> is sized so that it does not include the area under the device's status bar (the area at the stop of the screen that shows, e.g., signal and carrier, battery charge, etc.). If set to <see langword="true" /> and <see cref="P:UIKit.UIApplication.StatusBarStyle" /> is set to <see cref="F:UIKit.UIStatusBarStyle.BlackTranslucent" />, the <see cref="P:UIKit.UIViewController.View" /> will be visible behind the status bar.</para>
          <example>
            <code lang="csharp lang-csharp"><![CDATA[
public override void ViewDidLoad ()
{
    base.ViewDidLoad ();

    WantsFullScreenLayout = true;
    UIApplication.SharedApplication.StatusBarStyle = UIStatusBarStyle.BlackTranslucent;
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WeakTransitioningDelegate">
      <MemberSignature Language="C#" Value="public virtual Foundation.NSObject WeakTransitioningDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Foundation.NSObject WeakTransitioningDelegate" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIViewController.WeakTransitioningDelegate" />
      <MemberSignature Language="F#" Value="member this.WeakTransitioningDelegate : Foundation.NSObject with get, set" Usage="UIKit.UIViewController.WeakTransitioningDelegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("transitioningDelegate", ObjCRuntime.ArgumentSemantic.UnsafeUnretained)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setTransitioningDelegate:", ObjCRuntime.ArgumentSemantic.UnsafeUnretained)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The delegate object used to provide controllers for transition animations and interactions.</summary>
        <value>
          <para>(More documentation for this node is coming)</para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WillAnimateFirstHalfOfRotation">
      <MemberSignature Language="C#" Value="public virtual void WillAnimateFirstHalfOfRotation (UIKit.UIInterfaceOrientation toInterfaceOrientation, double duration);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WillAnimateFirstHalfOfRotation(valuetype UIKit.UIInterfaceOrientation toInterfaceOrientation, float64 duration) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.WillAnimateFirstHalfOfRotation(UIKit.UIInterfaceOrientation,System.Double)" />
      <MemberSignature Language="F#" Value="abstract member WillAnimateFirstHalfOfRotation : UIKit.UIInterfaceOrientation * double -&gt; unit&#xA;override this.WillAnimateFirstHalfOfRotation : UIKit.UIInterfaceOrientation * double -&gt; unit" Usage="uIViewController.WillAnimateFirstHalfOfRotation (toInterfaceOrientation, duration)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("willAnimateFirstHalfOfRotationToInterfaceOrientation:duration:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 5, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toInterfaceOrientation" Type="UIKit.UIInterfaceOrientation" />
        <Parameter Name="duration" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="toInterfaceOrientation">
          <para>The new orientation.</para>
        </param>
        <param name="duration">
          <para>The duration of the first half of the rotation animation, in seconds.</para>
        </param>
        <summary>Deprecated method sent during the first half of a rotation. Application developers should instead use <see cref="M:UIKit.UIViewController.WillAnimateRotation(UIKit.UIInterfaceOrientation,System.Double)" />.</summary>
        <remarks>
          <para>Two-step rotations are deprecated and application developers should instead use single-step rotations (see <see cref="M:UIKit.UIViewController.WillAnimateRotation(UIKit.UIInterfaceOrientation,System.Double)" /> ).</para>
          <para>When this method is called, the <see cref="P:UIKit.UIViewController.InterfaceOrientation" /> is set to the old orientation. </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WillAnimateRotation">
      <MemberSignature Language="C#" Value="public virtual void WillAnimateRotation (UIKit.UIInterfaceOrientation toInterfaceOrientation, double duration);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WillAnimateRotation(valuetype UIKit.UIInterfaceOrientation toInterfaceOrientation, float64 duration) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.WillAnimateRotation(UIKit.UIInterfaceOrientation,System.Double)" />
      <MemberSignature Language="F#" Value="abstract member WillAnimateRotation : UIKit.UIInterfaceOrientation * double -&gt; unit&#xA;override this.WillAnimateRotation : UIKit.UIInterfaceOrientation * double -&gt; unit" Usage="uIViewController.WillAnimateRotation (toInterfaceOrientation, duration)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("willAnimateRotationToInterfaceOrientation:duration:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, "Use Adaptive View Controllers instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toInterfaceOrientation" Type="UIKit.UIInterfaceOrientation" />
        <Parameter Name="duration" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="toInterfaceOrientation">
          <para>The new orientation.</para>
        </param>
        <param name="duration">
          <para>The duration of the rotation animation, in seconds.</para>
        </param>
        <summary>Called prior to a one-step interface rotation.</summary>
        <remarks>
          <para>This method is called from with the animation block associated with a user interface rotation. When this method is called, the <see cref="P:UIKit.UIViewController.InterfaceOrientation" /> is set to the new interface orientation and the <see cref="P:UIKit.UIView.Bounds" /> of the <see cref="T:UIKit.UIViewController" />'s <see cref="P:UIKit.UIViewController.View" /> have been modified.</para>
        </remarks>
        <altmember cref="M:UIKit.UIViewController.WillRotate" />
        <altmember cref="M:UIKit.UIViewController.DidRotate" />
      </Docs>
    </Member>
    <Member MemberName="WillAnimateSecondHalfOfRotation">
      <MemberSignature Language="C#" Value="public virtual void WillAnimateSecondHalfOfRotation (UIKit.UIInterfaceOrientation fromInterfaceOrientation, double duration);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WillAnimateSecondHalfOfRotation(valuetype UIKit.UIInterfaceOrientation fromInterfaceOrientation, float64 duration) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.WillAnimateSecondHalfOfRotation(UIKit.UIInterfaceOrientation,System.Double)" />
      <MemberSignature Language="F#" Value="abstract member WillAnimateSecondHalfOfRotation : UIKit.UIInterfaceOrientation * double -&gt; unit&#xA;override this.WillAnimateSecondHalfOfRotation : UIKit.UIInterfaceOrientation * double -&gt; unit" Usage="uIViewController.WillAnimateSecondHalfOfRotation (fromInterfaceOrientation, duration)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("willAnimateSecondHalfOfRotationFromInterfaceOrientation:duration:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 5, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInterfaceOrientation" Type="UIKit.UIInterfaceOrientation" />
        <Parameter Name="duration" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="fromInterfaceOrientation">
          <para>The old orientation.</para>
        </param>
        <param name="duration">
          <para>The duration of the second half of the rotation animation, in seconds.</para>
        </param>
        <summary>Deprecated method sent during the second half of a rotation. Application developers should instead use <see cref="M:UIKit.UIViewController.WillAnimateRotation(UIKit.UIInterfaceOrientation,System.Double)" />.</summary>
        <remarks>
          <para>Two-step rotations are deprecated and application developers should instead use single-step rotations (see <see cref="M:UIKit.UIViewController.WillAnimateRotation(UIKit.UIInterfaceOrientation,System.Double)" /> ).</para>
          <para>When this method is called, the <see cref="P:UIKit.UIViewController.InterfaceOrientation" /> is set to the new orientation. </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WillMoveToParentViewController">
      <MemberSignature Language="C#" Value="public virtual void WillMoveToParentViewController (UIKit.UIViewController parent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WillMoveToParentViewController(class UIKit.UIViewController parent) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.WillMoveToParentViewController(UIKit.UIViewController)" />
      <MemberSignature Language="F#" Value="abstract member WillMoveToParentViewController : UIKit.UIViewController -&gt; unit&#xA;override this.WillMoveToParentViewController : UIKit.UIViewController -&gt; unit" Usage="uIViewController.WillMoveToParentViewController parent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("willMoveToParentViewController:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parent" Type="UIKit.UIViewController" />
      </Parameters>
      <Docs>
        <param name="parent">
          <para>The new parent view controller, or <see langword="null" /> if there won't be a new parent.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Called prior to adding or removing <c>this</c> from a container <see cref="T:UIKit.UIViewController" />.</summary>
        <remarks>
          <para>Application developers may override this method in their custom container <see cref="T:UIKit.UIViewController" />s. Application developers who implement their own container <see cref="T:UIKit.UIViewController" />s must call this method with the <paramref name="parent" /> parameter set to <see langword="null" /> prior to calling <see cref="M:UIKit.UIViewController.RemoveFromParentViewController" />. </para>
        </remarks>
        <altmember cref="M:UIKit.UIViewController.RemoveFromParentViewController" />
      </Docs>
    </Member>
    <Member MemberName="WillRotate">
      <MemberSignature Language="C#" Value="public virtual void WillRotate (UIKit.UIInterfaceOrientation toInterfaceOrientation, double duration);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WillRotate(valuetype UIKit.UIInterfaceOrientation toInterfaceOrientation, float64 duration) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.WillRotate(UIKit.UIInterfaceOrientation,System.Double)" />
      <MemberSignature Language="F#" Value="abstract member WillRotate : UIKit.UIInterfaceOrientation * double -&gt; unit&#xA;override this.WillRotate : UIKit.UIInterfaceOrientation * double -&gt; unit" Usage="uIViewController.WillRotate (toInterfaceOrientation, duration)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("willRotateToInterfaceOrientation:duration:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, "Use Adaptive View Controllers instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toInterfaceOrientation" Type="UIKit.UIInterfaceOrientation" />
        <Parameter Name="duration" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="toInterfaceOrientation">
          <para>The new interface orientation.</para>
        </param>
        <param name="duration">
          <para>The duration of the rotation, in seconds.</para>
        </param>
        <summary>Called prior to a user interface rotation.</summary>
        <remarks>
          <para>Application developers may override this method to disable expensive drawing operations, media playback, or other resource-intensive operations during a user interface rotation.</para>
          <para>When this method is called, the <see cref="P:UIKit.UIViewController.InterfaceOrientation" /> is set to the original <see cref="T:UIKit.UIInterfaceOrientation" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WillTransitionToTraitCollection">
      <MemberSignature Language="C#" Value="public virtual void WillTransitionToTraitCollection (UIKit.UITraitCollection traitCollection, UIKit.IUIViewControllerTransitionCoordinator coordinator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WillTransitionToTraitCollection(class UIKit.UITraitCollection traitCollection, class UIKit.IUIViewControllerTransitionCoordinator coordinator) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIViewController.WillTransitionToTraitCollection(UIKit.UITraitCollection,UIKit.IUIViewControllerTransitionCoordinator)" />
      <MemberSignature Language="F#" Value="abstract member WillTransitionToTraitCollection : UIKit.UITraitCollection * UIKit.IUIViewControllerTransitionCoordinator -&gt; unit&#xA;override this.WillTransitionToTraitCollection : UIKit.UITraitCollection * UIKit.IUIViewControllerTransitionCoordinator -&gt; unit" Usage="uIViewController.WillTransitionToTraitCollection (traitCollection, coordinator)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:UIKit.IUIContentContainer.WillTransitionToTraitCollection(UIKit.UITraitCollection,UIKit.IUIViewControllerTransitionCoordinator)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("willTransitionToTraitCollection:withTransitionCoordinator:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="traitCollection" Type="UIKit.UITraitCollection" />
        <Parameter Name="coordinator" Type="UIKit.IUIViewControllerTransitionCoordinator" />
      </Parameters>
      <Docs>
        <param name="traitCollection">The new trait collection.</param>
        <param name="coordinator">The <see cref="T:UIKit.IUIViewControllerTransitionCoordinator" /> coordinating the transition.</param>
        <summary>Notifies <c>this</c> that its trait collection will change to <paramref name="traitCollection" />, as coordinated by <paramref name="coordinator" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
