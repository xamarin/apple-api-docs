<Type Name="UIView" FullName="UIKit.UIView">
  <TypeSignature Language="C#" Value="public class UIView : UIKit.UIResponder, CoreAnimation.ICALayerDelegate, Foundation.INSCoding, IDisposable, System.Collections.IEnumerable, UIKit.IUIAccessibilityIdentification, UIKit.IUIAppearance, UIKit.IUIAppearanceContainer, UIKit.IUICoordinateSpace, UIKit.IUIDynamicItem, UIKit.IUIFocusItem, UIKit.IUIFocusItemContainer, UIKit.IUITraitEnvironment" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit UIView extends UIKit.UIResponder implements class CoreAnimation.ICALayerDelegate, class Foundation.INSCoding, class ObjCRuntime.INativeObject, class System.Collections.IEnumerable, class System.IDisposable, class UIKit.IUIAccessibilityIdentification, class UIKit.IUIAppearance, class UIKit.IUIAppearanceContainer, class UIKit.IUICoordinateSpace, class UIKit.IUIDynamicItem, class UIKit.IUIFocusEnvironment, class UIKit.IUIFocusItem, class UIKit.IUIFocusItemContainer, class UIKit.IUITraitEnvironment" />
  <TypeSignature Language="DocId" Value="T:UIKit.UIView" />
  <TypeSignature Language="F#" Value="type UIView = class&#xA;    inherit UIResponder&#xA;    interface IEnumerable&#xA;    interface INSCoding&#xA;    interface INativeObject&#xA;    interface IDisposable&#xA;    interface IUIAccessibilityIdentification&#xA;    interface IUIAppearance&#xA;    interface IUIAppearanceContainer&#xA;    interface IUICoordinateSpace&#xA;    interface IUIDynamicItem&#xA;    interface IUIFocusEnvironment&#xA;    interface IUIFocusItem&#xA;    interface IUIFocusItemContainer&#xA;    interface IUITraitEnvironment&#xA;    interface ICALayerDelegate" />
  <AssemblyInfo>
    <AssemblyName>Xamarin.iOS</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>UIKit.UIResponder</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>CoreAnimation.ICALayerDelegate</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Foundation.INSCoding</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>ObjCRuntime.INativeObject</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>UIKit.IUIAccessibilityIdentification</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>UIKit.IUIAppearance</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>UIKit.IUIAppearanceContainer</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>UIKit.IUICoordinateSpace</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>UIKit.IUIDynamicItem</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>UIKit.IUIFocusEnvironment</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>UIKit.IUIFocusItem</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>UIKit.IUIFocusItemContainer</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>UIKit.IUITraitEnvironment</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>Foundation.Register("UIView", true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Base class used for components that want to render themselves and respond to events.</summary>
    <remarks>
      <para>
        The UIView class is a rectangular area on the screen that is
        responsible for displaying content and handling user interactions
        with that content. It can also contain other views, allowing the developer to
        create complex interactive controls.  UIView can thus be used as
        either a standalone control, or as a full screen of content built from
        many other independent UIViews. 
      </para>
      <para>Views have three major responsibilities:</para>
      <list type="bullet">
        <item>
          <term>
            Visualization: UIView instances are responsible for displaying
            their content, typically this is done by implementing a draw
            method using either <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=Core%20Graphics&amp;scope=Xamarin" title="N:CoreGraphics">N:CoreGraphics</a></format>,
            OpenGL or customizing some of their visual properties.  Views 
            also have built-in support for animating elements of the view.  
          </term>
        </item>
        <item>
          <term>
            Managing Layout and Subviews: UIViews are responsible for
            managing their layout in response to changes in size and
            orientation. This includes re-drawing any content they manage,
            as well as repositioning children views. This is most often in
            response to size of the UIView. For instance, if a view
            represents a button, the location of corners would change
            according to size. Or, if the device was rotated, the view might
            get resized (or it might resize it's child views).
          </term>
        </item>
        <item>
          <term>
            Event Handling: UIViews are a natural place to handle touch
            events since they are self-contained user interface elements.
            UIViews subclass the <see cref="T:UIKit.UIResponder" />
            class, so they participate both on system events (like motion
            and actions) as well as being able to process touch events.
            
          </term>
        </item>
      </list>
      <format type="text/html">
        <h2>Event Handling</h2>
      </format>
      <para>
        UIViews can handle touch events in two ways.  Developers use the
        high-level gesture recognizer API to detect and handle gestures, or roll their own event handling by using the low-level
        interface that provides detailed touch events as they happen: every
        time a finger touches the screen or is lifted as well as motion of
        those fingers.  Both are covered below
      </para>
      <para>
        To cause the UIView to respond to user input by updating its
        display, developers should call the
        <see cref="M:UIKit.UIView.SetNeedsDisplayInRect(CoreGraphics.CGRect)" /> or
        <see cref="M:UIKit.UIView.SetNeedsDisplayInRect(CoreGraphics.CGRect)" /> which will queue a call to the developer's
        <see cref="M:UIKit.UIView.Draw(CoreGraphics.CGRect)" /> method
        where the developer has implemented logic to re-render the control with the new state.
      </para>
      <para>
        Event delivery can be turned off either by setting the
        <see cref="P:UIKit.UIView.UserInteractionEnabled" /> to false or you can
        disable them temporarily at the application level by calling
        <see cref="M:UIKit.UIApplication.BeginIgnoringInteractionEvents" />.  In
        both cases, events destined for the view are dropped and are not
        delivered to the views.
      </para>
      <para>
        Events are disabled while animation are playing back.  Devs can
        change this behavior when using explicit animations by using the
        <see cref="T:UIKit.UIViewAnimationOptions" />'s AllowUserInteraction
        flag in the animation.
      </para>
      <format type="text/html">
        <h3>Event Handling with Gesture Recognizers</h3>
      </format>
      <para>
        Interacting with touch interfaces has lead to a series of common
        gesture idioms that are used everywhere.  Gestures like swiping,
        panning, long-presses, pinching rotating and tapping.  iOS makes the
        process of detecting these common gesture idioms very easy by
        providing Gesture Recognizers.  These are objects that inherit from
        the UIGestureRecognizer class and can detect various standard
        gesture idioms.  The built-in recognizers include:
      </para>
      <list type="bullet">
        <item>
          <term>
            <see cref="T:UIKit.UILongPressGestureRecognizer" />
          </term>
        </item>
        <item>
          <term>
            <see cref="T:UIKit.UIPanGestureRecognizer" />
          </term>
        </item>
        <item>
          <term>
            <see cref="T:UIKit.UIPinchGestureRecognizer" />
          </term>
        </item>
        <item>
          <term>
            <see cref="T:UIKit.UIRotationGestureRecognizer" />
          </term>
        </item>
        <item>
          <term>
            <see cref="T:UIKit.UISwipeGestureRecognizer" />
          </term>
        </item>
        <item>
          <term>
            <see cref="T:UIKit.UITapGestureRecognizer" />
          </term>
        </item>
      </list>
      <para>
        In addition, developers can create their own custom gesture recognizer by
        subclassing <see cref="T:UIKit.UIGestureRecognizer" />.
      </para>
      <para>
        Developers use the recognizer by creating an instance of the
        specific kind of recognizer that is needed, optionally setting some
        parameters, and adding it to the view by calling
        AddGestureRecognizer.  It is possible to attach multiple gesture
        recognizers to a single view.
      </para>
      <para>
        For example, the following code creates a gesture recognizer that
        detects a panning gesture and assigns it to myView:
        
      </para>
      <example>
        <code lang="C#"><![CDATA[
var recognizer = new UIPanGestureRecognizer ((g) => {
  Console.WriteLine ("Panning detected");
  Console.WriteLine ("Gesture recognizer state: {0}", g.State);
});

myView.AddGestureRecognizer (recognizer);
        ]]></code>
      </example>
      <para>
        The parameter passed to the lambda (the "g" parameter in the above code)
        is an instance of the gesture recognizer that detected the gesture.
        The developr can query the parameters of the recognized query by looking at
        the properties in the recognizer; the
        <see cref="P:UIKit.UIGestureRecognizer.State" /> property contains the
        recognizer state.
        
      </para>
      <format type="text/html">
        <h3>Event Handling with method Overrides</h3>
      </format>
      <para>
        Although Gesture Recognizers provide a high-level and convenient way
        of capturing many touch events, they do not cover every
        possibility. For those cases, developers should subclass UIView and
        override one or more of the following methods inherited from
        UIResponder:
      </para>
      <list type="bullet">
        <item>
          <term>
            <see cref="M:UIKit.UIResponder.TouchesBegan(Foundation.NSSet,UIKit.UIEvent)" />:
            sent when one or more fingers touch the screen.
          </term>
        </item>
        <item>
          <term>
            <see cref="M:UIKit.UIResponder.TouchesMoved(Foundation.NSSet,UIKit.UIEvent)" />:
            sent when one or more fingers move.
          </term>
        </item>
        <item>
          <term>
            <see cref="M:UIKit.UIResponder.TouchesEnded(Foundation.NSSet,UIKit.UIEvent)" />:
            sent when one or more fingers are lifted from the screen.
          </term>
        </item>
        <item>
          <term>
            <see cref="M:UIKit.UIResponder.TouchesCancelled(Foundation.NSSet,UIKit.UIEvent)" />:
            sent when the touch is cancelled by the system (for example if
            the phone interrupts your application).
          </term>
        </item>
      </list>
      <para>
        UIViews by default only handle a single touch event at once.  If you
        want your view to handle multiple touches, you must set the
        <see cref="P:UIKit.UIView.MultipleTouchEnabled" /> to true.
      </para>
      <para>
        iOS creates a <see cref="T:UIKit.UIEvent" /> object any time a finger
        touches the screen, moves or is removed from the screen.  The <see cref="T:UIKit.UIEvent" /> encapsulates all of the touches
        that are taking place on the screen at this point, even those that
        do not belong to this view.  In addition to the <see cref="T:UIKit.UIEvent" />, there is an <see cref="T:Foundation.NSSet" /> containing <see cref="T:UIKit.UITouch" /> objects that represent the state
        of each finger on the screen for this particular view.
      </para>
      <para>
        If the application handles touches directly, developers can
        override the <see cref="M:UIKit.UIView.GestureRecognizerShouldBegin(UIKit.UIGestureRecognizer)" />
        method to control whether an associated
        <see cref="T:UIKit.UIGestureRecognizer" /> should execute or not.
        
      </para>
      <format type="text/html">
        <h2>Creating Views</h2>
      </format>
      <para>
        UIViews are typically created by invoking the constructor that takes
        a frame as its parameter (the frame is of type
        <see cref="T:System.Drawing.RectangleF" />), for example:
      </para>
      <example>
        <code lang="C#"><![CDATA[
var myView = new UIView (new RectangleF (0, 0, 100, 100));
]]></code>
      </example>
      <para>
        Most subclasses of UIView will provide a constructor that takes the
        initial frame, just like UIView.  The section below on subclassing
        UIView has more information on how to do
        this.
      </para>
      <para>
         The developer should configure the
        <see cref="P:UIKit.UIView.AutoresizingMask" /> property, which determines how the
        view will be resized when
        <see cref="M:UIKit.UIView.SetNeedsLayout" /> is invoked or when the geometry of the
        view container changes (for example, in response to a device
        rotation).
      </para>
      <para>
        After creating a view, the developer adds it to a containing view.
        On the main screen, this could be a UIWindow or it could be the
        <see cref="P:UIKit.UIViewController.View" /> property of the current
        <see cref="T:UIKit.UIViewController" />. This is done using one of the
        following methods:
      </para>
      <list type="bullet">
        <item>
          <term>
            <see cref="M:UIKit.UIView.AddSubview(UIKit.UIView)" />
          </term>
        </item>
        <item>
          <term>
            <see cref="M:UIKit.UIView.InsertSubview(UIKit.UIView,System.nint)" />
          </term>
        </item>
        <item>
          <term>
            <see cref="M:UIKit.UIView.InsertSubviewAbove(UIKit.UIView,UIKit.UIView)" />
          </term>
        </item>
        <item>
          <term>
            <see cref="M:UIKit.UIView.InsertSubviewBelow(UIKit.UIView,UIKit.UIView)" />
          </term>
        </item>
      </list>
      <para>
        Although developers can use the above APIs to add subviews to any
        UIView, Apple advises against extending
        existing high-level views by adding subviews to them.  Instead developers should use the public API those high-level
        views expose.
      </para>
      <format type="text/html">
        <h2>Bounds and Sizes</h2>
      </format>
      <para>
        Each view is created with an initial <see cref="P:UIKit.UIView.Frame" />.  The Frame is a
        <see cref="T:System.Drawing.RectangleF" /> structure that represents both the size and the initial
        position for the view.  The coordinates for the Frame are used to
        specify the position relative to its superview.
      </para>
      <para>
        You can resize and move views around using the frame.  Every time
        you set the frame the view will layout its subviews. If you are
        purely moving the view, using frame can cause performance issues, as
        it relays out the view and all its subviews.
      </para>
      <para>
        The <see cref="P:UIKit.UIView.Bounds" /> is the usable
        frame of the view.  Unlike the <see cref="P:UIKit.UIView.Frame" />, the <see cref="P:UIKit.UIView.Bounds" /> do not use the container's
        coordinate space, but instead represent the size in the view's own
        coordinate space.  By default the <see cref="P:UIKit.UIView.Bounds" /> location is (0,0).
      </para>
      <para>
        When the developer updates the <see cref="P:UIKit.UIView.Bounds" />
        property, it will modify the <see cref="P:UIKit.UIView.Frame" /> based on the value of the
        <see cref="P:UIKit.UIView.Center" />.  Developers can also change the position of a view by updating the <see cref="P:UIKit.UIView.Center" /> property.
        
      </para>
      <para>
        When the <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=UIKit%20UIView%20Bound&amp;scope=Xamarin" title="P:UIKit.UIView.Bound">P:UIKit.UIView.Bound</a></format> property is changed, the size of the view is affected
        relative to the <see cref="P:UIKit.UIView.Center" /> property.
      </para>
      <format type="text/html">
        <h2>Animation</h2>
      </format>
      <para>Apple recommends that app developers use the <see cref="T:UIKit.UIViewPropertyAnimator" /> class to implement animations on their <see cref="T:UIKit.UIView" /> objects. Apple also discourages, but has not deprecated, any other animation APIs on the <see cref="T:UIKit.UIView" /> class. Additionally, developers can implement implicit animations for some or all properties by creating a custom views that has a custom <see cref="P:UIKit.UIView.Layer" /> property that provides animation actions for animation keys.</para>
      <para>Developers can animate changes in the geometry or appearance of a UIView by creating a new <see cref="T:UIKit.UIViewPropertyAnimator" />, configuring it, and calling its <see cref="M:UIKit.UIViewPropertyAnimator.StartAnimation(System.Double)" /> method. Developers can update the animations (for example, to cancel it) by calling the <see cref="M:UIKit.UIViewPropertyAnimator.AddAnimations(System.Action,System.nfloat)" /> method while the animation is in progress. The <format type="text/html"><a href="https://developer.xamarin.com/recipes/ios/animation/coreanimation/animate_a_uiview_using_uikit/">Animate a UIView using UIKit</a></format> recipe shows how to create an cancel an animation by using the <see cref="T:UIKit.UIViewPropertyAnimator" /> class.</para>
      <para>
        Alternatively, developers can create animations by calling the
        <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=M:UIKit.UIView.BeginAnimations(string)&amp;scope=Xamarin" title="M:UIKit.UIView.BeginAnimations(string)">M:UIKit.UIView.BeginAnimations(string)</a></format> method, configuring the animation, making the
        changes to the animatable properties and then completing the
        transaction by calling <see cref="M:UIKit.UIView.CommitAnimations" />.
      </para>
      <para>
        After the developer calls <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=M:UIKit.UIView.BeginAnimations(string)&amp;scope=Xamarin" title="M:UIKit.UIView.BeginAnimations(string)">M:UIKit.UIView.BeginAnimations(string)</a></format>, they can
        call the following methods to configure the animation:
      </para>
      <list type="bullet">
        <item>
          <term>
            <see cref="M:UIKit.UIView.SetAnimationDuration(System.Double)" />
          </term>
        </item>
        <item>
          <term>
            <see cref="M:UIKit.UIView.SetAnimationCurve(UIKit.UIViewAnimationCurve)" />
          </term>
        </item>
        <item>
          <term>
            <see cref="M:UIKit.UIView.SetAnimationDelay(System.Double)" />
          </term>
        </item>
        <item>
          <term>
            <see cref="M:UIKit.UIView.SetAnimationDelegate(Foundation.NSObject)" />
          </term>
        </item>
        <item>
          <term>
            <see cref="M:UIKit.UIView.SetAnimationRepeatAutoreverses(System.Boolean)" />
          </term>
        </item>
        <item>
          <term>
            <see cref="M:UIKit.UIView.SetAnimationRepeatCount(System.Single)" />
          </term>
        </item>
        <item>
          <term>
            <see cref="M:UIKit.UIView.SetAnimationDidStopSelector(ObjCRuntime.Selector)" />
          </term>
        </item>
      </list>
      <para>
        The following example shows how to use these methods in a
        transaction:
      </para>
      <example>
        <code lang="C#"><![CDATA[
UIView.BeginAnimations (null);
UIView.SetAnimationDuration (5);
UIView.SetAnimationCurve (UIViewAnimationCurve.EaseOut);
view.Bounds = new RectangleF (0, 0, 100, 100);
view.Position = new PointF (200, 200);
UIView.CommitAnimations ();
]]></code>
      </example>
      <para>
        Alternatively, developers can create transactions and set configuration
        options in the <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=UIKit%20UIView%20Animate&amp;scope=Xamarin" title="M:UIKit.UIView.Animate*">M:UIKit.UIView.Animate*</a></format> collection of methods. These methods take, in a single call, the delay, the duration, an animation block, and an action to be invoked when the animation
        completes. However, Apple also discourages the use of these APIs. Their use is shown below:
      </para>
      <example>
        <code lang="C#"><![CDATA[
UIView.Animate (duration, delay, UIViewAnimationOption.Autoreverse,
  delegate {
      view.Bounds = new RectangleF (0, 0, 100, 100);
      view.Position = new PointF (200, 200);
   },
   delegate {
       Console.WriteLine ("Animation completed");
   }
);
          ]]></code>
      </example>
      <para>
        The above is the basic set of animations that are directly supported by the UIView class. For finer control over animations, developers can use the  <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=Core%20Animation&amp;scope=Xamarin" title="N:CoreAnimation">N:CoreAnimation</a></format> API to animate properties on their UI elements. While implicit animation is disabled for the default layer of a UIView, developers can extend the <see cref="T:UIKit.UIView" /> class to create a derived UIView that contain a derived <see cref="T:CoreAnimation.CALayer" /> that handles animation action keys correctly. Developers should note that animated properties that are changed when adding a subview will be animated during the addition if their default value differs from the final value. For example, the "bounds" and "position" keys, if captured and animated, will cause added subviews to animate in from the origin of the screen.
      </para>
      <example>
        <para>To enable implicit animation, the developer first creates a custom layer that supplies customized animations for the keys or combinations of keys that the layer will handle. The following custom layer example animates the corner radius and transparency for custom views that use it:</para>
        <code lang="C#"><![CDATA[
public class CustomLayer : CALayer
{
  public CustomLayer(IntPtr ptr) : base(ptr)
  {

  }

  public override CAAnimation AnimationForKey(string key)
  {
      CABasicAnimation animation = CABasicAnimation.FromKeyPath(key);
      animation.From = this.ValueForKey(new NSString(key));
      animation.Duration = 1f;
      return animation;
  }

  override public NSObject ActionForKey(string key)
  {
      if (key == "cornerRadius" || key == "opacity")
      {
          return this.AnimationForKey(key);
      }
      else
      {
          return base.ActionForKey(key);
      }
  }
}
]]></code>
        <para>Then, the developer extends UIView, exporting the "layerClass" selector to return a class for the custom layer created above:</para>
        <code lang="C#"><![CDATA[
public class CustomView : UIView
{
  public CustomView(CGRect r) : base(r)
  {
  }

  [Export("layerClass")]
  public static ObjCRuntime.Class GetLayerClass()
  {
      return new ObjCRuntime.Class(typeof(CustomLayer));
  }
}]]></code>
        <para>Finally, when the property is set, the changed property is animated with the animation properties that were specified by the custom layer:</para>
        <code lang="C#"><![CDATA[
fadeAndRound = () =>
          {
              redView.Layer.CornerRadius = 40;
              redView.Alpha = 0.5f;
          };]]></code>
      </example>
      <format type="text/html">
        <h2>Threading</h2>
      </format>
      <para>
        UIView methods are not thread safe. Developers should avoid configuring
        or invoking any of the UIView static methods from any thread that is
        not the main thread.  Newer versions of MonoTouch catch these
        mistakes in Debug builds by throwing an exception.  See the
        <see cref="F:UIKit.UIApplication.CheckForIllegalCrossThreadCalls" /> for
        more information.
      </para>
      <para>
        To perform some work in a background thread that must
        update any of the UIView properties, or to invoke any of the
        UIView static methods, developers should use either the
        <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=M:Foundation.NSObject.BeginInvokeOnMainThread()&amp;scope=Xamarin" title="M:Foundation.NSObject.BeginInvokeOnMainThread()">M:Foundation.NSObject.BeginInvokeOnMainThread()</a></format> or
        <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=M:Foundation.NSObject.InvokeOnMainThread()&amp;scope=Xamarin" title="M:Foundation.NSObject.InvokeOnMainThread()">M:Foundation.NSObject.InvokeOnMainThread()</a></format> methods.  Both
        methods take a C# delegate or lambda that is invoked on the main
        thread.
      </para>
      <para>
        The <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=M:Foundation.NSObject.InvokeOnMainThread()&amp;scope=Xamarin" title="M:Foundation.NSObject.InvokeOnMainThread()">M:Foundation.NSObject.InvokeOnMainThread()</a></format> method will
        invoke the specified delegate method synchronously on the main
        thread. The
        <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=M:Foundation.NSObject.BeginInvokeOnMainThread()&amp;scope=Xamarin" title="M:Foundation.NSObject.BeginInvokeOnMainThread()">M:Foundation.NSObject.BeginInvokeOnMainThread()</a></format> will queue
        the action to be executed on the main thread.
      </para>
      <para>
        Example:
      </para>
      <example>
        <code lang="C#"><![CDATA[
//
// This performs an expensive computation in the background, and then
// updates the main UI when done.
//
void DoSomeWork (UIView view)
{
  double sum = 0;
  for (int i = 0; i &lt; Int32.MaxValue; i++)
      sum += i * i;

  // Now invoke the update on the main UI.
  view.BeginInvokeOnMainThread (delegate {
      view.BackgroundColor = UIColor.Green;
      statusLabel.Text = "Sum is: " + sum;
  });
}
          ]]></code>
      </example>
      <para>
        The following example shows a helper method that can be used to run
        the provided action on the main thread. It is optimized for calling from the main thread already, and avoids
        a trip to the main loop pump:
      </para>
      <example>
        <code lang="C#"><![CDATA[
static NSObject Invoker = new NSObject();
public static void EnsureInvokedOnMainThread (Action action)
{
    if (NSThread.Current.IsMainThread) {
        action ();
        return;
    }
    Invoker.BeginInvokeOnMainThread (() => action());
}
        ]]></code>
      </example>
      <format type="text/html">
        <h2>How to Subclass UIView</h2>
      </format>
      <para>
        Developers will often subclass UIView to provide their own custom
        views to use. This section discusses the different classes of
        members that developers would overwrite to create their custom
        classes.
      </para>
      <format type="text/html">
        <h3>Initialization</h3>
      </format>
      <para>
        Subclasses of UIView should chain into either the UIView
        constructor that is initialized with an initial frame (<format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=C:UIKit.UIView(System.Drawing.RectangleF)&amp;scope=Xamarin" title="C:UIKit.UIView(System.Drawing.RectangleF)">C:UIKit.UIView(System.Drawing.RectangleF)</a></format>). The following code shows one way to do this:
      </para>
      <example>
        <code lang="C#"><![CDATA[
public class MyView : UIView {
    public MyView (RectangleF frame) : base (frame)
    {
        // Your initialization code goes here
    }
}
          ]]></code>
      </example>
      <para>
        In an object that will be deserialized from an archive produced by the
        UI designer, the developer must chain to the <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=C:UIKit.UIView(Foundation.NSCoder)&amp;scope=Xamarin" title="C:UIKit.UIView(Foundation.NSCoder)">C:UIKit.UIView(Foundation.NSCoder)</a></format>
        constructor and  flag the constructor as being the one
        implementing the selector "initWithCoder:", as shown in the code below:
      </para>
      <example>
        <code lang="C#"><![CDATA[
public class MyView : UIView {
    [Export ("initWithCoder:")]
    public MyView (NSCoder coder) : base (coder)
    {
        // Your initialization code goes here
    }
}
          ]]></code>
      </example>
      <para>
        By default UIViews will use a <see cref="T:CoreAnimation.CALayer" /> instance for their
        backing store.  The section on "Changing the CALayer" below has both
        information on how to make this change and a sample.
      </para>
      <para>
        The developer should initialize child views in the constructor for the parent view.
      </para>
      <format type="text/html">
        <h3>Custom Drawing</h3>
      </format>
      <para>
        To implement custom drawing code in a view, developers can subclass the
        UIView and override the <see cref="M:UIKit.UIView.Draw(CoreGraphics.CGRect)" />
        method. The drawing code placed in the Draw method can use <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=Core%20Graphics&amp;scope=Xamarin" title="N:CoreGraphics">N:CoreGraphics</a></format> to draw with. The steps to draw
        with Core Graphics are:
      </para>
      <list type="bullet">
        <item>
          <term>Obtain a reference to the current graphics context.</term>
        </item>
        <item>
          <term>Set up any desired drawing attributes, such as fill and stroke colors for instance.</term>
        </item>
        <item>
          <term>Create geometry from Core Graphics primitives.</term>
        </item>
        <item>
          <term>Draw the geometry.</term>
        </item>
      </list>
      <para>
        For example, the following code shows an implementation of an
        overridden Draw method that draws a triangle:
      </para>
      <example>
        <code lang="C#"><![CDATA[
public override void Draw (RectangleF rect)
{
    base.Draw (rect);

    var context = UIGraphics.GetCurrentContext ();

    context.SetLineWidth(4);
    UIColor.Red.SetFill ();
    UIColor.Blue.SetStroke ();

    var path = new CGPath ();

    path.AddLines(new PointF[]{
        new PointF(100,200),
        new PointF(160,100), 
        new PointF(220,200)
    });

    path.CloseSubpath();

    context.AddPath(path);		
    context.DrawPath(CGPathDrawingMode.FillStroke);
}
          ]]></code>
      </example>
      <para>
        The developer should not call <see cref="M:UIKit.UIView.Draw(CoreGraphics.CGRect)" /> directly. iOS calls it
        during run loop processing. iOS first calls it the first time through the run loop, and then whenever the view
        has been marked as needing display with a call to <see cref="M:UIKit.UIView.SetNeedsDisplayInRect(CoreGraphics.CGRect)" /> or
        <see cref="M:UIKit.UIView.SetNeedsDisplayInRect(CoreGraphics.CGRect)" />.
      </para>
      <para>
        Core Graphics uses device independent points rather than
        pixels. This allows drawing code to scale between different
        resolutions. For example, on a Retina display, 1 point is equivalent
        to 2 pixels, while on non-Retina displays, 1 point corresponds to 1
        pixel.
      </para>
      <format type="text/html">
        <h3>Printing</h3>
      </format>
      <para>
        UIViews can be printed.  The default behavior is for the contents of
        the UIView as rendered by the <see cref="M:UIKit.UIView.Draw(CoreGraphics.CGRect)" />
        method to be printed.
      </para>
      <para>
        Developers can provide a different rendering for the view when
        printed by overriding the <see cref="M:UIKit.UIView.DrawRect(CoreGraphics.CGRect,UIKit.UIViewPrintFormatter)" />
        method.
      </para>
      <format type="text/html">
        <h3>Constraints</h3>
      </format>
      <para>
        To use the constraint-based
        layout system i(ntroduced with iOS 6.0) in a subclassed view, the developer must
        respond to the requiresConstraintBasedLayout selector, as shown in the following example:
      </para>
      <example>
        <code lang="C#"><![CDATA[
class MyView : UIView {
    [Export ("requiresConstraintBasedLayout")]
    bool UseNewLayout ()
    {
        return true;
    }
}
          ]]></code>
      </example>
      <para>
        To use constraints to layout the subviews of a view own developers override the <see cref="M:P:UIKit.UIView.UpdateConstraints*" />. This method is
        called before the constraints-based layout is performed.
      </para>
      <para>
        Constraints-based layout is performed on the alignment rectangle
        instead of the view's <see cref="P:UIKit.UIView.Frame" />.
        The alignment rectangle by default is computed as the <see cref="P:UIKit.UIView.Frame" /> modified by the <see cref="P:UIKit.UIView.AlignmentRectInsets" />.  Developers can
        change that behavior and provide a custom alignment rectangle by
        overriding the <see cref="M:UIKit.UIView.AlignmentRectForFrame(CoreGraphics.CGRect)" />
        and <see cref="M:UIKit.UIView.FrameForAlignmentRect(CoreGraphics.CGRect)" />
        methods.
      </para>
      <format type="text/html">
        <h3>Layout</h3>
      </format>
      <para>
        The default layout system for UIViews is very simple.  UIViews are
        created with an initial <see cref="P:UIKit.UIView.Frame" />
        and an <see cref="P:UIKit.UIView.AutoresizingMask" /> that
        determines how the view will be resized in response to changes in
        the container's boundaries.
      </para>
      <para>
        Developers should set the default <see cref="P:UIKit.UIView.AutoresizingMask" /> property after
        initialization.
      </para>
      <para>
        For views the will be a container for other views, developers should
        configure their <see cref="P:UIKit.UIView.AutoresizingMask" /> property.  If the
        layout behavior provided is not sufficient, the developer should override the
        <see cref="M:UIKit.UIView.LayoutSubviews" /> method.
        This method is responsible for updating the <see cref="P:UIKit.UIView.Frame" /> property of each of the
        subviews.
      </para>
      <para>
        For views that change their state in response to some API calls,
        developers should call the <see cref="M:UIKit.UIView.SetNeedsLayout" />, instead of laying out the view themselves. The layout event will then be processed
        the next time the main loop runs.  By using this approach, develoers can
        coalesce multiple changes to the layout in a single pass.
      </para>
      <para>
        UIViews can implement the <see cref="M:UIKit.UIView.SizeThatFits(CoreGraphics.CGSize)" />
        method to report back what is their desired size based on the
        contents of the view.
      </para>
      <para>
        Developers can override the <see cref="M:UIKit.UIView.SubviewAdded(UIKit.UIView)" />
        and the <see cref="M:UIKit.UIView.WillRemoveSubview(UIKit.UIView)" />
        to track when subviews are added or removed to a UIView.
      </para>
      <para>
        Developers can override the <see cref="M:UIKit.UIView.WillMoveToWindow(UIKit.UIWindow)" />
        and the <see cref="M:UIKit.UIView.MovedToWindow" /> to
        track when views are moved from one <see cref="T:UIKit.UIWindow" /> to another.
      </para>
      <para>
        Developers can override the <see cref="M:UIKit.UIView.WillMoveToSuperview(UIKit.UIView)" />
        and the <see cref="M:UIKit.UIView.MovedToSuperview" /> to
        track when views are added or removed from a superview.
      </para>
      <format type="text/html">
        <h2>Constraints Based Layout</h2>
      </format>
      <para>
        A constraints-based layout system was added in iOS 6.0.  This system
        differs from the traditional layout system in that it uses rules
        (constraints) that describe the relationships between subviews that
        should be preserved.  When views change in size (for example a label
        is updated) or the size of the container changes (for example, after
        a rotation), the new positions and sizes for the subviews are
        computed based on these constraints.
      </para>
      <para>
        To opt into this system, a subclass of UIView should expose a static
        method that is exported as "requiresConstraintBasedLayout" and
        returns true, like this:
      </para>
      <example>
        <code lang="C#"><![CDATA[
class MyView : UIView {
    [Export ("requiresConstraintBasedLayout")]
    static bool RequiresConstraintBasedLayout ()
    {
        return true;
    }
}
          ]]></code>
      </example>
      <format type="text/html">
        <h3>Event Handling</h3>
      </format>
      <para>
        When using gesture recognizers, developers can add those directly to
        the constructor at initialization time.
      </para>
      <para>
        To perform low-level touch event handling, developers override the <see cref="M:UIKit.UIResponder.TouchesBegan(Foundation.NSSet,UIKit.UIEvent)" />, <see cref="M:UIKit.UIResponder.TouchesMoved(Foundation.NSSet,UIKit.UIEvent)" />, <see cref="M:UIKit.UIResponder.TouchesEnded(Foundation.NSSet,UIKit.UIEvent)" /> and <see cref="M:UIKit.UIResponder.TouchesCancelled(Foundation.NSSet,UIKit.UIEvent)" /> methods.
      </para>
      <para>Since iOS 9.0, <see cref="M:UIKit.UIResponder.TouchesMoved(Foundation.NSSet,UIKit.UIEvent)" /> events are raised on supported hardware and configurations for changes in user-applied pressure. The <see cref="P:UIKit.UITouch.Force" /> property of the <see cref="T:UIKit.UITouch" /> object in the <paramref name="touches" /> set argument contains the magnitude of the touch that raised the event. The following example shows a basic use:</para>
      <example>
        <code lang="C#"><![CDATA[
if (TraitCollection.ForceTouchCapability == UIForceTouchCapability.Available) {
    UITouch t = touches.AnyObject as UITouch;
    ForceLabel.Text = "Force: " + t.Force.ToString ();
}
else {
    ForceLabel.Text = "Force Not Active";
}]]></code>
      </example>
      <para>
        Application developers do not need to call the base methods for any of the above
        methods if they are overriding UIView directly.  But they should call base when deriving from another UIView subclass.
      </para>
      <para>
        Application developers can control whether a gesture recognizer is activated by
        overriding the <see cref="M:UIKit.UIView.GestureRecognizerShouldBegin(UIKit.UIGestureRecognizer)" />
        method.
      </para>
      <format type="text/html">
        <h2>Views and CALayers</h2>
      </format>
      <para>
        Each UIView is backed by a <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=Core%20Animation&amp;scope=Xamarin" title="N:CoreAnimation">N:CoreAnimation</a></format> Layer (<see cref="T:CoreAnimation.CALayer" />).  A CALayer
        represents the GPU-backed bitmap that is used to render the view
        into the screen.  Painting into a UIView  actually
        paints into the CALayer.
      </para>
      <para>
        While the appearance of a UIView can be controlled by setting its
        <see cref="P:UIKit.UIView.Frame" />, <see cref="P:UIKit.UIView.Alpha" />, <see cref="P:UIKit.UIView.BackgroundColor" />, or by overriding its <see cref="M:UIKit.UIView.Draw(CoreGraphics.CGRect)" /> method, all
        those properties and functions are in fact modifying the <see cref="T:CoreAnimation.CALayer" />
        owned by the view.
      </para>
      <para>
        The <see cref="P:UIKit.UIView.Layer" /> property is a reference to the
        CALayer owned by the view. Developers change the appearance of the view
        by modifying the properties of that layer.
      </para>
      <para>
        For example, modifyng the <see cref="P:CoreAnimation.CALayer.CornerRadius" /> property of a view's layer change the corner radius of the view:
      </para>
      <example>
        <code lang="C#"><![CDATA[
view.Layer.CornerRadius = 4;
        ]]></code>
      </example>
      <para>
        Developers can add drop shadows:
      </para>
      <example>
        <code lang="C#"><![CDATA[
view.Layer.ShadowColor = new CGColor (1, 0, 0);
view.Layer.ShadowOpacity = 1.0f;
view.Layer.ShadowOffset = new SizeF (0, 4);
        ]]></code>
      </example>
      <para>
        Developers can also apply a 3D transformation to the layer:
      </para>
      <example>
        <code lang="C#"><![CDATA[
view.Layer.Transform = CATransform3D.MakeRotation ((float)(Math.PI / 2), 1, 1, 1);
        ]]></code>
      </example>
      <para>
        This transformation is a full 3D transform, with a
        perspective element, and is more versatile than UIView's 2D
        Transform property. The Frame property is no longer useful after a 3D transformation of this kind.
      </para>
      <format type="text/html">
        <h3>Changing the CALayer</h3>
      </format>
      <para>
        The <see cref="P:UIKit.UIView.Layer" /> owned by a view is automatically
        created and assigned to the view by UIKit and it defaults to be a
        <see cref="T:CoreAnimation.CALayer" /> instance.   You can control the type
        of layer that is created for a view by responding to the "layerClass" 
        selector in a static method.
      </para>
      <para>
        Here is an example of a UIView subclass that uses a custom <see cref="T:CoreAnimation.CALayer" /> to do its drawing. This
        layer, and therefore the view, always displays the color blue:
      </para>
      <example>
        <code lang="C#"><![CDATA[
public class BlueView : UIView
{
    [Export ("layerClass")]
    public static Class GetLayerClass ()
    {
        return new Class (typeof (BlueLayer));
    }

    public override void Draw (RectangleF rect)
    {
        // Do nothing, the Layer will do all the drawing
    }
}

public class BlueLayer : CALayer
{
    public override void DrawInContext (CGContext ctx)
    {
        ctx.SetFillColor (0, 0, 1, 1);
        ctx.FillRect (Bounds);
    }
}
          ]]></code>
      </example>
      <para>
        In this example, a new UIView class called "BlueView" is created. It
        exports a static method called "GetLayerClass" that tells UIKit the
        type of layer that this view wishes to own. In this example, the
        BlueView wishes to own a BlueLayer.
      </para>
      <para>
        It is now up to the BlueLayer to provide the visual representation
        of the view. It does this by executing CoreGraphics drawing code in
        its <see cref="M:CoreAnimation.CALayer.DrawInContext(CoreGraphics.CGContext)" />
        method. This method is very similar to a UIView's Draw method but is used to fill the layer.
        
      </para>
      <para>
        Even though the BlueLayer will do all drawing for the BlueView, the
        view must still override its Draw method. This override should do
        nothing and is just a signal to UIKit that the Layer will do all the
        work.
      </para>
      <format type="text/html">
        <h2>Motion Effects</h2>
      </format>
      <para> Motion Effects are a family of effects that can be
	  applied to UIViews in response to external events, typically
	  the device tilt.  </para>
      <para>
	  Developers can tie to motion effects the same properties that are
	  animatable already.  UIKit ships with <see cref="T:UIKit.UIInterpolatingMotionEffect" /> which
	  allows control over a single property in response to a device tilt.

	</para>
      <para>
	  After the developer creates an effect, they attach it to a view by
	  calling the <see cref="M:UIKit.UIView.AddMotionEffect(UIKit.UIMotionEffect)" /> method and
	  remove it by calling the <see cref="M:UIKit.UIView.RemoveMotionEffect(UIKit.UIMotionEffect)" /> method.
	  The <see cref="P:UIKit.UIView.MotionEffects" />
	  property can also be used to query or set a number of motion
	  effects at once.

	</para>
      <para>
	  The developer can also create custom motion effects by subclassing the <see cref="T:UIKit.UIMotionEffect" />.
	</para>
      <format type="text/html">
        <h2>Tint Color</h2>
      </format>
      <para>
	Starting with iOS 7, the <see cref="P:UIKit.UIView.TintColor" /> property will now
	propagate to subviews.  This allows the developer to set a
	global tint color, and the color will be passed down to
	subviews for views that matter.  Some UIViews will respond
	specially based on the TintColor.  Developers should also set the
	<see cref="P:UIKit.UIView.TintAdjustmentMode" /> to
	control the desaturation when some views are no longer active.

      </para>
      <!--
      <format type="text/html">
        <h2>Dynamics</h2>
      </format>
-->
      <format type="text/html">
        <h2>View Hierarchies</h2>
      </format>
      <para>iOS user interfaces are built from <see cref="T:UIKit.UIView" /> hierarchies. Parent-child relationships determine not only the visual aspects of the UI, but determine how the application responds to touch events and orientation changes.</para>
      <para>View relationships may be built programmatically or via XIB files. <see cref="T:UIKit.UIView" />s may have many <see cref="P:UIKit.UIView.Subviews" /> but only one <see cref="P:UIKit.UIView.Superview" />.</para>
      <para>The most common way to add subviews is to use <see cref="M:UIKit.UIView.AddSubview(UIKit.UIView)" />, which appends the child view to the list of <see cref="P:UIKit.UIView.Subviews" />. More precise control of ordering during insertion may be done with the <see cref="M:UIKit.UIView.InsertSubview(UIKit.UIView,System.nint)" />, <see cref="M:UIKit.UIView.InsertSubviewAbove(UIKit.UIView,UIKit.UIView)" />, and <see cref="M:UIKit.UIView.InsertSubviewBelow(UIKit.UIView,UIKit.UIView)" /> methods.</para>
      <para>The ordering of <see cref="P:UIKit.UIView.Subviews" /> may be manipulated with the <see cref="M:UIKit.UIView.BringSubviewToFront(UIKit.UIView)" />, <see cref="M:UIKit.UIView.SendSubviewToBack(UIKit.UIView)" />, and <see cref="M:UIKit.UIView.ExchangeSubview(System.nint,System.nint)" /> methods.</para>
      <format type="text/html">
        <h2>Focus</h2>
      </format>
      <para>On handheld iOS devices, the user interacts directly with screen objects. On tvOS, a remote is used to navigate through the elements on the screen and only one <see cref="T:UIKit.UIView" /> has "focus." Focus-related APIs include:</para>
      <list type="bullet">
        <item>
          <term>
            <see cref="P:UIKit.UIView.CanBecomeFocused" />
          </term>
          <description>
            <see langword="true" /> if the <see cref="T:UIKit.UIView" /> may become the focused view. (See discussion below about additional requirements.)</description>
        </item>
        <item>
          <term>
            <see cref="M:UIKit.UIView.DidUpdateFocus(UIKit.UIFocusUpdateContext,UIKit.UIFocusAnimationCoordinator)" />
          </term>
          <description>Called after the <see cref="T:UIKit.UIView" /> has either lost or received focus. (See also <see cref="M:UIKit.UIView.ShouldUpdateFocus(UIKit.UIFocusUpdateContext)" />.)</description>
        </item>
        <item>
          <term>
            <see cref="P:UIKit.UIView.Focused" />
          </term>
          <description>Whether the <see cref="T:UIKit.UIView" /> is the focused view.</description>
        </item>
        <item>
          <term>
            <see cref="P:UIKit.UIView.PreferredFocusedView" />
          </term>
          <description>Returns the <see cref="T:UIKit.UIView" /> that should actually be focused. (For instance, a child <see cref="T:UIKit.UIView" />.)</description>
        </item>
        <item>
          <term>
            <see cref="M:UIKit.UIView.SetNeedsFocusUpdate" />
          </term>
          <description>When this is the active focus environment, requests a focus update, which can potentially change the <see cref="P:UIKit.UIViewController.PreferredFocusedView" />. (See also <see cref="M:UIKit.UIViewController.UpdateFocusIfNeeded" />.)</description>
        </item>
        <item>
          <term>
            <see cref="M:UIKit.UIView.ShouldUpdateFocus(UIKit.UIFocusUpdateContext)" />
          </term>
          <description>Called prior to the <see cref="T:UIKit.UIView" /> either losing or receiving focus. If either focus environment returns <see langword="false" />, the focus update is canceled.</description>
        </item>
        <item>
          <term>
            <see cref="M:UIKit.UIViewController.UpdateFocusIfNeeded" />
          </term>
          <description>If any focus environment has a pending update, this method forces an immediate focus update. Unlike <see cref="M:UIKit.UIView.SetNeedsFocusUpdate" />, this method may be called by any <see cref="T:UIKit.UIView" />, whether it currently contains focus or not.</description>
        </item>
      </list>
      <para>In addition to <see cref="P:UIKit.UIView.CanBecomeFocused" /> returning <see langword="true" />, for a <see cref="T:UIKit.UIView" /> to be focused, it must have a <see cref="P:UIKit.UIView.Hidden" /> value of <see langword="false" />, a <see cref="P:UIKit.UIView.UserInteractionEnabled" /> value of <see langword="true" />, a <see cref="P:UIKit.UIView.Alpha" /> value greater than 0, and it must not be obscured by another <see cref="T:UIKit.UIView" />. </para>
    </remarks>
    <related type="recipe" href="https://developer.xamarin.com/ios/Recipes/Animation/CoreAnimation/Animate_a_UIView_using_UIKit">Animate a UIView using UIKit</related>
    <related type="externalDocumentation" href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/index.html">Apple documentation for <c>UIView</c></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIView ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("init")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Default constructor that initializes a new instance of this class with no parameters.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIView (CoreGraphics.CGRect frame);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype CoreGraphics.CGRect frame) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.#ctor(CoreGraphics.CGRect)" />
      <MemberSignature Language="F#" Value="new UIKit.UIView : CoreGraphics.CGRect -&gt; UIKit.UIView" Usage="new UIKit.UIView frame" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("initWithFrame:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.DesignatedInitializer</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="frame" Type="CoreGraphics.CGRect" />
      </Parameters>
      <Docs>
        <param name="frame">Frame used by the view, expressed in iOS points.</param>
        <summary>Initializes the UIView with the specified frame.</summary>
        <remarks>
          <para>This constructor is used to programmatically create a new instance of UIView with the specified dimension in the frame.   The object will only be displayed once it has been added to a view hierarchy by calling AddSubview in a containing view.</para>
          <para>This constructor is not invoked when deserializing objects from storyboards or XIB filesinstead the constructor that takes an NSCoder parameter is invoked.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIView (Foundation.NSCoder coder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Foundation.NSCoder coder) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.#ctor(Foundation.NSCoder)" />
      <MemberSignature Language="F#" Value="new UIKit.UIView : Foundation.NSCoder -&gt; UIKit.UIView" Usage="new UIKit.UIView coder" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("initWithCoder:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.DesignatedInitializer</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="coder" Type="Foundation.NSCoder" />
      </Parameters>
      <Docs>
        <param name="coder">The unarchiver object.</param>
        <summary>A constructor that initializes the object from the data stored in the unarchiver object.</summary>
        <remarks>
          <para>This constructor is provided to allow the class to be initialized from an unarchiver (for example, during NIB deserialization).   This is part of the <see cref="T:Foundation.NSCoding" />  protocol.</para>
          <para>If developers want to create a subclass of this object and continue to support deserialization from an archive, they should implement a constructor with an identical signature: taking a single parameter of type <see cref="T:Foundation.NSCoder" /> and decorate it with the [Export("initWithCoder:"] attribute declaration.</para>
          <para>The state of this object can also be serialized by using the companion method, EncodeTo.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected UIView (Foundation.NSObjectFlag t);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class Foundation.NSObjectFlag t) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.#ctor(Foundation.NSObjectFlag)" />
      <MemberSignature Language="F#" Value="new UIKit.UIView : Foundation.NSObjectFlag -&gt; UIKit.UIView" Usage="new UIKit.UIView t" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="t" Type="Foundation.NSObjectFlag" />
      </Parameters>
      <Docs>
        <param name="t">Unused sentinel value, pass NSObjectFlag.Empty.</param>
        <summary>Constructor to call on derived classes to skip initialization and merely allocate the object.</summary>
        <remarks>
          <para>This constructor should be called by derived classes when they completely construct the object in managed code and merely want the runtime to allocate and initialize the NSObject.   This is required to implement the two-step initialization process that Objective-C uses, the first step is to perform the object allocation, the second step is to initialize the object.   When developers invoke the constructor that takes the NSObjectFlag.Empty they take advantage of a direct path that goes all the way up to NSObject to merely allocate the object's memory and bind the Objective-C and C# objects together.    The actual initialization of the object is up to the developer.</para>
          <para>This constructor is typically used by the binding generator to allocate the object, but prevent the actual initialization to take place.   Once the allocation has taken place, the constructor has to initialize the object.   With constructors generated by the binding generator this means that it manually invokes one of the "init" methods to initialize the object.</para>
          <para>It is the developer's responsibility to completely initialize the object if they chain up using the NSObjectFlag.Empty path.</para>
          <para>In general, if the developer's constructor invokes the NSObjectFlag.Empty base implementation, then it should be calling an Objective-C init method.   If this is not the case, developers should instead chain to the proper constructor in their class. </para>
          <para>The argument value is ignored and merely ensures that the only code that is executed is the construction phase is the basic NSObject allocation and runtime type registration.  Typically the chaining would look like this:</para>
          <example>
            <code lang="C#"><![CDATA[
//
// The NSObjectFlag merely allocates the object and registers the
// C# class with the Objective-C runtime if necessary, but no actual
// initXxx method is invoked, that is done later in the constructor
//
// This is taken from Xamarin.iOS's source code:
//
[Export ("initWithFrame:")]
public UIView (System.Drawing.RectangleF frame) : base (NSObjectFlag.Empty)
{
// Invoke the init method now.
	var initWithFrame = new Selector ("initWithFrame:").Handle;
	if (IsDirectBinding)
		Handle = ObjCRuntime.Messaging.IntPtr_objc_msgSend_CGRect (this.Handle, initWithFrame, frame);
	else
		Handle = ObjCRuntime.Messaging.IntPtr_objc_msgSendSuper_CGRect (this.SuperHandle, initWithFrame, frame);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected internal UIView (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig specialname rtspecialname instance void .ctor(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.#ctor(System.IntPtr)" />
      <MemberSignature Language="F#" Value="new UIKit.UIView : nativeint -&gt; UIKit.UIView" Usage="new UIKit.UIView handle" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Pointer (handle) to the unmanaged object.</param>
        <summary>A constructor used when creating managed representations of unmanaged objects;  Called by the runtime.</summary>
        <remarks>
          <para>This constructor is invoked by the runtime infrastructure (<see cref="M:ObjCRuntime.Runtime.GetNSObject(System.IntPtr)" />) to create a new managed representation for a pointer to an unmanaged Objective-C object.    Developers should not invoke this method directly, instead they should call the GetNSObject method as it will prevent two instances of a managed object to point to the same native object.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityActivate">
      <MemberSignature Language="C#" Value="public virtual bool AccessibilityActivate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool AccessibilityActivate() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.AccessibilityActivate" />
      <MemberSignature Language="F#" Value="abstract member AccessibilityActivate : unit -&gt; bool&#xA;override this.AccessibilityActivate : unit -&gt; bool" Usage="uIView.AccessibilityActivate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("accessibilityActivate")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Activates accessibility for this UIView, returning <see langword="true" /> on success.</summary>
        <returns>True upon success.</returns>
        <remarks>This is a Boolean which will return a true value upon success.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityActivationPoint">
      <MemberSignature Language="C#" Value="public virtual CoreGraphics.CGPoint AccessibilityActivationPoint { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype CoreGraphics.CGPoint AccessibilityActivationPoint" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.AccessibilityActivationPoint" />
      <MemberSignature Language="F#" Value="member this.AccessibilityActivationPoint : CoreGraphics.CGPoint with get, set" Usage="UIKit.UIView.AccessibilityActivationPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("accessibilityActivationPoint")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setAccessibilityActivationPoint:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>CoreGraphics.CGPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The screen coordinates for the accessibility element.</summary>
        <value>The default value is the center of the <see cref="P:UIKit.UIView.AccessibilityFrame" />.</value>
        <remarks>
          <para>Application developers can set this value to move the location of the accessibility element. For instance, by default the <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=UIKit%20UIView%20Accessibility%20Point&amp;scope=Xamarin" title="P:UIKit.UIView.AccessibilityPoint">P:UIKit.UIView.AccessibilityPoint</a></format> of an app icon is the center of the icon, but during rearrangement, the point is moved to the "remove control" (the circled X).</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityAttributedHint">
      <MemberSignature Language="C#" Value="public virtual Foundation.NSAttributedString AccessibilityAttributedHint { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Foundation.NSAttributedString AccessibilityAttributedHint" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.AccessibilityAttributedHint" />
      <MemberSignature Language="F#" Value="member this.AccessibilityAttributedHint : Foundation.NSAttributedString with get, set" Usage="UIKit.UIView.AccessibilityAttributedHint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("accessibilityAttributedHint", ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setAccessibilityAttributedHint:", ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSAttributedString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An attributed string providing a brief description of the behavior of the accessibility element.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityAttributedLabel">
      <MemberSignature Language="C#" Value="public virtual Foundation.NSAttributedString AccessibilityAttributedLabel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Foundation.NSAttributedString AccessibilityAttributedLabel" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.AccessibilityAttributedLabel" />
      <MemberSignature Language="F#" Value="member this.AccessibilityAttributedLabel : Foundation.NSAttributedString with get, set" Usage="UIKit.UIView.AccessibilityAttributedLabel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("accessibilityAttributedLabel", ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setAccessibilityAttributedLabel:", ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSAttributedString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A brief attributed string describing the purpose of the <see cref="T:UIKit.UIView" />.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityAttributedValue">
      <MemberSignature Language="C#" Value="public virtual Foundation.NSAttributedString AccessibilityAttributedValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Foundation.NSAttributedString AccessibilityAttributedValue" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.AccessibilityAttributedValue" />
      <MemberSignature Language="F#" Value="member this.AccessibilityAttributedValue : Foundation.NSAttributedString with get, set" Usage="UIKit.UIView.AccessibilityAttributedValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("accessibilityAttributedValue", ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setAccessibilityAttributedValue:", ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSAttributedString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An attributed string holding the value of the <see cref="T:UIKit.UIView" />, when it is different than the <see cref="P:UIKit.UIView.AccessibilityAttributedLabel" />.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityElementsHidden">
      <MemberSignature Language="C#" Value="public virtual bool AccessibilityElementsHidden { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AccessibilityElementsHidden" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.AccessibilityElementsHidden" />
      <MemberSignature Language="F#" Value="member this.AccessibilityElementsHidden : bool with get, set" Usage="UIKit.UIView.AccessibilityElementsHidden" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("accessibilityElementsHidden")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setAccessibilityElementsHidden:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether the view's accessibility elements are visible.</summary>
        <value>Boolean indicating whether visible or not.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityFrame">
      <MemberSignature Language="C#" Value="public virtual CoreGraphics.CGRect AccessibilityFrame { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype CoreGraphics.CGRect AccessibilityFrame" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.AccessibilityFrame" />
      <MemberSignature Language="F#" Value="member this.AccessibilityFrame : CoreGraphics.CGRect with get, set" Usage="UIKit.UIView.AccessibilityFrame" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("accessibilityFrame")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setAccessibilityFrame:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>CoreGraphics.CGRect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The Frame of the accessibility element, in screen coordinates.</summary>
        <value>The designated frame.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityHint">
      <MemberSignature Language="C#" Value="public virtual string AccessibilityHint { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AccessibilityHint" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.AccessibilityHint" />
      <MemberSignature Language="F#" Value="member this.AccessibilityHint : string with get, set" Usage="UIKit.UIView.AccessibilityHint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("accessibilityHint", ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setAccessibilityHint:", ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A brief description of the action performed by the accessibility element.</summary>
        <value>String that contains the hint.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityIdentifier">
      <MemberSignature Language="C#" Value="public virtual string AccessibilityIdentifier { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AccessibilityIdentifier" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.AccessibilityIdentifier" />
      <MemberSignature Language="F#" Value="member this.AccessibilityIdentifier : string with get, set" Usage="UIKit.UIView.AccessibilityIdentifier" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:UIKit.IUIAccessibilityIdentification.AccessibilityIdentifier</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("accessibilityIdentifier", ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setAccessibilityIdentifier:", ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Uniquely identifies <c>this</c> for the purposes of accessibility.</summary>
        <value>String identifier.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityIgnoresInvertColors">
      <MemberSignature Language="C#" Value="public virtual bool AccessibilityIgnoresInvertColors { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AccessibilityIgnoresInvertColors" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.AccessibilityIgnoresInvertColors" />
      <MemberSignature Language="F#" Value="member this.AccessibilityIgnoresInvertColors : bool with get, set" Usage="UIKit.UIView.AccessibilityIgnoresInvertColors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("accessibilityIgnoresInvertColors")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setAccessibilityIgnoresInvertColors:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets whether the <see cref="T:UIKit.UIView" /> will invert its colors in response to such an accessibility request.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityLabel">
      <MemberSignature Language="C#" Value="public virtual string AccessibilityLabel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AccessibilityLabel" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.AccessibilityLabel" />
      <MemberSignature Language="F#" Value="member this.AccessibilityLabel : string with get, set" Usage="UIKit.UIView.AccessibilityLabel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("accessibilityLabel", ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setAccessibilityLabel:", ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A localized identifier for the accessibility element.</summary>
        <value>String label identifier text.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityLanguage">
      <MemberSignature Language="C#" Value="public virtual string AccessibilityLanguage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AccessibilityLanguage" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.AccessibilityLanguage" />
      <MemberSignature Language="F#" Value="member this.AccessibilityLanguage : string with get, set" Usage="UIKit.UIView.AccessibilityLanguage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("accessibilityLanguage", ObjCRuntime.ArgumentSemantic.Strong)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setAccessibilityLanguage:", ObjCRuntime.ArgumentSemantic.Strong)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The BCP 47 language tag of the language used to speak the accessibility element's components.</summary>
        <value>String containing language tag.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityNavigationStyle">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIAccessibilityNavigationStyle AccessibilityNavigationStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype UIKit.UIAccessibilityNavigationStyle AccessibilityNavigationStyle" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.AccessibilityNavigationStyle" />
      <MemberSignature Language="F#" Value="member this.AccessibilityNavigationStyle : UIKit.UIAccessibilityNavigationStyle with get, set" Usage="UIKit.UIView.AccessibilityNavigationStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("accessibilityNavigationStyle")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setAccessibilityNavigationStyle:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIAccessibilityNavigationStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the navigation style.</summary>
        <value>
          <see cref="T:UIKit.UIAccessibilityNavigationStyle" />
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityPath">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIBezierPath AccessibilityPath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIBezierPath AccessibilityPath" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.AccessibilityPath" />
      <MemberSignature Language="F#" Value="member this.AccessibilityPath : UIKit.UIBezierPath with get, set" Usage="UIKit.UIView.AccessibilityPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("accessibilityPath", ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setAccessibilityPath:", ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIBezierPath</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Allows the accessibility element to be non-rectangular.</summary>
        <value>
          <see langword="null" /> by default, in which case the <see cref="P:UIKit.UIView.AccessibilityFrame" /> is used to highlight the element.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityTraits">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIAccessibilityTrait AccessibilityTraits { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype UIKit.UIAccessibilityTrait AccessibilityTraits" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.AccessibilityTraits" />
      <MemberSignature Language="F#" Value="member this.AccessibilityTraits : UIKit.UIAccessibilityTrait with get, set" Usage="UIKit.UIView.AccessibilityTraits" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("accessibilityTraits")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setAccessibilityTraits:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIAccessibilityTrait</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A bitmask of the <see cref="T:UIKit.UIAccessibilityTrait" />s of <c>this</c>.</summary>
        <value>
          <see cref="T:UIKit.UIAccessibilityTrait" />
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityValue">
      <MemberSignature Language="C#" Value="public virtual string AccessibilityValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AccessibilityValue" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.AccessibilityValue" />
      <MemberSignature Language="F#" Value="member this.AccessibilityValue : string with get, set" Usage="UIKit.UIView.AccessibilityValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("accessibilityValue", ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setAccessibilityValue:", ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The value of the accessibility element.</summary>
        <value>If the <see cref="T:UIKit.UIView" /> has a label, returns the value of the label.</value>
        <remarks>
          <para>Application developers should override this if their <see cref="T:UIKit.UIView" /> has both a label and a value.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityViewIsModal">
      <MemberSignature Language="C#" Value="public virtual bool AccessibilityViewIsModal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AccessibilityViewIsModal" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.AccessibilityViewIsModal" />
      <MemberSignature Language="F#" Value="member this.AccessibilityViewIsModal : bool with get, set" Usage="UIKit.UIView.AccessibilityViewIsModal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("accessibilityViewIsModal")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setAccessibilityViewIsModal:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether Voice Over should ignore sibling elements.</summary>
        <value>The default value is <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ActionForLayer">
      <MemberSignature Language="C#" Value="public virtual Foundation.NSObject ActionForLayer (CoreAnimation.CALayer layer, string eventKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Foundation.NSObject ActionForLayer(class CoreAnimation.CALayer layer, string eventKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.ActionForLayer(CoreAnimation.CALayer,System.String)" />
      <MemberSignature Language="F#" Value="abstract member ActionForLayer : CoreAnimation.CALayer * string -&gt; Foundation.NSObject&#xA;override this.ActionForLayer : CoreAnimation.CALayer * string -&gt; Foundation.NSObject" Usage="uIView.ActionForLayer (layer, eventKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("actionForLayer:forKey:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="layer" Type="CoreAnimation.CALayer" />
        <Parameter Name="eventKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="layer">To be added.</param>
        <param name="eventKey">To be added.</param>
        <summary>Retrieves the default <see cref="T:CoreAnimation.CAAction" /> identified by <param name="eventKey" /> that targets <param name="layer" />.</summary>
        <returns>This method may return <see langword="null" /> if there is no specified behavior.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (UIKit.UIView view);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(class UIKit.UIView view) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.Add(UIKit.UIView)" />
      <MemberSignature Language="F#" Value="member this.Add : UIKit.UIView -&gt; unit" Usage="uIView.Add view" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="view" Type="UIKit.UIView" />
      </Parameters>
      <Docs>
        <param name="view">The subview to add.</param>
        <summary>This is an alias for <see cref="M:UIKit.UIView.AddSubview(UIKit.UIView)" />, but uses the Add pattern as it allows C# 3.0 constructs to add subviews after creating the object.</summary>
        <remarks>
          <para>
            This method is equivalent to <see cref="M:UIKit.UIView.AddSubview(UIKit.UIView)" /> and is present to enable C# 3.0 to add subviews at creation time.
          </para>
          <example>
            <code lang="C#"><![CDATA[
              var myView = new MyView (new RectangleF (0, 0, 320, 320)){
                new ImageGallery (region [0]),
                new ImageGallery (region [1]),
                new UILabel (new RectangleF (10, 10, 200, 200)){
                  Text = "Images from our Trip"
                }
              };
            ]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddConstraint">
      <MemberSignature Language="C#" Value="public virtual void AddConstraint (UIKit.NSLayoutConstraint constraint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddConstraint(class UIKit.NSLayoutConstraint constraint) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.AddConstraint(UIKit.NSLayoutConstraint)" />
      <MemberSignature Language="F#" Value="abstract member AddConstraint : UIKit.NSLayoutConstraint -&gt; unit&#xA;override this.AddConstraint : UIKit.NSLayoutConstraint -&gt; unit" Usage="uIView.AddConstraint constraint" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("addConstraint:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constraint" Type="UIKit.NSLayoutConstraint" />
      </Parameters>
      <Docs>
        <param name="constraint">A <see cref="T:UIKit.NSLayoutConstraint" /> to add. The <paramref name="constraint" /> must refer only to the receiving view or its subviews.</param>
        <summary>Adds a constraint to the layout of the receiving view or its subviews.</summary>
        <remarks>
          <para>The <paramref name="constraint" /> must refer only to the receiving view or its subviews.</para>
        </remarks>
        <altmember cref="P:UIKit.UIView.Constraints" />
        <altmember cref="M:UIKit.UIView.AddConstraints" />
        <altmember cref="M:UIKit.UIView.RemoveConstraint" />
        <altmember cref="M:UIKit.UIView.RemoveConstraints" />
        <altmember cref="P:UIKit.UIView.TranslatesAutoresizingMaskIntoConstraints" />
      </Docs>
    </Member>
    <Member MemberName="AddConstraints">
      <MemberSignature Language="C#" Value="public virtual void AddConstraints (UIKit.NSLayoutConstraint[] constraints);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddConstraints(class UIKit.NSLayoutConstraint[] constraints) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.AddConstraints(UIKit.NSLayoutConstraint[])" />
      <MemberSignature Language="F#" Value="abstract member AddConstraints : UIKit.NSLayoutConstraint[] -&gt; unit&#xA;override this.AddConstraints : UIKit.NSLayoutConstraint[] -&gt; unit" Usage="uIView.AddConstraints constraints" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("addConstraints:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constraints" Type="UIKit.NSLayoutConstraint[]" />
      </Parameters>
      <Docs>
        <param name="constraints">An array of <see cref="T:UIKit.NSLayoutConstraint" />s to add. The <paramref name="constraints" /> must refer only to the receiving view or its subviews.</param>
        <summary>Adds multiple constraints to the layout of the receiving view or its subviews.</summary>
        <remarks>
          <para>The <paramref name="constraints" /> must refer only to the receiving view or its subviews.</para>
          <para>In the following example, <format type="text/html"><a href="https://developer.apple.com/library/mac/#documentation/UserExperience/Conceptual/AutolayoutPG/Articles/formatLanguage.html#//apple_ref/doc/uid/TP40010853-CH3-SW1">Visual Format Language</a></format> specifies that the <c>blueView</c> be horizontally attched to the leading and trailing edge (sides), that the <c>blueView</c> and <c>greenView</c> be vertically attached to the leading and trailing edges (top and bottom) and separated by 30 pixels, and that the <c>greenView</c> be the same width as the <c>blueView</c> and attached to both the leading and trailing edges. The result is shown in the following image.</para>
          <example>
            <code lang="C#"><![CDATA[
mainView.AddSubview(blueView);
mainView.AddSubview(greenView);

greenView.TranslatesAutoresizingMaskIntoConstraints = false;
blueView.TranslatesAutoresizingMaskIntoConstraints = false;

var viewsDictionary = NSDictionary.FromObjectsAndKeys(new NSObject[] { greenView, blueView}, new NSObject[] { new NSString("green"), new NSString("blue")});
var metrics = new NSDictionary();

mainView.AddConstraints(NSLayoutConstraint.FromVisualFormat("H:|-[blue]-|",0, new NSDictionary(), viewsDictionary));
mainView.AddConstraints(NSLayoutConstraint.FromVisualFormat("V:|-[blue]-(==30)-[green(==blue)]-|",0, new NSDictionary(), viewsDictionary));
mainView.AddConstraints(NSLayoutConstraint.FromVisualFormat("|-[green(==blue)]-|",0, new NSDictionary(), viewsDictionary));
              ]]></code>
          </example>
          <para>
            <img href="~/UIKit/_images/UIKit.UIView.AddConstraints.png" />
          </para>
        </remarks>
        <altmember cref="P:UIKit.UIView.Constraints" />
        <altmember cref="M:UIKit.UIView.AddConstraint" />
        <altmember cref="M:UIKit.UIView.RemoveConstraint" />
        <altmember cref="M:UIKit.UIView.RemoveConstraints" />
        <altmember cref="P:UIKit.UIView.TranslatesAutoresizingMaskIntoConstraints" />
      </Docs>
    </Member>
    <Member MemberName="AddGestureRecognizer">
      <MemberSignature Language="C#" Value="public virtual void AddGestureRecognizer (UIKit.UIGestureRecognizer gestureRecognizer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddGestureRecognizer(class UIKit.UIGestureRecognizer gestureRecognizer) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.AddGestureRecognizer(UIKit.UIGestureRecognizer)" />
      <MemberSignature Language="F#" Value="abstract member AddGestureRecognizer : UIKit.UIGestureRecognizer -&gt; unit&#xA;override this.AddGestureRecognizer : UIKit.UIGestureRecognizer -&gt; unit" Usage="uIView.AddGestureRecognizer gestureRecognizer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("addGestureRecognizer:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="gestureRecognizer" Type="UIKit.UIGestureRecognizer" />
      </Parameters>
      <Docs>
        <param name="gestureRecognizer">The configured gesture recognizer to add to this view.</param>
        <summary>Adds a gesture recognizer to this view.</summary>
        <remarks>Adding a gesture recognizer to a view allows definition of the scope of that represented gesture, and causes it to receive touches that are hit-tested to that view and to all of its subviews. That view then establishes a strong reference to the gesture recognizer.
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddInteraction">
      <MemberSignature Language="C#" Value="public virtual void AddInteraction (UIKit.IUIInteraction interaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddInteraction(class UIKit.IUIInteraction interaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.AddInteraction(UIKit.IUIInteraction)" />
      <MemberSignature Language="F#" Value="abstract member AddInteraction : UIKit.IUIInteraction -&gt; unit&#xA;override this.AddInteraction : UIKit.IUIInteraction -&gt; unit" Usage="uIView.AddInteraction interaction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("addInteraction:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interaction" Type="UIKit.IUIInteraction" />
      </Parameters>
      <Docs>
        <param name="interaction">The interaction to add.</param>
        <summary>Adds the interaction to the view.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddKeyframeWithRelativeStartTime">
      <MemberSignature Language="C#" Value="public static void AddKeyframeWithRelativeStartTime (double frameStartTime, double frameDuration, Action animations);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddKeyframeWithRelativeStartTime(float64 frameStartTime, float64 frameDuration, class System.Action animations) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.AddKeyframeWithRelativeStartTime(System.Double,System.Double,System.Action)" />
      <MemberSignature Language="F#" Value="static member AddKeyframeWithRelativeStartTime : double * double * Action -&gt; unit" Usage="UIKit.UIView.AddKeyframeWithRelativeStartTime (frameStartTime, frameDuration, animations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("addKeyframeWithRelativeStartTime:relativeDuration:animations:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="frameStartTime" Type="System.Double" />
        <Parameter Name="frameDuration" Type="System.Double" />
        <Parameter Name="animations" Type="System.Action">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="frameStartTime">The starting time of the animation, relative to the containing action (0-1)</param>
        <param name="frameDuration">The duration of the animation, relative to the containing action (0-1).</param>
        <param name="animations">The action defining the ending state of the keyframe.</param>
        <summary>Adds a single keyframe to an animation.</summary>
        <remarks>
          <para>This method, when called within the <c>animations</c> action of a call to <see cref="M:UIKit.UIView.AnimateKeyframes(System.Double,System.Double,UIKit.UIViewKeyframeAnimationOptions,System.Action,UIKit.UICompletionHandler)" />, specifies a keyframe in an animation sequence. Both the <paramref name="frameStartTime" /> and <paramref name="frameDuration" /> parameters range fro m 0 to 1 and specify durations relative to the enclosing <see cref="M:UIKit.UIView.AnimateKeyframes(System.Double,System.Double,UIKit.UIViewKeyframeAnimationOptions,System.Action,UIKit.UICompletionHandler)" /><c>duration</c> parameter.</para>
          <para>For instance, in the following example (which shows the use of both passed-in <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=Foundation%20NSAction&amp;scope=Xamarin" title="T:Foundation.NSAction">T:Foundation.NSAction</a></format> parameters and a C# lambda expression), the third keyframe's <paramref name="frameStartTime" /> and <paramref name="frameDuration" /> are both set to 0.5; since the the containing <see cref="M:UIKit.UIView.AnimateKeyframesAsync(System.Double,System.Double,UIKit.UIViewKeyframeAnimationOptions,System.Action)" />'s <paramref name="duration" /> is set to 3 seconds, this animation will start at 1.5 seconds and take 1.5 seconds to complete.</para>
          <example>
            <code lang="C#"><![CDATA[
var animationSucceeded = await UIView.AnimateKeyframesAsync(
		duration : 3,
		delay : 0,
		options: UIViewKeyframeAnimationOptions.AllowUserInteraction,
		animations: () => {
			UIView.AddKeyframeWithRelativeStartTime(0, 0.25, () => label.Frame = new RectangleF(label.Frame.Left + 250, label.Frame.Top, label.Frame.Width, label.Frame.Height)
				);
			UIView.AddKeyframeWithRelativeStartTime(0.25, 0.25, keyframe2);
			UIView.AddKeyframeWithRelativeStartTime(0.5, 0.5, keyframe3);
		}
	);
    ]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLayoutGuide">
      <MemberSignature Language="C#" Value="public virtual void AddLayoutGuide (UIKit.UILayoutGuide guide);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddLayoutGuide(class UIKit.UILayoutGuide guide) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.AddLayoutGuide(UIKit.UILayoutGuide)" />
      <MemberSignature Language="F#" Value="abstract member AddLayoutGuide : UIKit.UILayoutGuide -&gt; unit&#xA;override this.AddLayoutGuide : UIKit.UILayoutGuide -&gt; unit" Usage="uIView.AddLayoutGuide guide" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("addLayoutGuide:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guide" Type="UIKit.UILayoutGuide" />
      </Parameters>
      <Docs>
        <param name="guide">The <see cref="T:UIKit.UILayoutGuide" /> to add.</param>
        <summary>Adds the specified <paramref name="guide" />, allowing for Autolayout control without creating dummy views.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddMotionEffect">
      <MemberSignature Language="C#" Value="public virtual void AddMotionEffect (UIKit.UIMotionEffect effect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddMotionEffect(class UIKit.UIMotionEffect effect) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.AddMotionEffect(UIKit.UIMotionEffect)" />
      <MemberSignature Language="F#" Value="abstract member AddMotionEffect : UIKit.UIMotionEffect -&gt; unit&#xA;override this.AddMotionEffect : UIKit.UIMotionEffect -&gt; unit" Usage="uIView.AddMotionEffect effect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("addMotionEffect:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="effect" Type="UIKit.UIMotionEffect" />
      </Parameters>
      <Docs>
        <param name="effect">Motion effect to add to the view.</param>
        <summary>Adds the specified motion effect to the view.</summary>
        <remarks>This method, when called using the present UIView animation context, animates the transition to the specified motion effect's values.
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddSubview">
      <MemberSignature Language="C#" Value="public virtual void AddSubview (UIKit.UIView view);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddSubview(class UIKit.UIView view) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.AddSubview(UIKit.UIView)" />
      <MemberSignature Language="F#" Value="abstract member AddSubview : UIKit.UIView -&gt; unit&#xA;override this.AddSubview : UIKit.UIView -&gt; unit" Usage="uIView.AddSubview view" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("addSubview:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="view" Type="UIKit.UIView" />
      </Parameters>
      <Docs>
        <param name="view">
          <para>The <see cref="T:UIKit.UIView" /> to add as a nested view of this view.</para>
        </param>
        <summary>Adds the specified view as a subview of this view.</summary>
        <remarks>
          <para>
            <see cref="M:UIKit.UIView.AddSubview(UIKit.UIView)" /> appends the <paramref name="view" /> to the end of <c>this</c> <see cref="T:UIKit.UIView" />'s <see cref="P:UIKit.UIView.Subviews" />. The methods <see cref="M:UIKit.UIView.InsertSubview(UIKit.UIView,System.nint)" />, <see cref="M:UIKit.UIView.InsertSubviewBelow(UIKit.UIView,UIKit.UIView)" />, and <see cref="M:UIKit.UIView.InsertSubviewAbove(UIKit.UIView,UIKit.UIView)" /> can be used to control the order.</para>
          <para>To remove a <see cref="T:UIKit.UIView" /> from <see cref="P:UIKit.UIView.Subviews" />, call <see cref="M:UIKit.UIView.RemoveFromSuperview" /> on the child <see cref="T:UIKit.UIView" />.</para>
          <para>Since <see cref="T:UIKit.UIView" />s can only have direct ancestor, this will overwrite the existing <see cref="P:UIKit.UIView.Superview" /> of the <paramref name="view" />.</para>
          <para>A number of methods are called when a subview is added or removed:</para>
          <list type="bullet">
            <item>
              <term>
                <see cref="M:UIKit.UIView.WillMoveToSuperview(UIKit.UIView)" />
              </term>
            </item>
            <item>
              <term>
                <see cref="M:UIKit.UIView.WillMoveToWindow(UIKit.UIWindow)" />
              </term>
            </item>
            <item>
              <term>
                <see cref="M:UIKit.UIView.WillRemoveSubview(UIKit.UIView)" />
              </term>
            </item>
            <item>
              <term>
                <see cref="M:UIKit.UIView.SubviewAdded(UIKit.UIView)" />
              </term>
            </item>
            <item>
              <term>
                <see cref="M:UIKit.UIView.MovedToSuperview" />
              </term>
            </item>
            <item>
              <term>
                <see cref="M:UIKit.UIView.MovedToWindow" />
              </term>
            </item>
          </list>
          <para>The following diagram shows the sequence of calls resulting from a call to <see cref="M:UIKit.UIView.AddSubview(UIKit.UIView)" />. Note that the calls to <see cref="M:UIKit.UIView.WillMoveToWindow(UIKit.UIWindow)" /> and <see cref="M:UIKit.UIView.MovedToWindow" /> occur shortly after <see cref="M:UIKit.UIView.AddSubview(UIKit.UIView)" /> has completed.</para>
          <para>
            <img href="~/UIKit/_images/UIView.AddSubviewSequence.png" />
          </para>
        </remarks>
        <altmember cref="P:UIKit.UIView.Subviews" />
        <altmember cref="M:UIKit.UIView.RemoveFromSuperview" />
      </Docs>
    </Member>
    <Member MemberName="AddSubviews">
      <MemberSignature Language="C#" Value="public void AddSubviews (params UIKit.UIView[] views);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddSubviews(class UIKit.UIView[] views) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.AddSubviews(UIKit.UIView[])" />
      <MemberSignature Language="F#" Value="member this.AddSubviews : UIKit.UIView[] -&gt; unit" Usage="uIView.AddSubviews views" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="views" Type="UIKit.UIView[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="views">An array of zero or more <see cref="T:UIKit.UIView" />s.</param>
        <summary>Convenience routine to add various views to a UIView.</summary>
        <remarks>
          <para>
            This is merely a convenience routine that allows the application developer to add a number of views in a single call.
          </para>
          <example>
            <code lang="C#"><![CDATA[
myView.AddSubviews (label, button, entry, image1, image2);
            ]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AlignmentRectForFrame">
      <MemberSignature Language="C#" Value="public virtual CoreGraphics.CGRect AlignmentRectForFrame (CoreGraphics.CGRect frame);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype CoreGraphics.CGRect AlignmentRectForFrame(valuetype CoreGraphics.CGRect frame) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.AlignmentRectForFrame(CoreGraphics.CGRect)" />
      <MemberSignature Language="F#" Value="abstract member AlignmentRectForFrame : CoreGraphics.CGRect -&gt; CoreGraphics.CGRect&#xA;override this.AlignmentRectForFrame : CoreGraphics.CGRect -&gt; CoreGraphics.CGRect" Usage="uIView.AlignmentRectForFrame frame" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("alignmentRectForFrame:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>CoreGraphics.CGRect</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="frame" Type="CoreGraphics.CGRect" />
      </Parameters>
      <Docs>
        <param name="frame">A <see cref="T:System.Drawing.RectangleF" /> for which the alignment rectangle should be calculated.</param>
        <summary>Returns a customized alignment rectangle for Auto Layout.</summary>
        <returns>The alignment rectangle appropriate to the <paramref name="frame" />.</returns>
        <remarks>
          <para>By overriding this method, application developers can fully customize the alignment rectangle of the <see cref="T:UIKit.UIView" />.Application developers who override this method must also override the complementary method <see cref="M:UIKit.UIView.FrameForAlignmentRect(CoreGraphics.CGRect)" />. The two methods must provide complementary values.</para>
          <para>Auto Layout uses "alignment rectangles" to layout subviews rather than the subviews' <see cref="P:UIKit.UIView.Frame" />. The <see cref="P:UIKit.UIView.Frame" /> of a <see cref="T:UIKit.UIView" /> may include visual elements, such as drop-shadows, that are not symmetrical around the <see cref="T:UIKit.UIView" />'s logical center. The "alignment rectangle" for a <see cref="T:UIKit.UIView" /> should be related to its logical content.</para>
          <para> By default, the "alignment rectangle" of a <see cref="T:UIKit.UIView" /> is the <see cref="P:UIKit.UIView.Frame" /> plus the <see cref="P:UIKit.UIView.AlignmentRectInsets" />. The <see cref="M:UIKit.UIView.AlignmentRectForFrame(CoreGraphics.CGRect)" /> and <see cref="M:UIKit.UIView.FrameForAlignmentRect(CoreGraphics.CGRect)" /> methods can be used to fully customize the alignment rectangle.</para>
        </remarks>
        <altmember cref="M:UIKit.UIView.FrameForAlignmentRect" />
        <altmember cref="M:UIKit.UIView.AlignmentRectInsets" />
        <altmember cref="M:UIKit.UIView.ViewForBaselineLayout" />
      </Docs>
    </Member>
    <Member MemberName="AlignmentRectInsets">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIEdgeInsets AlignmentRectInsets { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype UIKit.UIEdgeInsets AlignmentRectInsets" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.AlignmentRectInsets" />
      <MemberSignature Language="F#" Value="member this.AlignmentRectInsets : UIKit.UIEdgeInsets" Usage="UIKit.UIView.AlignmentRectInsets" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("alignmentRectInsets")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIEdgeInsets</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Adjustments to the <see cref="P:UIKit.UIView.Frame" /> for use with Auto Layout.</summary>
        <value>The default value is an <see cref="T:UIKit.UIEdgeInsets" /> whose values are all zero.</value>
        <remarks>
          <para>Application developers can use this property to modify the rectangle that is used by Auto Layout to control the <see cref="T:UIKit.UIView" />'s ultimate alignment.</para>
          <para>Auto Layout uses "alignment rectangles" to layout subviews rather than the subviews' <see cref="P:UIKit.UIView.Frame" />. The <see cref="P:UIKit.UIView.Frame" /> of a <see cref="T:UIKit.UIView" /> may include visual elements, such as drop-shadows, that are not symmetrical around the <see cref="T:UIKit.UIView" />'s logical center. The "alignment rectangle" for a <see cref="T:UIKit.UIView" /> should be related to its logical content.</para>
          <para> By default, the "alignment rectangle" of a <see cref="T:UIKit.UIView" /> is the <see cref="P:UIKit.UIView.Frame" /> plus the <see cref="P:UIKit.UIView.AlignmentRectInsets" />. The <see cref="M:UIKit.UIView.AlignmentRectForFrame(CoreGraphics.CGRect)" /> and <see cref="M:UIKit.UIView.FrameForAlignmentRect(CoreGraphics.CGRect)" /> methods can be used to fully customize the alignment rectangle.</para>
        </remarks>
        <altmember cref="M:UIKit.UIView.AlignmentRectForFrame" />
        <altmember cref="M:UIKit.UIView.FrameForAlignmentRect" />
        <altmember cref="M:UIKit.UIView.ViewForBaselineLayout" />
      </Docs>
    </Member>
    <Member MemberName="Alpha">
      <MemberSignature Language="C#" Value="public virtual nfloat Alpha { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.nfloat Alpha" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.Alpha" />
      <MemberSignature Language="F#" Value="member this.Alpha : nfloat with get, set" Usage="UIKit.UIView.Alpha" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("alpha")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setAlpha:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.nfloat</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Controls the transparency (alpha) value for the view.</summary>
        <value>0 to 1.</value>
        <remarks>
          <para>
            This controls the transparency for the view.  If the value
            is 1.0, the view is completely opaque, if the value is 0.0
            the view is completely transparent.    
          </para>
          <para>
            When the value of the view is in between 0 and 1, the
            contents of the view are composited with views that are
            lower in the view hierarchy or the superview.
            
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Animate">
      <MemberSignature Language="C#" Value="public static void Animate (double duration, Action animation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Animate(float64 duration, class System.Action animation) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.Animate(System.Double,System.Action)" />
      <MemberSignature Language="F#" Value="static member Animate : double * Action -&gt; unit" Usage="UIKit.UIView.Animate (duration, animation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("animateWithDuration:animations:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="animation" Type="System.Action">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="duration">Duration in seconds for the animation.</param>
        <param name="animation">Code containing the changes that you will apply to your view.</param>
        <summary>Animates the property changes that take place in the specified action.</summary>
        <remarks>
          <para>The use of this method is discouraged. Application developers should prefer to use the <see cref="T:UIKit.UIViewPropertyAnimator" /> class to animate UIViews.</para>
          <para>
            This uses the CurveEaseOut and TransitionNone flags for the animation.
          </para>
          <example>
            <code lang="C#"><![CDATA[
// Animates hiding the label by setting the alpha to zero over three seconds.
UIView.Animate (3, () => { label.Alpha = 0; });
            ]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Animate">
      <MemberSignature Language="C#" Value="public static void Animate (double duration, Action animation, Action completion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Animate(float64 duration, class System.Action animation, class System.Action completion) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.Animate(System.Double,System.Action,System.Action)" />
      <MemberSignature Language="F#" Value="static member Animate : double * Action * Action -&gt; unit" Usage="UIKit.UIView.Animate (duration, animation, completion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Use the *Notify method that has 'UICompletionHandler completion' parameter, the 'bool' will tell you if the operation finished.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="animation" Type="System.Action" />
        <Parameter Name="completion" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="duration">Duration in seconds for the animation.</param>
        <param name="animation">Code containing the changes that you will apply to your view.</param>
        <param name="completion">Code that is invoked when the animation completes.</param>
        <summary>Animates the property changes that take place in the specified action and invokes a completion callback when the animation completes.</summary>
        <remarks>
          <para>The use of this method is discouraged. Application developers should prefer to use the <see cref="T:UIKit.UIViewPropertyAnimator" /> class to animate UIViews.</para>
          <para>
            This uses the CurveEaseOut and TransitionNone flags for the animation.
          </para>
          <example>
            <code lang="C#"><![CDATA[
// Animates hiding the label by setting the alpha to zero over three seconds.
UIView.Animate (3, () => { label.Alpha = 0; });
            ]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Animate">
      <MemberSignature Language="C#" Value="public static void Animate (double duration, double delay, UIKit.UIViewAnimationOptions options, Action animation, Action completion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Animate(float64 duration, float64 delay, valuetype UIKit.UIViewAnimationOptions options, class System.Action animation, class System.Action completion) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.Animate(System.Double,System.Double,UIKit.UIViewAnimationOptions,System.Action,System.Action)" />
      <MemberSignature Language="F#" Value="static member Animate : double * double * UIKit.UIViewAnimationOptions * Action * Action -&gt; unit" Usage="UIKit.UIView.Animate (duration, delay, options, animation, completion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Use the *Notify method that has 'UICompletionHandler completion' parameter, the 'bool' will tell you if the operation finished.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="delay" Type="System.Double" />
        <Parameter Name="options" Type="UIKit.UIViewAnimationOptions" />
        <Parameter Name="animation" Type="System.Action" />
        <Parameter Name="completion" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="duration">Duration in seconds for the animation.</param>
        <param name="delay">Delay before the animation begins.</param>
        <param name="options">Animation options</param>
        <param name="animation">Code containing the changes that you will apply to your view.</param>
        <param name="completion">Code that is invoked when the animation completes.</param>
        <summary>Invokes animation changes to one or more views by specifying duration, delay, options, and a completion handler.</summary>
        <remarks>
          <para>The use of this method is discouraged. Application developers should prefer to use the <see cref="T:UIKit.UIViewPropertyAnimator" /> class to animate UIViews.</para>
          <para>This method initiates a set of animations that areto be performed on this view. The action indicated in the animations parameter contains the code for the animation of the properties of one or more views.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AnimateAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;bool&gt; AnimateAsync (double duration, Action animation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;bool&gt; AnimateAsync(float64 duration, class System.Action animation) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.AnimateAsync(System.Double,System.Action)" />
      <MemberSignature Language="F#" Value="static member AnimateAsync : double * Action -&gt; System.Threading.Tasks.Task&lt;bool&gt;" Usage="UIKit.UIView.AnimateAsync (duration, animation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="animation" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="duration">Duration in seconds for the animation.</param>
        <param name="animation">Code containing the changes that you will apply to your view.</param>
        <summary>Animates the property changes that take place in the specified <paramref name="animation" /> as an asynchronous operation.</summary>
        <returns>Indicates whether the animation ran to completion or not.</returns>
        <remarks>
          <para>The use of this method is discouraged. Application developers should prefer to use the <see cref="T:UIKit.UIViewPropertyAnimator" /> class to animate UIViews.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AnimateKeyframes">
      <MemberSignature Language="C#" Value="public static void AnimateKeyframes (double duration, double delay, UIKit.UIViewKeyframeAnimationOptions options, Action animations, UIKit.UICompletionHandler completion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AnimateKeyframes(float64 duration, float64 delay, valuetype UIKit.UIViewKeyframeAnimationOptions options, class System.Action animations, class UIKit.UICompletionHandler completion) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.AnimateKeyframes(System.Double,System.Double,UIKit.UIViewKeyframeAnimationOptions,System.Action,UIKit.UICompletionHandler)" />
      <MemberSignature Language="F#" Value="static member AnimateKeyframes : double * double * UIKit.UIViewKeyframeAnimationOptions * Action * UIKit.UICompletionHandler -&gt; unit" Usage="UIKit.UIView.AnimateKeyframes (duration, delay, options, animations, completion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("animateKeyframesWithDuration:delay:options:animations:completion:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="delay" Type="System.Double" />
        <Parameter Name="options" Type="UIKit.UIViewKeyframeAnimationOptions" />
        <Parameter Name="animations" Type="System.Action">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="completion" Type="UIKit.UICompletionHandler">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDUICompletionHandler))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="duration">Duration in seconds for the animation.</param>
        <param name="delay">Duration in seconds before starting the animation.</param>
        <param name="options">Designates a mask of options that indicates how the developer wants to perform the animations.</param>
        <param name="animations">An action object that contains the changes to be committed to the views.</param>
        <param name="completion">An action object that is to be executed when the animation sequence ends.</param>
        <summary>Creates an animation action object that is to be used to set up keyframe-based animations for the current view.</summary>
        <remarks>
          <para>The use of this method is discouraged. Application developers should prefer to use the <see cref="T:UIKit.UIViewPropertyAnimator" /> class to animate UIViews.</para>
          <para>Creates an animation action that is to be used to set up a keyframe-based animation.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AnimateKeyframesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;bool&gt; AnimateKeyframesAsync (double duration, double delay, UIKit.UIViewKeyframeAnimationOptions options, Action animations);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;bool&gt; AnimateKeyframesAsync(float64 duration, float64 delay, valuetype UIKit.UIViewKeyframeAnimationOptions options, class System.Action animations) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.AnimateKeyframesAsync(System.Double,System.Double,UIKit.UIViewKeyframeAnimationOptions,System.Action)" />
      <MemberSignature Language="F#" Value="static member AnimateKeyframesAsync : double * double * UIKit.UIViewKeyframeAnimationOptions * Action -&gt; System.Threading.Tasks.Task&lt;bool&gt;" Usage="UIKit.UIView.AnimateKeyframesAsync (duration, delay, options, animations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="delay" Type="System.Double" />
        <Parameter Name="options" Type="UIKit.UIViewKeyframeAnimationOptions" />
        <Parameter Name="animations" Type="System.Action">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="duration">Duration in seconds for the animation.</param>
        <param name="delay">Duration in seconds before starting the animation.</param>
        <param name="options">Designates a mask of options that indicates how the developer wants to perform the animations.</param>
        <param name="animations">An action object that contains the changes to be committed to the views.</param>
        <summary>Creates an animation action object that is to be used to set up keyframe-based animations for the current view.</summary>
        <returns>Boolean indicating whether animations finished before a completion handler was called.</returns>
        <remarks>
          <para>The use of this method is discouraged. Application developers should prefer to use the <see cref="T:UIKit.UIViewPropertyAnimator" /> class to animate UIViews.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AnimateNotify">
      <MemberSignature Language="C#" Value="public static void AnimateNotify (double duration, Action animation, UIKit.UICompletionHandler completion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AnimateNotify(float64 duration, class System.Action animation, class UIKit.UICompletionHandler completion) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.AnimateNotify(System.Double,System.Action,UIKit.UICompletionHandler)" />
      <MemberSignature Language="F#" Value="static member AnimateNotify : double * Action * UIKit.UICompletionHandler -&gt; unit" Usage="UIKit.UIView.AnimateNotify (duration, animation, completion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("animateWithDuration:animations:completion:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="animation" Type="System.Action">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="completion" Type="UIKit.UICompletionHandler">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDUICompletionHandler))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="duration">Duration in seconds for the animation.</param>
        <param name="animation">Code containing the changes that you will apply to your view.</param>
        <param name="completion">
          <para>The method to invoke when the animation has completed.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Animates the property changes that take place in the specified action.</summary>
        <remarks>
          <para>The use of this method is discouraged. Application developers should prefer to use the <see cref="T:UIKit.UIViewPropertyAnimator" /> class to animate UIViews.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AnimateNotify">
      <MemberSignature Language="C#" Value="public static void AnimateNotify (double duration, double delay, UIKit.UIViewAnimationOptions options, Action animation, UIKit.UICompletionHandler completion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AnimateNotify(float64 duration, float64 delay, valuetype UIKit.UIViewAnimationOptions options, class System.Action animation, class UIKit.UICompletionHandler completion) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.AnimateNotify(System.Double,System.Double,UIKit.UIViewAnimationOptions,System.Action,UIKit.UICompletionHandler)" />
      <MemberSignature Language="F#" Value="static member AnimateNotify : double * double * UIKit.UIViewAnimationOptions * Action * UIKit.UICompletionHandler -&gt; unit" Usage="UIKit.UIView.AnimateNotify (duration, delay, options, animation, completion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("animateWithDuration:delay:options:animations:completion:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="delay" Type="System.Double" />
        <Parameter Name="options" Type="UIKit.UIViewAnimationOptions" />
        <Parameter Name="animation" Type="System.Action">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="completion" Type="UIKit.UICompletionHandler">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDUICompletionHandler))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="duration">Duration in seconds for the animation.</param>
        <param name="delay">Delay before the animation begins.</param>
        <param name="options">Animation options</param>
        <param name="animation">Code containing the changes that you will apply to your view.</param>
        <param name="completion">
          <para>The method to invoke when the animation has completed.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Animates the property changes that take place in the specified action and invokes a completion callback when the animation completes.</summary>
        <remarks>
          <para>The use of this method is discouraged. Application developers should prefer to use the <see cref="T:UIKit.UIViewPropertyAnimator" /> class to animate UIViews.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AnimateNotify">
      <MemberSignature Language="C#" Value="public static void AnimateNotify (double duration, double delay, nfloat springWithDampingRatio, nfloat initialSpringVelocity, UIKit.UIViewAnimationOptions options, Action animations, UIKit.UICompletionHandler completion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AnimateNotify(float64 duration, float64 delay, valuetype System.nfloat springWithDampingRatio, valuetype System.nfloat initialSpringVelocity, valuetype UIKit.UIViewAnimationOptions options, class System.Action animations, class UIKit.UICompletionHandler completion) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.AnimateNotify(System.Double,System.Double,System.nfloat,System.nfloat,UIKit.UIViewAnimationOptions,System.Action,UIKit.UICompletionHandler)" />
      <MemberSignature Language="F#" Value="static member AnimateNotify : double * double * nfloat * nfloat * UIKit.UIViewAnimationOptions * Action * UIKit.UICompletionHandler -&gt; unit" Usage="UIKit.UIView.AnimateNotify (duration, delay, springWithDampingRatio, initialSpringVelocity, options, animations, completion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("animateWithDuration:delay:usingSpringWithDamping:initialSpringVelocity:options:animations:completion:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="delay" Type="System.Double" />
        <Parameter Name="springWithDampingRatio" Type="System.nfloat" />
        <Parameter Name="initialSpringVelocity" Type="System.nfloat" />
        <Parameter Name="options" Type="UIKit.UIViewAnimationOptions" />
        <Parameter Name="animations" Type="System.Action">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="completion" Type="UIKit.UICompletionHandler">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDUICompletionHandler))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="duration">Duration in seconds for the animation.</param>
        <param name="delay">Delay before the animation begins.</param>
        <param name="springWithDampingRatio">Damping ratio set for spring animation when it is approaching its quiescent state. Value between 0 and 1 representing the amount of damping to apply to the spring effect.</param>
        <param name="initialSpringVelocity">Initial spring velocity prior to attachment. The initial velocity of the spring, in points per second.</param>
        <param name="options">Animation options.</param>
        <param name="animations">Code containing the changes that you will apply to your view.</param>
        <param name="completion">
          <para>The method to invoke when the animation has completed.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Executes a view animation that uses a timing curve that corresponds to the activity of a physical spring.</summary>
        <remarks>
          <para>The use of this method is discouraged. Application developers should prefer to use the <see cref="T:UIKit.UIViewPropertyAnimator" /> class to animate UIViews.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AnimateNotifyAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;bool&gt; AnimateNotifyAsync (double duration, Action animation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;bool&gt; AnimateNotifyAsync(float64 duration, class System.Action animation) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.AnimateNotifyAsync(System.Double,System.Action)" />
      <MemberSignature Language="F#" Value="static member AnimateNotifyAsync : double * Action -&gt; System.Threading.Tasks.Task&lt;bool&gt;" Usage="UIKit.UIView.AnimateNotifyAsync (duration, animation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="animation" Type="System.Action">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="duration">Duration in seconds for the animation.</param>
        <param name="animation">Code containing the changes that you will apply to your view.</param>
        <summary>Animates the property changes that take place in the specified action and invokes a completion callback when the animation completes.</summary>
        <returns>System.Threading.Tasks.Task&lt;System.Boolean&gt;</returns>
        <remarks>
          <para>The use of this method is discouraged. Application developers should prefer to use the <see cref="T:UIKit.UIViewPropertyAnimator" /> class to animate UIViews.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AnimateNotifyAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;bool&gt; AnimateNotifyAsync (double duration, double delay, UIKit.UIViewAnimationOptions options, Action animation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;bool&gt; AnimateNotifyAsync(float64 duration, float64 delay, valuetype UIKit.UIViewAnimationOptions options, class System.Action animation) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.AnimateNotifyAsync(System.Double,System.Double,UIKit.UIViewAnimationOptions,System.Action)" />
      <MemberSignature Language="F#" Value="static member AnimateNotifyAsync : double * double * UIKit.UIViewAnimationOptions * Action -&gt; System.Threading.Tasks.Task&lt;bool&gt;" Usage="UIKit.UIView.AnimateNotifyAsync (duration, delay, options, animation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="delay" Type="System.Double" />
        <Parameter Name="options" Type="UIKit.UIViewAnimationOptions" />
        <Parameter Name="animation" Type="System.Action">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="duration">Duration in seconds for the animation.</param>
        <param name="delay">Delay before the animation begins.</param>
        <param name="options">Animation options.</param>
        <param name="animation">The changes to be applied to the view.</param>
        <summary>Executes the specified <paramref name="animation" /> as an asynchronous operation.</summary>
        <returns>To be added.</returns>
        <remarks>
          <para>The use of this method is discouraged. Application developers should prefer to use the <see cref="T:UIKit.UIViewPropertyAnimator" /> class to animate UIViews.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AnimateNotifyAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;bool&gt; AnimateNotifyAsync (double duration, double delay, nfloat springWithDampingRatio, nfloat initialSpringVelocity, UIKit.UIViewAnimationOptions options, Action animations);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;bool&gt; AnimateNotifyAsync(float64 duration, float64 delay, valuetype System.nfloat springWithDampingRatio, valuetype System.nfloat initialSpringVelocity, valuetype UIKit.UIViewAnimationOptions options, class System.Action animations) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.AnimateNotifyAsync(System.Double,System.Double,System.nfloat,System.nfloat,UIKit.UIViewAnimationOptions,System.Action)" />
      <MemberSignature Language="F#" Value="static member AnimateNotifyAsync : double * double * nfloat * nfloat * UIKit.UIViewAnimationOptions * Action -&gt; System.Threading.Tasks.Task&lt;bool&gt;" Usage="UIKit.UIView.AnimateNotifyAsync (duration, delay, springWithDampingRatio, initialSpringVelocity, options, animations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="delay" Type="System.Double" />
        <Parameter Name="springWithDampingRatio" Type="System.nfloat" />
        <Parameter Name="initialSpringVelocity" Type="System.nfloat" />
        <Parameter Name="options" Type="UIKit.UIViewAnimationOptions" />
        <Parameter Name="animations" Type="System.Action">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="duration">Duration in seconds for the animation.</param>
        <param name="delay">Delay before the animation begins.</param>
        <param name="springWithDampingRatio">Damping ratio set for spring animation when it is approaching its quiescent state. Value between 0 and 1 representing the amount of damping to apply to the spring effect.</param>
        <param name="initialSpringVelocity">Initial spring velocity prior to attachment. The initial velocity of the spring, in points per second.</param>
        <param name="options">Animation options.</param>
        <param name="animations">Code containing the changes that you will apply to your view.</param>
        <summary>Executes a view animation that uses a timing curve that corresponds to the activity of a physical spring.</summary>
        <returns>
          <para>A task that represents the asynchronous AnimateNotify operation.   The value of the TResult parameter is a <see cref="T:UIKit.UICompletionHandler" />.</para>
        </returns>
        <remarks>
          <para>The use of this method is discouraged. Application developers should prefer to use the <see cref="T:UIKit.UIViewPropertyAnimator" /> class to animate UIViews.</para>
          <para copied="true">The AnimateNotifyAsync method is suitable to be used with C# async by returning control to the caller with a Task representing the operation.</para>
          <para copied="true">The use of this method is discouraged. Application developers should prefer to use the <see cref="T:UIKit.UIViewPropertyAnimator" /> class to animate UIViews.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AnimationsEnabled">
      <MemberSignature Language="C#" Value="public static bool AnimationsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool AnimationsEnabled" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.AnimationsEnabled" />
      <MemberSignature Language="F#" Value="member this.AnimationsEnabled : bool with get, set" Usage="UIKit.UIView.AnimationsEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("areAnimationsEnabled")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setAnimationsEnabled:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies whether animations are displayed or not.</summary>
        <value>The default value is <see langword="true" />.</value>
        <remarks>
          <para>The use of this method is discouraged. Application developers should prefer to use the <see cref="T:UIKit.UIViewPropertyAnimator" /> class to animate UIViews.</para>
          <para>Whether this is <see langword="true" /> or <see langword="false" />, the code inside animation blocks will execute. A <see langword="false" /> value simply means the animation does not display.</para>
          <para>Setting this value during an existing animation will not modify that animation's display.</para>
        </remarks>
        <altmember cref="M:UIKit.UIView.PerformWithoutAnimation" />
      </Docs>
    </Member>
    <Member MemberName="AnimationWillEnd">
      <MemberSignature Language="C#" Value="public static event Action AnimationWillEnd;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Action AnimationWillEnd" />
      <MemberSignature Language="DocId" Value="E:UIKit.UIView.AnimationWillEnd" />
      <MemberSignature Language="F#" Value="member this.AnimationWillEnd : Action " Usage="member this.AnimationWillEnd : System.Action " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Action</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>This event is raised when the animations will end.</summary>
        <remarks>
          <para>The use of this method is discouraged. Application developers should prefer to use the <see cref="T:UIKit.UIViewPropertyAnimator" /> class to animate UIViews.</para>
          <para>Notice that these events are only fired as long as the application does not install its own animation delegate by calling <see cref="M:UIKit.UIView.SetAnimationDelegate(Foundation.NSObject)" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AnimationWillStart">
      <MemberSignature Language="C#" Value="public static event Action AnimationWillStart;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Action AnimationWillStart" />
      <MemberSignature Language="DocId" Value="E:UIKit.UIView.AnimationWillStart" />
      <MemberSignature Language="F#" Value="member this.AnimationWillStart : Action " Usage="member this.AnimationWillStart : System.Action " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Action</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>This event is raised when the animations will start.</summary>
        <remarks>
          <para>The use of this method is discouraged. Application developers should prefer to use the <see cref="T:UIKit.UIViewPropertyAnimator" /> class to animate UIViews.</para>
          <para>Notice that these events are only fired as long as the application does not install its own animation delegate by calling <see cref="M:UIKit.UIView.SetAnimationDelegate(Foundation.NSObject)" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AnnouncementDidFinishNotification">
      <MemberSignature Language="C#" Value="public static Foundation.NSString AnnouncementDidFinishNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString AnnouncementDidFinishNotification" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.AnnouncementDidFinishNotification" />
      <MemberSignature Language="F#" Value="member this.AnnouncementDidFinishNotification : Foundation.NSString" Usage="UIKit.UIView.AnnouncementDidFinishNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Use UIView.Notifications.ObserveAnnouncementDidFinish helper method instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Field("UIAccessibilityAnnouncementDidFinishNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for AnnouncementDidFinish</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
    UIView.AnnouncementDidFinishNotification, (notification) => {
        Console.WriteLine ("Received the notification UIView", notification); 
    });


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIView", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIView.AnnouncementDidFinishNotification, Callback);
}
              ]]></code>
          </example>
        </remarks>
        <altmember cref="P:UIKit.UIView.AnnouncementNotification" />
        <altmember cref="P:UIKit.UIView.AnnouncementDidFinishNotification" />
        <altmember cref="P:UIKit.UIView.ClosedCaptioningStatusDidChangeNotification" />
        <altmember cref="P:UIKit.UIView.GuidedAccessStatusDidChangeNotification" />
        <altmember cref="P:UIKit.UIView.InvertColorStatusDidChangeNotification" />
        <altmember cref="P:UIKit.UIView.AnnouncementNotification" />
        <altmember cref="P:UIKit.UIView.LayoutChangedNotification" />
        <altmember cref="P:UIKit.UIView.MonoAudioStatusDidChangeNotification" />
        <altmember cref="P:UIKit.UIView.PageScrolledNotification" />
        <altmember cref="P:UIKit.UIView.ScreenChangedNotification" />
        <altmember cref="P:UIKit.UIView.VoiceOverStatusChangedNotification" />
      </Docs>
    </Member>
    <Member MemberName="AnnouncementNotification">
      <MemberSignature Language="C#" Value="public static int AnnouncementNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 AnnouncementNotification" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.AnnouncementNotification" />
      <MemberSignature Language="F#" Value="member this.AnnouncementNotification : int" Usage="UIKit.UIView.AnnouncementNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIAccessibilityAnnouncementNotification", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An accessibility notification that an announcement will happen.</summary>
        <value>.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:UIKit.UIView.AnnouncementNotification" />
        <altmember cref="P:UIKit.UIView.AnnouncementDidFinishNotification" />
        <altmember cref="P:UIKit.UIView.ClosedCaptioningStatusDidChangeNotification" />
        <altmember cref="P:UIKit.UIView.GuidedAccessStatusDidChangeNotification" />
        <altmember cref="P:UIKit.UIView.InvertColorStatusDidChangeNotification" />
        <altmember cref="P:UIKit.UIView.AnnouncementNotification" />
        <altmember cref="P:UIKit.UIView.LayoutChangedNotification" />
        <altmember cref="P:UIKit.UIView.MonoAudioStatusDidChangeNotification" />
        <altmember cref="P:UIKit.UIView.PageScrolledNotification" />
        <altmember cref="P:UIKit.UIView.ScreenChangedNotification" />
        <altmember cref="P:UIKit.UIView.VoiceOverStatusChangedNotification" />
      </Docs>
    </Member>
    <Member MemberName="Appearance">
      <MemberSignature Language="C#" Value="public static UIKit.UIView.UIViewAppearance Appearance { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class UIKit.UIView/UIViewAppearance Appearance" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.Appearance" />
      <MemberSignature Language="F#" Value="member this.Appearance : UIKit.UIView.UIViewAppearance" Usage="UIKit.UIView.Appearance" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>UIKit.UIView+UIViewAppearance</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Strongly-typed property that returns the UIAppearance class for this class.</summary>
        <value>
        </value>
        <remarks>
          <para>Setting any appearance properties on this instance will affect the appearance of all instances of UIView.</para>
          <para>If developers want to control the appearance of subclasses of UIView, they should use the <see cref="M:UIKit.UIView.GetAppearance``1" /> method.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppearanceWhenContainedIn">
      <MemberSignature Language="C#" Value="public static UIKit.UIView.UIViewAppearance AppearanceWhenContainedIn (params Type[] containers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class UIKit.UIView/UIViewAppearance AppearanceWhenContainedIn(class System.Type[] containers) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.AppearanceWhenContainedIn(System.Type[])" />
      <MemberSignature Language="F#" Value="static member AppearanceWhenContainedIn : Type[] -&gt; UIKit.UIView.UIViewAppearance" Usage="UIKit.UIView.AppearanceWhenContainedIn containers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>UIKit.UIView+UIViewAppearance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containers" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="containers">List of types that developers want to have as the containers to apply this particular appearance</param>
        <summary>Returns a strongly typed UIAppearance for instances of this class when the view is hosted in the specified hierarchy.</summary>
        <returns>The appearance proxy object that developers can use to set properties when the given container hierarchy is active</returns>
        <remarks>
          <para>The returned object represents the UIAppearance proxy where developers can set appearance properties for instances of UIView when those instances are contained in the hierarchy specified by the <paramref name="containers" /> parameter.</para>
          <para>If developers want to control the appearance of subclasses of UIView, they should use the <see cref="M:UIKit.UIView.GetAppearance``1" /> method.</para>
          <para>The following example shows how the AppearanceWhenContainedIn method works</para>
          <example>
            <code lang="C#"><![CDATA[
var mySliders = UISlider.AppearanceWhenContainedIn (typeof (UINavigationBar), typeof (UIPopoverController));
mySliders.TintColor = UIColor.Red;
]]></code>
          </example>
          <para>For more information, see the documentation for the <see cref="T:UIKit.UIAppearance" /> class.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssistiveTechnologyKey">
      <MemberSignature Language="C#" Value="public static Foundation.NSString AssistiveTechnologyKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString AssistiveTechnologyKey" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.AssistiveTechnologyKey" />
      <MemberSignature Language="F#" Value="member this.AssistiveTechnologyKey : Foundation.NSString" Usage="UIKit.UIView.AssistiveTechnologyKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Use UIView.Notifications.ObserveAssistiveTechnologyKey helper method instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Field("UIAccessibilityAssistiveTechnologyKey", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The string "UIAccessibilityAssistiveTechnologyKey" which can be used to distinguish accessibility notifications.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AssistiveTouchStatusDidChangeNotification">
      <MemberSignature Language="C#" Value="public static Foundation.NSString AssistiveTouchStatusDidChangeNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString AssistiveTouchStatusDidChangeNotification" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.AssistiveTouchStatusDidChangeNotification" />
      <MemberSignature Language="F#" Value="member this.AssistiveTouchStatusDidChangeNotification : Foundation.NSString" Usage="UIKit.UIView.AssistiveTouchStatusDidChangeNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Use UIView.Notifications.ObserveAssistiveTouchStatusDidChange helper method instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Field("UIAccessibilityAssistiveTouchStatusDidChangeNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 10, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 10, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 10, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 10, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for AssistiveTouchStatusDidChange</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIView.AssistiveTouchStatusDidChangeNotification, (notification) => {Console.WriteLine ("Received the notification UIView", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIView", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIView.AssistiveTouchStatusDidChangeNotification, Callback);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoresizingMask">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIViewAutoresizing AutoresizingMask { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype UIKit.UIViewAutoresizing AutoresizingMask" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.AutoresizingMask" />
      <MemberSignature Language="F#" Value="member this.AutoresizingMask : UIKit.UIViewAutoresizing with get, set" Usage="UIKit.UIView.AutoresizingMask" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("autoresizingMask")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setAutoresizingMask:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIViewAutoresizing</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A bitmask that specifies how the receiver should resize itself when it's super-view's bounds change.</summary>
        <value>The default value is <see cref="F:UIKit.UIViewAutoresizing.None" />.</value>
        <remarks>
          <para>Application developers may wish to use the more powerful Auto Layout capability rather than the older Autoresizing Mask capability.</para>
          <para>The <see cref="P:UIKit.UIView.AutoresizingMask" /> is a powerful feature that handles a good deal of the complexity of resizing views, such as occurs during device rotation. However, it is not necessarily a complete solution. For instance, when using a <see cref="T:UIKit.UIScrollView" />,  logic may require the <see cref="P:UIKit.UIScrollView.ContentSize" /> to be resized. In such situations, application developers may subscribe to the <c>UIDeviceOrientationDidChangeNotification</c> and implement a custom method with additional resizing logic:</para>
          <example>
            <code lang="C#"><![CDATA[
//During initialization, subscribe to orientation changes              
NSNotificationCenter.DefaultCenter.AddObserver ("UIDeviceOrientationDidChangeNotification", DeviceRotated);

protected void DeviceRotated (NSNotification notification)
{
    //Code to resize UIScrollView.ContentSize and other custom on-rotation logic
}
              ]]></code>
          </example>
        </remarks>
        <altmember cref="M:UIKit.UIView.AutoResizingMask" />
      </Docs>
    </Member>
    <Member MemberName="AutosizesSubviews">
      <MemberSignature Language="C#" Value="public virtual bool AutosizesSubviews { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutosizesSubviews" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.AutosizesSubviews" />
      <MemberSignature Language="F#" Value="member this.AutosizesSubviews : bool with get, set" Usage="UIKit.UIView.AutosizesSubviews" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("autoresizesSubviews")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setAutoresizesSubviews:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies whether the receiver should automatically resize its <see cref="P:UIKit.UIView.Subviews" /> when the receiver's <see cref="P:UIKit.UIView.Bounds" /> change.</summary>
        <value>The default value is <see langword="true" />.</value>
        <remarks>
          <para>If this value is <see langword="true" />, this <see cref="T:UIKit.UIView" /> will resize its <see cref="P:UIKit.UIView.Subviews" /> when this <see cref="T:UIKit.UIView" />'s <see cref="P:UIKit.UIView.Bounds" /> change.</para>
          <para>Application developers may wish to use the more powerful Auto Layout capability rather than the older Autoresizing Mask capability.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundColor">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIColor BackgroundColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIColor BackgroundColor" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.BackgroundColor" />
      <MemberSignature Language="F#" Value="member this.BackgroundColor : UIKit.UIColor with get, set" Usage="UIKit.UIView.BackgroundColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("backgroundColor", ObjCRuntime.ArgumentSemantic.Strong)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setBackgroundColor:", ObjCRuntime.ArgumentSemantic.Strong)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIColor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sets the background color of the <see cref="T:UIKit.UIView" />.</summary>
        <value>
          <para>The default value is <see langword="null" />.</para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>
          <para>The <see cref="P:UIKit.UIView.BackgroundColor" /> is the rear-most visible element of a <see cref="T:UIKit.UIView" />, but developers should be aware that certain <see cref="T:UIKit.UIView" /> subclasses such as <see cref="T:UIKit.UITableViewCell" /> and <see cref="T:UIKit.UICollectionViewCell" /> have a <see cref="P:UIKit.UITableViewCell.BackgroundView" /> that may obscure their <see cref="P:UIKit.UIView.BackgroundColor" />.</para>
          <para id="tool-remark">This member participates in the <see cref="T:UIKit.UIAppearance" /> styling system.  See the <see cref="P:UIKit.UIView.Appearance" /> property and the <see cref="M:UIKit.UIView.AppearanceWhenContainedIn(System.Type[])" /> method.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginAnimations">
      <MemberSignature Language="C#" Value="public static void BeginAnimations (string animation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginAnimations(string animation) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.BeginAnimations(System.String)" />
      <MemberSignature Language="F#" Value="static member BeginAnimations : string -&gt; unit" Usage="UIKit.UIView.BeginAnimations animation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="animation" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="animation">The animation identifier.</param>
        <summary>Indicates the beginning of an animation block.</summary>
        <remarks>
          <para>Application developers should prefer to use the more compact syntax of the <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=UIKit%20UIView%20Animate&amp;scope=Xamarin" title="M:UIKit.UIView.Animate*">M:UIKit.UIView.Animate*</a></format> method.</para>
          <para>Older versions of iOS used a matched set of <see cref="M:UIKit.UIView.BeginAnimations(System.String,System.IntPtr)" /> and <see cref="M:UIKit.UIView.CommitAnimations" /> to specify an animation block. The following code, taken from the "Animate a UIView using UIKit" recipe, shows the technique:</para>
          <example>
            <code lang="C#"><![CDATA[
UIView.BeginAnimations ("slideAnimation");

UIView.SetAnimationDuration (2);
UIView.SetAnimationCurve (UIViewAnimationCurve.EaseInOut);
UIView.SetAnimationRepeatCount (2);
UIView.SetAnimationRepeatAutoreverses (true);
UIView.SetAnimationDelegate (this);
UIView.SetAnimationDidStopSelector (
  new Selector ("slideAnimationFinished:"));
_imageView.Center = new PointF (UIScreen.MainScreen.Bounds.Right -
  _imageView.Frame.Width / 2, _imageView.Center.Y);
UIView.CommitAnimations ();
              ]]></code>
          </example>
        </remarks>
        <altmember cref="M:UIKit.UIView.CommitAnimations" />
        <related type="recipe" href="https://developer.xamarin.com/ios/Recipes/Animation/CoreAnimation/Animate_a_UIView_using_UIKit" />
        <!-- TODO: Switch to UUID-based URL -->
      </Docs>
    </Member>
    <Member MemberName="BeginAnimations">
      <MemberSignature Language="C#" Value="public static void BeginAnimations (string animationID, IntPtr context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginAnimations(string animationID, native int context) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.BeginAnimations(System.String,System.IntPtr)" />
      <MemberSignature Language="F#" Value="static member BeginAnimations : string * nativeint -&gt; unit" Usage="UIKit.UIView.BeginAnimations (animationID, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("beginAnimations:context:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="animationID" Type="System.String" />
        <Parameter Name="context" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="animationID">
          <para>The animation identifier.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <param name="context">A handle to custom data that provides context for the animation.</param>
        <summary>Indicates the beginning of an animation block</summary>
        <remarks>
          <para>The use of this method is discouraged. Application developers should prefer to use the <see cref="T:UIKit.UIViewPropertyAnimator" /> class to animate UIViews.</para>
          <para>If no native data is being used for <paramref name="context" />, application developers should specify <paramref name="context" /> as <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=System%20Int%20Ptr%20Zero&amp;scope=Xamarin" title="F:System.IntPtr.Zero">F:System.IntPtr.Zero</a></format>.        </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BoldTextStatusDidChangeNotification">
      <MemberSignature Language="C#" Value="public static Foundation.NSString BoldTextStatusDidChangeNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString BoldTextStatusDidChangeNotification" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.BoldTextStatusDidChangeNotification" />
      <MemberSignature Language="F#" Value="member this.BoldTextStatusDidChangeNotification : Foundation.NSString" Usage="UIKit.UIView.BoldTextStatusDidChangeNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Use UIView.Notifications.ObserveBoldTextStatusDidChange helper method instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Field("UIAccessibilityBoldTextStatusDidChangeNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for BoldTextStatusDidChange</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIView.BoldTextStatusDidChangeNotification, (notification) => {Console.WriteLine ("Received the notification UIView", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIView", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIView.BoldTextStatusDidChangeNotification, Callback);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BottomAnchor">
      <MemberSignature Language="C#" Value="public virtual UIKit.NSLayoutYAxisAnchor BottomAnchor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.NSLayoutYAxisAnchor BottomAnchor" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.BottomAnchor" />
      <MemberSignature Language="F#" Value="member this.BottomAnchor : UIKit.NSLayoutYAxisAnchor" Usage="UIKit.UIView.BottomAnchor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("bottomAnchor")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.NSLayoutYAxisAnchor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The <see cref="T:UIKit.NSLayoutYAxisAnchor" /> that defines the bottom of this <see cref="T:UIKit.UIView" />.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:UIKit.UIView.TopAnchor" />
        <altmember cref="P:UIKit.UIView.LeftAnchor" />
        <altmember cref="P:UIKit.UIView.RightAnchor" />
        <altmember cref="P:UIKit.UIView.LeadingAnchor" />
        <altmember cref="P:UIKit.UIView.TrailingAnchor" />
        <altmember cref="P:UIKit.UIView.CenterXAnchor" />
        <altmember cref="P:UIKit.UIView.CenterYAnchor" />
        <altmember cref="P:UIKit.UIView.TopAnchor" />
        <altmember cref="P:UIKit.UIView.FirstBaselineAnchor" />
        <altmember cref="P:UIKit.UIView.LastBaselineAnchor" />
      </Docs>
    </Member>
    <Member MemberName="Bounds">
      <MemberSignature Language="C#" Value="public virtual CoreGraphics.CGRect Bounds { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype CoreGraphics.CGRect Bounds" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.Bounds" />
      <MemberSignature Language="F#" Value="member this.Bounds : CoreGraphics.CGRect with get, set" Usage="UIKit.UIView.Bounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("bounds")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setBounds:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>CoreGraphics.CGRect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The usable frame of the view, specified using the view's own coordinate system.</summary>
        <value>
        </value>
        <remarks>
          <para>
            This property represents the usable
            frame of the view.  Unlike the <see cref="P:UIKit.UIView.Frame" />, the <see cref="P:UIKit.UIView.Bounds" /> do not use the container's
            coordinate space, but instead represent the size in the view's own
            coordinate space.  By default the <see cref="P:UIKit.UIView.Bounds" /> location is
            (0,0).
          </para>
          <para>
            When you update this property, it will modify the <see cref="P:UIKit.UIView.Frame" /> based on the value
            of the <see cref="P:UIKit.UIView.Center" />.  You
            can also change the position of your view by updating the
            <see cref="P:UIKit.UIView.Center" /> property.
            
          </para>
          <para>
            When the Bound property is changed, the size of the view is affected
            relative to the <see cref="P:UIKit.UIView.Center" /> property.
          </para>
          <para>The <see cref="P:UIKit.UIView.Bounds" /> property is relative to <c>this</c> <see cref="T:UIKit.UIView" />'s coordinate system. For instance, the following example shows a view (a <see cref="T:UIKit.UIImageView" />, actually) that has been rotated 45 degrees. The value of <c>flowerView.Bounds</c> remains [{0,0},{100,100}]. In contrast, the <see cref="P:UIKit.UIView.Frame" /> property is expressed in terms of the containing view's coordinate system. In this case, after the rotation has been applied, the value of <c>flowerView.Frame</c> becomes [{79.3,79.3}, {141.4, 141.4}].</para>
          <example>
            <code lang="C#"><![CDATA[
var flowerView = new UIImageView(new RectangleF(100, 100, 100, 100)) {
	Image = UIImage.FromFile("flower.png"),
	ContentMode = UIViewContentMode.Center,
	ClipsToBounds = true
};

flowerView.Transform = CGAffineTransform.MakeRotation((float) Math.PI / 4);
view.AddSubview(flowerView);            
              ]]></code>
          </example>
          <para>
            <img href="~/UIKit/_images/UIKit.UIView.Frame.png" />
          </para>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BringSubviewToFront">
      <MemberSignature Language="C#" Value="public virtual void BringSubviewToFront (UIKit.UIView view);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BringSubviewToFront(class UIKit.UIView view) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.BringSubviewToFront(UIKit.UIView)" />
      <MemberSignature Language="F#" Value="abstract member BringSubviewToFront : UIKit.UIView -&gt; unit&#xA;override this.BringSubviewToFront : UIKit.UIView -&gt; unit" Usage="uIView.BringSubviewToFront view" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("bringSubviewToFront:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="view" Type="UIKit.UIView" />
      </Parameters>
      <Docs>
        <param name="view">
          <para>The subview to move to the front.</para>
        </param>
        <summary>Moves the specified subview so that it appears in front of other <see cref="P:UIKit.UIView.Subviews" />.</summary>
        <remarks>
        </remarks>
        <altmember cref="M:UIKit.UIView.SendSubviewToBack" />
      </Docs>
    </Member>
    <Member MemberName="CanBecomeFocused">
      <MemberSignature Language="C#" Value="public virtual bool CanBecomeFocused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanBecomeFocused" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.CanBecomeFocused" />
      <MemberSignature Language="F#" Value="member this.CanBecomeFocused : bool" Usage="UIKit.UIView.CanBecomeFocused" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:UIKit.IUIFocusItem.CanBecomeFocused</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("canBecomeFocused")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether this <see cref="T:UIKit.UIView" /> can become the focused view.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Capture">
      <MemberSignature Language="C#" Value="public UIKit.UIImage Capture (bool afterScreenUpdates = true);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class UIKit.UIImage Capture(bool afterScreenUpdates) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.Capture(System.Boolean)" />
      <MemberSignature Language="F#" Value="member this.Capture : bool -&gt; UIKit.UIImage" Usage="uIView.Capture afterScreenUpdates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>UIKit.UIImage</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="afterScreenUpdates" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="afterScreenUpdates">If <see langword="true" />, the capture occurs after screen updating has finished.</param>
        <summary>Performs a screen-capture of the <see cref="T:UIKit.UIView" />.</summary>
        <returns>To be added.</returns>
        <remarks>
          <para>This method is slower than <see cref="M:UIKit.UIView.SnapshotView(System.Boolean)" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Center">
      <MemberSignature Language="C#" Value="public virtual CoreGraphics.CGPoint Center { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype CoreGraphics.CGPoint Center" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.Center" />
      <MemberSignature Language="F#" Value="member this.Center : CoreGraphics.CGPoint with get, set" Usage="UIKit.UIView.Center" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:UIKit.IUIDynamicItem.Center</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("center")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setCenter:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>CoreGraphics.CGPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The center of the view, in the container coordinate space.</summary>
        <value>This value is measured in points, not pixels.</value>
        <remarks>
          <para>
            When you update this property, this will automatically
            adjust corresponding  <see cref="P:UIKit.UIView.Frame" />.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CenterXAnchor">
      <MemberSignature Language="C#" Value="public virtual UIKit.NSLayoutXAxisAnchor CenterXAnchor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.NSLayoutXAxisAnchor CenterXAnchor" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.CenterXAnchor" />
      <MemberSignature Language="F#" Value="member this.CenterXAnchor : UIKit.NSLayoutXAxisAnchor" Usage="UIKit.UIView.CenterXAnchor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("centerXAnchor")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.NSLayoutXAxisAnchor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The <see cref="T:UIKit.NSLayoutXAxisAnchor" /> that defines the X-axis center of this <see cref="T:UIKit.UIView" />.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:UIKit.UIView.TopAnchor" />
        <altmember cref="P:UIKit.UIView.BottomAnchor" />
        <altmember cref="P:UIKit.UIView.LeftAnchor" />
        <altmember cref="P:UIKit.UIView.RightAnchor" />
        <altmember cref="P:UIKit.UIView.LeadingAnchor" />
        <altmember cref="P:UIKit.UIView.TrailingAnchor" />
        <altmember cref="P:UIKit.UIView.CenterYAnchor" />
        <altmember cref="P:UIKit.UIView.TopAnchor" />
        <altmember cref="P:UIKit.UIView.FirstBaselineAnchor" />
        <altmember cref="P:UIKit.UIView.LastBaselineAnchor" />
      </Docs>
    </Member>
    <Member MemberName="CenterYAnchor">
      <MemberSignature Language="C#" Value="public virtual UIKit.NSLayoutYAxisAnchor CenterYAnchor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.NSLayoutYAxisAnchor CenterYAnchor" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.CenterYAnchor" />
      <MemberSignature Language="F#" Value="member this.CenterYAnchor : UIKit.NSLayoutYAxisAnchor" Usage="UIKit.UIView.CenterYAnchor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("centerYAnchor")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.NSLayoutYAxisAnchor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The <see cref="T:UIKit.NSLayoutYAxisAnchor" /> that defines the Y-axis center of this <see cref="T:UIKit.UIView" />.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:UIKit.UIView.TopAnchor" />
        <altmember cref="P:UIKit.UIView.BottomAnchor" />
        <altmember cref="P:UIKit.UIView.LeftAnchor" />
        <altmember cref="P:UIKit.UIView.RightAnchor" />
        <altmember cref="P:UIKit.UIView.LeadingAnchor" />
        <altmember cref="P:UIKit.UIView.TrailingAnchor" />
        <altmember cref="P:UIKit.UIView.CenterXAnchor" />
        <altmember cref="P:UIKit.UIView.TopAnchor" />
        <altmember cref="P:UIKit.UIView.FirstBaselineAnchor" />
        <altmember cref="P:UIKit.UIView.LastBaselineAnchor" />
      </Docs>
    </Member>
    <Member MemberName="ClassHandle">
      <MemberSignature Language="C#" Value="public override IntPtr ClassHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ClassHandle" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.ClassHandle" />
      <MemberSignature Language="F#" Value="member this.ClassHandle : nativeint" Usage="UIKit.UIView.ClassHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The handle for this class.</summary>
        <value>The pointer to the Objective-C class.</value>
        <remarks>Each Xamarin.iOS class mirrors an unmanaged Objective-C class.   This value contains the pointer to the Objective-C class, it is similar to calling objc_getClass with the object name.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearsContextBeforeDrawing">
      <MemberSignature Language="C#" Value="public virtual bool ClearsContextBeforeDrawing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ClearsContextBeforeDrawing" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.ClearsContextBeforeDrawing" />
      <MemberSignature Language="F#" Value="member this.ClearsContextBeforeDrawing : bool with get, set" Usage="UIKit.UIView.ClearsContextBeforeDrawing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("clearsContextBeforeDrawing")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setClearsContextBeforeDrawing:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies that the drawing buffer be erased prior to calling <see cref="M:UIKit.UIView.DrawRect(CoreGraphics.CGRect,UIKit.UIViewPrintFormatter)" /></summary>
        <value>The default value is <see langword="true" />.</value>
        <remarks>
          <para>If this value is <see langword="true" />, the receiver's <see cref="P:UIKit.UIView.Bounds" /> are erased and set to transparent black before the receiver's <see cref="M:UIKit.UIView.DrawRect(CoreGraphics.CGRect,UIKit.UIViewPrintFormatter)" /> method is called.</para>
          <para>If the application developer has written a highly optimized <see cref="M:UIKit.UIView.DrawRect(CoreGraphics.CGRect,UIKit.UIViewPrintFormatter)" />, this property can be set to <see langword="false" /> which may lead to a performance improvement.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClipsToBounds">
      <MemberSignature Language="C#" Value="public virtual bool ClipsToBounds { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ClipsToBounds" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.ClipsToBounds" />
      <MemberSignature Language="F#" Value="member this.ClipsToBounds : bool with get, set" Usage="UIKit.UIView.ClipsToBounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("clipsToBounds")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setClipsToBounds:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies whether the <see cref="P:UIKit.UIView.Subviews" /> are confined to the <see cref="P:UIKit.UIView.Bounds" /> of the receiver.</summary>
        <value>The default value is <see langword="false" />.</value>
        <remarks>
          <para>If this property is <see langword="false" />, subviews whose <see cref="P:UIKit.UIView.Frame" /> extends beyond their <see cref="P:UIKit.UIView.Superview" />'s <see cref="P:UIKit.UIView.Bounds" /> will be fully displayed. If this property is <see langword="true" />, only that portion that lies within their <see cref="P:UIKit.UIView.Superview" />'s <see cref="P:UIKit.UIView.Bounds" /> will be displayed. </para>
          <para>In the following image, the green rectangles are subviews of the blue rectangles (<c>var innerView = new UIView(new RectangleF(-10, 10, 175, 25));</c>). The top blue rectangle has its <see cref="P:UIKit.UIView.ClipsToBounds" /> left at the default <see langword="false" /> value while the lower rectangle shows the clipping that occurs when <see cref="P:UIKit.UIView.ClipsToBounds" /> is set to <see langword="true" />.</para>
          <para>
            <img href="~/UIKit/_images/UIKit.UIView.ClipsToBounds.png" />
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClosedCaptioningStatusDidChangeNotification">
      <MemberSignature Language="C#" Value="public static Foundation.NSString ClosedCaptioningStatusDidChangeNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString ClosedCaptioningStatusDidChangeNotification" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.ClosedCaptioningStatusDidChangeNotification" />
      <MemberSignature Language="F#" Value="member this.ClosedCaptioningStatusDidChangeNotification : Foundation.NSString" Usage="UIKit.UIView.ClosedCaptioningStatusDidChangeNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Use UIView.Notifications.ObserveClosedCaptioningStatusDidChange helper method instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Field("UIAccessibilityClosedCaptioningStatusDidChangeNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for ClosedCaptioningStatusDidChange</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
    UIView.ClosedCaptioningStatusDidChangeNotification, (notification) => {
        Console.WriteLine ("Received the notification UIView", notification); 
    });

// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIView", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIView.ClosedCaptioningStatusDidChangeNotification, Callback);
}
              ]]></code>
          </example>
        </remarks>
        <altmember cref="P:UIKit.UIView.AnnouncementNotification" />
        <altmember cref="P:UIKit.UIView.AnnouncementDidFinishNotification" />
        <altmember cref="P:UIKit.UIView.ClosedCaptioningStatusDidChangeNotification" />
        <altmember cref="P:UIKit.UIView.GuidedAccessStatusDidChangeNotification" />
        <altmember cref="P:UIKit.UIView.InvertColorStatusDidChangeNotification" />
        <altmember cref="P:UIKit.UIView.AnnouncementNotification" />
        <altmember cref="P:UIKit.UIView.LayoutChangedNotification" />
        <altmember cref="P:UIKit.UIView.MonoAudioStatusDidChangeNotification" />
        <altmember cref="P:UIKit.UIView.PageScrolledNotification" />
        <altmember cref="P:UIKit.UIView.ScreenChangedNotification" />
        <altmember cref="P:UIKit.UIView.VoiceOverStatusChangedNotification" />
      </Docs>
    </Member>
    <Member MemberName="CollisionBoundingPath">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIBezierPath CollisionBoundingPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIBezierPath CollisionBoundingPath" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.CollisionBoundingPath" />
      <MemberSignature Language="F#" Value="member this.CollisionBoundingPath : UIKit.UIBezierPath" Usage="UIKit.UIView.CollisionBoundingPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("collisionBoundingPath")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIBezierPath</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the <see cref="T:UIKit.UIBezierPath" /> to be used for collision detection.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CollisionBoundsType">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIDynamicItemCollisionBoundsType CollisionBoundsType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype UIKit.UIDynamicItemCollisionBoundsType CollisionBoundsType" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.CollisionBoundsType" />
      <MemberSignature Language="F#" Value="member this.CollisionBoundsType : UIKit.UIDynamicItemCollisionBoundsType" Usage="UIKit.UIView.CollisionBoundsType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("collisionBoundsType")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIDynamicItemCollisionBoundsType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the <see cref="T:UIKit.UIDynamicItemCollisionBoundsType" /> describing the type of bounds used for collision detected.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommitAnimations">
      <MemberSignature Language="C#" Value="public static void CommitAnimations ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CommitAnimations() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.CommitAnimations" />
      <MemberSignature Language="F#" Value="static member CommitAnimations : unit -&gt; unit" Usage="UIKit.UIView.CommitAnimations " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("commitAnimations")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indicates the end of an animation block.</summary>
        <remarks>
          <para>The use of this method is discouraged. Application developers should prefer to use the <see cref="T:UIKit.UIViewPropertyAnimator" /> class to animate UIViews.</para>
          <para>Older versions of iOS used a matched set of <see cref="M:UIKit.UIView.BeginAnimations(System.String,System.IntPtr)" /> and <see cref="M:UIKit.UIView.CommitAnimations" /> to specify an animation block. The following code, taken from the "Animate a UIView using UIKit" recipe, shows the technique:</para>
          <example>
            <code lang="C#"><![CDATA[
  UIView.BeginAnimations ("slideAnimation");
  
  UIView.SetAnimationDuration (2);
  UIView.SetAnimationCurve (UIViewAnimationCurve.EaseInOut);
  UIView.SetAnimationRepeatCount (2);
  UIView.SetAnimationRepeatAutoreverses (true);
  UIView.SetAnimationDelegate (this);
  UIView.SetAnimationDidStopSelector (
    new Selector ("slideAnimationFinished:"));
  _imageView.Center = new PointF (UIScreen.MainScreen.Bounds.Right -
    _imageView.Frame.Width / 2, _imageView.Center.Y);
  UIView.CommitAnimations ();
              ]]></code>
          </example>
        </remarks>
        <altmember cref="M:UIKit.UIView.BeginAnimations" />
        <related type="recipe" href="https://developer.xamarin.com/ios/Recipes/Animation/CoreAnimation/Animate_a_UIView_using_UIKit" />
        <!-- TODO: Switch to UUID-based URL -->
      </Docs>
    </Member>
    <Member MemberName="Constraints">
      <MemberSignature Language="C#" Value="public virtual UIKit.NSLayoutConstraint[] Constraints { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.NSLayoutConstraint[] Constraints" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.Constraints" />
      <MemberSignature Language="F#" Value="member this.Constraints : UIKit.NSLayoutConstraint[]" Usage="UIKit.UIView.Constraints" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("constraints")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.NSLayoutConstraint[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The constraints used by Auto Layout on this <see cref="T:UIKit.UIView" />.</summary>
        <value>The default value is an empty array.</value>
        <remarks>
          <para>
            Auto Layout uses the <see cref="P:UIKit.UIView.Constraints" /> of a <see cref="T:UIKit.UIView" /> to lay out its <see cref="P:UIKit.UIView.Subviews" />. These constraints are set with <see cref="M:UIKit.UIView.AddConstraint(UIKit.NSLayoutConstraint)" /> or <see cref="M:UIKit.UIView.AddConstraints(UIKit.NSLayoutConstraint[])" />. 
          </para>
          <para>
            The <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=UIKit%20NSLayout%20Constraint%20Debug%20Description&amp;scope=Xamarin" title="P:UIKit.NSLayoutConstraint.DebugDescription">P:UIKit.NSLayoutConstraint.DebugDescription</a></format> property can be helpful in debugging Auto Layout issues. 
          </para>
          <example>
            <code lang="C#"><![CDATA[
foreach(var c in mainView.Constraints)
{
    Console.WriteLine(c.DebugDescription);
}              
              ]]></code>
          </example>
        </remarks>
        <altmember cref="M:UIKit.UIView.AddConstraint" />
        <altmember cref="M:UIKit.UIView.AddConstraints" />
        <altmember cref="M:UIKit.UIView.RemoveConstraint" />
        <altmember cref="M:UIKit.UIView.RemoveConstraints" />
        <altmember cref="P:UIKit.UIView.TranslatesAutoresizingMaskIntoConstraints" />
      </Docs>
    </Member>
    <Member MemberName="ContentCompressionResistancePriority">
      <MemberSignature Language="C#" Value="public virtual float ContentCompressionResistancePriority (UIKit.UILayoutConstraintAxis axis);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float32 ContentCompressionResistancePriority(valuetype UIKit.UILayoutConstraintAxis axis) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.ContentCompressionResistancePriority(UIKit.UILayoutConstraintAxis)" />
      <MemberSignature Language="F#" Value="abstract member ContentCompressionResistancePriority : UIKit.UILayoutConstraintAxis -&gt; single&#xA;override this.ContentCompressionResistancePriority : UIKit.UILayoutConstraintAxis -&gt; single" Usage="uIView.ContentCompressionResistancePriority axis" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("contentCompressionResistancePriorityForAxis:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="axis" Type="UIKit.UILayoutConstraintAxis" />
      </Parameters>
      <Docs>
        <param name="axis">The axis whose resistance is being queried.</param>
        <summary>Returns the resistance of an axis to compression below its intrinsic size.</summary>
        <returns>A <see cref="T:UIKit.UILayoutPriority" /> that specifies how resistant the view is along the <paramref name="axis" /> to compression below its intrinsic size.</returns>
        <remarks>
          <para>Application developers should not override this method. Instead, they should manipulate the result by using <see cref="M:UIKit.UIView.SetContentCompressionResistancePriority(System.Single,UIKit.UILayoutConstraintAxis)" /></para>.
        <para><see cref="M:UIKit.UIView.ContentCompressionResistancePriority(UIKit.UILayoutConstraintAxis)" /> and <see cref="M:UIKit.UIView.ContentHuggingPriority(UIKit.UILayoutConstraintAxis)" /> are complementary: <see cref="M:UIKit.UIView.ContentCompressionResistancePriority(UIKit.UILayoutConstraintAxis)" /> is the resistance to shrinking of the content and <see cref="M:UIKit.UIView.ContentHuggingPriority(UIKit.UILayoutConstraintAxis)" /> is the resistance to growing.</para></remarks>
        <altmember cref="M:UIKit.UIView.SetContentCompressionResistancePriority" />
        <altmember cref="M:UIKit.UIView.ContentHuggingPriority" />
      </Docs>
    </Member>
    <Member MemberName="ContentHuggingPriority">
      <MemberSignature Language="C#" Value="public virtual float ContentHuggingPriority (UIKit.UILayoutConstraintAxis axis);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float32 ContentHuggingPriority(valuetype UIKit.UILayoutConstraintAxis axis) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.ContentHuggingPriority(UIKit.UILayoutConstraintAxis)" />
      <MemberSignature Language="F#" Value="abstract member ContentHuggingPriority : UIKit.UILayoutConstraintAxis -&gt; single&#xA;override this.ContentHuggingPriority : UIKit.UILayoutConstraintAxis -&gt; single" Usage="uIView.ContentHuggingPriority axis" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("contentHuggingPriorityForAxis:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="axis" Type="UIKit.UILayoutConstraintAxis" />
      </Parameters>
      <Docs>
        <param name="axis">The axis whose resistance is being queried.</param>
        <summary>Returns the resistance of an axis to expansion larger than its intrinsic size.</summary>
        <returns>A <see cref="T:UIKit.UILayoutPriority" /> that specifies how resistant the view is along the <paramref name="axis" /> to expansion beyond its intrinsic size.</returns>
        <remarks>
          <para>Application developers should not override this method. Instead, they should manipulate the result by using <see cref="M:UIKit.UIView.SetContentHuggingPriority(System.Single,UIKit.UILayoutConstraintAxis)" />.</para>
          <para>
            <see cref="M:UIKit.UIView.ContentCompressionResistancePriority(UIKit.UILayoutConstraintAxis)" /> and <see cref="M:UIKit.UIView.ContentHuggingPriority(UIKit.UILayoutConstraintAxis)" /> are complementary: <see cref="M:UIKit.UIView.ContentCompressionResistancePriority(UIKit.UILayoutConstraintAxis)" /> is the resistance to shrinking of the content and <see cref="M:UIKit.UIView.ContentHuggingPriority(UIKit.UILayoutConstraintAxis)" /> is the resistance to growing.</para>
        </remarks>
        <altmember cref="M:UIKit.UIView.SetContentHuggingPriority" />
        <altmember cref="M:UIKit.UIView.ContentCompressionResistancePriority" />
      </Docs>
    </Member>
    <Member MemberName="ContentMode">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIViewContentMode ContentMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype UIKit.UIViewContentMode ContentMode" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.ContentMode" />
      <MemberSignature Language="F#" Value="member this.ContentMode : UIKit.UIViewContentMode with get, set" Usage="UIKit.UIView.ContentMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("contentMode")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setContentMode:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIViewContentMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Controls how the cached bitmap of a view must be rendered when the view's bounds change.</summary>
        <value>
        </value>
        <remarks>
          <para>
            Used to control how the cached bitmap of the UIView changes when the <see cref="P:UIKit.UIView.Frame" /> or <see cref="P:UIKit.UIView.Bounds" /> properties are updated.   
          </para>
          <para>
            This property works in conjunction with the <see cref="P:UIKit.UIView.ContentStretch" /> property.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentScaleFactor">
      <MemberSignature Language="C#" Value="public virtual nfloat ContentScaleFactor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.nfloat ContentScaleFactor" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.ContentScaleFactor" />
      <MemberSignature Language="F#" Value="member this.ContentScaleFactor : nfloat with get, set" Usage="UIKit.UIView.ContentScaleFactor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("contentScaleFactor")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setContentScaleFactor:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.nfloat</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The number of device pixels per logical coordinate point.</summary>
        <value>The default value depends on the underlying hardware and the backing view type. The value is typically either 2.0 or 1.0.</value>
        <remarks>
          <para>The coordinate space used by application developers is measured in logical points. High-resolution (Retina) displays will have more than a single physical pixel per logical point and this property specifies the scale factor.</para>
          <para>
            <see cref="T:UIKit.UIView" />s that are backed by a <see cref="T:CoreAnimation.CAEAGLLayer" /> may return 1.0 even if they are being displayed on a high-resolution screen.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentStretch">
      <MemberSignature Language="C#" Value="public virtual CoreGraphics.CGRect ContentStretch { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype CoreGraphics.CGRect ContentStretch" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.ContentStretch" />
      <MemberSignature Language="F#" Value="member this.ContentStretch : CoreGraphics.CGRect with get, set" Usage="UIKit.UIView.ContentStretch" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, "Use 'CreateResizableImage' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("contentStretch")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, "Use 'CreateResizableImage' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setContentStretch:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, "Use 'CreateResizableImage' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>CoreGraphics.CGRect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Developers should not use this deprecated property. Developers should use 'CreateResizableImage' instead.</summary>
        <value>
        </value>
        <remarks>This property was deprecated in iOS 6.0.   Developers are advised to use UIImageView with a stretchable UIImage instead.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertPointFromCoordinateSpace">
      <MemberSignature Language="C#" Value="public virtual CoreGraphics.CGPoint ConvertPointFromCoordinateSpace (CoreGraphics.CGPoint point, UIKit.IUICoordinateSpace coordinateSpace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype CoreGraphics.CGPoint ConvertPointFromCoordinateSpace(valuetype CoreGraphics.CGPoint point, class UIKit.IUICoordinateSpace coordinateSpace) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.ConvertPointFromCoordinateSpace(CoreGraphics.CGPoint,UIKit.IUICoordinateSpace)" />
      <MemberSignature Language="F#" Value="abstract member ConvertPointFromCoordinateSpace : CoreGraphics.CGPoint * UIKit.IUICoordinateSpace -&gt; CoreGraphics.CGPoint&#xA;override this.ConvertPointFromCoordinateSpace : CoreGraphics.CGPoint * UIKit.IUICoordinateSpace -&gt; CoreGraphics.CGPoint" Usage="uIView.ConvertPointFromCoordinateSpace (point, coordinateSpace)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:UIKit.IUICoordinateSpace.ConvertPointFromCoordinateSpace(CoreGraphics.CGPoint,UIKit.IUICoordinateSpace)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("convertPoint:fromCoordinateSpace:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>CoreGraphics.CGPoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="CoreGraphics.CGPoint" />
        <Parameter Name="coordinateSpace" Type="UIKit.IUICoordinateSpace" />
      </Parameters>
      <Docs>
        <param name="point">To be added.</param>
        <param name="coordinateSpace">To be added.</param>
        <summary>Converts <param name="point" /> from the coordinate system <param name="coordinateSpace" /> to <see langword="this" /><see cref="T:UIKit.UIView" /> object's coordinate system.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertPointFromView">
      <MemberSignature Language="C#" Value="public virtual CoreGraphics.CGPoint ConvertPointFromView (CoreGraphics.CGPoint point, UIKit.UIView fromView);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype CoreGraphics.CGPoint ConvertPointFromView(valuetype CoreGraphics.CGPoint point, class UIKit.UIView fromView) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.ConvertPointFromView(CoreGraphics.CGPoint,UIKit.UIView)" />
      <MemberSignature Language="F#" Value="abstract member ConvertPointFromView : CoreGraphics.CGPoint * UIKit.UIView -&gt; CoreGraphics.CGPoint&#xA;override this.ConvertPointFromView : CoreGraphics.CGPoint * UIKit.UIView -&gt; CoreGraphics.CGPoint" Usage="uIView.ConvertPointFromView (point, fromView)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("convertPoint:fromView:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>CoreGraphics.CGPoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="CoreGraphics.CGPoint" />
        <Parameter Name="fromView" Type="UIKit.UIView" />
      </Parameters>
      <Docs>
        <param name="point">To be added.</param>
        <param name="fromView">
          <para>To be added.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Converts <param name="point" /> from the coordinate system of <param name="fromView" /> to <see langword="this" /> object's coordinate system.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertPointToCoordinateSpace">
      <MemberSignature Language="C#" Value="public virtual CoreGraphics.CGPoint ConvertPointToCoordinateSpace (CoreGraphics.CGPoint point, UIKit.IUICoordinateSpace coordinateSpace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype CoreGraphics.CGPoint ConvertPointToCoordinateSpace(valuetype CoreGraphics.CGPoint point, class UIKit.IUICoordinateSpace coordinateSpace) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.ConvertPointToCoordinateSpace(CoreGraphics.CGPoint,UIKit.IUICoordinateSpace)" />
      <MemberSignature Language="F#" Value="abstract member ConvertPointToCoordinateSpace : CoreGraphics.CGPoint * UIKit.IUICoordinateSpace -&gt; CoreGraphics.CGPoint&#xA;override this.ConvertPointToCoordinateSpace : CoreGraphics.CGPoint * UIKit.IUICoordinateSpace -&gt; CoreGraphics.CGPoint" Usage="uIView.ConvertPointToCoordinateSpace (point, coordinateSpace)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:UIKit.IUICoordinateSpace.ConvertPointToCoordinateSpace(CoreGraphics.CGPoint,UIKit.IUICoordinateSpace)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("convertPoint:toCoordinateSpace:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>CoreGraphics.CGPoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="CoreGraphics.CGPoint" />
        <Parameter Name="coordinateSpace" Type="UIKit.IUICoordinateSpace" />
      </Parameters>
      <Docs>
        <param name="point">To be added.</param>
        <param name="coordinateSpace">To be added.</param>
        <summary>Converts <param name="point" /> from <see langword="this" /> object's coordinate system to that of <param name="coordinateSpace" />.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertPointToView">
      <MemberSignature Language="C#" Value="public virtual CoreGraphics.CGPoint ConvertPointToView (CoreGraphics.CGPoint point, UIKit.UIView toView);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype CoreGraphics.CGPoint ConvertPointToView(valuetype CoreGraphics.CGPoint point, class UIKit.UIView toView) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.ConvertPointToView(CoreGraphics.CGPoint,UIKit.UIView)" />
      <MemberSignature Language="F#" Value="abstract member ConvertPointToView : CoreGraphics.CGPoint * UIKit.UIView -&gt; CoreGraphics.CGPoint&#xA;override this.ConvertPointToView : CoreGraphics.CGPoint * UIKit.UIView -&gt; CoreGraphics.CGPoint" Usage="uIView.ConvertPointToView (point, toView)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("convertPoint:toView:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>CoreGraphics.CGPoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="CoreGraphics.CGPoint" />
        <Parameter Name="toView" Type="UIKit.UIView" />
      </Parameters>
      <Docs>
        <param name="point">To be added.</param>
        <param name="toView">
          <para>To be added.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Converts <param name="point" /> from <see langword="this" /> object's coordinate system to that of <param name="toView" />.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertRectFromCoordinateSpace">
      <MemberSignature Language="C#" Value="public virtual CoreGraphics.CGRect ConvertRectFromCoordinateSpace (CoreGraphics.CGRect rect, UIKit.IUICoordinateSpace coordinateSpace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype CoreGraphics.CGRect ConvertRectFromCoordinateSpace(valuetype CoreGraphics.CGRect rect, class UIKit.IUICoordinateSpace coordinateSpace) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.ConvertRectFromCoordinateSpace(CoreGraphics.CGRect,UIKit.IUICoordinateSpace)" />
      <MemberSignature Language="F#" Value="abstract member ConvertRectFromCoordinateSpace : CoreGraphics.CGRect * UIKit.IUICoordinateSpace -&gt; CoreGraphics.CGRect&#xA;override this.ConvertRectFromCoordinateSpace : CoreGraphics.CGRect * UIKit.IUICoordinateSpace -&gt; CoreGraphics.CGRect" Usage="uIView.ConvertRectFromCoordinateSpace (rect, coordinateSpace)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:UIKit.IUICoordinateSpace.ConvertRectFromCoordinateSpace(CoreGraphics.CGRect,UIKit.IUICoordinateSpace)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("convertRect:fromCoordinateSpace:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>CoreGraphics.CGRect</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="CoreGraphics.CGRect" />
        <Parameter Name="coordinateSpace" Type="UIKit.IUICoordinateSpace" />
      </Parameters>
      <Docs>
        <param name="rect">To be added.</param>
        <param name="coordinateSpace">To be added.</param>
        <summary>Converts <param name="rect" /> from the coordinate system of <param name="coordinateSpace" /> to that of <see langword="this" /> object.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertRectFromView">
      <MemberSignature Language="C#" Value="public virtual CoreGraphics.CGRect ConvertRectFromView (CoreGraphics.CGRect rect, UIKit.UIView fromView);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype CoreGraphics.CGRect ConvertRectFromView(valuetype CoreGraphics.CGRect rect, class UIKit.UIView fromView) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.ConvertRectFromView(CoreGraphics.CGRect,UIKit.UIView)" />
      <MemberSignature Language="F#" Value="abstract member ConvertRectFromView : CoreGraphics.CGRect * UIKit.UIView -&gt; CoreGraphics.CGRect&#xA;override this.ConvertRectFromView : CoreGraphics.CGRect * UIKit.UIView -&gt; CoreGraphics.CGRect" Usage="uIView.ConvertRectFromView (rect, fromView)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("convertRect:fromView:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>CoreGraphics.CGRect</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="CoreGraphics.CGRect" />
        <Parameter Name="fromView" Type="UIKit.UIView" />
      </Parameters>
      <Docs>
        <param name="rect">To be added.</param>
        <param name="fromView">
          <para>To be added.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Converts <param name="rect" /> from the coordinate system used in <param name="fromView" /> to that of <see langword="this" /> object.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertRectToCoordinateSpace">
      <MemberSignature Language="C#" Value="public virtual CoreGraphics.CGRect ConvertRectToCoordinateSpace (CoreGraphics.CGRect rect, UIKit.IUICoordinateSpace coordinateSpace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype CoreGraphics.CGRect ConvertRectToCoordinateSpace(valuetype CoreGraphics.CGRect rect, class UIKit.IUICoordinateSpace coordinateSpace) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.ConvertRectToCoordinateSpace(CoreGraphics.CGRect,UIKit.IUICoordinateSpace)" />
      <MemberSignature Language="F#" Value="abstract member ConvertRectToCoordinateSpace : CoreGraphics.CGRect * UIKit.IUICoordinateSpace -&gt; CoreGraphics.CGRect&#xA;override this.ConvertRectToCoordinateSpace : CoreGraphics.CGRect * UIKit.IUICoordinateSpace -&gt; CoreGraphics.CGRect" Usage="uIView.ConvertRectToCoordinateSpace (rect, coordinateSpace)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:UIKit.IUICoordinateSpace.ConvertRectToCoordinateSpace(CoreGraphics.CGRect,UIKit.IUICoordinateSpace)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("convertRect:toCoordinateSpace:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>CoreGraphics.CGRect</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="CoreGraphics.CGRect" />
        <Parameter Name="coordinateSpace" Type="UIKit.IUICoordinateSpace" />
      </Parameters>
      <Docs>
        <param name="rect">To be added.</param>
        <param name="coordinateSpace">To be added.</param>
        <summary>Converts <param name="rect" /> from <see langword="this" /> object's coordinate system to that described by <param name="coordinateSpace" />.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertRectToView">
      <MemberSignature Language="C#" Value="public virtual CoreGraphics.CGRect ConvertRectToView (CoreGraphics.CGRect rect, UIKit.UIView toView);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype CoreGraphics.CGRect ConvertRectToView(valuetype CoreGraphics.CGRect rect, class UIKit.UIView toView) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.ConvertRectToView(CoreGraphics.CGRect,UIKit.UIView)" />
      <MemberSignature Language="F#" Value="abstract member ConvertRectToView : CoreGraphics.CGRect * UIKit.UIView -&gt; CoreGraphics.CGRect&#xA;override this.ConvertRectToView : CoreGraphics.CGRect * UIKit.UIView -&gt; CoreGraphics.CGRect" Usage="uIView.ConvertRectToView (rect, toView)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("convertRect:toView:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>CoreGraphics.CGRect</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="CoreGraphics.CGRect" />
        <Parameter Name="toView" Type="UIKit.UIView" />
      </Parameters>
      <Docs>
        <param name="rect">To be added.</param>
        <param name="toView">
          <para>To be added.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Converts <param name="rect" /> from <see langword="this" /> object's coordinate system to that of <param name="toView" />.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CoordinateSpace">
      <MemberSignature Language="C#" Value="public virtual UIKit.IUICoordinateSpace CoordinateSpace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.IUICoordinateSpace CoordinateSpace" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.CoordinateSpace" />
      <MemberSignature Language="F#" Value="member this.CoordinateSpace : UIKit.IUICoordinateSpace" Usage="UIKit.UIView.CoordinateSpace" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:UIKit.IUIFocusItemContainer.CoordinateSpace</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 12, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 12, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("coordinateSpace")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.IUICoordinateSpace</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns the coordinate space implemenation for the UIView.</summary>
        <value>The coordinate space implemenation for the UIView.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DarkerSystemColorsStatusDidChangeNotification">
      <MemberSignature Language="C#" Value="public static Foundation.NSString DarkerSystemColorsStatusDidChangeNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString DarkerSystemColorsStatusDidChangeNotification" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.DarkerSystemColorsStatusDidChangeNotification" />
      <MemberSignature Language="F#" Value="member this.DarkerSystemColorsStatusDidChangeNotification : Foundation.NSString" Usage="UIKit.UIView.DarkerSystemColorsStatusDidChangeNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Use UIView.Notifications.ObserveDarkerSystemColorsStatusDidChange helper method instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Field("UIAccessibilityDarkerSystemColorsStatusDidChangeNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for DarkerSystemColorsStatusDidChange</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIView.DarkerSystemColorsStatusDidChangeNotification, (notification) =>=> {Console.WriteLine ("Received the notification UIView", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIView", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIView.DarkerSystemColorsStatusDidChangeNotification, Callback);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DecodeRestorableState">
      <MemberSignature Language="C#" Value="public virtual void DecodeRestorableState (Foundation.NSCoder coder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DecodeRestorableState(class Foundation.NSCoder coder) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.DecodeRestorableState(Foundation.NSCoder)" />
      <MemberSignature Language="F#" Value="abstract member DecodeRestorableState : Foundation.NSCoder -&gt; unit&#xA;override this.DecodeRestorableState : Foundation.NSCoder -&gt; unit" Usage="uIView.DecodeRestorableState coder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("decodeRestorableStateWithCoder:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="coder" Type="Foundation.NSCoder" />
      </Parameters>
      <Docs>
        <param name="coder">The <see cref="T:Foundation.NSCoder" /> used to decode the state.</param>
        <summary>Application developers can override this method to support state restoration.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:UIKit.UIView.EncodeRestorableState" />
        <altmember cref="M:UIKit.UIApplicationDelegate.ShouldRestoreApplicationState" />
        <altmember cref="M:UIKit.UIApplicationDelegate.ShouldSaveApplicationState" />
      </Docs>
    </Member>
    <Member MemberName="DidHintFocusMovement">
      <MemberSignature Language="C#" Value="public virtual void DidHintFocusMovement (UIKit.UIFocusMovementHint hint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DidHintFocusMovement(class UIKit.UIFocusMovementHint hint) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.DidHintFocusMovement(UIKit.UIFocusMovementHint)" />
      <MemberSignature Language="F#" Value="abstract member DidHintFocusMovement : UIKit.UIFocusMovementHint -&gt; unit&#xA;override this.DidHintFocusMovement : UIKit.UIFocusMovementHint -&gt; unit" Usage="uIView.DidHintFocusMovement hint" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("didHintFocusMovement:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 12, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 12, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 10, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hint" Type="UIKit.UIFocusMovementHint" />
      </Parameters>
      <Docs>
        <param name="hint">The focus movement hint, which contains a vector hint.</param>
        <summary>Called to tell the focused item in the UIView that the focus may change.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DidUpdateFocus">
      <MemberSignature Language="C#" Value="public virtual void DidUpdateFocus (UIKit.UIFocusUpdateContext context, UIKit.UIFocusAnimationCoordinator coordinator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DidUpdateFocus(class UIKit.UIFocusUpdateContext context, class UIKit.UIFocusAnimationCoordinator coordinator) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.DidUpdateFocus(UIKit.UIFocusUpdateContext,UIKit.UIFocusAnimationCoordinator)" />
      <MemberSignature Language="F#" Value="abstract member DidUpdateFocus : UIKit.UIFocusUpdateContext * UIKit.UIFocusAnimationCoordinator -&gt; unit&#xA;override this.DidUpdateFocus : UIKit.UIFocusUpdateContext * UIKit.UIFocusAnimationCoordinator -&gt; unit" Usage="uIView.DidUpdateFocus (context, coordinator)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:UIKit.IUIFocusEnvironment.DidUpdateFocus(UIKit.UIFocusUpdateContext,UIKit.UIFocusAnimationCoordinator)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("didUpdateFocusInContext:withAnimationCoordinator:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="UIKit.UIFocusUpdateContext" />
        <Parameter Name="coordinator" Type="UIKit.UIFocusAnimationCoordinator" />
      </Parameters>
      <Docs>
        <param name="context">To be added.</param>
        <param name="coordinator">To be added.</param>
        <summary>Called after the <see cref="T:UIKit.UIView" /> has either lost or received focus. (See also <see cref="M:UIKit.UIView.ShouldUpdateFocus(UIKit.UIFocusUpdateContext)" />.)</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DirectionalLayoutMargins">
      <MemberSignature Language="C#" Value="public virtual UIKit.NSDirectionalEdgeInsets DirectionalLayoutMargins { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype UIKit.NSDirectionalEdgeInsets DirectionalLayoutMargins" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.DirectionalLayoutMargins" />
      <MemberSignature Language="F#" Value="member this.DirectionalLayoutMargins : UIKit.NSDirectionalEdgeInsets with get, set" Usage="UIKit.UIView.DirectionalLayoutMargins" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("directionalLayoutMargins", ObjCRuntime.ArgumentSemantic.UnsafeUnretained)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setDirectionalLayoutMargins:", ObjCRuntime.ArgumentSemantic.UnsafeUnretained)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.NSDirectionalEdgeInsets</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the layout margins for laying out content that respects the current language direction.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DisplayLayer">
      <MemberSignature Language="C#" Value="public virtual void DisplayLayer (CoreAnimation.CALayer layer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DisplayLayer(class CoreAnimation.CALayer layer) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.DisplayLayer(CoreAnimation.CALayer)" />
      <MemberSignature Language="F#" Value="abstract member DisplayLayer : CoreAnimation.CALayer -&gt; unit&#xA;override this.DisplayLayer : CoreAnimation.CALayer -&gt; unit" Usage="uIView.DisplayLayer layer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("displayLayer:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="layer" Type="CoreAnimation.CALayer" />
      </Parameters>
      <Docs>
        <param name="layer">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.Dispose(System.Boolean)" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="uIView.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <para>If set to <see langword="true" />, the method is invoked directly and will dispose manage and unmanaged resources;   If set to <see langword="false" /> the method is being called by the garbage collector finalizer and should only release unmanaged resources.</para>
        </param>
        <summary>Releases the resources used by the UIView object.</summary>
        <remarks>
          <para>This Dispose method releases the resources used by the UIView class.</para>
          <para>This method is called by both the Dispose() method and the object finalizer (Finalize).    When invoked by the Dispose method, the parameter disposing <paramref name="disposing" /> is set to <see langword="true" /> and any managed object references that this object holds are also disposed or released;  when invoked by the object finalizer, on the finalizer thread the value is set to <see langword="false" />. </para>
          <para>Calling the Dispose method when the application is finished using the UIView ensures that all external resources used by this managed object are released as soon as possible.  Once developers have invoked the Dispose method, the object is no longer useful and developers should no longer make any calls to it.</para>
          <para>  For more information on how to override this method and on the Dispose/IDisposable pattern, read the ``Implementing a Dispose Method'' document at https://msdn.microsoft.com/en-us/library/fs2xkftw.aspx</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Draw">
      <MemberSignature Language="C#" Value="public virtual void Draw (CoreGraphics.CGRect rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Draw(valuetype CoreGraphics.CGRect rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.Draw(CoreGraphics.CGRect)" />
      <MemberSignature Language="F#" Value="abstract member Draw : CoreGraphics.CGRect -&gt; unit&#xA;override this.Draw : CoreGraphics.CGRect -&gt; unit" Usage="uIView.Draw rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("drawRect:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="CoreGraphics.CGRect" />
      </Parameters>
      <Docs>
        <param name="rect">
          <para>The <see cref="T:System.Drawing.RectangleF" /> to draw.</para>
        </param>
        <summary>Draws the view within the passed-in rectangle.</summary>
        <remarks>
          <para>
            The <see cref="M:UIKit.UIView.Draw(CoreGraphics.CGRect)" /> method should never be called directly. It is called by iOS
            during run loop processing. The first time through the run loop, it
            is called. After that, it will be called on demand whenever the view
            has been marked as needing display by calling <see cref="M:UIKit.UIView.SetNeedsDisplayInRect(CoreGraphics.CGRect)" /> or
            <see cref="M:UIKit.UIView.SetNeedsDisplayInRect(CoreGraphics.CGRect)" />.
          </para>
          <para>
            Core Graphics uses device independent points rather than
            pixels. This allows drawing code to scale between different
            resolutions. For example, on a Retina display, 1 point is equivalent
            to 2 pixels, while on non-Retina displays, 1 point corresponds to 1
            pixel.
          </para>
          <example>
            <code lang="C#"><![CDATA[
public override void Draw (RectangleF rect)
{
    base.Draw (rect);

    var context = UIGraphics.GetCurrentContext ();

    context.SetLineWidth(4);
    UIColor.Red.SetFill ();
    UIColor.Blue.SetStroke ();

    var path = new CGPath ();

    path.AddLines(new PointF[]{
    new PointF(100,200),
    new PointF(160,100), 
    new PointF(220,200)});

    path.CloseSubpath();

    context.AddPath(path);		
    context.DrawPath(CGPathDrawingMode.FillStroke);
}
              ]]></code>
          </example>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawLayer">
      <MemberSignature Language="C#" Value="public virtual void DrawLayer (CoreAnimation.CALayer layer, CoreGraphics.CGContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawLayer(class CoreAnimation.CALayer layer, class CoreGraphics.CGContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.DrawLayer(CoreAnimation.CALayer,CoreGraphics.CGContext)" />
      <MemberSignature Language="F#" Value="abstract member DrawLayer : CoreAnimation.CALayer * CoreGraphics.CGContext -&gt; unit&#xA;override this.DrawLayer : CoreAnimation.CALayer * CoreGraphics.CGContext -&gt; unit" Usage="uIView.DrawLayer (layer, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("drawLayer:inContext:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="layer" Type="CoreAnimation.CALayer" />
        <Parameter Name="context" Type="CoreGraphics.CGContext" />
      </Parameters>
      <Docs>
        <param name="layer">To be added.</param>
        <param name="context">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawRect">
      <MemberSignature Language="C#" Value="public virtual void DrawRect (CoreGraphics.CGRect area, UIKit.UIViewPrintFormatter formatter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawRect(valuetype CoreGraphics.CGRect area, class UIKit.UIViewPrintFormatter formatter) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.DrawRect(CoreGraphics.CGRect,UIKit.UIViewPrintFormatter)" />
      <MemberSignature Language="F#" Value="abstract member DrawRect : CoreGraphics.CGRect * UIKit.UIViewPrintFormatter -&gt; unit&#xA;override this.DrawRect : CoreGraphics.CGRect * UIKit.UIViewPrintFormatter -&gt; unit" Usage="uIView.DrawRect (area, formatter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("drawRect:forViewPrintFormatter:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="area" Type="CoreGraphics.CGRect" />
        <Parameter Name="formatter" Type="UIKit.UIViewPrintFormatter" />
      </Parameters>
      <Docs>
        <param name="area">The area that should be drawn.</param>
        <param name="formatter">To be added.</param>
        <summary>Developers should override this method if their appr draws the <see cref="T:UIKit.UIView" /> contents.</summary>
        <remarks>
          <para>Developers directly over-riding <see cref="T:UIKit.UIView" /> need not call the base-class implementation.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawViewHierarchy">
      <MemberSignature Language="C#" Value="public virtual bool DrawViewHierarchy (CoreGraphics.CGRect rect, bool afterScreenUpdates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool DrawViewHierarchy(valuetype CoreGraphics.CGRect rect, bool afterScreenUpdates) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.DrawViewHierarchy(CoreGraphics.CGRect,System.Boolean)" />
      <MemberSignature Language="F#" Value="abstract member DrawViewHierarchy : CoreGraphics.CGRect * bool -&gt; bool&#xA;override this.DrawViewHierarchy : CoreGraphics.CGRect * bool -&gt; bool" Usage="uIView.DrawViewHierarchy (rect, afterScreenUpdates)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("drawViewHierarchyInRect:afterScreenUpdates:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="CoreGraphics.CGRect" />
        <Parameter Name="afterScreenUpdates" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="rect">To be added.</param>
        <param name="afterScreenUpdates">To be added.</param>
        <summary>Renders the complete view hierarchy visible on screen.</summary>
        <returns>
          <see langword="true" /> if the rendering succeeded.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EffectiveUserInterfaceLayoutDirection">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIUserInterfaceLayoutDirection EffectiveUserInterfaceLayoutDirection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype UIKit.UIUserInterfaceLayoutDirection EffectiveUserInterfaceLayoutDirection" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.EffectiveUserInterfaceLayoutDirection" />
      <MemberSignature Language="F#" Value="member this.EffectiveUserInterfaceLayoutDirection : UIKit.UIUserInterfaceLayoutDirection" Usage="UIKit.UIView.EffectiveUserInterfaceLayoutDirection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 10, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 10, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("effectiveUserInterfaceLayoutDirection")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 10, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 10, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIUserInterfaceLayoutDirection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the layout direction for arranging the view's contents.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ElementFocusedNotification">
      <MemberSignature Language="C#" Value="public static Foundation.NSString ElementFocusedNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString ElementFocusedNotification" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.ElementFocusedNotification" />
      <MemberSignature Language="F#" Value="member this.ElementFocusedNotification : Foundation.NSString" Usage="UIKit.UIView.ElementFocusedNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Use UIView.Notifications.ObserveElementFocused helper method instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Field("UIAccessibilityElementFocusedNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for ElementFocused</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIView.ElementFocusedNotification, (notification) =>=> {Console.WriteLine ("Received the notification UIView", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIView", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIView.ElementFocusedNotification, Callback);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EncodeRestorableState">
      <MemberSignature Language="C#" Value="public virtual void EncodeRestorableState (Foundation.NSCoder coder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EncodeRestorableState(class Foundation.NSCoder coder) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.EncodeRestorableState(Foundation.NSCoder)" />
      <MemberSignature Language="F#" Value="abstract member EncodeRestorableState : Foundation.NSCoder -&gt; unit&#xA;override this.EncodeRestorableState : Foundation.NSCoder -&gt; unit" Usage="uIView.EncodeRestorableState coder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("encodeRestorableStateWithCoder:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="coder" Type="Foundation.NSCoder" />
      </Parameters>
      <Docs>
        <param name="coder">The <see cref="T:Foundation.NSCoder" /> to encode the state.</param>
        <summary>Application developers can override this method to store state associated with the view.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:UIKit.UIView.DecodeRestorableState" />
        <altmember cref="M:UIKit.UIApplicationDelegate.ShouldRestoreApplicationState" />
        <altmember cref="M:UIKit.UIApplicationDelegate.ShouldSaveApplicationState" />
      </Docs>
    </Member>
    <Member MemberName="EncodeTo">
      <MemberSignature Language="C#" Value="public virtual void EncodeTo (Foundation.NSCoder encoder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EncodeTo(class Foundation.NSCoder encoder) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.EncodeTo(Foundation.NSCoder)" />
      <MemberSignature Language="F#" Value="abstract member EncodeTo : Foundation.NSCoder -&gt; unit&#xA;override this.EncodeTo : Foundation.NSCoder -&gt; unit" Usage="uIView.EncodeTo encoder" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Foundation.INSCoding.EncodeTo(Foundation.NSCoder)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("encodeWithCoder:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="encoder" Type="Foundation.NSCoder" />
      </Parameters>
      <Docs>
        <param name="encoder">The encoder object where the state of the object will be stored</param>
        <summary>Encodes the state of the object on the provided encoder</summary>
        <remarks>
          <para>This method is part of the <see cref="T:Foundation.NSCoding" /> protocol and is used by applications to preserve the state of the object into an archive.</para>
          <para>Users will typically create a <see cref="T:Foundation.NSKeyedArchiver" /> and then invoke the <see cref="M:Foundation.NSKeyedArchiver.ArchiveRootObjectToFile(Foundation.NSObject,System.String)" /> which will call into this method</para>
          <para>If developers want to allow their object to be archived, they should override this method and store their state in using the provided <paramref name="encoder" /> parameter.   In addition, developers should also implement a constructor that takes an NSCoder argument and is exported with [Export ("initWithCoder:")]</para>
          <example>
            <code lang="C#"><![CDATA[public void override EncodeTo (NSCoder coder){
    coder.Encode (1, key: "version");
    coder.Encode (userName, key: "userName");
    coder.Encode (hostName, key: "hostName");]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExchangeSubview">
      <MemberSignature Language="C#" Value="public virtual void ExchangeSubview (nint atIndex, nint withSubviewAtIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ExchangeSubview(valuetype System.nint atIndex, valuetype System.nint withSubviewAtIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.ExchangeSubview(System.nint,System.nint)" />
      <MemberSignature Language="F#" Value="abstract member ExchangeSubview : nint * nint -&gt; unit&#xA;override this.ExchangeSubview : nint * nint -&gt; unit" Usage="uIView.ExchangeSubview (atIndex, withSubviewAtIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("exchangeSubviewAtIndex:withSubviewAtIndex:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="atIndex" Type="System.nint" />
        <Parameter Name="withSubviewAtIndex" Type="System.nint" />
      </Parameters>
      <Docs>
        <param name="atIndex">
          <para>An index within the zero-based <see cref="P:UIKit.UIView.Subviews" /> array.</para>
        </param>
        <param name="withSubviewAtIndex">
          <para>Another index within the zero-based <see cref="P:UIKit.UIView.Subviews" /> array.</para>
        </param>
        <summary>This method exchanges the indices of two <see cref="T:UIKit.UIView" />s within the <see cref="P:UIKit.UIView.Subviews" /> array. </summary>
        <remarks>
        </remarks>
        <altmember cref="M:UIKit.UIView.AddSubview" />
        <altmember cref="M:UIKit.UIView.InsertSubview" />
        <altmember cref="M:UIKit.UIView.InsertSubviewAbove" />
        <altmember cref="M:UIKit.UIView.InsertSubviewBelow" />
      </Docs>
    </Member>
    <Member MemberName="ExclusiveTouch">
      <MemberSignature Language="C#" Value="public virtual bool ExclusiveTouch { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveTouch" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.ExclusiveTouch" />
      <MemberSignature Language="F#" Value="member this.ExclusiveTouch : bool with get, set" Usage="UIKit.UIView.ExclusiveTouch" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("isExclusiveTouch")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setExclusiveTouch:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Restricts the event delivery to this view.</summary>
        <value>The default value is false.</value>
        <remarks>
          <para>
            When this property is set, if this view starts tracking a
            touch, no other views in the window will receive these
            events.  Additionally, a view that has set this property
            to true wont receive any events that are associated with
            other views in the window.
          </para>
          <para>
            If a finger touches a view that hast this property set,
            the event is only delivered if no other view in the window
            is tracking a finger.  If a finger touches a non-exclusive
            window, the event is only delivered if there are no
            exclusive views tracking a finger.
            
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExerciseAmbiguityInLayout">
      <MemberSignature Language="C#" Value="public virtual void ExerciseAmbiguityInLayout ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ExerciseAmbiguityInLayout() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.ExerciseAmbiguityInLayout" />
      <MemberSignature Language="F#" Value="abstract member ExerciseAmbiguityInLayout : unit -&gt; unit&#xA;override this.ExerciseAmbiguityInLayout : unit -&gt; unit" Usage="uIView.ExerciseAmbiguityInLayout " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("exerciseAmbiguityInLayout")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Randomly changes the <see cref="P:UIKit.UIView.Frame" /> within an ambiguous set of Auto Layout constraints.</summary>
        <remarks>
          <para>This is a debugging method that should not be used in production applications.</para>
          <para>This method should be used with an under-constrained (ambiguous) Auto Layout. When called, it varies the <see cref="P:UIKit.UIView.Frame" /> among its valid values, providing visual cues to assist the application developer in determining needed constraints.</para>
        </remarks>
        <altmember cref="P:UIKit.UIView.HasAmbiguousLayout" />
      </Docs>
    </Member>
    <Member MemberName="FirstBaselineAnchor">
      <MemberSignature Language="C#" Value="public virtual UIKit.NSLayoutYAxisAnchor FirstBaselineAnchor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.NSLayoutYAxisAnchor FirstBaselineAnchor" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.FirstBaselineAnchor" />
      <MemberSignature Language="F#" Value="member this.FirstBaselineAnchor : UIKit.NSLayoutYAxisAnchor" Usage="UIKit.UIView.FirstBaselineAnchor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("firstBaselineAnchor")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.NSLayoutYAxisAnchor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A <see cref="T:UIKit.NSLayoutYAxisAnchor" /> that defines a constraint based on the baseline of the first line of text in this <see cref="T:UIKit.UIView" />.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:UIKit.UIView.TopAnchor" />
        <altmember cref="P:UIKit.UIView.BottomAnchor" />
        <altmember cref="P:UIKit.UIView.LeftAnchor" />
        <altmember cref="P:UIKit.UIView.RightAnchor" />
        <altmember cref="P:UIKit.UIView.LeadingAnchor" />
        <altmember cref="P:UIKit.UIView.TrailingAnchor" />
        <altmember cref="P:UIKit.UIView.CenterXAnchor" />
        <altmember cref="P:UIKit.UIView.CenterYAnchor" />
        <altmember cref="P:UIKit.UIView.TopAnchor" />
        <altmember cref="P:UIKit.UIView.LastBaselineAnchor" />
      </Docs>
    </Member>
    <Member MemberName="Focused">
      <MemberSignature Language="C#" Value="public virtual bool Focused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Focused" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.Focused" />
      <MemberSignature Language="F#" Value="member this.Focused : bool" Usage="UIKit.UIView.Focused" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("isFocused")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether the <see cref="T:UIKit.UIView" /> is the focused view.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusedElementKey">
      <MemberSignature Language="C#" Value="public static Foundation.NSString FocusedElementKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString FocusedElementKey" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.FocusedElementKey" />
      <MemberSignature Language="F#" Value="member this.FocusedElementKey : Foundation.NSString" Usage="UIKit.UIView.FocusedElementKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Use UIView.Notifications.ObserveFocusedElementKey helper method instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Field("UIAccessibilityFocusedElementKey", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A string constant used by accessibility APIs (see <see cref="M:UIKit.UIAccessibility.FocusedElement(System.String)" />) to identify the focused element.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusItemContainer">
      <MemberSignature Language="C#" Value="public virtual UIKit.IUIFocusItemContainer FocusItemContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.IUIFocusItemContainer FocusItemContainer" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.FocusItemContainer" />
      <MemberSignature Language="F#" Value="member this.FocusItemContainer : UIKit.IUIFocusItemContainer" Usage="UIKit.UIView.FocusItemContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 12, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 12, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("focusItemContainer")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 12, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 12, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.IUIFocusItemContainer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the focus container that provides spatial information to child focus items.</summary>
        <value>The focus container that provides spatial information to child focus items.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Frame">
      <MemberSignature Language="C#" Value="public virtual CoreGraphics.CGRect Frame { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype CoreGraphics.CGRect Frame" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.Frame" />
      <MemberSignature Language="F#" Value="member this.Frame : CoreGraphics.CGRect with get, set" Usage="UIKit.UIView.Frame" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("frame")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setFrame:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>CoreGraphics.CGRect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Coordinates of the view relative to its container.</summary>
        <value>The value of this property is in points, not pixels.</value>
        <remarks>
          <para>The <see cref="P:UIKit.UIView.Frame" /> property is expressed in terms of the <see cref="P:UIKit.UIView.Superview" />'s coordinate system. (The <see cref="P:UIKit.UIView.Bounds" /> property is expressed in terms of <c>this</c> <see cref="T:UIKit.UIView" />'s coordinate system.)</para>
          <para>The following example shows just one way the <see cref="P:UIKit.UIView.Frame" />'s coordinate system and values can vary from that of the <see cref="T:UIKit.UIView" />'s <see cref="P:UIKit.UIView.Bounds" />. In this case, a <see cref="T:UIKit.UIImageView" /> is placed with an initial <see cref="P:UIKit.UIView.Frame" /> originating at {100,100} and of size {100,100}. Once rotated, both the origin and size of the <see cref="P:UIKit.UIView.Frame" /> bounding box shift: the origin to accomodate the rotation and the sizes in order to contain the diagonal of the {100,100} box. The <see cref="P:UIKit.UIView.Bounds" /> of the <c>flowerView</c> remains [{0,0},{100,100}].</para>
          <example>
            <code lang="C#"><![CDATA[
var flowerView = new UIImageView(new RectangleF(100, 100, 100, 100)) {
	Image = UIImage.FromFile("flower.png"),
	ContentMode = UIViewContentMode.Center,
	ClipsToBounds = true
};

flowerView.Transform = CGAffineTransform.MakeRotation((float) Math.PI / 4);
view.AddSubview(flowerView);            
              
              ]]></code>
          </example>
          <para>
            <img href="~/UIKit/_images/UIKit.UIView.Frame.png" />
          </para>
          <para>
            When changes are done to this property, the <see cref="P:UIKit.UIView.Center" /> is updated with
            the new location and the <see cref="P:UIKit.UIView.Bounds" /> is updated with
            the new dimensions and a re-layout of the subviews is
            performed.
            
          </para>
          <para>
            Changing this property will not trigger a call to <see cref="M:UIKit.UIView.Draw(CoreGraphics.CGRect)" /> unless you set the <see cref="P:UIKit.UIView.ContentMode" /> property to
            <see cref="F:UIKit.UIViewContentMode.Redraw" />.
            
          </para>
          <para>
            At least on iOS 6 and later, changing this property causes the a
            re-layout of the subviews, even if the dimensions are the
            same.  This can cause performance problems as some views
            (like UITableView) can perform some very expensive
            computations when they are laid out.  
            
          </para>
          <para>
            If your <see cref="P:UIKit.UIView.ContentMode" />
            property is set to <see cref="F:UIKit.UIViewContentMode.Redraw" />, you
            can avoid a redraw of your view if you update the <see cref="P:UIKit.UIView.Center" /> property instead
            of updating the Frame as that one will merely move the
            view without triggering a call to <see cref="M:UIKit.UIView.LayoutSubviews" />.
            
          </para>
          <para id="tool-remark">
            This property participates in the implicit animation
            protocol, changing it outside of a transaction will trigger
            an implicit animation for its values.
          </para>
          <para>
            If you change the <see cref="P:UIKit.UIView.Transform" /> property to a
            matrix that does not represent the identity matrix,
            changing this property can have unintended consequences.   In those cases, you should instead update <see cref="P:UIKit.UIView.Center" /> and <see cref="P:UIKit.UIView.Bounds" /> directly.
            
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FrameForAlignmentRect">
      <MemberSignature Language="C#" Value="public virtual CoreGraphics.CGRect FrameForAlignmentRect (CoreGraphics.CGRect alignmentRect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype CoreGraphics.CGRect FrameForAlignmentRect(valuetype CoreGraphics.CGRect alignmentRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.FrameForAlignmentRect(CoreGraphics.CGRect)" />
      <MemberSignature Language="F#" Value="abstract member FrameForAlignmentRect : CoreGraphics.CGRect -&gt; CoreGraphics.CGRect&#xA;override this.FrameForAlignmentRect : CoreGraphics.CGRect -&gt; CoreGraphics.CGRect" Usage="uIView.FrameForAlignmentRect alignmentRect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("frameForAlignmentRect:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>CoreGraphics.CGRect</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="alignmentRect" Type="CoreGraphics.CGRect" />
      </Parameters>
      <Docs>
        <param name="alignmentRect">A <see cref="T:System.Drawing.RectangleF" /> for which the frame rectangle should be calculated.</param>
        <summary>Returns the frame resulting from applying the <paramref name="alignmentRect" /> to the current Auto Layout constraints.</summary>
        <returns>
          <para>The frame rectangle appropriate to the <paramref name="alignmentRect" />/</para>
        </returns>
        <remarks>
          <para>By overriding this method, application developers can fully customize the alignment rectangle of the <see cref="T:UIKit.UIView" />.Application developers who override this method must also override the complementary method <see cref="M:UIKit.UIView.AlignmentRectForFrame(CoreGraphics.CGRect)" />. The two methods must provide complementary values.</para>
          <para>Auto Layout uses "alignment rectangles" to layout subviews rather than the subviews' <see cref="P:UIKit.UIView.Frame" />. The <see cref="P:UIKit.UIView.Frame" /> of a <see cref="T:UIKit.UIView" /> may include visual elements, such as drop-shadows, that are not symmetrical around the <see cref="T:UIKit.UIView" />'s logical center. The "alignment rectangle" for a <see cref="T:UIKit.UIView" /> should be related to its logical content.</para>
          <para> By default, the "alignment rectangle" of a <see cref="T:UIKit.UIView" /> is the <see cref="P:UIKit.UIView.Frame" /> plus the <see cref="P:UIKit.UIView.AlignmentRectInsets" />. The <see cref="M:UIKit.UIView.AlignmentRectForFrame(CoreGraphics.CGRect)" /> and <see cref="M:UIKit.UIView.FrameForAlignmentRect(CoreGraphics.CGRect)" /> methods can be used to fully customize the alignment rectangle.</para>
        </remarks>
        <altmember cref="M:UIKit.UIView.AlignmentRectForFrame" />
        <altmember cref="M:UIKit.UIView.AlignmentRectInsets" />
        <altmember cref="M:UIKit.UIView.ViewForBaselineLayout" />
      </Docs>
    </Member>
    <Member MemberName="GestureRecognizers">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIGestureRecognizer[] GestureRecognizers { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIGestureRecognizer[] GestureRecognizers" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.GestureRecognizers" />
      <MemberSignature Language="F#" Value="member this.GestureRecognizers : UIKit.UIGestureRecognizer[] with get, set" Usage="UIKit.UIView.GestureRecognizers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("gestureRecognizers", ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setGestureRecognizers:", ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIGestureRecognizer[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The array of <see cref="T:UIKit.UIGestureRecognizer" />s for this <see cref="T:UIKit.UIView" />.</summary>
        <value>
          <para>The default value is <see langword="null" />.</para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GestureRecognizerShouldBegin">
      <MemberSignature Language="C#" Value="public virtual bool GestureRecognizerShouldBegin (UIKit.UIGestureRecognizer gestureRecognizer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GestureRecognizerShouldBegin(class UIKit.UIGestureRecognizer gestureRecognizer) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.GestureRecognizerShouldBegin(UIKit.UIGestureRecognizer)" />
      <MemberSignature Language="F#" Value="abstract member GestureRecognizerShouldBegin : UIKit.UIGestureRecognizer -&gt; bool&#xA;override this.GestureRecognizerShouldBegin : UIKit.UIGestureRecognizer -&gt; bool" Usage="uIView.GestureRecognizerShouldBegin gestureRecognizer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("gestureRecognizerShouldBegin:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="gestureRecognizer" Type="UIKit.UIGestureRecognizer" />
      </Parameters>
      <Docs>
        <param name="gestureRecognizer">The gesture recognizer that is
          trying to transitioning out of the <see cref="T:UIKit.UIGestureRecognizerState" />'s Possible state.</param>
        <summary>Determines if the specified gesture recognizers
          should be allowed to track touch events.</summary>
        <returns>
        </returns>
        <remarks>
          Override this method if your application handles touches
          directly, it controls whether an associated
          <see cref="T:UIKit.UIGestureRecognizer" /> should execute or not.
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAppearance">
      <MemberSignature Language="C#" Value="public static UIKit.UIView.UIViewAppearance GetAppearance (UIKit.UITraitCollection traits);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class UIKit.UIView/UIViewAppearance GetAppearance(class UIKit.UITraitCollection traits) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.GetAppearance(UIKit.UITraitCollection)" />
      <MemberSignature Language="F#" Value="static member GetAppearance : UIKit.UITraitCollection -&gt; UIKit.UIView.UIViewAppearance" Usage="UIKit.UIView.GetAppearance traits" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>UIKit.UIView+UIViewAppearance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="traits" Type="UIKit.UITraitCollection" />
      </Parameters>
      <Docs>
        <param name="traits">To be added.</param>
        <summary>Returns an appearance proxy for the specified <paramref name="traits" />.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAppearance">
      <MemberSignature Language="C#" Value="public static UIKit.UIView.UIViewAppearance GetAppearance (UIKit.UITraitCollection traits, params Type[] containers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class UIKit.UIView/UIViewAppearance GetAppearance(class UIKit.UITraitCollection traits, class System.Type[] containers) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.GetAppearance(UIKit.UITraitCollection,System.Type[])" />
      <MemberSignature Language="F#" Value="static member GetAppearance : UIKit.UITraitCollection * Type[] -&gt; UIKit.UIView.UIViewAppearance" Usage="UIKit.UIView.GetAppearance (traits, containers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>UIKit.UIView+UIViewAppearance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="traits" Type="UIKit.UITraitCollection" />
        <Parameter Name="containers" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="traits">To be added.</param>
        <param name="containers">To be added.</param>
        <summary>Returns an appearance proxy for the specified <paramref name="traits" />.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAppearance&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static UIKit.UIView.UIViewAppearance GetAppearance&lt;T&gt; () where T : UIKit.UIView;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class UIKit.UIView/UIViewAppearance GetAppearance&lt;(class UIKit.UIView) T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.GetAppearance``1" />
      <MemberSignature Language="F#" Value="static member GetAppearance : unit -&gt; UIKit.UIView.UIViewAppearance (requires 'T :&gt; UIKit.UIView)" Usage="UIKit.UIView.GetAppearance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>UIKit.UIView+UIViewAppearance</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">The type for which the UIAppearance proxy must be returned.  This is a subclass of UIView.</typeparam>
        <summary>Obtains the appearance proxy <see cref="T:UIKit.UIView.UIViewAppearance" /> for the subclass of UIView.</summary>
        <returns>
          <para>appearance proxy object for the specified type.</para>
        </returns>
        <remarks>
          <para>Setting any appearance properties on the returned object will affect the appearance of all classes and subclasses of the type parameter.</para>
          <para>Unlike the <see cref="P:UIKit.UIView.Appearance" /> property, or the <see cref="M:UIKit.UIWebView.AppearanceWhenContainedIn(System.Type[])" /> method which only work on instances of this particular class, the proxies returned by GetAppearance can be used to change the style of subclasses.</para>
          <para>The following example shows how the GetAppearance method works</para>
          <example>
            <code lang="C#"><![CDATA[
var myTheme = UIView.GetAppearance<MyUIViewSubclass> ();
myTheme.TintColor = UIColor.Red;
]]></code>
          </example>
          <para>For more information, see the documentation for the <see cref="T:UIKit.UIAppearance" /> class.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAppearance&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static UIKit.UIView.UIViewAppearance GetAppearance&lt;T&gt; (UIKit.UITraitCollection traits) where T : UIKit.UIView;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class UIKit.UIView/UIViewAppearance GetAppearance&lt;(class UIKit.UIView) T&gt;(class UIKit.UITraitCollection traits) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.GetAppearance``1(UIKit.UITraitCollection)" />
      <MemberSignature Language="F#" Value="static member GetAppearance : UIKit.UITraitCollection -&gt; UIKit.UIView.UIViewAppearance (requires 'T :&gt; UIKit.UIView)" Usage="UIKit.UIView.GetAppearance traits" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>UIKit.UIView+UIViewAppearance</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <BaseTypeName>UIKit.UIView</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="traits" Type="UIKit.UITraitCollection" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type for which the UIAppearance proxy must be returned.  This is a subclass of UIView.</typeparam>
        <param name="traits">Trait collection to match.</param>
        <summary>Obtains the appearance proxy <see cref="T:UIKit.UIView.UIViewAppearance" /> for the subclass of UIView.</summary>
        <returns>
          <para>appearance proxy object for the specified type.</para>
        </returns>
        <remarks>
          <para>The returned object represents the UIAppearance proxy where developers can set appearance properties for instances of UIView.</para>
          <para>Unlike the <see cref="P:UIKit.UIView.Appearance" /> property, or the <see cref="M:UIKit.UIWebView.AppearanceWhenContainedIn(System.Type[])" /> method which only work on instances of this particular class, the proxies returned by GetAppearance can be used to change the style of subclasses.</para>
          <para>The following example shows how the GetAppearance method works</para>
          <example>
            <code lang="C#"><![CDATA[
var myTheme = UIView.GetAppearance<MyUIViewSubclass> (myTraits, );
myTheme.TintColor = UIColor.Red;
]]></code>
          </example>
          <para>For more information, see the documentation for the <see cref="T:UIKit.UIAppearance" /> class.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAppearance&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static UIKit.UIView.UIViewAppearance GetAppearance&lt;T&gt; (UIKit.UITraitCollection traits, params Type[] containers) where T : UIKit.UIView;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class UIKit.UIView/UIViewAppearance GetAppearance&lt;(class UIKit.UIView) T&gt;(class UIKit.UITraitCollection traits, class System.Type[] containers) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.GetAppearance``1(UIKit.UITraitCollection,System.Type[])" />
      <MemberSignature Language="F#" Value="static member GetAppearance : UIKit.UITraitCollection * Type[] -&gt; UIKit.UIView.UIViewAppearance (requires 'T :&gt; UIKit.UIView)" Usage="UIKit.UIView.GetAppearance (traits, containers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>UIKit.UIView+UIViewAppearance</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <BaseTypeName>UIKit.UIView</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="traits" Type="UIKit.UITraitCollection" />
        <Parameter Name="containers" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">The type for which the UIAppearance proxy must be returned.  This is a subclass of UIView.</typeparam>
        <param name="traits">Trait collection to match.</param>
        <param name="containers">List of types that the developer wishes to have as the containers to apply this particular appearance.</param>
        <summary>Obtains the appearance proxy <see cref="T:UIKit.UIView.UIViewAppearance" /> for the subclass of UIView that has the specified trait collection when the view is hosted in the specified hierarchy.</summary>
        <returns>
          <para>appearance proxy object for the specified type.</para>
        </returns>
        <remarks>
          <para>The returned object represents the UIAppearance proxy where developers can set appearance properties for instances of UIView that has the specified trait collection when the view is hosted in the specified hierarchy when those instances are contained in the hierarchy specified by the <paramref name="containers" /> parameter.</para>
          <para>Unlike the <see cref="P:UIKit.UIView.Appearance" /> property, or the <see cref="M:UIKit.UIWebView.AppearanceWhenContainedIn(System.Type[])" /> method which only work on instances of this particular class, the proxies returned by GetAppearance can be used to change the style of subclasses.</para>
          <para>The following example shows how the GetAppearance method works</para>
          <example>
            <code lang="C#"><![CDATA[
var myTheme = UIView.GetAppearance<MyUIViewSubclass> (myTraits, typeof (UINavigationBar), typeof (UIPopoverController));
myTheme.TintColor = UIColor.Red;
]]></code>
          </example>
          <para>For more information, see the documentation for the <see cref="T:UIKit.UIAppearance" /> class.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConstraintsAffectingLayout">
      <MemberSignature Language="C#" Value="public virtual UIKit.NSLayoutConstraint[] GetConstraintsAffectingLayout (UIKit.UILayoutConstraintAxis axis);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class UIKit.NSLayoutConstraint[] GetConstraintsAffectingLayout(valuetype UIKit.UILayoutConstraintAxis axis) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.GetConstraintsAffectingLayout(UIKit.UILayoutConstraintAxis)" />
      <MemberSignature Language="F#" Value="abstract member GetConstraintsAffectingLayout : UIKit.UILayoutConstraintAxis -&gt; UIKit.NSLayoutConstraint[]&#xA;override this.GetConstraintsAffectingLayout : UIKit.UILayoutConstraintAxis -&gt; UIKit.NSLayoutConstraint[]" Usage="uIView.GetConstraintsAffectingLayout axis" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("constraintsAffectingLayoutForAxis:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.NSLayoutConstraint[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="axis" Type="UIKit.UILayoutConstraintAxis" />
      </Parameters>
      <Docs>
        <param name="axis">The direction of interest.</param>
        <summary>Returns the array of <see cref="T:UIKit.NSLayoutConstraint" /> that are affecting the layout of the <see cref="T:UIKit.UIView" /> along the specified <paramref name="axis" />.</summary>
        <returns>The default value is an empty array.</returns>
        <remarks>
          <para>This is a debugging method that should not be used in production applications.</para>
          <para>
            The returned array may contain <see cref="T:UIKit.NSLayoutConstraint" />s that do not explicitly reference <c>this</c> <see cref="T:UIKit.UIView" /> but which nonetheless affect the <see cref="P:UIKit.UIView.Frame" />. For instance, if <c>this</c> is pinned to <c>anotherView</c> and <c>anotherView</c> is pinned to it's <see cref="P:UIKit.UIView.Superview" />, the method may return both constraints. 
          </para>
          <para>This method is a debugging oriented helper method and is not guaranteed to return the complete set (or any) <see cref="T:UIKit.NSLayoutConstraint" />s. </para>
          <para>If this method is called directly from within <see cref="M:UIKit.UIViewController.ViewDidLoad" />, it will generally return an empty array. If it is invoked as shown in the following example, it appears to be more likely to provide a comprehensive answer.</para>
          <example>
            <code lang="C#"><![CDATA[
mainView.AddConstraints(NSLayoutConstraint.FromVisualFormat("H:|-[blue]-|", 0, new NSDictionary(), viewsDictionary));
mainView.AddConstraints(NSLayoutConstraint.FromVisualFormat("V:|-[blue]-(==30)-[green(==blue)]-|", 0, new NSDictionary(), viewsDictionary));
mainView.AddConstraints(NSLayoutConstraint.FromVisualFormat("|-[green(==blue)]-|", 0, new NSDictionary(), viewsDictionary));

System.Threading.ThreadPool.QueueUserWorkItem(delegate {
  InvokeOnMainThread(delegate {
    foreach(var c2 in blueView.GetConstraintsAffectingLayout(UILayoutConstraintAxis.Horizontal))
    {
      Console.WriteLine(c2);
    }
  });
});
              ]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.GetEnumerator" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="uIView.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.IteratorStateMachine(typeof(UIKit.UIView/&lt;GetEnumerator&gt;d__2))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns an enumerator that lists all of the subviews in this view</summary>
        <returns>
        </returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFocusItems">
      <MemberSignature Language="C#" Value="public virtual UIKit.IUIFocusItem[] GetFocusItems (CoreGraphics.CGRect rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class UIKit.IUIFocusItem[] GetFocusItems(valuetype CoreGraphics.CGRect rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.GetFocusItems(CoreGraphics.CGRect)" />
      <MemberSignature Language="F#" Value="abstract member GetFocusItems : CoreGraphics.CGRect -&gt; UIKit.IUIFocusItem[]&#xA;override this.GetFocusItems : CoreGraphics.CGRect -&gt; UIKit.IUIFocusItem[]" Usage="uIView.GetFocusItems rect" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:UIKit.IUIFocusItemContainer.GetFocusItems(CoreGraphics.CGRect)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("focusItemsInRect:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 12, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 12, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.IUIFocusItem[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="CoreGraphics.CGRect" />
      </Parameters>
      <Docs>
        <param name="rect">The rectangle whose focus items to get.</param>
        <summary>Returns a list of all the child focus items within the specified rectangle.</summary>
        <returns>The list of all the child focus items within the specified rectangle.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUserInterfaceLayoutDirection">
      <MemberSignature Language="C#" Value="public static UIKit.UIUserInterfaceLayoutDirection GetUserInterfaceLayoutDirection (UIKit.UISemanticContentAttribute attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype UIKit.UIUserInterfaceLayoutDirection GetUserInterfaceLayoutDirection(valuetype UIKit.UISemanticContentAttribute attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.GetUserInterfaceLayoutDirection(UIKit.UISemanticContentAttribute)" />
      <MemberSignature Language="F#" Value="static member GetUserInterfaceLayoutDirection : UIKit.UISemanticContentAttribute -&gt; UIKit.UIUserInterfaceLayoutDirection" Usage="UIKit.UIView.GetUserInterfaceLayoutDirection attribute" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("userInterfaceLayoutDirectionForSemanticContentAttribute:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIUserInterfaceLayoutDirection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attribute" Type="UIKit.UISemanticContentAttribute" />
      </Parameters>
      <Docs>
        <param name="attribute">To be added.</param>
        <summary>Returns the layout direction for the specified <paramref name="attribute" />.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUserInterfaceLayoutDirection">
      <MemberSignature Language="C#" Value="public static UIKit.UIUserInterfaceLayoutDirection GetUserInterfaceLayoutDirection (UIKit.UISemanticContentAttribute semanticContentAttribute, UIKit.UIUserInterfaceLayoutDirection layoutDirection);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype UIKit.UIUserInterfaceLayoutDirection GetUserInterfaceLayoutDirection(valuetype UIKit.UISemanticContentAttribute semanticContentAttribute, valuetype UIKit.UIUserInterfaceLayoutDirection layoutDirection) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.GetUserInterfaceLayoutDirection(UIKit.UISemanticContentAttribute,UIKit.UIUserInterfaceLayoutDirection)" />
      <MemberSignature Language="F#" Value="static member GetUserInterfaceLayoutDirection : UIKit.UISemanticContentAttribute * UIKit.UIUserInterfaceLayoutDirection -&gt; UIKit.UIUserInterfaceLayoutDirection" Usage="UIKit.UIView.GetUserInterfaceLayoutDirection (semanticContentAttribute, layoutDirection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 10, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 10, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIUserInterfaceLayoutDirection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticContentAttribute" Type="UIKit.UISemanticContentAttribute" />
        <Parameter Name="layoutDirection" Type="UIKit.UIUserInterfaceLayoutDirection" />
      </Parameters>
      <Docs>
        <param name="semanticContentAttribute">To be added.</param>
        <param name="layoutDirection">To be added.</param>
        <summary>Returns the layout direction for the specified semantic attribute relative to the provided layout direction.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GrayscaleStatusDidChangeNotification">
      <MemberSignature Language="C#" Value="public static Foundation.NSString GrayscaleStatusDidChangeNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString GrayscaleStatusDidChangeNotification" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.GrayscaleStatusDidChangeNotification" />
      <MemberSignature Language="F#" Value="member this.GrayscaleStatusDidChangeNotification : Foundation.NSString" Usage="UIKit.UIView.GrayscaleStatusDidChangeNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Use UIView.Notifications.ObserveGrayscaleStatusDidChange helper method instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Field("UIAccessibilityGrayscaleStatusDidChangeNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for GrayscaleStatusDidChange</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIView.GrayscaleStatusDidChangeNotification, (notification) =>=> {Console.WriteLine ("Received the notification UIView", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIView", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIView.GrayscaleStatusDidChangeNotification, Callback);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GuidedAccessStatusDidChangeNotification">
      <MemberSignature Language="C#" Value="public static Foundation.NSString GuidedAccessStatusDidChangeNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString GuidedAccessStatusDidChangeNotification" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.GuidedAccessStatusDidChangeNotification" />
      <MemberSignature Language="F#" Value="member this.GuidedAccessStatusDidChangeNotification : Foundation.NSString" Usage="UIKit.UIView.GuidedAccessStatusDidChangeNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Use UIView.Notifications.ObserveGuidedAccessStatusDidChange helper method instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Field("UIAccessibilityGuidedAccessStatusDidChangeNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for GuidedAccessStatusDidChange</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
    UIView.GuidedAccessStatusDidChangeNotification, (notification) => {
        Console.WriteLine ("Received the notification UIView", notification); 
    }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIView", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIView.GuidedAccessStatusDidChangeNotification, Callback);
}
              ]]></code>
          </example>
        </remarks>
        <altmember cref="P:UIKit.UIView.AnnouncementNotification" />
        <altmember cref="P:UIKit.UIView.AnnouncementDidFinishNotification" />
        <altmember cref="P:UIKit.UIView.ClosedCaptioningStatusDidChangeNotification" />
        <altmember cref="P:UIKit.UIView.GuidedAccessStatusDidChangeNotification" />
        <altmember cref="P:UIKit.UIView.InvertColorStatusDidChangeNotification" />
        <altmember cref="P:UIKit.UIView.AnnouncementNotification" />
        <altmember cref="P:UIKit.UIView.LayoutChangedNotification" />
        <altmember cref="P:UIKit.UIView.MonoAudioStatusDidChangeNotification" />
        <altmember cref="P:UIKit.UIView.PageScrolledNotification" />
        <altmember cref="P:UIKit.UIView.ScreenChangedNotification" />
        <altmember cref="P:UIKit.UIView.VoiceOverStatusChangedNotification" />
      </Docs>
    </Member>
    <Member MemberName="HasAmbiguousLayout">
      <MemberSignature Language="C#" Value="public virtual bool HasAmbiguousLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasAmbiguousLayout" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.HasAmbiguousLayout" />
      <MemberSignature Language="F#" Value="member this.HasAmbiguousLayout : bool" Usage="UIKit.UIView.HasAmbiguousLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("hasAmbiguousLayout")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns <see langword="true" /> if the Auto Layout for this <see cref="T:UIKit.UIView" /> is ambiguous.</summary>
        <value>Returns <see langword="false" /> if the <see cref="T:UIKit.UIView" />'s constraints are sufficient to accurately specify its alignment rectangle.</value>
        <remarks>
          <para>This is a debugging method that should not be used in production applications.</para>
          <para>This method can be used to determine if the set of <see cref="T:UIKit.NSLayoutConstraint" />s for a <see cref="T:UIKit.UIView" /> are sufficient to fully determine the alignment rectangle or if they are ambiguous. </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HearingDevicePairedEarDidChangeNotification">
      <MemberSignature Language="C#" Value="public static Foundation.NSString HearingDevicePairedEarDidChangeNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString HearingDevicePairedEarDidChangeNotification" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.HearingDevicePairedEarDidChangeNotification" />
      <MemberSignature Language="F#" Value="member this.HearingDevicePairedEarDidChangeNotification : Foundation.NSString" Usage="UIKit.UIView.HearingDevicePairedEarDidChangeNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Use UIView.Notifications.ObserveHearingDevicePairedEarDidChange helper method instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Field("UIAccessibilityHearingDevicePairedEarDidChangeNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 10, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 10, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for HearingDevicePairedEarDidChange</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIView.HearingDevicePairedEarDidChangeNotification, (notification) => {Console.WriteLine ("Received the notification UIView", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIView", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIView.HearingDevicePairedEarDidChangeNotification, Callback);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HeightAnchor">
      <MemberSignature Language="C#" Value="public virtual UIKit.NSLayoutDimension HeightAnchor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.NSLayoutDimension HeightAnchor" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.HeightAnchor" />
      <MemberSignature Language="F#" Value="member this.HeightAnchor : UIKit.NSLayoutDimension" Usage="UIKit.UIView.HeightAnchor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("heightAnchor")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.NSLayoutDimension</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The <see cref="T:UIKit.NSLayoutDimension" /> that defines the height of this <see cref="T:UIKit.UIView" />.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Hidden">
      <MemberSignature Language="C#" Value="public virtual bool Hidden { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Hidden" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.Hidden" />
      <MemberSignature Language="F#" Value="member this.Hidden : bool with get, set" Usage="UIKit.UIView.Hidden" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("isHidden")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setHidden:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies whether the <see cref="T:UIKit.UIView" /> displays or not.</summary>
        <value>The default value is <see langword="false" />.</value>
        <remarks>
          <para>A hidden <see cref="T:UIKit.UIView" /> does not display and does not receive input events. It does, however, participate in resizing and layout events and remains in its <see cref="P:UIKit.UIView.Superview" />'s list of <see cref="P:UIKit.UIView.Subviews" />s.</para>
          <para>A hidden <see cref="T:UIKit.UIView" /> hides its descendant views in addition to hiding itself. This does not affect the <see cref="P:UIKit.UIView.Hidden" /> property of the descendant views. Thus, a <see cref="T:UIKit.UIView" /> may be hidden even though its <see cref="P:UIKit.UIView.Hidden" /> property is <see langword="false" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HitTest">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIView HitTest (CoreGraphics.CGPoint point, UIKit.UIEvent uievent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class UIKit.UIView HitTest(valuetype CoreGraphics.CGPoint point, class UIKit.UIEvent uievent) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.HitTest(CoreGraphics.CGPoint,UIKit.UIEvent)" />
      <MemberSignature Language="F#" Value="abstract member HitTest : CoreGraphics.CGPoint * UIKit.UIEvent -&gt; UIKit.UIView&#xA;override this.HitTest : CoreGraphics.CGPoint * UIKit.UIEvent -&gt; UIKit.UIView" Usage="uIView.HitTest (point, uievent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("hitTest:withEvent:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIView</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="CoreGraphics.CGPoint" />
        <Parameter Name="uievent" Type="UIKit.UIEvent" />
      </Parameters>
      <Docs>
        <param name="point">To be added.</param>
        <param name="uievent">
          <para>To be added.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>The frontmost visible, interaction-enabled <see cref="T:UIKit.UIView" /> containing <param name="point" />.</summary>
        <returns>To be added.</returns>
        <remarks>
          <para>
            <see cref="T:UIKit.UIView" /> objects must have an alpha value greater than 0.01 to be returned. However, this method does not account for interior transparent portions.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InheritedAnimationDuration">
      <MemberSignature Language="C#" Value="public static double InheritedAnimationDuration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property float64 InheritedAnimationDuration" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.InheritedAnimationDuration" />
      <MemberSignature Language="F#" Value="member this.InheritedAnimationDuration : double" Usage="UIKit.UIView.InheritedAnimationDuration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("inheritedAnimationDuration")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Static method that returns the currently-active animation's duration, in seconds.</summary>
        <value>The default value is 0.</value>
        <remarks>
          <para>This property shows the duration of the currently-active animation.</para>
          <example>
            <code lang="C#"><![CDATA[
UIView.Animate(2.0, () => {
    //...Animation
    var inheritedDuration = UIView.InheritedAnimationDuration;
    // inheritedDuration == 2.0
});
var defaultDuration = UIView.InheritedAnimationDuration;
// defaultDuration == 0.0
          ]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertSubview">
      <MemberSignature Language="C#" Value="public virtual void InsertSubview (UIKit.UIView view, nint atIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void InsertSubview(class UIKit.UIView view, valuetype System.nint atIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.InsertSubview(UIKit.UIView,System.nint)" />
      <MemberSignature Language="F#" Value="abstract member InsertSubview : UIKit.UIView * nint -&gt; unit&#xA;override this.InsertSubview : UIKit.UIView * nint -&gt; unit" Usage="uIView.InsertSubview (view, atIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("insertSubview:atIndex:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="view" Type="UIKit.UIView" />
        <Parameter Name="atIndex" Type="System.nint" />
      </Parameters>
      <Docs>
        <param name="view">
          <para>The view to add as a nested view of this view.</para>
        </param>
        <param name="atIndex">
          <para>The index in the stack of subviews where this view
            will be inserted.</para>
        </param>
        <summary>Inserts the specified subview at the specified
          location as a subview of this view.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertSubviewAbove">
      <MemberSignature Language="C#" Value="public virtual void InsertSubviewAbove (UIKit.UIView view, UIKit.UIView siblingSubview);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void InsertSubviewAbove(class UIKit.UIView view, class UIKit.UIView siblingSubview) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.InsertSubviewAbove(UIKit.UIView,UIKit.UIView)" />
      <MemberSignature Language="F#" Value="abstract member InsertSubviewAbove : UIKit.UIView * UIKit.UIView -&gt; unit&#xA;override this.InsertSubviewAbove : UIKit.UIView * UIKit.UIView -&gt; unit" Usage="uIView.InsertSubviewAbove (view, siblingSubview)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("insertSubview:aboveSubview:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="view" Type="UIKit.UIView" />
        <Parameter Name="siblingSubview" Type="UIKit.UIView" />
      </Parameters>
      <Docs>
        <param name="view">
          <para>The view to add as a nested view of this view.</para>
        </param>
        <param name="siblingSubview">
          <para>The subview of this view that will be below the view.</para>
        </param>
        <summary>Inserts the specified view above the siblingSubvie in
          the view hierarchy</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertSubviewBelow">
      <MemberSignature Language="C#" Value="public virtual void InsertSubviewBelow (UIKit.UIView view, UIKit.UIView siblingSubview);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void InsertSubviewBelow(class UIKit.UIView view, class UIKit.UIView siblingSubview) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.InsertSubviewBelow(UIKit.UIView,UIKit.UIView)" />
      <MemberSignature Language="F#" Value="abstract member InsertSubviewBelow : UIKit.UIView * UIKit.UIView -&gt; unit&#xA;override this.InsertSubviewBelow : UIKit.UIView * UIKit.UIView -&gt; unit" Usage="uIView.InsertSubviewBelow (view, siblingSubview)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("insertSubview:belowSubview:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="view" Type="UIKit.UIView" />
        <Parameter Name="siblingSubview" Type="UIKit.UIView" />
      </Parameters>
      <Docs>
        <param name="view">
          <para>The view to add as a nested view of this view.</para>
        </param>
        <param name="siblingSubview">
          <para>The subview of this view that will be below the view.</para>
        </param>
        <summary>Inserts the specified view below the <paramref name="siblingSubview" /> in
          the view hierarchy.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsetsLayoutMarginsFromSafeArea">
      <MemberSignature Language="C#" Value="public virtual bool InsetsLayoutMarginsFromSafeArea { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool InsetsLayoutMarginsFromSafeArea" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.InsetsLayoutMarginsFromSafeArea" />
      <MemberSignature Language="F#" Value="member this.InsetsLayoutMarginsFromSafeArea : bool with get, set" Usage="UIKit.UIView.InsetsLayoutMarginsFromSafeArea" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("insetsLayoutMarginsFromSafeArea")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setInsetsLayoutMarginsFromSafeArea:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a Boolean value that controls whether margins are adjusted to always fall within the safe area. Default is <see langword="true" />.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Interactions">
      <MemberSignature Language="C#" Value="public virtual UIKit.IUIInteraction[] Interactions { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.IUIInteraction[] Interactions" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.Interactions" />
      <MemberSignature Language="F#" Value="member this.Interactions : UIKit.IUIInteraction[] with get, set" Usage="UIKit.UIView.Interactions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("interactions", ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setInteractions:", ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.IUIInteraction[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the current set of interactions.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IntrinsicContentSize">
      <MemberSignature Language="C#" Value="public virtual CoreGraphics.CGSize IntrinsicContentSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype CoreGraphics.CGSize IntrinsicContentSize" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.IntrinsicContentSize" />
      <MemberSignature Language="F#" Value="member this.IntrinsicContentSize : CoreGraphics.CGSize" Usage="UIKit.UIView.IntrinsicContentSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("intrinsicContentSize")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>CoreGraphics.CGSize</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The size of the intrinsic content of the <see cref="T:UIKit.UIView" />.</summary>
        <value>The default value is {<see cref="P:UIKit.UIView.NoIntrinsicMetric" />, <see cref="P:UIKit.UIView.NoIntrinsicMetric" />}.</value>
        <remarks>
          <para>Some views, such as <see cref="T:UIKit.UILabel" />s, have a natural intrinsic size that is not related to the actual <see cref="P:UIKit.UIView.Frame" /> that contains the entirety of the <see cref="T:UIKit.UIView" />. This property allows the <see cref="T:UIKit.UIView" /> to tell the Auto Layout system what <see cref="T:System.Drawing.SizeF" /> it would prefer to be.</para>
          <para>If a <see cref="T:UIKit.UIView" /> has no intrinsic size, it should return the default {<see cref="P:UIKit.UIView.NoIntrinsicMetric" />,<see cref="P:UIKit.UIView.NoIntrinsicMetric" />} value.</para>
        </remarks>
        <altmember cref="M:UIKit.UIView.InvalidateIntrinsicContentSize" />
        <altmember cref="M:UIKit.UIView.SetContentCompressionResistancePriority" />
      </Docs>
    </Member>
    <Member MemberName="InvalidateIntrinsicContentSize">
      <MemberSignature Language="C#" Value="public virtual void InvalidateIntrinsicContentSize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void InvalidateIntrinsicContentSize() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.InvalidateIntrinsicContentSize" />
      <MemberSignature Language="F#" Value="abstract member InvalidateIntrinsicContentSize : unit -&gt; unit&#xA;override this.InvalidateIntrinsicContentSize : unit -&gt; unit" Usage="uIView.InvalidateIntrinsicContentSize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("invalidateIntrinsicContentSize")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Alerts the Auto Layout system that the intrinsic value of the <see cref="T:UIKit.UIView" /> has changed.</summary>
        <remarks>
          <para>Application developers should call this method when they have overridden <see cref="P:UIKit.UIView.IntrinsicContentSize" /> and something has happened to change the value of that property. The Auto Layout system will use the new property in its next layout pass.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvertColorsStatusDidChangeNotification">
      <MemberSignature Language="C#" Value="public static Foundation.NSString InvertColorsStatusDidChangeNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString InvertColorsStatusDidChangeNotification" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.InvertColorsStatusDidChangeNotification" />
      <MemberSignature Language="F#" Value="member this.InvertColorsStatusDidChangeNotification : Foundation.NSString" Usage="UIKit.UIView.InvertColorsStatusDidChangeNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Use UIView.Notifications.ObserveInvertColorsStatusDidChange helper method instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Field("UIAccessibilityInvertColorsStatusDidChangeNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for InvertColorsStatusDidChange</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
    UIView.InvertColorsStatusDidChangeNotification, (notification) => {
        Console.WriteLine ("Received the notification UIView", notification); 
    });


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIView", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIView.InvertColorsStatusDidChangeNotification, Callback);
}
              ]]></code>
          </example>
        </remarks>
        <altmember cref="P:UIKit.UIView.AnnouncementNotification" />
        <altmember cref="P:UIKit.UIView.AnnouncementDidFinishNotification" />
        <altmember cref="P:UIKit.UIView.ClosedCaptioningStatusDidChangeNotification" />
        <altmember cref="P:UIKit.UIView.GuidedAccessStatusDidChangeNotification" />
        <altmember cref="P:UIKit.UIView.InvertColorStatusDidChangeNotification" />
        <altmember cref="P:UIKit.UIView.AnnouncementNotification" />
        <altmember cref="P:UIKit.UIView.LayoutChangedNotification" />
        <altmember cref="P:UIKit.UIView.MonoAudioStatusDidChangeNotification" />
        <altmember cref="P:UIKit.UIView.PageScrolledNotification" />
        <altmember cref="P:UIKit.UIView.ScreenChangedNotification" />
        <altmember cref="P:UIKit.UIView.VoiceOverStatusChangedNotification" />
      </Docs>
    </Member>
    <Member MemberName="IsAccessibilityElement">
      <MemberSignature Language="C#" Value="public virtual bool IsAccessibilityElement { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAccessibilityElement" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.IsAccessibilityElement" />
      <MemberSignature Language="F#" Value="member this.IsAccessibilityElement : bool with get, set" Usage="UIKit.UIView.IsAccessibilityElement" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("isAccessibilityElement")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setIsAccessibilityElement:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether <c>this</c> is an accessibility element.</summary>
        <value>
          <see langword="true" /> if the <see cref="T:UIKit.UIView" /> is an accessibility element.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDescendantOfView">
      <MemberSignature Language="C#" Value="public virtual bool IsDescendantOfView (UIKit.UIView view);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsDescendantOfView(class UIKit.UIView view) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.IsDescendantOfView(UIKit.UIView)" />
      <MemberSignature Language="F#" Value="abstract member IsDescendantOfView : UIKit.UIView -&gt; bool&#xA;override this.IsDescendantOfView : UIKit.UIView -&gt; bool" Usage="uIView.IsDescendantOfView view" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("isDescendantOfView:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="view" Type="UIKit.UIView" />
      </Parameters>
      <Docs>
        <param name="view">
          <para>The <see cref="T:UIKit.UIView" /> that may be an ancestore of <c>this</c> <see cref="T:UIKit.UIView" />.</para>
        </param>
        <summary>Returns <see langword="true" /> if <c>this</c> <see cref="T:UIKit.UIView" /> is in the <paramref name="view" />'s view hierarchy.</summary>
        <returns>
          <para>Returns <see langword="true" /> if the <paramref name="view" /> is the same as <c>this</c> or if the <paramref name="view" /> is an ancestor of <c>this</c>.</para>
        </returns>
        <remarks>
          <para>A <see cref="T:UIKit.UIView" /> is a descendant of another <paramref name="view" /> if the views are the same or if the <paramref name="view" /> can be reached by repeatedly retrieving the <see cref="P:UIKit.UIView.Superview" /> property. This is the equivalent to specifying that <c>this</c> <see cref="T:UIKit.UIView" /> is in <paramref name="view" />'s view hierarchy.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LastBaselineAnchor">
      <MemberSignature Language="C#" Value="public virtual UIKit.NSLayoutYAxisAnchor LastBaselineAnchor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.NSLayoutYAxisAnchor LastBaselineAnchor" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.LastBaselineAnchor" />
      <MemberSignature Language="F#" Value="member this.LastBaselineAnchor : UIKit.NSLayoutYAxisAnchor" Usage="UIKit.UIView.LastBaselineAnchor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("lastBaselineAnchor")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.NSLayoutYAxisAnchor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A <see cref="T:UIKit.NSLayoutYAxisAnchor" /> that defines a constraint based on the baseline of the first line of text in this <see cref="T:UIKit.UIView" />.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:UIKit.UIView.TopAnchor" />
        <altmember cref="P:UIKit.UIView.BottomAnchor" />
        <altmember cref="P:UIKit.UIView.LeftAnchor" />
        <altmember cref="P:UIKit.UIView.RightAnchor" />
        <altmember cref="P:UIKit.UIView.LeadingAnchor" />
        <altmember cref="P:UIKit.UIView.TrailingAnchor" />
        <altmember cref="P:UIKit.UIView.CenterXAnchor" />
        <altmember cref="P:UIKit.UIView.CenterYAnchor" />
        <altmember cref="P:UIKit.UIView.TopAnchor" />
        <altmember cref="P:UIKit.UIView.FirstBaselineAnchor" />
      </Docs>
    </Member>
    <Member MemberName="Layer">
      <MemberSignature Language="C#" Value="public virtual CoreAnimation.CALayer Layer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class CoreAnimation.CALayer Layer" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.Layer" />
      <MemberSignature Language="F#" Value="member this.Layer : CoreAnimation.CALayer" Usage="UIKit.UIView.Layer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("layer", ObjCRuntime.ArgumentSemantic.Strong)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>CoreAnimation.CALayer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The Core Animation layer used for rendering.</summary>
        <value>Returns the <see cref="T:CoreAnimation.CALayer" /> that the <see cref="T:UIKit.UIView" /> is being rendered on.</value>
        <remarks>
          <para>The <see cref="T:CoreAnimation.CALayer" /> object that is returned does not support implicit animations. To support implicit animations, developers must create a type derived from UIView that exports the "layerClass" selector to return the <see cref="T:ObjCRuntime.Class" /> for a custom layer that implements the desired animations. The remarks in <see cref="T:UIKit.UIView" /> have more information in the Animation section.</para>
          <para>This method will not return <see langword="null" />.</para>
          <para>The <see cref="T:UIKit.UIView" /> and the <see cref="T:CoreAnimation.CALayer" /> are tightly coupled and should not be reassigned.</para>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LayoutChangedNotification">
      <MemberSignature Language="C#" Value="public static int LayoutChangedNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 LayoutChangedNotification" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.LayoutChangedNotification" />
      <MemberSignature Language="F#" Value="member this.LayoutChangedNotification : int" Usage="UIKit.UIView.LayoutChangedNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIAccessibilityLayoutChangedNotification", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An accessibility notification indicating that the layout has changed.</summary>
        <value>The layer that the view is being rendered on..</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:UIKit.UIView.AnnouncementNotification" />
        <altmember cref="P:UIKit.UIView.AnnouncementDidFinishNotification" />
        <altmember cref="P:UIKit.UIView.ClosedCaptioningStatusDidChangeNotification" />
        <altmember cref="P:UIKit.UIView.GuidedAccessStatusDidChangeNotification" />
        <altmember cref="P:UIKit.UIView.InvertColorStatusDidChangeNotification" />
        <altmember cref="P:UIKit.UIView.AnnouncementNotification" />
        <altmember cref="P:UIKit.UIView.LayoutChangedNotification" />
        <altmember cref="P:UIKit.UIView.MonoAudioStatusDidChangeNotification" />
        <altmember cref="P:UIKit.UIView.PageScrolledNotification" />
        <altmember cref="P:UIKit.UIView.ScreenChangedNotification" />
        <altmember cref="P:UIKit.UIView.VoiceOverStatusChangedNotification" />
      </Docs>
    </Member>
    <Member MemberName="LayoutGuides">
      <MemberSignature Language="C#" Value="public virtual UIKit.UILayoutGuide[] LayoutGuides { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UILayoutGuide[] LayoutGuides" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.LayoutGuides" />
      <MemberSignature Language="F#" Value="member this.LayoutGuides : UIKit.UILayoutGuide[]" Usage="UIKit.UIView.LayoutGuides" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("layoutGuides")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UILayoutGuide[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The <see cref="T:UIKit.UILayoutGuide" /> objects defined for this <see cref="T:UIKit.UIView" />.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LayoutIfNeeded">
      <MemberSignature Language="C#" Value="public virtual void LayoutIfNeeded ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void LayoutIfNeeded() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.LayoutIfNeeded" />
      <MemberSignature Language="F#" Value="abstract member LayoutIfNeeded : unit -&gt; unit&#xA;override this.LayoutIfNeeded : unit -&gt; unit" Usage="uIView.LayoutIfNeeded " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("layoutIfNeeded")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lays out the subviews if needed.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LayoutMargins">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIEdgeInsets LayoutMargins { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype UIKit.UIEdgeInsets LayoutMargins" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.LayoutMargins" />
      <MemberSignature Language="F#" Value="member this.LayoutMargins : UIKit.UIEdgeInsets with get, set" Usage="UIKit.UIView.LayoutMargins" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("layoutMargins")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setLayoutMargins:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIEdgeInsets</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lays out margins.</summary>
        <value>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LayoutMarginsDidChange">
      <MemberSignature Language="C#" Value="public virtual void LayoutMarginsDidChange ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void LayoutMarginsDidChange() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.LayoutMarginsDidChange" />
      <MemberSignature Language="F#" Value="abstract member LayoutMarginsDidChange : unit -&gt; unit&#xA;override this.LayoutMarginsDidChange : unit -&gt; unit" Usage="uIView.LayoutMarginsDidChange " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("layoutMarginsDidChange")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lays out changed subviews</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LayoutMarginsGuide">
      <MemberSignature Language="C#" Value="public virtual UIKit.UILayoutGuide LayoutMarginsGuide { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UILayoutGuide LayoutMarginsGuide" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.LayoutMarginsGuide" />
      <MemberSignature Language="F#" Value="member this.LayoutMarginsGuide : UIKit.UILayoutGuide" Usage="UIKit.UIView.LayoutMarginsGuide" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("layoutMarginsGuide", ObjCRuntime.ArgumentSemantic.Strong)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UILayoutGuide</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Defines the margin attributes.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LayoutSublayersOfLayer">
      <MemberSignature Language="C#" Value="public virtual void LayoutSublayersOfLayer (CoreAnimation.CALayer layer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void LayoutSublayersOfLayer(class CoreAnimation.CALayer layer) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.LayoutSublayersOfLayer(CoreAnimation.CALayer)" />
      <MemberSignature Language="F#" Value="abstract member LayoutSublayersOfLayer : CoreAnimation.CALayer -&gt; unit&#xA;override this.LayoutSublayersOfLayer : CoreAnimation.CALayer -&gt; unit" Usage="uIView.LayoutSublayersOfLayer layer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("layoutSublayersOfLayer:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="layer" Type="CoreAnimation.CALayer" />
      </Parameters>
      <Docs>
        <param name="layer">To be added.</param>
        <summary>Called to indicate that the <param name="layer" /> object's <see cref="P:CoreAnimation.CALayer.Bounds" /> has changed.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LayoutSubviews">
      <MemberSignature Language="C#" Value="public virtual void LayoutSubviews ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void LayoutSubviews() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.LayoutSubviews" />
      <MemberSignature Language="F#" Value="abstract member LayoutSubviews : unit -&gt; unit&#xA;override this.LayoutSubviews : unit -&gt; unit" Usage="uIView.LayoutSubviews " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("layoutSubviews")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lays out subviews.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LeadingAnchor">
      <MemberSignature Language="C#" Value="public virtual UIKit.NSLayoutXAxisAnchor LeadingAnchor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.NSLayoutXAxisAnchor LeadingAnchor" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.LeadingAnchor" />
      <MemberSignature Language="F#" Value="member this.LeadingAnchor : UIKit.NSLayoutXAxisAnchor" Usage="UIKit.UIView.LeadingAnchor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("leadingAnchor")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.NSLayoutXAxisAnchor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The <see cref="T:UIKit.NSLayoutXAxisAnchor" /> that defines the leading edge of this <see cref="T:UIKit.UIView" />.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:UIKit.UIView.TopAnchor" />
        <altmember cref="P:UIKit.UIView.BottomAnchor" />
        <altmember cref="P:UIKit.UIView.LeftAnchor" />
        <altmember cref="P:UIKit.UIView.RightAnchor" />
        <altmember cref="P:UIKit.UIView.TrailingAnchor" />
        <altmember cref="P:UIKit.UIView.CenterXAnchor" />
        <altmember cref="P:UIKit.UIView.CenterYAnchor" />
        <altmember cref="P:UIKit.UIView.TopAnchor" />
        <altmember cref="P:UIKit.UIView.FirstBaselineAnchor" />
        <altmember cref="P:UIKit.UIView.LastBaselineAnchor" />
      </Docs>
    </Member>
    <Member MemberName="LeftAnchor">
      <MemberSignature Language="C#" Value="public virtual UIKit.NSLayoutXAxisAnchor LeftAnchor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.NSLayoutXAxisAnchor LeftAnchor" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.LeftAnchor" />
      <MemberSignature Language="F#" Value="member this.LeftAnchor : UIKit.NSLayoutXAxisAnchor" Usage="UIKit.UIView.LeftAnchor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("leftAnchor")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.NSLayoutXAxisAnchor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The <see cref="T:UIKit.NSLayoutXAxisAnchor" /> that defines the left edge of this <see cref="T:UIKit.UIView" />.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:UIKit.UIView.TopAnchor" />
        <altmember cref="P:UIKit.UIView.BottomAnchor" />
        <altmember cref="P:UIKit.UIView.RightAnchor" />
        <altmember cref="P:UIKit.UIView.LeadingAnchor" />
        <altmember cref="P:UIKit.UIView.TrailingAnchor" />
        <altmember cref="P:UIKit.UIView.CenterXAnchor" />
        <altmember cref="P:UIKit.UIView.CenterYAnchor" />
        <altmember cref="P:UIKit.UIView.TopAnchor" />
        <altmember cref="P:UIKit.UIView.FirstBaselineAnchor" />
        <altmember cref="P:UIKit.UIView.LastBaselineAnchor" />
      </Docs>
    </Member>
    <Member MemberName="MaskView">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIView MaskView { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIView MaskView" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.MaskView" />
      <MemberSignature Language="F#" Value="member this.MaskView : UIKit.UIView with get, set" Usage="UIKit.UIView.MaskView" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("maskView", ObjCRuntime.ArgumentSemantic.Strong)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setMaskView:", ObjCRuntime.ArgumentSemantic.Strong)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns mask view.</summary>
        <value>
          <para>
          </para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MonoAudioStatusDidChangeNotification">
      <MemberSignature Language="C#" Value="public static Foundation.NSString MonoAudioStatusDidChangeNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString MonoAudioStatusDidChangeNotification" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.MonoAudioStatusDidChangeNotification" />
      <MemberSignature Language="F#" Value="member this.MonoAudioStatusDidChangeNotification : Foundation.NSString" Usage="UIKit.UIView.MonoAudioStatusDidChangeNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Use UIView.Notifications.ObserveMonoAudioStatusDidChange helper method instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Field("UIAccessibilityMonoAudioStatusDidChangeNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for MonoAudioStatusDidChange</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
    UIView.MonoAudioStatusDidChangeNotification, (notification) => {
        Console.WriteLine ("Received the notification UIView", notification); 
    });


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIView", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIView.MonoAudioStatusDidChangeNotification, Callback);
}
              ]]></code>
          </example>
        </remarks>
        <altmember cref="P:UIKit.UIView.AnnouncementNotification" />
        <altmember cref="P:UIKit.UIView.AnnouncementDidFinishNotification" />
        <altmember cref="P:UIKit.UIView.ClosedCaptioningStatusDidChangeNotification" />
        <altmember cref="P:UIKit.UIView.GuidedAccessStatusDidChangeNotification" />
        <altmember cref="P:UIKit.UIView.InvertColorStatusDidChangeNotification" />
        <altmember cref="P:UIKit.UIView.AnnouncementNotification" />
        <altmember cref="P:UIKit.UIView.LayoutChangedNotification" />
        <altmember cref="P:UIKit.UIView.MonoAudioStatusDidChangeNotification" />
        <altmember cref="P:UIKit.UIView.PageScrolledNotification" />
        <altmember cref="P:UIKit.UIView.ScreenChangedNotification" />
        <altmember cref="P:UIKit.UIView.VoiceOverStatusChangedNotification" />
      </Docs>
    </Member>
    <Member MemberName="MotionEffects">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIMotionEffect[] MotionEffects { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIMotionEffect[] MotionEffects" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.MotionEffects" />
      <MemberSignature Language="F#" Value="member this.MotionEffects : UIKit.UIMotionEffect[] with get, set" Usage="UIKit.UIView.MotionEffects" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("motionEffects", ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setMotionEffects:", ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIMotionEffect[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Current set of motion effects on this view.</summary>
        <value>
          <para>
          </para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>You can use this property to retrieve the list of currently active motion effects, or to set the list of motion effects on this view.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MovedToSuperview">
      <MemberSignature Language="C#" Value="public virtual void MovedToSuperview ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MovedToSuperview() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.MovedToSuperview" />
      <MemberSignature Language="F#" Value="abstract member MovedToSuperview : unit -&gt; unit&#xA;override this.MovedToSuperview : unit -&gt; unit" Usage="uIView.MovedToSuperview " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("didMoveToSuperview")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indicates the <see cref="T:UIKit.UIView" /> has had its <see cref="P:UIKit.UIView.Superview" /> property changed.</summary>
        <remarks>
          <para>Application developers can override this method to perform additional calculations when the <see cref="P:UIKit.UIView.Superview" /> changes.</para>
          <para>This method is only called on the immediate descendants of the <see cref="P:UIKit.UIView.Superview" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MovedToWindow">
      <MemberSignature Language="C#" Value="public virtual void MovedToWindow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MovedToWindow() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.MovedToWindow" />
      <MemberSignature Language="F#" Value="abstract member MovedToWindow : unit -&gt; unit&#xA;override this.MovedToWindow : unit -&gt; unit" Usage="uIView.MovedToWindow " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("didMoveToWindow")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indicates the <see cref="T:UIKit.UIView" /> has had its <see cref="P:UIKit.UIView.Window" /> property changed.</summary>
        <remarks>
          <para>Application developers can override this method to perform additional calculations whent he <see cref="P:UIKit.UIView.Window" /> changes.</para>
          <para>This method is called on all members of the <see cref="T:UIKit.UIView" />'s view hierarchy when the <see cref="P:UIKit.UIView.Window" /> property changes.</para>
        </remarks>
        <altmember cref="P:UIKit.UIView.TopAnchor" />
        <altmember cref="P:UIKit.UIView.BottomAnchor" />
        <altmember cref="P:UIKit.UIView.RightAnchor" />
        <altmember cref="P:UIKit.UIView.LeadingAnchor" />
        <altmember cref="P:UIKit.UIView.TrailingAnchor" />
        <altmember cref="P:UIKit.UIView.CenterXAnchor" />
        <altmember cref="P:UIKit.UIView.CenterYAnchor" />
        <altmember cref="P:UIKit.UIView.TopAnchor" />
        <altmember cref="P:UIKit.UIView.FirstBaselineAnchor" />
        <altmember cref="P:UIKit.UIView.LastBaselineAnchor" />
      </Docs>
    </Member>
    <Member MemberName="MultipleTouchEnabled">
      <MemberSignature Language="C#" Value="public virtual bool MultipleTouchEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MultipleTouchEnabled" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.MultipleTouchEnabled" />
      <MemberSignature Language="F#" Value="member this.MultipleTouchEnabled : bool with get, set" Usage="UIKit.UIView.MultipleTouchEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("isMultipleTouchEnabled")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setMultipleTouchEnabled:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Controls whether the UIView can handle multitouch events.</summary>
        <value>State of multiple touch recotgnition.</value>
        <remarks>
          UIViews by default only handle a single touch event at once.  If you
          want your view to handle multiple touches, you must set this property
          to true.
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NeedsUpdateConstraints">
      <MemberSignature Language="C#" Value="public virtual bool NeedsUpdateConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool NeedsUpdateConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.NeedsUpdateConstraints" />
      <MemberSignature Language="F#" Value="abstract member NeedsUpdateConstraints : unit -&gt; bool&#xA;override this.NeedsUpdateConstraints : unit -&gt; bool" Usage="uIView.NeedsUpdateConstraints " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("needsUpdateConstraints")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indicates that the Auto Layout constraints of the <see cref="T:UIKit.UIView" /> need updating.</summary>
        <returns>If this method returns <see langword="true" />, the Auto Layout system will call <see cref="M:UIKit.UIView.UpdateConstraints" /> during its layout pass.</returns>
        <remarks>
          <para>This method is checked by the Auto Layout system to determine if the <see cref="P:UIKit.UIView.Constraints" /> for this <see cref="T:UIKit.UIView" /> need updating. If this method returns <see langword="true" />, the method <see cref="M:UIKit.UIView.UpdateConstraints" /> will be called and should perform the updates.</para>
        </remarks>
        <altmember cref="M:UIKit.UIView.SetNeedsUpdateConstraints" />
      </Docs>
    </Member>
    <Member MemberName="NoIntrinsicMetric">
      <MemberSignature Language="C#" Value="public static nfloat NoIntrinsicMetric { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.nfloat NoIntrinsicMetric" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.NoIntrinsicMetric" />
      <MemberSignature Language="F#" Value="member this.NoIntrinsicMetric : nfloat" Usage="UIKit.UIView.NoIntrinsicMetric" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIViewNoIntrinsicMetric", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.nfloat</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UIViewNoIntrinsicMetric</summary>
        <value>
        </value>
        <remarks>
          <para>This property is associated with the <see cref="P:UIKit.UIView.IntrinsicContentSize" /> method. This value indicates that the <see cref="T:UIKit.UIView" /> has no natural size in a particular dimension.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NotificationSwitchControlIdentifier">
      <MemberSignature Language="C#" Value="public static Foundation.NSString NotificationSwitchControlIdentifier { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString NotificationSwitchControlIdentifier" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.NotificationSwitchControlIdentifier" />
      <MemberSignature Language="F#" Value="member this.NotificationSwitchControlIdentifier : Foundation.NSString" Usage="UIKit.UIView.NotificationSwitchControlIdentifier" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIAccessibilityNotificationSwitchControlIdentifier", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for NotificationSwitchContr</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIView.NotificationSwitchControlIdentifier, (notification) =>=> {Console.WriteLine ("Received the notification UIView", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIView", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIView.NotificationSwitchControlIdentifier, Callback);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NotificationVoiceOverIdentifier">
      <MemberSignature Language="C#" Value="public static Foundation.NSString NotificationVoiceOverIdentifier { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString NotificationVoiceOverIdentifier" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.NotificationVoiceOverIdentifier" />
      <MemberSignature Language="F#" Value="member this.NotificationVoiceOverIdentifier : Foundation.NSString" Usage="UIKit.UIView.NotificationVoiceOverIdentifier" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIAccessibilityNotificationVoiceOverIdentifier", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for NotificationVoiceOv</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIView.NotificationVoiceOverIdentifier, (notification) => {Console.WriteLine ("Received the notification UIView", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIView", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIView.NotificationVoiceOverIdentifier, Callback);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Opaque">
      <MemberSignature Language="C#" Value="public virtual bool Opaque { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Opaque" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.Opaque" />
      <MemberSignature Language="F#" Value="member this.Opaque : bool with get, set" Usage="UIKit.UIView.Opaque" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("isOpaque")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setOpaque:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determines whether the view is opaque or not.</summary>
        <value>
        </value>
        <remarks>
          <para>
            If you set this value to true, you should make sure that
            the entire area is painted, if you do not, the behavior is
            undefined.  You should also set the <see cref="P:UIKit.UIView.Alpha" /> property to 1.0.
            
          </para>
          <para>
            Whenever possible, you should try to set the view as
            opaque, as that informs UIKit that the view does not need
            to be composited and blended with underlying views.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PageScrolledNotification">
      <MemberSignature Language="C#" Value="public static int PageScrolledNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 PageScrolledNotification" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.PageScrolledNotification" />
      <MemberSignature Language="F#" Value="member this.PageScrolledNotification : int" Usage="UIKit.UIView.PageScrolledNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIAccessibilityPageScrolledNotification", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An accessibility notification indicating that the page has scrolled.</summary>
        <value>
        </value>
        <remarks>To be added.</remarks>
        <altmember cref="P:UIKit.UIView.AnnouncementNotification" />
        <altmember cref="P:UIKit.UIView.AnnouncementDidFinishNotification" />
        <altmember cref="P:UIKit.UIView.ClosedCaptioningStatusDidChangeNotification" />
        <altmember cref="P:UIKit.UIView.GuidedAccessStatusDidChangeNotification" />
        <altmember cref="P:UIKit.UIView.InvertColorStatusDidChangeNotification" />
        <altmember cref="P:UIKit.UIView.AnnouncementNotification" />
        <altmember cref="P:UIKit.UIView.LayoutChangedNotification" />
        <altmember cref="P:UIKit.UIView.MonoAudioStatusDidChangeNotification" />
        <altmember cref="P:UIKit.UIView.PageScrolledNotification" />
        <altmember cref="P:UIKit.UIView.ScreenChangedNotification" />
        <altmember cref="P:UIKit.UIView.VoiceOverStatusChangedNotification" />
      </Docs>
    </Member>
    <Member MemberName="ParentFocusEnvironment">
      <MemberSignature Language="C#" Value="public virtual UIKit.IUIFocusEnvironment ParentFocusEnvironment { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.IUIFocusEnvironment ParentFocusEnvironment" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.ParentFocusEnvironment" />
      <MemberSignature Language="F#" Value="member this.ParentFocusEnvironment : UIKit.IUIFocusEnvironment" Usage="UIKit.UIView.ParentFocusEnvironment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 12, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 12, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 12, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 12, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("parentFocusEnvironment", ObjCRuntime.ArgumentSemantic.Weak)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.IUIFocusEnvironment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the parent focus environment.</summary>
        <value>The parent focus environment.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PauseAssistiveTechnologyNotification">
      <MemberSignature Language="C#" Value="public static int PauseAssistiveTechnologyNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 PauseAssistiveTechnologyNotification" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.PauseAssistiveTechnologyNotification" />
      <MemberSignature Language="F#" Value="member this.PauseAssistiveTechnologyNotification : int" Usage="UIKit.UIView.PauseAssistiveTechnologyNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIAccessibilityPauseAssistiveTechnologyNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pauses assistive technology notifications.</summary>
        <value>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformSystemAnimation">
      <MemberSignature Language="C#" Value="public static void PerformSystemAnimation (UIKit.UISystemAnimation animation, UIKit.UIView[] views, UIKit.UIViewAnimationOptions options, Action parallelAnimations, UIKit.UICompletionHandler completion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PerformSystemAnimation(valuetype UIKit.UISystemAnimation animation, class UIKit.UIView[] views, valuetype UIKit.UIViewAnimationOptions options, class System.Action parallelAnimations, class UIKit.UICompletionHandler completion) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.PerformSystemAnimation(UIKit.UISystemAnimation,UIKit.UIView[],UIKit.UIViewAnimationOptions,System.Action,UIKit.UICompletionHandler)" />
      <MemberSignature Language="F#" Value="static member PerformSystemAnimation : UIKit.UISystemAnimation * UIKit.UIView[] * UIKit.UIViewAnimationOptions * Action * UIKit.UICompletionHandler -&gt; unit" Usage="UIKit.UIView.PerformSystemAnimation (animation, views, options, parallelAnimations, completion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("performSystemAnimation:onViews:options:animations:completion:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="animation" Type="UIKit.UISystemAnimation" />
        <Parameter Name="views" Type="UIKit.UIView[]" />
        <Parameter Name="options" Type="UIKit.UIViewAnimationOptions" />
        <Parameter Name="parallelAnimations" Type="System.Action">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="completion" Type="UIKit.UICompletionHandler">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDUICompletionHandler))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="animation">Defined UISystemAnimation to perform.</param>
        <param name="views">Views on which to to perform the animations.</param>
        <param name="options">Mask of options that indicates how the animations are to be performed.</param>
        <param name="parallelAnimations">Additional animations specified to run alongside system animation.</param>
        <param name="completion">Action object that is executed when the animation sequence ends.</param>
        <summary>Performs specified system-provided animation sequence on one or more views, together with user-defined parallel animations.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformSystemAnimationAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;bool&gt; PerformSystemAnimationAsync (UIKit.UISystemAnimation animation, UIKit.UIView[] views, UIKit.UIViewAnimationOptions options, Action parallelAnimations);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;bool&gt; PerformSystemAnimationAsync(valuetype UIKit.UISystemAnimation animation, class UIKit.UIView[] views, valuetype UIKit.UIViewAnimationOptions options, class System.Action parallelAnimations) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.PerformSystemAnimationAsync(UIKit.UISystemAnimation,UIKit.UIView[],UIKit.UIViewAnimationOptions,System.Action)" />
      <MemberSignature Language="F#" Value="static member PerformSystemAnimationAsync : UIKit.UISystemAnimation * UIKit.UIView[] * UIKit.UIViewAnimationOptions * Action -&gt; System.Threading.Tasks.Task&lt;bool&gt;" Usage="UIKit.UIView.PerformSystemAnimationAsync (animation, views, options, parallelAnimations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="animation" Type="UIKit.UISystemAnimation" />
        <Parameter Name="views" Type="UIKit.UIView[]" />
        <Parameter Name="options" Type="UIKit.UIViewAnimationOptions" />
        <Parameter Name="parallelAnimations" Type="System.Action">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="animation">Defined UISystemAnimation to perform.</param>
        <param name="views">Views on which to to perform the animations.</param>
        <param name="options">Mask of options that indicates how the animations are to be performed.</param>
        <param name="parallelAnimations">Additional animations specified to run alongside system animation.</param>
        <summary>Performs specified system-provided animation sequence on one or more views, together with user-defined parallel animations.</summary>
        <returns>
          <para>A task that represents the asynchronous PerformSystemAnimation operation.   The value of the TResult parameter is a UIKit.UICompletionHandler.</para>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformWithoutAnimation">
      <MemberSignature Language="C#" Value="public static void PerformWithoutAnimation (Action actionsWithoutAnimation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PerformWithoutAnimation(class System.Action actionsWithoutAnimation) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.PerformWithoutAnimation(System.Action)" />
      <MemberSignature Language="F#" Value="static member PerformWithoutAnimation : Action -&gt; unit" Usage="UIKit.UIView.PerformWithoutAnimation actionsWithoutAnimation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("performWithoutAnimation:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="actionsWithoutAnimation" Type="System.Action">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="actionsWithoutAnimation">View transition code that is to be performed without animation.</param>
        <summary>Applies a set of changes to a view with a guarantee that animations will not be used.</summary>
        <remarks>
          <para>The use of this method is discouraged. Application developers should prefer to use the <see cref="T:UIKit.UIViewPropertyAnimator" /> class to animate UIViews.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PointInside">
      <MemberSignature Language="C#" Value="public virtual bool PointInside (CoreGraphics.CGPoint point, UIKit.UIEvent uievent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool PointInside(valuetype CoreGraphics.CGPoint point, class UIKit.UIEvent uievent) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.PointInside(CoreGraphics.CGPoint,UIKit.UIEvent)" />
      <MemberSignature Language="F#" Value="abstract member PointInside : CoreGraphics.CGPoint * UIKit.UIEvent -&gt; bool&#xA;override this.PointInside : CoreGraphics.CGPoint * UIKit.UIEvent -&gt; bool" Usage="uIView.PointInside (point, uievent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("pointInside:withEvent:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="CoreGraphics.CGPoint" />
        <Parameter Name="uievent" Type="UIKit.UIEvent" />
      </Parameters>
      <Docs>
        <param name="point">To be added.</param>
        <param name="uievent">
          <para>The <see cref="T:UIKit.UIEvent" /> that triggered this function call.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Whether <param name="point" /> is inside <see langword="this" /><see cref="T:UIKit.UIView" /> object's <see cref="P:UIKit.UIView.Bounds" />.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreferredFocusedView">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIView PreferredFocusedView { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIView PreferredFocusedView" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.PreferredFocusedView" />
      <MemberSignature Language="F#" Value="member this.PreferredFocusedView : UIKit.UIView" Usage="UIKit.UIView.PreferredFocusedView" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:UIKit.IUIFocusEnvironment.PreferredFocusedView</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 10, 0, ObjCRuntime.PlatformArchitecture.All, "Use 'PreferredFocusEnvironments' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 10, 0, ObjCRuntime.PlatformArchitecture.All, "Use 'PreferredFocusEnvironments' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("preferredFocusedView", ObjCRuntime.ArgumentSemantic.Weak)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns the <see cref="T:UIKit.UIView" /> that should actually be focused.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreferredFocusEnvironments">
      <MemberSignature Language="C#" Value="public virtual UIKit.IUIFocusEnvironment[] PreferredFocusEnvironments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.IUIFocusEnvironment[] PreferredFocusEnvironments" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.PreferredFocusEnvironments" />
      <MemberSignature Language="F#" Value="member this.PreferredFocusEnvironments : UIKit.IUIFocusEnvironment[]" Usage="UIKit.UIView.PreferredFocusEnvironments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 10, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 10, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("preferredFocusEnvironments", ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.IUIFocusEnvironment[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An array of <see cref="T:UIKit.IUIFocusEnvironment" />s that are recursively searched by the system to find the default focused view.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreservesSuperviewLayoutMargins">
      <MemberSignature Language="C#" Value="public virtual bool PreservesSuperviewLayoutMargins { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PreservesSuperviewLayoutMargins" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.PreservesSuperviewLayoutMargins" />
      <MemberSignature Language="F#" Value="member this.PreservesSuperviewLayoutMargins : bool with get, set" Usage="UIKit.UIView.PreservesSuperviewLayoutMargins" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("preservesSuperviewLayoutMargins")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setPreservesSuperviewLayoutMargins:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Preserves layout margins for superview.</summary>
        <value>Boolean indicating whether superviw layout was preserved.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadableContentGuide">
      <MemberSignature Language="C#" Value="public virtual UIKit.UILayoutGuide ReadableContentGuide { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UILayoutGuide ReadableContentGuide" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.ReadableContentGuide" />
      <MemberSignature Language="F#" Value="member this.ReadableContentGuide : UIKit.UILayoutGuide" Usage="UIKit.UIView.ReadableContentGuide" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("readableContentGuide", ObjCRuntime.ArgumentSemantic.Strong)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UILayoutGuide</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An area that can be read by the user with minimal head moving.</summary>
        <value>To be added.</value>
        <remarks>
          <para>The <see cref="P:UIKit.UIView.ReadableContentGuide" /> is intended for laying out a single column of text. If multiple columns are desired, the <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=UIKit%20UILayout%20Guide%20Width&amp;scope=Xamarin" title="P:UIKit.UILayoutGuide.Width">P:UIKit.UILayoutGuide.Width</a></format> can be used as a guide to the optimal width.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReduceMotionStatusDidChangeNotification">
      <MemberSignature Language="C#" Value="public static Foundation.NSString ReduceMotionStatusDidChangeNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString ReduceMotionStatusDidChangeNotification" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.ReduceMotionStatusDidChangeNotification" />
      <MemberSignature Language="F#" Value="member this.ReduceMotionStatusDidChangeNotification : Foundation.NSString" Usage="UIKit.UIView.ReduceMotionStatusDidChangeNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Use UIView.Notifications.ObserveReduceMotionStatusDidChange helper method instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Field("UIAccessibilityReduceMotionStatusDidChangeNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for ReduceMotionStatusDidChange</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIView.ReduceMotionStatusDidChangeNotification, (notification) => {Console.WriteLine ("Received the notification UIView", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIView", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIView.ReduceMotionStatusDidChangeNotification, Callback);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReduceTransparencyStatusDidChangeNotification">
      <MemberSignature Language="C#" Value="public static Foundation.NSString ReduceTransparencyStatusDidChangeNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString ReduceTransparencyStatusDidChangeNotification" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.ReduceTransparencyStatusDidChangeNotification" />
      <MemberSignature Language="F#" Value="member this.ReduceTransparencyStatusDidChangeNotification : Foundation.NSString" Usage="UIKit.UIView.ReduceTransparencyStatusDidChangeNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Use UIView.Notifications.ObserveReduceTransparencyStatusDidChange helper method instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Field("UIAccessibilityReduceTransparencyStatusDidChangeNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for ReduceTransparencyStatusDidChange</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIView.ReduceTransparencyStatusDidChangeNotification, (notification) => {Console.WriteLine ("Received the notification UIView", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIView", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIView.ReduceTransparencyStatusDidChangeNotification, Callback);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveConstraint">
      <MemberSignature Language="C#" Value="public virtual void RemoveConstraint (UIKit.NSLayoutConstraint constraint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveConstraint(class UIKit.NSLayoutConstraint constraint) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.RemoveConstraint(UIKit.NSLayoutConstraint)" />
      <MemberSignature Language="F#" Value="abstract member RemoveConstraint : UIKit.NSLayoutConstraint -&gt; unit&#xA;override this.RemoveConstraint : UIKit.NSLayoutConstraint -&gt; unit" Usage="uIView.RemoveConstraint constraint" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("removeConstraint:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constraint" Type="UIKit.NSLayoutConstraint" />
      </Parameters>
      <Docs>
        <param name="constraint">The <see cref="T:UIKit.NSLayoutConstraint" /> to be removed.</param>
        <summary>Removes an Auto Layout constraint from the <see cref="T:UIKit.UIView" />'s <see cref="P:UIKit.UIView.Constraints" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:UIKit.UIView.Constraints" />
        <altmember cref="M:UIKit.UIView.AddConstraint" />
        <altmember cref="M:UIKit.UIView.AddConstraints" />
        <altmember cref="M:UIKit.UIView.RemoveConstraints" />
        <altmember cref="P:UIKit.UIView.TranslatesAutoresizingMaskIntoConstraints" />
      </Docs>
    </Member>
    <Member MemberName="RemoveConstraints">
      <MemberSignature Language="C#" Value="public virtual void RemoveConstraints (UIKit.NSLayoutConstraint[] constraints);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveConstraints(class UIKit.NSLayoutConstraint[] constraints) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.RemoveConstraints(UIKit.NSLayoutConstraint[])" />
      <MemberSignature Language="F#" Value="abstract member RemoveConstraints : UIKit.NSLayoutConstraint[] -&gt; unit&#xA;override this.RemoveConstraints : UIKit.NSLayoutConstraint[] -&gt; unit" Usage="uIView.RemoveConstraints constraints" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("removeConstraints:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constraints" Type="UIKit.NSLayoutConstraint[]" />
      </Parameters>
      <Docs>
        <param name="constraints">The <see cref="T:UIKit.NSLayoutConstraint" />s to be removed.</param>
        <summary>Removes multiple Auto Layout constraints from the <see cref="T:UIKit.UIView" />'s <see cref="P:UIKit.UIView.Constraints" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:UIKit.UIView.Constraints" />
        <altmember cref="M:UIKit.UIView.AddConstraint" />
        <altmember cref="M:UIKit.UIView.AddConstraints" />
        <altmember cref="M:UIKit.UIView.RemoveConstraint" />
        <altmember cref="P:UIKit.UIView.TranslatesAutoresizingMaskIntoConstraints" />
      </Docs>
    </Member>
    <Member MemberName="RemoveFromSuperview">
      <MemberSignature Language="C#" Value="public virtual void RemoveFromSuperview ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveFromSuperview() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.RemoveFromSuperview" />
      <MemberSignature Language="F#" Value="abstract member RemoveFromSuperview : unit -&gt; unit&#xA;override this.RemoveFromSuperview : unit -&gt; unit" Usage="uIView.RemoveFromSuperview " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("removeFromSuperview")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Detaches the <see cref="T:UIKit.UIView" /> from its <see cref="P:UIKit.UIView.Superview" />.</summary>
        <remarks>
          <para>Application developers must not call this method from within the <see cref="T:UIKit.UIView" />'s <see cref="M:UIKit.UIView.DrawRect(CoreGraphics.CGRect,UIKit.UIViewPrintFormatter)" /> method.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveGestureRecognizer">
      <MemberSignature Language="C#" Value="public virtual void RemoveGestureRecognizer (UIKit.UIGestureRecognizer gestureRecognizer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveGestureRecognizer(class UIKit.UIGestureRecognizer gestureRecognizer) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.RemoveGestureRecognizer(UIKit.UIGestureRecognizer)" />
      <MemberSignature Language="F#" Value="abstract member RemoveGestureRecognizer : UIKit.UIGestureRecognizer -&gt; unit&#xA;override this.RemoveGestureRecognizer : UIKit.UIGestureRecognizer -&gt; unit" Usage="uIView.RemoveGestureRecognizer gestureRecognizer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("removeGestureRecognizer:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="gestureRecognizer" Type="UIKit.UIGestureRecognizer" />
      </Parameters>
      <Docs>
        <param name="gestureRecognizer">The <see cref="T:UIKit.UIGestureRecognizer" /> to remove.</param>
        <summary>Removes a gesture recognizer from the <see cref="T:UIKit.UIView" />'s <see cref="P:UIKit.UIView.GestureRecognizers" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveInteraction">
      <MemberSignature Language="C#" Value="public virtual void RemoveInteraction (UIKit.IUIInteraction interaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveInteraction(class UIKit.IUIInteraction interaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.RemoveInteraction(UIKit.IUIInteraction)" />
      <MemberSignature Language="F#" Value="abstract member RemoveInteraction : UIKit.IUIInteraction -&gt; unit&#xA;override this.RemoveInteraction : UIKit.IUIInteraction -&gt; unit" Usage="uIView.RemoveInteraction interaction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("removeInteraction:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interaction" Type="UIKit.IUIInteraction" />
      </Parameters>
      <Docs>
        <param name="interaction">The interaction to remove.</param>
        <summary>Removes the interaction from the view.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveLayoutGuide">
      <MemberSignature Language="C#" Value="public virtual void RemoveLayoutGuide (UIKit.UILayoutGuide guide);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveLayoutGuide(class UIKit.UILayoutGuide guide) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.RemoveLayoutGuide(UIKit.UILayoutGuide)" />
      <MemberSignature Language="F#" Value="abstract member RemoveLayoutGuide : UIKit.UILayoutGuide -&gt; unit&#xA;override this.RemoveLayoutGuide : UIKit.UILayoutGuide -&gt; unit" Usage="uIView.RemoveLayoutGuide guide" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("removeLayoutGuide:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guide" Type="UIKit.UILayoutGuide" />
      </Parameters>
      <Docs>
        <param name="guide">To be added.</param>
        <summary>Removes <paramref name="guide" /> from the <see cref="P:UIKit.UIView.LayoutGuides" /> array.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveMotionEffect">
      <MemberSignature Language="C#" Value="public virtual void RemoveMotionEffect (UIKit.UIMotionEffect effect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveMotionEffect(class UIKit.UIMotionEffect effect) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.RemoveMotionEffect(UIKit.UIMotionEffect)" />
      <MemberSignature Language="F#" Value="abstract member RemoveMotionEffect : UIKit.UIMotionEffect -&gt; unit&#xA;override this.RemoveMotionEffect : UIKit.UIMotionEffect -&gt; unit" Usage="uIView.RemoveMotionEffect effect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("removeMotionEffect:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="effect" Type="UIKit.UIMotionEffect" />
      </Parameters>
      <Docs>
        <param name="effect">Motion effect to remove from the view.</param>
        <summary>Removes the specified motion effect to the view.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RequiresConstraintBasedLayout">
      <MemberSignature Language="C#" Value="public static bool RequiresConstraintBasedLayout ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool RequiresConstraintBasedLayout() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.RequiresConstraintBasedLayout" />
      <MemberSignature Language="F#" Value="static member RequiresConstraintBasedLayout : unit -&gt; bool" Usage="UIKit.UIView.RequiresConstraintBasedLayout " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("requiresConstraintBasedLayout")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indicates that the <see cref="T:UIKit.UIView" /> uses Auto Layout.</summary>
        <returns>The default value is <see langword="false" />.</returns>
        <remarks>
          <para>Application developers should override this method to return  <see langword="true" /> if their <see cref="T:UIKit.UIView" /> relies on Auto Layout.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResizableSnapshotView">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIView ResizableSnapshotView (CoreGraphics.CGRect rect, bool afterScreenUpdates, UIKit.UIEdgeInsets capInsets);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class UIKit.UIView ResizableSnapshotView(valuetype CoreGraphics.CGRect rect, bool afterScreenUpdates, valuetype UIKit.UIEdgeInsets capInsets) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.ResizableSnapshotView(CoreGraphics.CGRect,System.Boolean,UIKit.UIEdgeInsets)" />
      <MemberSignature Language="F#" Value="abstract member ResizableSnapshotView : CoreGraphics.CGRect * bool * UIKit.UIEdgeInsets -&gt; UIKit.UIView&#xA;override this.ResizableSnapshotView : CoreGraphics.CGRect * bool * UIKit.UIEdgeInsets -&gt; UIKit.UIView" Usage="uIView.ResizableSnapshotView (rect, afterScreenUpdates, capInsets)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("resizableSnapshotViewFromRect:afterScreenUpdates:withCapInsets:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIView</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="CoreGraphics.CGRect" />
        <Parameter Name="afterScreenUpdates" Type="System.Boolean" />
        <Parameter Name="capInsets" Type="UIKit.UIEdgeInsets" />
      </Parameters>
      <Docs>
        <param name="rect">The rectangle to capture.</param>
        <param name="afterScreenUpdates">
          <see langword="true" /> if the capture should wait for pending redraws.</param>
        <param name="capInsets">The stretchable portion of the rendered content.</param>
        <summary>Efficiently creates a rendering of <see langword="this" /> object's current appearance within <param name="rect" />.</summary>
        <returns>To be added.</returns>
        <remarks>
          <para>This method is efficient, but does not apply graphical effects such as screen blur. If such effects are needed, developers should use <see cref="M:UIKit.UIView.DrawViewHierarchy(CoreGraphics.CGRect,System.Boolean)" /> instead.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RestorationIdentifier">
      <MemberSignature Language="C#" Value="public virtual string RestorationIdentifier { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RestorationIdentifier" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.RestorationIdentifier" />
      <MemberSignature Language="F#" Value="member this.RestorationIdentifier : string with get, set" Usage="UIKit.UIView.RestorationIdentifier" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("restorationIdentifier", ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setRestorationIdentifier:", ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>If not <see langword="null" />, indicates that the <see cref="T:UIKit.UIView" /> supports state preservation and restoration.</summary>
        <value>
          <para>The default value is <see langword="null" />.</para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>
          <para>If this method returns the default <see langword="null" /> value, the <see cref="T:UIKit.UIView" /> will not have its state preserved and restored.</para>
          <para>If the <see cref="T:UIKit.UIView" /> does need state preservation and restoration, this method should be overridden to return a <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=System%20String&amp;scope=Xamarin" title="T:System.String">T:System.String</a></format>.</para>
          <para>In addition to returning a non-<c>null</c> <see cref="P:UIKit.UIView.RestorationIdentifier" />, so too must the <see cref="T:UIKit.UIViewController" /> for which this <see cref="T:UIKit.UIView" /> is the <see cref="P:UIKit.UIViewController.View" /> and all the ancestor  <see cref="T:UIKit.UIViewController" />s reachable by the <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=UIKit%20UIView%20Controller%20Parent&amp;scope=Xamarin" title="P:UIKit.UIViewController.Parent">P:UIKit.UIViewController.Parent</a></format> property.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResumeAssistiveTechnologyNotification">
      <MemberSignature Language="C#" Value="public static int ResumeAssistiveTechnologyNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 ResumeAssistiveTechnologyNotification" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.ResumeAssistiveTechnologyNotification" />
      <MemberSignature Language="F#" Value="member this.ResumeAssistiveTechnologyNotification : int" Usage="UIKit.UIView.ResumeAssistiveTechnologyNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIAccessibilityResumeAssistiveTechnologyNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Resumes assistive technology notifications.</summary>
        <value>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RightAnchor">
      <MemberSignature Language="C#" Value="public virtual UIKit.NSLayoutXAxisAnchor RightAnchor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.NSLayoutXAxisAnchor RightAnchor" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.RightAnchor" />
      <MemberSignature Language="F#" Value="member this.RightAnchor : UIKit.NSLayoutXAxisAnchor" Usage="UIKit.UIView.RightAnchor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("rightAnchor")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.NSLayoutXAxisAnchor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The <see cref="T:UIKit.NSLayoutXAxisAnchor" /> that defines the right edge of this <see cref="T:UIKit.UIView" />.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:UIKit.UIView.TopAnchor" />
        <altmember cref="P:UIKit.UIView.BottomAnchor" />
        <altmember cref="P:UIKit.UIView.LeftAnchor" />
        <altmember cref="P:UIKit.UIView.LeadingAnchor" />
        <altmember cref="P:UIKit.UIView.TrailingAnchor" />
        <altmember cref="P:UIKit.UIView.CenterXAnchor" />
        <altmember cref="P:UIKit.UIView.CenterYAnchor" />
        <altmember cref="P:UIKit.UIView.TopAnchor" />
        <altmember cref="P:UIKit.UIView.FirstBaselineAnchor" />
        <altmember cref="P:UIKit.UIView.LastBaselineAnchor" />
      </Docs>
    </Member>
    <Member MemberName="SafeAreaInsets">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIEdgeInsets SafeAreaInsets { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype UIKit.UIEdgeInsets SafeAreaInsets" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.SafeAreaInsets" />
      <MemberSignature Language="F#" Value="member this.SafeAreaInsets : UIKit.UIEdgeInsets" Usage="UIKit.UIView.SafeAreaInsets" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("safeAreaInsets")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIEdgeInsets</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the insets that place the content so that navigation and tab bars, toolbars, and other content does not obscure the view of the content.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SafeAreaInsetsDidChange">
      <MemberSignature Language="C#" Value="public virtual void SafeAreaInsetsDidChange ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SafeAreaInsetsDidChange() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.SafeAreaInsetsDidChange" />
      <MemberSignature Language="F#" Value="abstract member SafeAreaInsetsDidChange : unit -&gt; unit&#xA;override this.SafeAreaInsetsDidChange : unit -&gt; unit" Usage="uIView.SafeAreaInsetsDidChange " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("safeAreaInsetsDidChange")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Method that is called when the safe area changes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SafeAreaLayoutGuide">
      <MemberSignature Language="C#" Value="public virtual UIKit.UILayoutGuide SafeAreaLayoutGuide { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UILayoutGuide SafeAreaLayoutGuide" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.SafeAreaLayoutGuide" />
      <MemberSignature Language="F#" Value="member this.SafeAreaLayoutGuide : UIKit.UILayoutGuide" Usage="UIKit.UIView.SafeAreaLayoutGuide" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("safeAreaLayoutGuide", ObjCRuntime.ArgumentSemantic.Strong)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UILayoutGuide</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the layout guide for placing the content so that navigation and tab bars, toolbars, and other content does not obscure the view of the content.</summary>
        <value>To be added.</value>
        <remarks>
          <para>Introduced in iOS 11, this property and the related <see cref="P:UIKit.UIView.SafeAreaInsets" /> property describe the insets at the edges of the <see cref="T:UIKit.UIView" /> that may obscure the developer's content.</para>
          <para>This property is valid only after the <see cref="T:UIKit.UIView" /> has been added to the view hierarchy and laid out (for instance, it will be valid in <see cref="M:UIKit.UIViewController.ViewDidAppear(System.Boolean)" />).</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScreenChangedNotification">
      <MemberSignature Language="C#" Value="public static int ScreenChangedNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 ScreenChangedNotification" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.ScreenChangedNotification" />
      <MemberSignature Language="F#" Value="member this.ScreenChangedNotification : int" Usage="UIKit.UIView.ScreenChangedNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIAccessibilityScreenChangedNotification", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An accessibility notification that the screen has changed.</summary>
        <value>
        </value>
        <remarks>To be added.</remarks>
        <altmember cref="P:UIKit.UIView.AnnouncementNotification" />
        <altmember cref="P:UIKit.UIView.AnnouncementDidFinishNotification" />
        <altmember cref="P:UIKit.UIView.ClosedCaptioningStatusDidChangeNotification" />
        <altmember cref="P:UIKit.UIView.GuidedAccessStatusDidChangeNotification" />
        <altmember cref="P:UIKit.UIView.InvertColorStatusDidChangeNotification" />
        <altmember cref="P:UIKit.UIView.AnnouncementNotification" />
        <altmember cref="P:UIKit.UIView.LayoutChangedNotification" />
        <altmember cref="P:UIKit.UIView.MonoAudioStatusDidChangeNotification" />
        <altmember cref="P:UIKit.UIView.PageScrolledNotification" />
        <altmember cref="P:UIKit.UIView.ScreenChangedNotification" />
        <altmember cref="P:UIKit.UIView.VoiceOverStatusChangedNotification" />
      </Docs>
    </Member>
    <Member MemberName="SemanticContentAttribute">
      <MemberSignature Language="C#" Value="public virtual UIKit.UISemanticContentAttribute SemanticContentAttribute { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype UIKit.UISemanticContentAttribute SemanticContentAttribute" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.SemanticContentAttribute" />
      <MemberSignature Language="F#" Value="member this.SemanticContentAttribute : UIKit.UISemanticContentAttribute with get, set" Usage="UIKit.UIView.SemanticContentAttribute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("semanticContentAttribute", ObjCRuntime.ArgumentSemantic.UnsafeUnretained)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setSemanticContentAttribute:", ObjCRuntime.ArgumentSemantic.UnsafeUnretained)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UISemanticContentAttribute</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies whether the <see cref="T:UIKit.UIView" /> should maintain it's layour or flip when used with a right-to-left layout.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SendSubviewToBack">
      <MemberSignature Language="C#" Value="public virtual void SendSubviewToBack (UIKit.UIView view);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SendSubviewToBack(class UIKit.UIView view) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.SendSubviewToBack(UIKit.UIView)" />
      <MemberSignature Language="F#" Value="abstract member SendSubviewToBack : UIKit.UIView -&gt; unit&#xA;override this.SendSubviewToBack : UIKit.UIView -&gt; unit" Usage="uIView.SendSubviewToBack view" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("sendSubviewToBack:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="view" Type="UIKit.UIView" />
      </Parameters>
      <Docs>
        <param name="view">
          <para>The <see cref="T:UIKit.UIView" /> to be sent to the back.</para>
        </param>
        <summary>Moves a <see cref="T:UIKit.UIView" /> so that it appears behind all its siblings.</summary>
        <remarks>
          <para>This method moves the <paramref name="view" /> so that it appears behind other <see cref="T:UIKit.UIView" />s in the <see cref="P:UIKit.UIView.Subviews" /> array. Display z-order is determined by the position of the <see cref="T:UIKit.UIView" /> in the <see cref="P:UIKit.UIView.Subviews" /> array and this method moves <paramref name="view" /> to the first location in the <see cref="P:UIKit.UIView.Subviews" /> array. 
          </para>
        </remarks>
        <altmember cref="M:UIKit.UIView.BringSubviewToFront" />
        <altmember cref="M:UIKit.UIView.ExchangeSubview" />
      </Docs>
    </Member>
    <Member MemberName="SetAnimationBeginsFromCurrentState">
      <MemberSignature Language="C#" Value="public static void SetAnimationBeginsFromCurrentState (bool fromCurrentState);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAnimationBeginsFromCurrentState(bool fromCurrentState) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.SetAnimationBeginsFromCurrentState(System.Boolean)" />
      <MemberSignature Language="F#" Value="static member SetAnimationBeginsFromCurrentState : bool -&gt; unit" Usage="UIKit.UIView.SetAnimationBeginsFromCurrentState fromCurrentState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("setAnimationBeginsFromCurrentState:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromCurrentState" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fromCurrentState">Returns true if you want to start the
          animation from the current state, false otherwise.</param>
        <summary>Sets whether the animation transaction will animate
          from the current view state.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAnimationCurve">
      <MemberSignature Language="C#" Value="public static void SetAnimationCurve (UIKit.UIViewAnimationCurve curve);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAnimationCurve(valuetype UIKit.UIViewAnimationCurve curve) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.SetAnimationCurve(UIKit.UIViewAnimationCurve)" />
      <MemberSignature Language="F#" Value="static member SetAnimationCurve : UIKit.UIViewAnimationCurve -&gt; unit" Usage="UIKit.UIView.SetAnimationCurve curve" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("setAnimationCurve:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="curve" Type="UIKit.UIViewAnimationCurve" />
      </Parameters>
      <Docs>
        <param name="curve">A curve used to animate the property changes.</param>
        <summary>Sets the animation curve for this animation transaction.</summary>
        <remarks>
          <para>The use of this method is discouraged. Application developers should prefer to use the <see cref="T:UIKit.UIViewPropertyAnimator" /> class to animate UIViews.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAnimationDelay">
      <MemberSignature Language="C#" Value="public static void SetAnimationDelay (double delay);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAnimationDelay(float64 delay) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.SetAnimationDelay(System.Double)" />
      <MemberSignature Language="F#" Value="static member SetAnimationDelay : double -&gt; unit" Usage="UIKit.UIView.SetAnimationDelay delay" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("setAnimationDelay:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delay" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="delay">Animation delay in seconds.</param>
        <summary>Sets the animation delay for this animation transaction.</summary>
        <remarks>
          <para>The use of this method is discouraged. Application developers should prefer to use the <see cref="T:UIKit.UIViewPropertyAnimator" /> class to animate UIViews.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAnimationDelegate">
      <MemberSignature Language="C#" Value="public static void SetAnimationDelegate (Foundation.NSObject del);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAnimationDelegate(class Foundation.NSObject del) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.SetAnimationDelegate(Foundation.NSObject)" />
      <MemberSignature Language="F#" Value="static member SetAnimationDelegate : Foundation.NSObject -&gt; unit" Usage="UIKit.UIView.SetAnimationDelegate del" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("setAnimationDelegate:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="del" Type="Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="del">Delegate object used to define the methods registered using the "SetAnimationDidStopSelector".</param>
        <summary>Allows the app developer to create a custom animation delegate.</summary>
        <remarks>
          <para>The use of this method is discouraged. Application developers should prefer to use the <see cref="T:UIKit.UIViewPropertyAnimator" /> class to animate UIViews.</para>
          <para>This method, with <see cref="M:UIKit.UIView.SetAnimationWillStartSelector(ObjCRuntime.Selector)" /> and <see cref="M:UIKit.UIView.SetAnimationDidStopSelector(ObjCRuntime.Selector)" /> allows the application developer to register a custom delegate object for animations created using the now-discouraged <see cref="M:UIKit.UIView.BeginAnimations(System.String,System.IntPtr)" /> / <see cref="M:UIKit.UIView.CommitAnimations" /> method, rather than the preferred block-based animations.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAnimationDidStopSelector">
      <MemberSignature Language="C#" Value="public static void SetAnimationDidStopSelector (ObjCRuntime.Selector sel);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAnimationDidStopSelector(class ObjCRuntime.Selector sel) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.SetAnimationDidStopSelector(ObjCRuntime.Selector)" />
      <MemberSignature Language="F#" Value="static member SetAnimationDidStopSelector : ObjCRuntime.Selector -&gt; unit" Usage="UIKit.UIView.SetAnimationDidStopSelector sel" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("setAnimationDidStopSelector:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sel" Type="ObjCRuntime.Selector" />
      </Parameters>
      <Docs>
        <param name="sel">Delegate object used to define the methods registered using the "SetAnimationDidStopSelector"</param>
        <summary>Specifies the selector to be used by a custom animation delegate when animation ends.</summary>
        <remarks>
          <para>The use of this method is discouraged. Application developers should prefer to use the <see cref="T:UIKit.UIViewPropertyAnimator" /> class to animate UIViews.</para>
          <para>This method, with <see cref="M:UIKit.UIView.SetAnimationDelegate(Foundation.NSObject)" /> and <see cref="M:UIKit.UIView.SetAnimationWillStartSelector(ObjCRuntime.Selector)" />, can be used to create a custom animation delegate.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAnimationDuration">
      <MemberSignature Language="C#" Value="public static void SetAnimationDuration (double duration);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAnimationDuration(float64 duration) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.SetAnimationDuration(System.Double)" />
      <MemberSignature Language="F#" Value="static member SetAnimationDuration : double -&gt; unit" Usage="UIKit.UIView.SetAnimationDuration duration" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("setAnimationDuration:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="duration">Duration in seconds.</param>
        <summary>Sets the duration for this animation transaction.</summary>
        <remarks>
          <para>The use of this method is discouraged. Application developers should prefer to use the <see cref="T:UIKit.UIViewPropertyAnimator" /> class to animate UIViews.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAnimationRepeatAutoreverses">
      <MemberSignature Language="C#" Value="public static void SetAnimationRepeatAutoreverses (bool repeatAutoreverses);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAnimationRepeatAutoreverses(bool repeatAutoreverses) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.SetAnimationRepeatAutoreverses(System.Boolean)" />
      <MemberSignature Language="F#" Value="static member SetAnimationRepeatAutoreverses : bool -&gt; unit" Usage="UIKit.UIView.SetAnimationRepeatAutoreverses repeatAutoreverses" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("setAnimationRepeatAutoreverses:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="repeatAutoreverses" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="repeatAutoreverses">True if this animation should autoreverse when it completes.</param>
        <summary>Sets whether this animation transaction will automatically reverse when it completes.</summary>
        <remarks>
          <para>The use of this method is discouraged. Application developers should prefer to use the <see cref="T:UIKit.UIViewPropertyAnimator" /> class to animate UIViews.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAnimationRepeatCount">
      <MemberSignature Language="C#" Value="public static void SetAnimationRepeatCount (float repeatCount);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAnimationRepeatCount(float32 repeatCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.SetAnimationRepeatCount(System.Single)" />
      <MemberSignature Language="F#" Value="static member SetAnimationRepeatCount : single -&gt; unit" Usage="UIKit.UIView.SetAnimationRepeatCount repeatCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("setAnimationRepeatCount:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="repeatCount" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="repeatCount">The repeat count for this transaction.</param>
        <summary>Sets the repeat count for this animation transaction.</summary>
        <remarks>
          <para>The use of this method is discouraged. Application developers should prefer to use the <see cref="T:UIKit.UIViewPropertyAnimator" /> class to animate UIViews.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAnimationStartDate">
      <MemberSignature Language="C#" Value="public static void SetAnimationStartDate (Foundation.NSDate startDate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAnimationStartDate(class Foundation.NSDate startDate) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.SetAnimationStartDate(Foundation.NSDate)" />
      <MemberSignature Language="F#" Value="static member SetAnimationStartDate : Foundation.NSDate -&gt; unit" Usage="UIKit.UIView.SetAnimationStartDate startDate" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("setAnimationStartDate:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startDate" Type="Foundation.NSDate" />
      </Parameters>
      <Docs>
        <param name="startDate">Start time defined to begin the animations.</param>
        <summary>Specifies when the animation should begin.</summary>
        <remarks>
          <para>The use of this method is discouraged. Application developers should prefer to use the <see cref="T:UIKit.UIViewPropertyAnimator" /> class to animate UIViews.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAnimationTransition">
      <MemberSignature Language="C#" Value="public static void SetAnimationTransition (UIKit.UIViewAnimationTransition transition, UIKit.UIView forView, bool cache);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAnimationTransition(valuetype UIKit.UIViewAnimationTransition transition, class UIKit.UIView forView, bool cache) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.SetAnimationTransition(UIKit.UIViewAnimationTransition,UIKit.UIView,System.Boolean)" />
      <MemberSignature Language="F#" Value="static member SetAnimationTransition : UIKit.UIViewAnimationTransition * UIKit.UIView * bool -&gt; unit" Usage="UIKit.UIView.SetAnimationTransition (transition, forView, cache)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("setAnimationTransition:forView:cache:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transition" Type="UIKit.UIViewAnimationTransition" />
        <Parameter Name="forView" Type="UIKit.UIView" />
        <Parameter Name="cache" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="transition">The transition to be applied to the view.</param>
        <param name="forView">The view to which to apply the transition.</param>
        <param name="cache">Set to YES, if before and after images of the view are to be rendered once and used to create frames in the animation; set to NO, when the view and its contents are to be updated for each frame of the transition animation</param>
        <summary>Sets a transition to be used during an animation block.</summary>
        <remarks>
          <para>The use of this method is discouraged. Application developers should prefer to use the <see cref="T:UIKit.UIViewPropertyAnimator" /> class to animate UIViews.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAnimationWillStartSelector">
      <MemberSignature Language="C#" Value="public static void SetAnimationWillStartSelector (ObjCRuntime.Selector sel);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAnimationWillStartSelector(class ObjCRuntime.Selector sel) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.SetAnimationWillStartSelector(ObjCRuntime.Selector)" />
      <MemberSignature Language="F#" Value="static member SetAnimationWillStartSelector : ObjCRuntime.Selector -&gt; unit" Usage="UIKit.UIView.SetAnimationWillStartSelector sel" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("setAnimationWillStartSelector:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sel" Type="ObjCRuntime.Selector" />
      </Parameters>
      <Docs>
        <param name="sel">A message that is sent to the animation delegate before the animations commence.</param>
        <summary>Specifies the selector to be used by a custom animation delegate when animation is about to begin.</summary>
        <remarks>
          <para>The use of this method is discouraged. Application developers should prefer to use the <see cref="T:UIKit.UIViewPropertyAnimator" /> class to animate UIViews.</para>
          <para>This method, with <see cref="M:UIKit.UIView.SetAnimationDelegate(Foundation.NSObject)" /> and <see cref="M:UIKit.UIView.SetAnimationDidStopSelector(ObjCRuntime.Selector)" />, can be used to create a custom animation delegate.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetContentCompressionResistancePriority">
      <MemberSignature Language="C#" Value="public virtual void SetContentCompressionResistancePriority (float priority, UIKit.UILayoutConstraintAxis axis);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetContentCompressionResistancePriority(float32 priority, valuetype UIKit.UILayoutConstraintAxis axis) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.SetContentCompressionResistancePriority(System.Single,UIKit.UILayoutConstraintAxis)" />
      <MemberSignature Language="F#" Value="abstract member SetContentCompressionResistancePriority : single * UIKit.UILayoutConstraintAxis -&gt; unit&#xA;override this.SetContentCompressionResistancePriority : single * UIKit.UILayoutConstraintAxis -&gt; unit" Usage="uIView.SetContentCompressionResistancePriority (priority, axis)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("setContentCompressionResistancePriority:forAxis:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Single" />
        <Parameter Name="axis" Type="UIKit.UILayoutConstraintAxis" />
      </Parameters>
      <Docs>
        <param name="priority">The new priority. Preferable if a member of <see cref="T:UIKit.UILayoutPriority" />.</param>
        <param name="axis">The axis for which the resistance is being set.</param>
        <summary>Sets the resistance to compression below the <see cref="T:UIKit.UIView" />'s <see cref="P:UIKit.UIView.IntrinsicContentSize" />.</summary>
        <remarks>
          <para>This method sets the resistance of a <see cref="T:UIKit.UIView" /> to compression to a size smaller than its <see cref="P:UIKit.UIView.IntrinsicContentSize" />. Application developers should set this property for both <see cref="F:UIKit.UILayoutConstraintAxis.Horizontal" /> and <see cref="F:UIKit.UILayoutConstraintAxis.Vertical" />.</para>
        </remarks>
        <altmember cref="M:UIKit.UIView.ContentCompressionResistancePriority" />
        <altmember cref="M:UIKit.UIView.SetContentHuggingPriority" />
      </Docs>
    </Member>
    <Member MemberName="SetContentHuggingPriority">
      <MemberSignature Language="C#" Value="public virtual void SetContentHuggingPriority (float priority, UIKit.UILayoutConstraintAxis axis);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetContentHuggingPriority(float32 priority, valuetype UIKit.UILayoutConstraintAxis axis) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.SetContentHuggingPriority(System.Single,UIKit.UILayoutConstraintAxis)" />
      <MemberSignature Language="F#" Value="abstract member SetContentHuggingPriority : single * UIKit.UILayoutConstraintAxis -&gt; unit&#xA;override this.SetContentHuggingPriority : single * UIKit.UILayoutConstraintAxis -&gt; unit" Usage="uIView.SetContentHuggingPriority (priority, axis)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("setContentHuggingPriority:forAxis:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Single" />
        <Parameter Name="axis" Type="UIKit.UILayoutConstraintAxis" />
      </Parameters>
      <Docs>
        <param name="priority">The new priority. Preferable if a member of <see cref="T:UIKit.UILayoutPriority" />.</param>
        <param name="axis">The axis for which the resistance is being set.</param>
        <summary>Sets the resistance to expansion beyond the <see cref="T:UIKit.UIView" />'s <see cref="P:UIKit.UIView.IntrinsicContentSize" />.</summary>
        <remarks>
          <para>This method sets the resistance of a <see cref="T:UIKit.UIView" /> to expansion to a size greater than its <see cref="P:UIKit.UIView.IntrinsicContentSize" />. Application developers should set this property for both <see cref="F:UIKit.UILayoutConstraintAxis.Horizontal" /> and <see cref="F:UIKit.UILayoutConstraintAxis.Vertical" />.</para>
        </remarks>
        <altmember cref="M:UIKit.UIView.SetContentCompressionResistancePriority" />
      </Docs>
    </Member>
    <Member MemberName="SetNeedsDisplay">
      <MemberSignature Language="C#" Value="public virtual void SetNeedsDisplay ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetNeedsDisplay() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.SetNeedsDisplay" />
      <MemberSignature Language="F#" Value="abstract member SetNeedsDisplay : unit -&gt; unit&#xA;override this.SetNeedsDisplay : unit -&gt; unit" Usage="uIView.SetNeedsDisplay " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("setNeedsDisplay")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Marks the view dirty and queues a redraw operation on it.</summary>
        <remarks>
          <para>
            This method is invoked if the contents of the view need to
            be refreshed due to a change of state or geometry.  Invoking
            this method will cause the <see cref="M:UIKit.UIView.Draw(CoreGraphics.CGRect)" />
            method to be invoked.
          </para>
          <para>
            Alternatively you can use the <see cref="M:UIKit.UIView.SetNeedsDisplayInRect(CoreGraphics.CGRect)" />
            method to only mark a specific region of the view to be repainted.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetNeedsDisplayInRect">
      <MemberSignature Language="C#" Value="public virtual void SetNeedsDisplayInRect (CoreGraphics.CGRect rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetNeedsDisplayInRect(valuetype CoreGraphics.CGRect rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.SetNeedsDisplayInRect(CoreGraphics.CGRect)" />
      <MemberSignature Language="F#" Value="abstract member SetNeedsDisplayInRect : CoreGraphics.CGRect -&gt; unit&#xA;override this.SetNeedsDisplayInRect : CoreGraphics.CGRect -&gt; unit" Usage="uIView.SetNeedsDisplayInRect rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("setNeedsDisplayInRect:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="CoreGraphics.CGRect" />
      </Parameters>
      <Docs>
        <param name="rect">
          <para>The region that will be marked as dirty.</para>
        </param>
        <summary>Marks a region of the view as dirty and queues a redraw operation on that region.</summary>
        <remarks>
          <para>
            This method is invoked if a region of the contents of the view need to
            be refreshed due to a change of state or geometry.  Invoking
            this method will cause the <see cref="M:UIKit.UIView.Draw(CoreGraphics.CGRect)" />
            method to be invoked.
          </para>
          <para>
            Alternatively you can use the <see cref="M:UIKit.UIView.SetNeedsDisplayInRect(CoreGraphics.CGRect)" />
            method if you want to repaint the entire view.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetNeedsFocusUpdate">
      <MemberSignature Language="C#" Value="public virtual void SetNeedsFocusUpdate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetNeedsFocusUpdate() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.SetNeedsFocusUpdate" />
      <MemberSignature Language="F#" Value="abstract member SetNeedsFocusUpdate : unit -&gt; unit&#xA;override this.SetNeedsFocusUpdate : unit -&gt; unit" Usage="uIView.SetNeedsFocusUpdate " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:UIKit.IUIFocusEnvironment.SetNeedsFocusUpdate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("setNeedsFocusUpdate")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>When <c>this</c> is the active focus environment, requests a focus update, which can potentially change the <see cref="P:UIKit.UIView.PreferredFocusedView" />. (See also <see cref="M:UIKit.UIViewController.UpdateFocusIfNeeded" />.)</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetNeedsLayout">
      <MemberSignature Language="C#" Value="public virtual void SetNeedsLayout ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetNeedsLayout() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.SetNeedsLayout" />
      <MemberSignature Language="F#" Value="abstract member SetNeedsLayout : unit -&gt; unit&#xA;override this.SetNeedsLayout : unit -&gt; unit" Usage="uIView.SetNeedsLayout " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("setNeedsLayout")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sets whether subviews need to be rearranged before displaying.</summary>
        <remarks>
          If the state of your view changes in response to some API calls,
          instead of changing the layout manually in response to the change,
          you should invoke this method which will
          flag the view for a layout.  The layout event will then be processed
          the next time the main loop runs.  By using this approach, you can
          coalesce multiple changes to the layout in a single pass.
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetNeedsUpdateConstraints">
      <MemberSignature Language="C#" Value="public virtual void SetNeedsUpdateConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetNeedsUpdateConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.SetNeedsUpdateConstraints" />
      <MemberSignature Language="F#" Value="abstract member SetNeedsUpdateConstraints : unit -&gt; unit&#xA;override this.SetNeedsUpdateConstraints : unit -&gt; unit" Usage="uIView.SetNeedsUpdateConstraints " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("setNeedsUpdateConstraints")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indicates to the Auto Layout system that it must call <see cref="M:UIKit.UIView.UpdateConstraints" />.</summary>
        <remarks>
          <para>This method tells the Auto Layout system to call <see cref="M:UIKit.UIView.UpdateConstraints" />, which will calculate new constraint parameters.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShakeToUndoDidChangeNotification">
      <MemberSignature Language="C#" Value="public static Foundation.NSString ShakeToUndoDidChangeNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString ShakeToUndoDidChangeNotification" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.ShakeToUndoDidChangeNotification" />
      <MemberSignature Language="F#" Value="member this.ShakeToUndoDidChangeNotification : Foundation.NSString" Usage="UIKit.UIView.ShakeToUndoDidChangeNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Use UIView.Notifications.ObserveShakeToUndoDidChange helper method instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Field("UIAccessibilityShakeToUndoDidChangeNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for ShakeToUndoDidChange</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIView.ShakeToUndoDidChangeNotification, (notification) => {Console.WriteLine ("Received the notification UIView", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIView", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIView.ShakeToUndoDidChangeNotification, Callback);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldGroupAccessibilityChildren">
      <MemberSignature Language="C#" Value="public virtual bool ShouldGroupAccessibilityChildren { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShouldGroupAccessibilityChildren" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.ShouldGroupAccessibilityChildren" />
      <MemberSignature Language="F#" Value="member this.ShouldGroupAccessibilityChildren : bool with get, set" Usage="UIKit.UIView.ShouldGroupAccessibilityChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("shouldGroupAccessibilityChildren")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setShouldGroupAccessibilityChildren:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether the <see cref="T:UIKit.UIView" />'s children should be grouped for the purposes of voice-over, regardless of their position on the screen.</summary>
        <value>The default value is <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldUpdateFocus">
      <MemberSignature Language="C#" Value="public virtual bool ShouldUpdateFocus (UIKit.UIFocusUpdateContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ShouldUpdateFocus(class UIKit.UIFocusUpdateContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.ShouldUpdateFocus(UIKit.UIFocusUpdateContext)" />
      <MemberSignature Language="F#" Value="abstract member ShouldUpdateFocus : UIKit.UIFocusUpdateContext -&gt; bool&#xA;override this.ShouldUpdateFocus : UIKit.UIFocusUpdateContext -&gt; bool" Usage="uIView.ShouldUpdateFocus context" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:UIKit.IUIFocusEnvironment.ShouldUpdateFocus(UIKit.UIFocusUpdateContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("shouldUpdateFocusInContext:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="UIKit.UIFocusUpdateContext" />
      </Parameters>
      <Docs>
        <param name="context">To be added.</param>
        <summary>Called prior to the <see cref="T:UIKit.UIView" /> either losing or receiving focus. If either focus environment returns <see langword="false" />, the focus update is canceled.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeThatFits">
      <MemberSignature Language="C#" Value="public virtual CoreGraphics.CGSize SizeThatFits (CoreGraphics.CGSize size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype CoreGraphics.CGSize SizeThatFits(valuetype CoreGraphics.CGSize size) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.SizeThatFits(CoreGraphics.CGSize)" />
      <MemberSignature Language="F#" Value="abstract member SizeThatFits : CoreGraphics.CGSize -&gt; CoreGraphics.CGSize&#xA;override this.SizeThatFits : CoreGraphics.CGSize -&gt; CoreGraphics.CGSize" Usage="uIView.SizeThatFits size" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("sizeThatFits:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>CoreGraphics.CGSize</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="CoreGraphics.CGSize" />
      </Parameters>
      <Docs>
        <param name="size">
          <para>The current <see cref="T:System.Drawing.SizeF" /> of the <see cref="T:UIKit.UIView" /></para>
        </param>
        <summary>Returns the <see cref="T:System.Drawing.SizeF" /> that best fits <c>this</c> <see cref="T:UIKit.UIView" />.</summary>
        <returns>
          <para>The default value is the <see cref="T:UIKit.UIView" />'s <see cref="P:UIKit.UIView.Bounds" />' <see cref="P:System.Drawing.RectangleF.Size" />.</para>
        </returns>
        <remarks>
        </remarks>
        <altmember cref="M:MonoToch.UIKit.UIView.SizeToFit" />
      </Docs>
    </Member>
    <Member MemberName="SizeToFit">
      <MemberSignature Language="C#" Value="public virtual void SizeToFit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SizeToFit() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.SizeToFit" />
      <MemberSignature Language="F#" Value="abstract member SizeToFit : unit -&gt; unit&#xA;override this.SizeToFit : unit -&gt; unit" Usage="uIView.SizeToFit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("sizeToFit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Moves and resizes the <see cref="T:UIKit.UIView" /> so that it tightly encloses its <see cref="P:UIKit.UIView.Subviews" /></summary>
        <remarks>
          <para>Calling this method resizes the <see cref="T:UIKit.UIView" /> so that it just encloses its subviews. Some <see cref="T:UIKit.UIView" /> that do not have their <see cref="P:UIKit.UIView.Superview" /> property set resize themselves to the screen bounds, so application developers should generally make sure that they have assembled an appropriate view hierarchy before calling <see cref="M:UIKit.UIView.SizeToFit" />.</para>
          <para>Application developers should not override this method. Instead, application developers should override <see cref="M:UIKit.UIView.SizeThatFits(CoreGraphics.CGSize)" />, which this method will call.</para>
        </remarks>
        <altmember cref="M:UIKit.UIView.SizeThatFits" />
      </Docs>
    </Member>
    <Member MemberName="SnapshotView">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIView SnapshotView (bool afterScreenUpdates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class UIKit.UIView SnapshotView(bool afterScreenUpdates) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.SnapshotView(System.Boolean)" />
      <MemberSignature Language="F#" Value="abstract member SnapshotView : bool -&gt; UIKit.UIView&#xA;override this.SnapshotView : bool -&gt; UIKit.UIView" Usage="uIView.SnapshotView afterScreenUpdates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("snapshotViewAfterScreenUpdates:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIView</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="afterScreenUpdates" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="afterScreenUpdates">Boolean that indicates whether the snapshot should be taken subsequent to recent changes being incorporated.</param>
        <summary>Creates a <see cref="T:UIKit.UIView" /> that contains a snapshot image of the current view's contents.</summary>
        <returns>A new view object that is based upon a snapshot of the rendered contents of the current view.</returns>
        <remarks>
          <para>This method is faster than rendering a view into a bitmap context. Application developers can use this method to create a visual proxy for their view before performing animations on a complex view hierarchy.</para>
        </remarks>
        <altmember cref="M:UIKit.UIView.ResizableSnapshotView" />
        <altmember cref="M:UIKit.UIView.DrawViewHierarchy" />
      </Docs>
    </Member>
    <Member MemberName="SpeakScreenStatusDidChangeNotification">
      <MemberSignature Language="C#" Value="public static Foundation.NSString SpeakScreenStatusDidChangeNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString SpeakScreenStatusDidChangeNotification" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.SpeakScreenStatusDidChangeNotification" />
      <MemberSignature Language="F#" Value="member this.SpeakScreenStatusDidChangeNotification : Foundation.NSString" Usage="UIKit.UIView.SpeakScreenStatusDidChangeNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Use UIView.Notifications.ObserveSpeakScreenStatusDidChange helper method instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Field("UIAccessibilitySpeakScreenStatusDidChangeNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for SpeakScreenStatusDidChange</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIView.SpeakScreenStatusDidChangeNotification, (notification) => {Console.WriteLine ("Received the notification UIView", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIView", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIView.SpeakScreenStatusDidChangeNotification, Callback);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SpeakSelectionStatusDidChangeNotification">
      <MemberSignature Language="C#" Value="public static Foundation.NSString SpeakSelectionStatusDidChangeNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString SpeakSelectionStatusDidChangeNotification" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.SpeakSelectionStatusDidChangeNotification" />
      <MemberSignature Language="F#" Value="member this.SpeakSelectionStatusDidChangeNotification : Foundation.NSString" Usage="UIKit.UIView.SpeakSelectionStatusDidChangeNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Use UIView.Notifications.ObserveSpeakSelectionStatusDidChange helper method instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Field("UIAccessibilitySpeakSelectionStatusDidChangeNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for SpeakSelectionStatusDidChange</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIView.SpeakSelectionStatusDidChangeNotification, (notification) => {Console.WriteLine ("Received the notification UIView", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIView", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIView.SpeakSelectionStatusDidChangeNotification, Callback);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SpeechAttributeIpaNotation">
      <MemberSignature Language="C#" Value="public static Foundation.NSString SpeechAttributeIpaNotation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString SpeechAttributeIpaNotation" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.SpeechAttributeIpaNotation" />
      <MemberSignature Language="F#" Value="member this.SpeechAttributeIpaNotation : Foundation.NSString" Usage="UIKit.UIView.SpeechAttributeIpaNotation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIAccessibilitySpeechAttributeIPANotation", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.WatchOS, 4, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.WatchOS, 4, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pronunciation hint for text-to-speech, in Internal Phonetic Notation.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SpeechAttributeLanguage">
      <MemberSignature Language="C#" Value="public static Foundation.NSString SpeechAttributeLanguage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString SpeechAttributeLanguage" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.SpeechAttributeLanguage" />
      <MemberSignature Language="F#" Value="member this.SpeechAttributeLanguage : Foundation.NSString" Usage="UIKit.UIView.SpeechAttributeLanguage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIAccessibilitySpeechAttributeLanguage", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retrieves the language used during voice-over.</summary>
        <value>A BCP-47 language code.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SpeechAttributePitch">
      <MemberSignature Language="C#" Value="public static Foundation.NSString SpeechAttributePitch { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString SpeechAttributePitch" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.SpeechAttributePitch" />
      <MemberSignature Language="F#" Value="member this.SpeechAttributePitch : Foundation.NSString" Usage="UIKit.UIView.SpeechAttributePitch" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIAccessibilitySpeechAttributePitch", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retrieves the pitch used by voice-over.</summary>
        <value>Values range from 0.5 (low pitch) to 2.0 (high pitch).</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SpeechAttributePunctuation">
      <MemberSignature Language="C#" Value="public static Foundation.NSString SpeechAttributePunctuation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString SpeechAttributePunctuation" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.SpeechAttributePunctuation" />
      <MemberSignature Language="F#" Value="member this.SpeechAttributePunctuation : Foundation.NSString" Usage="UIKit.UIView.SpeechAttributePunctuation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIAccessibilitySpeechAttributePunctuation", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether punctuation is being pronounced by voice-over.</summary>
        <value>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SpeechAttributeQueueAnnouncement">
      <MemberSignature Language="C#" Value="public static Foundation.NSString SpeechAttributeQueueAnnouncement { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString SpeechAttributeQueueAnnouncement" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.SpeechAttributeQueueAnnouncement" />
      <MemberSignature Language="F#" Value="member this.SpeechAttributeQueueAnnouncement : Foundation.NSString" Usage="UIKit.UIView.SpeechAttributeQueueAnnouncement" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIAccessibilitySpeechAttributeQueueAnnouncement", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.WatchOS, 4, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.WatchOS, 4, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>If "0", the announcement interrupts existing speech. If a string representation of another number, the announcement is queued.</summary>
        <value>The default value is "0". The value must be the string representation of a number.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubviewAdded">
      <MemberSignature Language="C#" Value="public virtual void SubviewAdded (UIKit.UIView uiview);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SubviewAdded(class UIKit.UIView uiview) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.SubviewAdded(UIKit.UIView)" />
      <MemberSignature Language="F#" Value="abstract member SubviewAdded : UIKit.UIView -&gt; unit&#xA;override this.SubviewAdded : UIKit.UIView -&gt; unit" Usage="uIView.SubviewAdded uiview" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("didAddSubview:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uiview" Type="UIKit.UIView" />
      </Parameters>
      <Docs>
        <param name="uiview">
          <para>The view that was added as a subview.</para>
        </param>
        <summary>Tells the view when subviews are added.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Subviews">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIView[] Subviews { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIView[] Subviews" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.Subviews" />
      <MemberSignature Language="F#" Value="member this.Subviews : UIKit.UIView[]" Usage="UIKit.UIView.Subviews" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("subviews", ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIView[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An array of <see cref="T:UIKit.UIView" />s that are contained within <c>this</c> <see cref="T:UIKit.UIView" />.</summary>
        <value>The default value is an empty array.</value>
        <remarks>
          <para>
            This property defines the view hierarchy of a <see cref="T:UIKit.UIView" />. The complete view hierarchy includes the <see cref="T:UIKit.UIView" />'s <see cref="P:UIKit.UIView.Superview" /> and the descendent <see cref="T:UIKit.UIView" />s that are <see cref="P:UIKit.UIView.Subviews" />s of <see cref="P:UIKit.UIView.Subviews" />s, but the methods for manipulating the hierarchy are focused on manipulating subviews (e.g., <see cref="M:UIKit.UIView.AddSubview(UIKit.UIView)" />, <see cref="M:UIKit.UIView.InsertSubview(UIKit.UIView,System.nint)" />, etc.).
          </para>
          <para>The position of a <see cref="T:UIKit.UIView" /> in the <see cref="P:UIKit.UIView.Subviews" /> array determines that <see cref="T:UIKit.UIView" />'s z-order among the subviews. The <see cref="T:UIKit.UIView" /> at index 0 is the rear-most view. <see cref="T:UIKit.UIView" />s can be initialized in a desired z-order by using <see cref="M:UIKit.UIView.InsertSubviewAbove(UIKit.UIView,UIKit.UIView)" /> and <see cref="M:UIKit.UIView.InsertSubviewBelow(UIKit.UIView,UIKit.UIView)" />. <see cref="T:UIKit.UIView" />s can be brought forward or sent backward in z-order by using <see cref="M:UIKit.UIView.ExchangeSubview(System.nint,System.nint)" />.</para>
          <para>Application developers should not manipulate or modify <see cref="P:UIKit.UIView.Subviews" /> of framework-supplied <see cref="T:UIKit.UIView" />s, as they may change without notice in system updates.</para>
        </remarks>
        <altmember cref="P:UIKit.UIView.Superview" />
      </Docs>
    </Member>
    <Member MemberName="Superview">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIView Superview { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIView Superview" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.Superview" />
      <MemberSignature Language="F#" Value="member this.Superview : UIKit.UIView" Usage="UIKit.UIView.Superview" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("superview")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The <see cref="T:UIKit.UIView" />, if any, that contains <c>this</c> <see cref="T:UIKit.UIView" /> in its <see cref="P:UIKit.UIView.Subviews" />.</summary>
        <value>The default value is <see langword="null" />.</value>
        <remarks>
          <para>This value may be <see langword="null" />, indicating that the <see cref="T:UIKit.UIView" /> is not contained within another <see cref="T:UIKit.UIView" />'s view hierarchy.</para>
        </remarks>
        <altmember cref="P:UIKit.UIView.Subviews" />
      </Docs>
    </Member>
    <Member MemberName="SwitchControlStatusDidChangeNotification">
      <MemberSignature Language="C#" Value="public static Foundation.NSString SwitchControlStatusDidChangeNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString SwitchControlStatusDidChangeNotification" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.SwitchControlStatusDidChangeNotification" />
      <MemberSignature Language="F#" Value="member this.SwitchControlStatusDidChangeNotification : Foundation.NSString" Usage="UIKit.UIView.SwitchControlStatusDidChangeNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Use UIView.Notifications.ObserveSwitchControlStatusDidChange helper method instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Field("UIAccessibilitySwitchControlStatusDidChangeNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for SwitchControlStatusDidChange</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIView.SwitchControlStatusDidChangeNotification, (notification) => {Console.WriteLine ("Received the notification UIView", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIView", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIView.SwitchControlStatusDidChangeNotification, Callback);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SystemLayoutSizeFittingSize">
      <MemberSignature Language="C#" Value="public virtual CoreGraphics.CGSize SystemLayoutSizeFittingSize (CoreGraphics.CGSize size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype CoreGraphics.CGSize SystemLayoutSizeFittingSize(valuetype CoreGraphics.CGSize size) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.SystemLayoutSizeFittingSize(CoreGraphics.CGSize)" />
      <MemberSignature Language="F#" Value="abstract member SystemLayoutSizeFittingSize : CoreGraphics.CGSize -&gt; CoreGraphics.CGSize&#xA;override this.SystemLayoutSizeFittingSize : CoreGraphics.CGSize -&gt; CoreGraphics.CGSize" Usage="uIView.SystemLayoutSizeFittingSize size" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("systemLayoutSizeFittingSize:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>CoreGraphics.CGSize</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="CoreGraphics.CGSize" />
      </Parameters>
      <Docs>
        <param name="size">This parameter should be <see cref="P:UIKit.UIView.UILayoutFittingCompressedSize" /> to retrieve the smallest possible size or <see cref="P:UIKit.UIView.UILayoutFittingExpandedSize" /> to retrieve the largest possible size</param>
        <summary>Calculates the smallest or largest size that this <see cref="T:UIKit.UIView" /> can have that satisfies its Auto Layout constraints.</summary>
        <returns>Returns the smallest (if <paramref name="size" /> == <see cref="P:UIKit.UIView.UILayoutFittingCompressedSize" />) or largest (if <paramref name="size" /> == <see cref="P:UIKit.UIView.UILayoutFittingExpandedSize" />)<see cref="T:System.Drawing.SizeF" /> that satisfies the constraints that relate to this <see cref="T:UIKit.UIView" />.</returns>
        <remarks>
          <para>
            This method can calculate either the largest or the smallest size consistent with the Auto Layout constraints of <c>this</c> <see cref="T:UIKit.UIView" /> and the constraints of its <see cref="P:UIKit.UIView.Subviews" />. This method may only be called with <paramref name="size" /> equal to one of the predefined <see cref="T:System.Drawing.SizeF" />s <see cref="P:UIKit.UIView.UILayoutFittingCompressedSize" /> or <see cref="P:UIKit.UIView.UILayoutFittingExpandedSize" />.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SystemLayoutSizeFittingSize">
      <MemberSignature Language="C#" Value="public virtual CoreGraphics.CGSize SystemLayoutSizeFittingSize (CoreGraphics.CGSize targetSize, float horizontalFittingPriority, float verticalFittingPriority);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype CoreGraphics.CGSize SystemLayoutSizeFittingSize(valuetype CoreGraphics.CGSize targetSize, float32 horizontalFittingPriority, float32 verticalFittingPriority) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.SystemLayoutSizeFittingSize(CoreGraphics.CGSize,System.Single,System.Single)" />
      <MemberSignature Language="F#" Value="abstract member SystemLayoutSizeFittingSize : CoreGraphics.CGSize * single * single -&gt; CoreGraphics.CGSize&#xA;override this.SystemLayoutSizeFittingSize : CoreGraphics.CGSize * single * single -&gt; CoreGraphics.CGSize" Usage="uIView.SystemLayoutSizeFittingSize (targetSize, horizontalFittingPriority, verticalFittingPriority)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("systemLayoutSizeFittingSize:withHorizontalFittingPriority:verticalFittingPriority:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>CoreGraphics.CGSize</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetSize" Type="CoreGraphics.CGSize" />
        <Parameter Name="horizontalFittingPriority" Type="System.Single" />
        <Parameter Name="verticalFittingPriority" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="targetSize">This should be either <see cref="P:UIKit.UIView.UILayoutFittingCompressedSize" /> or <see cref="P:UIKit.UIView.UILayoutFittingExpandedSize" />.</param>
        <param name="horizontalFittingPriority">To be added.</param>
        <param name="verticalFittingPriority">To be added.</param>
        <summary>Returns the optimal size for <see langword="this" />, based on constraints, and the fitting priority arguments.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public virtual nint Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.nint Tag" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.Tag" />
      <MemberSignature Language="F#" Value="member this.Tag : nint with get, set" Usage="UIKit.UIView.Tag" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("tag")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setTag:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.nint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An integer that can be used to identify a specific <see cref="T:UIKit.UIView" /> instance.</summary>
        <value>The default value is 0.</value>
        <remarks>
          <para>The stability and uniqueness of this property is entirely the responsibility of the application developer.</para>
        </remarks>
        <altmember cref="M:UIKit.UIView.ViewWithTag" />
      </Docs>
    </Member>
    <Member MemberName="TextAttributeCustom">
      <MemberSignature Language="C#" Value="public static Foundation.NSString TextAttributeCustom { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString TextAttributeCustom" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.TextAttributeCustom" />
      <MemberSignature Language="F#" Value="member this.TextAttributeCustom : Foundation.NSString" Usage="UIKit.UIView.TextAttributeCustom" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIAccessibilityTextAttributeCustom", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.WatchOS, 4, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.WatchOS, 4, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An accessibility key that maps to custom string attributes.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TextAttributeHeadingLevel">
      <MemberSignature Language="C#" Value="public static Foundation.NSString TextAttributeHeadingLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString TextAttributeHeadingLevel" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.TextAttributeHeadingLevel" />
      <MemberSignature Language="F#" Value="member this.TextAttributeHeadingLevel : Foundation.NSString" Usage="UIKit.UIView.TextAttributeHeadingLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIAccessibilityTextAttributeHeadingLevel", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.WatchOS, 4, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.WatchOS, 4, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An accessibility key that maps to an integer between 0 and 6, 0 meaning no heading.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TintAdjustmentMode">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIViewTintAdjustmentMode TintAdjustmentMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype UIKit.UIViewTintAdjustmentMode TintAdjustmentMode" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.TintAdjustmentMode" />
      <MemberSignature Language="F#" Value="member this.TintAdjustmentMode : UIKit.UIViewTintAdjustmentMode with get, set" Usage="UIKit.UIView.TintAdjustmentMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("tintAdjustmentMode")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setTintAdjustmentMode:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIViewTintAdjustmentMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The tint adjustment applied to this <see cref="T:UIKit.UIView" /> or one of its parent views.</summary>
        <value>
        </value>
        <remarks>
        </remarks>
        <altmember cref="M:UIKit.UIView.TintColorDidChange" />
      </Docs>
    </Member>
    <Member MemberName="TintColor">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIColor TintColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIColor TintColor" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.TintColor" />
      <MemberSignature Language="F#" Value="member this.TintColor : UIKit.UIColor with get, set" Usage="UIKit.UIView.TintColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("tintColor")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setTintColor:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIColor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A highlight color which should be used to indicate interactive controls.</summary>
        <value>
          <para>(More documentation for this node is coming)</para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>
          <para>Starting in iOS 7, application developers should use <see cref="P:UIKit.UIView.TintColor" /> to indicate interaction elements within their UI. <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=P:UIKit.UIView.TintColor &amp;scope=Xamarin" title="P:UIKit.UIView.TintColor ">P:UIKit.UIView.TintColor </a></format> is hierarchical; that is, setting the <see cref="P:UIKit.UIView.TintColor" /> on a top-level <see cref="T:UIKit.UIView" /> will carry through to child views until the <see cref="P:UIKit.UIView.TintColor" /> is overridden.</para>
          <para>When a <see cref="T:UIKit.UIActionSheet" /> is displayed, visible <see cref="T:UIKit.UIView" />s will have their tint grayed out (desaturated), indicating to the application user that they must interact with the <see cref="T:UIKit.UIActionSheet" />. Application developers who wish to customize the desaturation of their <see cref="T:UIKit.UIView" />s should override the <see cref="M:UIKit.UIView.TintColorDidChange" /> method.</para>
          <para id="tool-remark">This member participates in the <see cref="T:UIKit.UIAppearance" /> styling system.  See the <see cref="P:UIKit.UIView.Appearance" /> property and the <see cref="M:UIKit.UIView.AppearanceWhenContainedIn(System.Type[])" /> method.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TintColorDidChange">
      <MemberSignature Language="C#" Value="public virtual void TintColorDidChange ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void TintColorDidChange() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.TintColorDidChange" />
      <MemberSignature Language="F#" Value="abstract member TintColorDidChange : unit -&gt; unit&#xA;override this.TintColorDidChange : unit -&gt; unit" Usage="uIView.TintColorDidChange " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("tintColorDidChange")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Called when the <see cref="P:UIKit.UIView.TintColor" /> changes, such as when a <see cref="T:UIKit.UIActionSheet" /> is displayed.</summary>
        <remarks>
          <para>When a <see cref="T:UIKit.UIActionSheet" /> is displayed, visible <see cref="T:UIKit.UIView" />s will have their tint grayed out (desaturated), indicating to the application user that they must interact with the <see cref="T:UIKit.UIActionSheet" />. By overriding this method, application developers can customize the desaturation of custom <see cref="T:UIKit.UIView" />s.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TopAnchor">
      <MemberSignature Language="C#" Value="public virtual UIKit.NSLayoutYAxisAnchor TopAnchor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.NSLayoutYAxisAnchor TopAnchor" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.TopAnchor" />
      <MemberSignature Language="F#" Value="member this.TopAnchor : UIKit.NSLayoutYAxisAnchor" Usage="UIKit.UIView.TopAnchor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("topAnchor")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.NSLayoutYAxisAnchor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The <see cref="T:UIKit.NSLayoutYAxisAnchor" /> that defines the top of this <see cref="T:UIKit.UIView" />.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:UIKit.UIView.BottomAnchor" />
        <altmember cref="P:UIKit.UIView.LeftAnchor" />
        <altmember cref="P:UIKit.UIView.RightAnchor" />
        <altmember cref="P:UIKit.UIView.LeadingAnchor" />
        <altmember cref="P:UIKit.UIView.TrailingAnchor" />
        <altmember cref="P:UIKit.UIView.CenterXAnchor" />
        <altmember cref="P:UIKit.UIView.CenterYAnchor" />
        <altmember cref="P:UIKit.UIView.TopAnchor" />
        <altmember cref="P:UIKit.UIView.FirstBaselineAnchor" />
        <altmember cref="P:UIKit.UIView.LastBaselineAnchor" />
      </Docs>
    </Member>
    <Member MemberName="TrailingAnchor">
      <MemberSignature Language="C#" Value="public virtual UIKit.NSLayoutXAxisAnchor TrailingAnchor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.NSLayoutXAxisAnchor TrailingAnchor" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.TrailingAnchor" />
      <MemberSignature Language="F#" Value="member this.TrailingAnchor : UIKit.NSLayoutXAxisAnchor" Usage="UIKit.UIView.TrailingAnchor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("trailingAnchor")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.NSLayoutXAxisAnchor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The <see cref="T:UIKit.NSLayoutXAxisAnchor" /> that defines the leading edge of this <see cref="T:UIKit.UIView" />.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:UIKit.UIView.TopAnchor" />
        <altmember cref="P:UIKit.UIView.BottomAnchor" />
        <altmember cref="P:UIKit.UIView.LeftAnchor" />
        <altmember cref="P:UIKit.UIView.RightAnchor" />
        <altmember cref="P:UIKit.UIView.LeadingAnchor" />
        <altmember cref="P:UIKit.UIView.CenterXAnchor" />
        <altmember cref="P:UIKit.UIView.CenterYAnchor" />
        <altmember cref="P:UIKit.UIView.TopAnchor" />
        <altmember cref="P:UIKit.UIView.FirstBaselineAnchor" />
        <altmember cref="P:UIKit.UIView.LastBaselineAnchor" />
      </Docs>
    </Member>
    <Member MemberName="TraitAdjustable">
      <MemberSignature Language="C#" Value="public static long TraitAdjustable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 TraitAdjustable" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.TraitAdjustable" />
      <MemberSignature Language="F#" Value="member this.TraitAdjustable : int64" Usage="UIKit.UIView.TraitAdjustable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIAccessibilityTraitAdjustable", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An accessibility trait indicating that the underlying value can be adjusted continuously, as with a slider.</summary>
        <value>The value to be set for the trait.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TraitAllowsDirectInteraction">
      <MemberSignature Language="C#" Value="public static long TraitAllowsDirectInteraction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 TraitAllowsDirectInteraction" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.TraitAllowsDirectInteraction" />
      <MemberSignature Language="F#" Value="member this.TraitAllowsDirectInteraction : int64" Usage="UIKit.UIView.TraitAllowsDirectInteraction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIAccessibilityTraitAllowsDirectInteraction", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An accessibility trait indicating that the user can interact directly with the <see cref="T:UIKit.UIView" />.</summary>
        <value>The value to be set for the trait.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TraitButton">
      <MemberSignature Language="C#" Value="public static long TraitButton { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 TraitButton" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.TraitButton" />
      <MemberSignature Language="F#" Value="member this.TraitButton : int64" Usage="UIKit.UIView.TraitButton" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIAccessibilityTraitButton", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An accessibility trait indicating button-like behavior.</summary>
        <value>The value to be set for the trait.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TraitCausesPageTurn">
      <MemberSignature Language="C#" Value="public static long TraitCausesPageTurn { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 TraitCausesPageTurn" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.TraitCausesPageTurn" />
      <MemberSignature Language="F#" Value="member this.TraitCausesPageTurn : int64" Usage="UIKit.UIView.TraitCausesPageTurn" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIAccessibilityTraitCausesPageTurn", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An accessibility trait indicating that the <see cref="T:UIKit.UIView" /> causes a page turn after voice over completes.</summary>
        <value>The value to be set for the trait.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TraitCollection">
      <MemberSignature Language="C#" Value="public virtual UIKit.UITraitCollection TraitCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UITraitCollection TraitCollection" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.TraitCollection" />
      <MemberSignature Language="F#" Value="member this.TraitCollection : UIKit.UITraitCollection" Usage="UIKit.UIView.TraitCollection" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:UIKit.IUITraitEnvironment.TraitCollection</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("traitCollection")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UITraitCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns a trait collection.</summary>
        <value>TThe value to be set for the trait.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TraitCollectionDidChange">
      <MemberSignature Language="C#" Value="public virtual void TraitCollectionDidChange (UIKit.UITraitCollection previousTraitCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void TraitCollectionDidChange(class UIKit.UITraitCollection previousTraitCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.TraitCollectionDidChange(UIKit.UITraitCollection)" />
      <MemberSignature Language="F#" Value="abstract member TraitCollectionDidChange : UIKit.UITraitCollection -&gt; unit&#xA;override this.TraitCollectionDidChange : UIKit.UITraitCollection -&gt; unit" Usage="uIView.TraitCollectionDidChange previousTraitCollection" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:UIKit.IUITraitEnvironment.TraitCollectionDidChange(UIKit.UITraitCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("traitCollectionDidChange:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="previousTraitCollection" Type="UIKit.UITraitCollection" />
      </Parameters>
      <Docs>
        <param name="previousTraitCollection">Previous trait collection.</param>
        <summary>Defines previous trait collection.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TraitHeader">
      <MemberSignature Language="C#" Value="public static long TraitHeader { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 TraitHeader" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.TraitHeader" />
      <MemberSignature Language="F#" Value="member this.TraitHeader : int64" Usage="UIKit.UIView.TraitHeader" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIAccessibilityTraitHeader", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An accessibility trait indicating that the <see cref="T:UIKit.UIView" /> is a divider between content sections.</summary>
        <value>The value to be set for the trait.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TraitImage">
      <MemberSignature Language="C#" Value="public static long TraitImage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 TraitImage" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.TraitImage" />
      <MemberSignature Language="F#" Value="member this.TraitImage : int64" Usage="UIKit.UIView.TraitImage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIAccessibilityTraitImage", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An accessibility trait indicating the view should be treated as an image.</summary>
        <value>The value to be set for the trait.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TraitKeyboardKey">
      <MemberSignature Language="C#" Value="public static long TraitKeyboardKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 TraitKeyboardKey" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.TraitKeyboardKey" />
      <MemberSignature Language="F#" Value="member this.TraitKeyboardKey : int64" Usage="UIKit.UIView.TraitKeyboardKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIAccessibilityTraitKeyboardKey", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An accessibility trait indicating that the <see cref="T:UIKit.UIView" /> should be treated as a keyboard key.</summary>
        <value>The value to be set for the trait.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TraitLink">
      <MemberSignature Language="C#" Value="public static long TraitLink { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 TraitLink" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.TraitLink" />
      <MemberSignature Language="F#" Value="member this.TraitLink : int64" Usage="UIKit.UIView.TraitLink" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIAccessibilityTraitLink", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An accessibility trait indicating that the <see cref="T:UIKit.UIView" /> should be treated as a hyperlink.</summary>
        <value>The value to be set for the trait.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TraitNone">
      <MemberSignature Language="C#" Value="public static long TraitNone { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 TraitNone" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.TraitNone" />
      <MemberSignature Language="F#" Value="member this.TraitNone : int64" Usage="UIKit.UIView.TraitNone" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIAccessibilityTraitNone", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indicates that the <see cref="T:UIKit.UIView" /> has no accessibility traits.</summary>
        <value>The value to be set for the trait.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TraitNotEnabled">
      <MemberSignature Language="C#" Value="public static long TraitNotEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 TraitNotEnabled" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.TraitNotEnabled" />
      <MemberSignature Language="F#" Value="member this.TraitNotEnabled : int64" Usage="UIKit.UIView.TraitNotEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIAccessibilityTraitNotEnabled", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An accessibility trait indicating that the <see cref="T:UIKit.UIView" /> is disabled and does not allow user interaction.</summary>
        <value>The value to be set for the trait.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TraitPlaysSound">
      <MemberSignature Language="C#" Value="public static long TraitPlaysSound { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 TraitPlaysSound" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.TraitPlaysSound" />
      <MemberSignature Language="F#" Value="member this.TraitPlaysSound : int64" Usage="UIKit.UIView.TraitPlaysSound" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIAccessibilityTraitPlaysSound", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An accessibility trait indicating the accessibility element should play its sound when the <see cref="T:UIKit.UIView" /> is activated.</summary>
        <value>The value to be set for the trait.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TraitSearchField">
      <MemberSignature Language="C#" Value="public static long TraitSearchField { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 TraitSearchField" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.TraitSearchField" />
      <MemberSignature Language="F#" Value="member this.TraitSearchField : int64" Usage="UIKit.UIView.TraitSearchField" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIAccessibilityTraitSearchField", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An accessibility trait indicating that the <see cref="T:UIKit.UIView" /> is a search field.</summary>
        <value>The value to be set for the trait.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TraitSelected">
      <MemberSignature Language="C#" Value="public static long TraitSelected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 TraitSelected" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.TraitSelected" />
      <MemberSignature Language="F#" Value="member this.TraitSelected : int64" Usage="UIKit.UIView.TraitSelected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIAccessibilityTraitSelected", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An accessibility trait indicating that the <see cref="T:UIKit.UIView" /> is currently selected.</summary>
        <value>The value to be set for the trait.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TraitStartsMediaSession">
      <MemberSignature Language="C#" Value="public static long TraitStartsMediaSession { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 TraitStartsMediaSession" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.TraitStartsMediaSession" />
      <MemberSignature Language="F#" Value="member this.TraitStartsMediaSession : int64" Usage="UIKit.UIView.TraitStartsMediaSession" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIAccessibilityTraitStartsMediaSession", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An accessibility trait that starts a media session when the <see cref="T:UIKit.UIView" /> is activated.</summary>
        <value>The value to be set for the trait.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TraitStaticText">
      <MemberSignature Language="C#" Value="public static long TraitStaticText { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 TraitStaticText" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.TraitStaticText" />
      <MemberSignature Language="F#" Value="member this.TraitStaticText : int64" Usage="UIKit.UIView.TraitStaticText" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIAccessibilityTraitStaticText", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An accessibility trait indicating that the <see cref="T:UIKit.UIView" /> contains static text.</summary>
        <value>The value to be set for the trait.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TraitSummaryElement">
      <MemberSignature Language="C#" Value="public static long TraitSummaryElement { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 TraitSummaryElement" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.TraitSummaryElement" />
      <MemberSignature Language="F#" Value="member this.TraitSummaryElement : int64" Usage="UIKit.UIView.TraitSummaryElement" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIAccessibilityTraitSummaryElement", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An accessibility trait indicating that the <see cref="T:UIKit.UIView" /> contains summary information.</summary>
        <value>The value to be set for the trait.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TraitTabBar">
      <MemberSignature Language="C#" Value="public static long TraitTabBar { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 TraitTabBar" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.TraitTabBar" />
      <MemberSignature Language="F#" Value="member this.TraitTabBar : int64" Usage="UIKit.UIView.TraitTabBar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIAccessibilityTraitTabBar", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 10, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 10, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.WatchOS, 3, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 10, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 10, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.WatchOS, 3, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TraitUpdatesFrequently">
      <MemberSignature Language="C#" Value="public static long TraitUpdatesFrequently { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 TraitUpdatesFrequently" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.TraitUpdatesFrequently" />
      <MemberSignature Language="F#" Value="member this.TraitUpdatesFrequently : int64" Usage="UIKit.UIView.TraitUpdatesFrequently" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIAccessibilityTraitUpdatesFrequently", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An accessibility trait indicating that the <see cref="T:UIKit.UIView" /> updates frequently.</summary>
        <value>The value to be set for the trait.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Transform">
      <MemberSignature Language="C#" Value="public virtual CoreGraphics.CGAffineTransform Transform { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype CoreGraphics.CGAffineTransform Transform" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.Transform" />
      <MemberSignature Language="F#" Value="member this.Transform : CoreGraphics.CGAffineTransform with get, set" Usage="UIKit.UIView.Transform" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:UIKit.IUIDynamicItem.Transform</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("transform")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setTransform:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>CoreGraphics.CGAffineTransform</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The transform of the <see cref="T:UIKit.UIView" />, relative to the center of its bounds.</summary>
        <value>The default value is the identity transform.</value>
        <remarks>
          <para>
            This property can be used to manipulate the <see cref="T:CoreGraphics.CGAffineTransform" /> that is applied to the <see cref="T:UIKit.UIView" /> prior to rendering. The <see cref="P:UIKit.UIView.Transform" /> is applied to the center of the <see cref="T:UIKit.UIView" />'s <see cref="P:UIKit.UIView.Bounds" />. 
          </para>
          <para>
            The transform is applied prior to Auto Layout constraints being applied. For instance, the following code shows constraints that, with default transforms, lay out three equally sized subviews with 30-pixel vertical spacing. A scaling transform is applied to the green view and a rotational transform to the yellow. The following image shows the result: the transforms are applied and then the Auto Layout constraints are resolved. The result is that the views are resized such that their width and height match the constraints. This effectively overrides the scaling transform on the green view while rotating and scaling the yellow view such that it's alignment rectangle satisfies the constraints.
          </para>
          <example>
            <code lang="C#"><![CDATA[
mainView.AddConstraints(NSLayoutConstraint.FromVisualFormat("H:|-[blue]-|", 0, new NSDictionary(), viewsDictionary));
mainView.AddConstraints(NSLayoutConstraint.FromVisualFormat("V:|-[blue]-(==30)-[green(==blue)]-(==30)-[yellow(==blue)]-|", 0, new NSDictionary(), viewsDictionary));
mainView.AddConstraints(NSLayoutConstraint.FromVisualFormat("|-[green(==blue)]-|", 0, new NSDictionary(), viewsDictionary));
mainView.AddConstraints(NSLayoutConstraint.FromVisualFormat("|-[yellow(==blue)]-|", 0, new NSDictionary(), viewsDictionary));

greenView.Transform = CGAffineTransform.MakeScale(2F, 2F);
yellowView.Transform = CGAffineTransform.MakeRotation((float)(Math.PI / 10));		
]]></code>
          </example>
          <para>
            <img href="~/UIKit/_images/UIKit.View.Transform.png" />
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transition">
      <MemberSignature Language="C#" Value="public static void Transition (UIKit.UIView withView, double duration, UIKit.UIViewAnimationOptions options, Action animation, Action completion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Transition(class UIKit.UIView withView, float64 duration, valuetype UIKit.UIViewAnimationOptions options, class System.Action animation, class System.Action completion) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.Transition(UIKit.UIView,System.Double,UIKit.UIViewAnimationOptions,System.Action,System.Action)" />
      <MemberSignature Language="F#" Value="static member Transition : UIKit.UIView * double * UIKit.UIViewAnimationOptions * Action * Action -&gt; unit" Usage="UIKit.UIView.Transition (withView, duration, options, animation, completion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Use the *Notify method that has 'UICompletionHandler completion' parameter, the 'bool' will tell you if the operation finished.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="withView" Type="UIKit.UIView" />
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="options" Type="UIKit.UIViewAnimationOptions" />
        <Parameter Name="animation" Type="System.Action" />
        <Parameter Name="completion" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="withView">The view that performs the transition.</param>
        <param name="duration">Duration set for transition animation.</param>
        <param name="options">A mask of options defining animations performance.</param>
        <param name="animation">Action object containing  changes to make to the specified view.</param>
        <param name="completion">Action object for execution when the animation sequence completes.</param>
        <summary>Specifies a transition animation on the specified collection view.</summary>
        <remarks>
          <para>The use of this method is discouraged. Application developers should prefer to use the <see cref="T:UIKit.UIViewPropertyAnimator" /> class to animate UIViews.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transition">
      <MemberSignature Language="C#" Value="public static void Transition (UIKit.UIView fromView, UIKit.UIView toView, double duration, UIKit.UIViewAnimationOptions options, Action completion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Transition(class UIKit.UIView fromView, class UIKit.UIView toView, float64 duration, valuetype UIKit.UIViewAnimationOptions options, class System.Action completion) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.Transition(UIKit.UIView,UIKit.UIView,System.Double,UIKit.UIViewAnimationOptions,System.Action)" />
      <MemberSignature Language="F#" Value="static member Transition : UIKit.UIView * UIKit.UIView * double * UIKit.UIViewAnimationOptions * Action -&gt; unit" Usage="UIKit.UIView.Transition (fromView, toView, duration, options, completion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Use the *Notify method that has 'UICompletionHandler completion' parameter, the 'bool' will tell you if the operation finished.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromView" Type="UIKit.UIView" />
        <Parameter Name="toView" Type="UIKit.UIView" />
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="options" Type="UIKit.UIViewAnimationOptions" />
        <Parameter Name="completion" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="fromView">The initial view.</param>
        <param name="toView">The final view.</param>
        <param name="duration">The duration, in seconds, of the animation.</param>
        <param name="options">A mask of options to be used with the animation.</param>
        <param name="completion">An action to be executed at the end of the animation.</param>
        <summary>Specifies a transition animation on the specified collection view.</summary>
        <remarks>
          <para>The use of this method is discouraged. Application developers should prefer to use the <see cref="T:UIKit.UIViewPropertyAnimator" /> class to animate UIViews.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TransitionNotify">
      <MemberSignature Language="C#" Value="public static void TransitionNotify (UIKit.UIView withView, double duration, UIKit.UIViewAnimationOptions options, Action animation, UIKit.UICompletionHandler completion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TransitionNotify(class UIKit.UIView withView, float64 duration, valuetype UIKit.UIViewAnimationOptions options, class System.Action animation, class UIKit.UICompletionHandler completion) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.TransitionNotify(UIKit.UIView,System.Double,UIKit.UIViewAnimationOptions,System.Action,UIKit.UICompletionHandler)" />
      <MemberSignature Language="F#" Value="static member TransitionNotify : UIKit.UIView * double * UIKit.UIViewAnimationOptions * Action * UIKit.UICompletionHandler -&gt; unit" Usage="UIKit.UIView.TransitionNotify (withView, duration, options, animation, completion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("transitionWithView:duration:options:animations:completion:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="withView" Type="UIKit.UIView" />
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="options" Type="UIKit.UIViewAnimationOptions" />
        <Parameter Name="animation" Type="System.Action">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="completion" Type="UIKit.UICompletionHandler">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDUICompletionHandler))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="withView">View whose state is being manipulated and in which the animation should occur.</param>
        <param name="duration">The duration of the animation in seconds.</param>
        <param name="options">A mask of options to be used with the animation.</param>
        <param name="animation">
          <para>Action containing the animation and state manipulation of the view.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <param name="completion">
          <para>The method to invoke when the transition completes.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Creates a transition animation action that is used for the current container view.</summary>
        <remarks>
          <para>The use of this method is discouraged. Application developers should prefer to use the <see cref="T:UIKit.UIViewPropertyAnimator" /> class to animate UIViews.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TransitionNotify">
      <MemberSignature Language="C#" Value="public static void TransitionNotify (UIKit.UIView fromView, UIKit.UIView toView, double duration, UIKit.UIViewAnimationOptions options, UIKit.UICompletionHandler completion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TransitionNotify(class UIKit.UIView fromView, class UIKit.UIView toView, float64 duration, valuetype UIKit.UIViewAnimationOptions options, class UIKit.UICompletionHandler completion) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.TransitionNotify(UIKit.UIView,UIKit.UIView,System.Double,UIKit.UIViewAnimationOptions,UIKit.UICompletionHandler)" />
      <MemberSignature Language="F#" Value="static member TransitionNotify : UIKit.UIView * UIKit.UIView * double * UIKit.UIViewAnimationOptions * UIKit.UICompletionHandler -&gt; unit" Usage="UIKit.UIView.TransitionNotify (fromView, toView, duration, options, completion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("transitionFromView:toView:duration:options:completion:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromView" Type="UIKit.UIView" />
        <Parameter Name="toView" Type="UIKit.UIView" />
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="options" Type="UIKit.UIViewAnimationOptions" />
        <Parameter Name="completion" Type="UIKit.UICompletionHandler">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDUICompletionHandler))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="fromView">The initial view.</param>
        <param name="toView">The final view.</param>
        <param name="duration">The duration, in seconds, of the animation.</param>
        <param name="options">A mask of options to be used with the animation.</param>
        <param name="completion">
          <para>An <see cref="T:UIKit.UICompletionHandler" /> to be executed at the end of the animation. This parameter may be <see langword="null" />.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Specifies a transition animation to be used between the specified <see cref="T:UIKit.UIView" />s.</summary>
        <remarks>
          <para>The use of this method is discouraged. Application developers should prefer to use the <see cref="T:UIKit.UIViewPropertyAnimator" /> class to animate UIViews.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TransitionNotifyAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;bool&gt; TransitionNotifyAsync (UIKit.UIView withView, double duration, UIKit.UIViewAnimationOptions options, Action animation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;bool&gt; TransitionNotifyAsync(class UIKit.UIView withView, float64 duration, valuetype UIKit.UIViewAnimationOptions options, class System.Action animation) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.TransitionNotifyAsync(UIKit.UIView,System.Double,UIKit.UIViewAnimationOptions,System.Action)" />
      <MemberSignature Language="F#" Value="static member TransitionNotifyAsync : UIKit.UIView * double * UIKit.UIViewAnimationOptions * Action -&gt; System.Threading.Tasks.Task&lt;bool&gt;" Usage="UIKit.UIView.TransitionNotifyAsync (withView, duration, options, animation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="withView" Type="UIKit.UIView" />
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="options" Type="UIKit.UIViewAnimationOptions" />
        <Parameter Name="animation" Type="System.Action">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="withView">View whose state is being manipulated and in which the animation should occur.</param>
        <param name="duration">The duration of the animation in seconds.</param>
        <param name="options">A mask of options to be used with the animation.</param>
        <param name="animation">Action containing the animation and state manipulation of the view.</param>
        <summary>Creates a transition animation action that is used for the current container view.</summary>
        <returns>A task that represents the asynchronous TransitionNotify operation. </returns>
        <remarks>
          <para>The use of this method is discouraged. Application developers should prefer to use the <see cref="T:UIKit.UIViewPropertyAnimator" /> class to animate UIViews.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TransitionNotifyAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;bool&gt; TransitionNotifyAsync (UIKit.UIView fromView, UIKit.UIView toView, double duration, UIKit.UIViewAnimationOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;bool&gt; TransitionNotifyAsync(class UIKit.UIView fromView, class UIKit.UIView toView, float64 duration, valuetype UIKit.UIViewAnimationOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.TransitionNotifyAsync(UIKit.UIView,UIKit.UIView,System.Double,UIKit.UIViewAnimationOptions)" />
      <MemberSignature Language="F#" Value="static member TransitionNotifyAsync : UIKit.UIView * UIKit.UIView * double * UIKit.UIViewAnimationOptions -&gt; System.Threading.Tasks.Task&lt;bool&gt;" Usage="UIKit.UIView.TransitionNotifyAsync (fromView, toView, duration, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromView" Type="UIKit.UIView" />
        <Parameter Name="toView" Type="UIKit.UIView" />
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="options" Type="UIKit.UIViewAnimationOptions" />
      </Parameters>
      <Docs>
        <param name="fromView">The initial view.</param>
        <param name="toView">The final view.</param>
        <param name="duration">The duration, in seconds, of the animation.</param>
        <param name="options">A mask of options to be used with the animation.</param>
        <summary>Specifies a transition animation to be used between the specified <see cref="T:UIKit.UIView" />s.</summary>
        <returns>
          <para>A task that represents the asynchronous TransitionNotify operation.   The value of the TResult parameter is a <see cref="T:UIKit.UICompletionHandler" />.</para>
        </returns>
        <remarks>
          <para>The use of this method is discouraged. Application developers should prefer to use the <see cref="T:UIKit.UIViewPropertyAnimator" /> class to animate UIViews.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TranslatesAutoresizingMaskIntoConstraints">
      <MemberSignature Language="C#" Value="public virtual bool TranslatesAutoresizingMaskIntoConstraints { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TranslatesAutoresizingMaskIntoConstraints" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.TranslatesAutoresizingMaskIntoConstraints" />
      <MemberSignature Language="F#" Value="member this.TranslatesAutoresizingMaskIntoConstraints : bool with get, set" Usage="UIKit.UIView.TranslatesAutoresizingMaskIntoConstraints" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("translatesAutoresizingMaskIntoConstraints")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setTranslatesAutoresizingMaskIntoConstraints:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies whether the autoresizing mask should be translated into constraints for Auto Layout.</summary>
        <value>The default value is <see langword="true" />.</value>
        <remarks>
          <para>If this property is <see langword="true" />, this <see cref="T:UIKit.UIView" />'s <see cref="P:UIKit.UIView.Superview" /> will convert this <see cref="T:UIKit.UIView" />'s <see cref="P:UIKit.UIView.AutoresizingMask" /> into <see cref="T:UIKit.NSLayoutConstraint" />s and include them in the <see cref="P:UIKit.UIView.Superview" />'s <see cref="P:UIKit.UIView.Constraints" />. This will fully constrain this <see cref="T:UIKit.UIView" /> and Auto Layout will not be able to resize or reposition this <see cref="T:UIKit.UIView" />.</para>
          <para>If the application developer is using Auto Layout, setting this property to <see langword="false" /> allows Auto Layout to change the layout of this <see cref="T:UIKit.UIView" />.</para>
          <para>In an over-constrained Auto Layout, the appearance of <c>NSAutoresizingMaskLayoutConstraint</c> in the Auto Layout debugging information is often an indication that the Application Developer has inappropriately left this property as <see langword="true" /> somewhere.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UILayoutFittingCompressedSize">
      <MemberSignature Language="C#" Value="public static CoreGraphics.CGSize UILayoutFittingCompressedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype CoreGraphics.CGSize UILayoutFittingCompressedSize" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.UILayoutFittingCompressedSize" />
      <MemberSignature Language="F#" Value="member this.UILayoutFittingCompressedSize : CoreGraphics.CGSize" Usage="UIKit.UIView.UILayoutFittingCompressedSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UILayoutFittingCompressedSize", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>CoreGraphics.CGSize</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UILayoutFittingCompressedSize</summary>
        <value>
        </value>
        <remarks>Indicates that <see cref="M:UIKit.UIView.SystemLayoutSizeFittingSize(CoreGraphics.CGSize,System.Single,System.Single)" /> should calculate the smallest possible size.</remarks>
        <altmember cref="M:UIKit.UIView.SystemLayoutSizeFittingSize" />
      </Docs>
    </Member>
    <Member MemberName="UILayoutFittingExpandedSize">
      <MemberSignature Language="C#" Value="public static CoreGraphics.CGSize UILayoutFittingExpandedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype CoreGraphics.CGSize UILayoutFittingExpandedSize" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.UILayoutFittingExpandedSize" />
      <MemberSignature Language="F#" Value="member this.UILayoutFittingExpandedSize : CoreGraphics.CGSize" Usage="UIKit.UIView.UILayoutFittingExpandedSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UILayoutFittingExpandedSize", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>CoreGraphics.CGSize</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UILayoutFittingExpandedSize</summary>
        <value>
        </value>
        <remarks>Indicates that <see cref="M:UIKit.UIView.SystemLayoutSizeFittingSize(CoreGraphics.CGSize,System.Single,System.Single)" /> should calculate the largest possible size.</remarks>
        <altmember cref="M:UIKit.UIView.SystemLayoutSizeFittingSize" />
      </Docs>
    </Member>
    <Member MemberName="UnfocusedElementKey">
      <MemberSignature Language="C#" Value="public static Foundation.NSString UnfocusedElementKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString UnfocusedElementKey" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.UnfocusedElementKey" />
      <MemberSignature Language="F#" Value="member this.UnfocusedElementKey : Foundation.NSString" Usage="UIKit.UIView.UnfocusedElementKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Use UIView.Notifications.ObserveUnfocusedElementKey helper method instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Field("UIAccessibilityUnfocusedElementKey", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A string constant used by accessibility APIs (see <see cref="M:UIKit.UIAccessibility.FocusedElement(System.String)" />) to identify the previously focused element.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateConstraints">
      <MemberSignature Language="C#" Value="public virtual void UpdateConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UpdateConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.UpdateConstraints" />
      <MemberSignature Language="F#" Value="abstract member UpdateConstraints : unit -&gt; unit&#xA;override this.UpdateConstraints : unit -&gt; unit" Usage="uIView.UpdateConstraints " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Overriding this method requires a call to the overriden method.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Export("updateConstraints")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.RequiresSuper</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Updates the Auto Layout constraints for the <see cref="T:UIKit.UIView" />.</summary>
        <remarks>
          <para>Application developers may override this method in order to create and update custom constraints for use with Auto Layout.</para>
          <para>The Auto Layout system calls this method prior to layout. The <see cref="T:UIKit.UIView" />'s properties will be in a stable state when this method is called and application developers should be able to establish valid constraints.</para>
          <para>Application developers may add or remove constraints in this method. If they do so, they must call <see cref="M:UIKit.UIView.SetNeedsUpdateConstraints" /> to notify the Auto Layout system that further updating is required.</para>
          <para>Application developers must not invalidate existing <see cref="T:UIKit.NSLayoutConstraint" />s during this method. Applications developers must not perform drawing actions or invoke layout recalculation during this method.</para>
          <para>Application developers must call <c>base.UpdateConstraints()</c> in their implementations of this method.</para>
        </remarks>
        <altmember cref="M:UIKit.UIView.UpdateConstraintsIfNeeded" />
      </Docs>
    </Member>
    <Member MemberName="UpdateConstraintsIfNeeded">
      <MemberSignature Language="C#" Value="public virtual void UpdateConstraintsIfNeeded ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UpdateConstraintsIfNeeded() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.UpdateConstraintsIfNeeded" />
      <MemberSignature Language="F#" Value="abstract member UpdateConstraintsIfNeeded : unit -&gt; unit&#xA;override this.UpdateConstraintsIfNeeded : unit -&gt; unit" Usage="uIView.UpdateConstraintsIfNeeded " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("updateConstraintsIfNeeded")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Updates the constraints of the <see cref="T:UIKit.UIView" /> and its <see cref="P:UIKit.UIView.Subviews" />.</summary>
        <remarks>
          <para>Application developers should not overide this method.</para>
          <para>This method is called by the Auto Layout system during layout. Application developers may invoke it to ensure that constraints are current.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateFocusIfNeeded">
      <MemberSignature Language="C#" Value="public virtual void UpdateFocusIfNeeded ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UpdateFocusIfNeeded() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.UpdateFocusIfNeeded" />
      <MemberSignature Language="F#" Value="abstract member UpdateFocusIfNeeded : unit -&gt; unit&#xA;override this.UpdateFocusIfNeeded : unit -&gt; unit" Usage="uIView.UpdateFocusIfNeeded " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:UIKit.IUIFocusEnvironment.UpdateFocusIfNeeded</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("updateFocusIfNeeded")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>If any focus environment has a pending update, this method forces an immediate focus update. Unlike <see cref="M:UIKit.UIView.SetNeedsFocusUpdate" />, this method may be called by any <see cref="T:UIKit.UIView" />, whether it currently contains focus or not.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UserInteractionEnabled">
      <MemberSignature Language="C#" Value="public virtual bool UserInteractionEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UserInteractionEnabled" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.UserInteractionEnabled" />
      <MemberSignature Language="F#" Value="member this.UserInteractionEnabled : bool with get, set" Usage="UIKit.UIView.UserInteractionEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("isUserInteractionEnabled")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setUserInteractionEnabled:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determines whether input events are processed by this view.</summary>
        <value>
        </value>
        <remarks>
          <para>
            This property is used to control whether input events are
            delivered to the view.  By default all views receive
            events.  
            
          </para>
          <para>
            During animations, UIKit will disable event delivery to
            your view unless you pass the <see cref="T:UIKit.UIViewAnimationOptions" />.AllowUserInteraction
            flag to your animation function.
            
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewForBaselineLayout">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIView ViewForBaselineLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIView ViewForBaselineLayout" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.ViewForBaselineLayout" />
      <MemberSignature Language="F#" Value="member this.ViewForBaselineLayout : UIKit.UIView" Usage="UIKit.UIView.ViewForBaselineLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, "Override 'ViewForFirstBaselineLayout' or 'ViewForLastBaselineLayout'.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("viewForBaselineLayout")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, "Override 'ViewForFirstBaselineLayout' or 'ViewForLastBaselineLayout'.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns the <see cref="T:UIKit.UIView" /> upon which baseline constraints should be applied.</summary>
        <value>The default value is <c>this</c> <see cref="T:UIKit.UIView" />.</value>
        <remarks>
          <para>Returns the <see cref="T:UIKit.UIView" /> for which constraints relating to <see cref="F:UIKit.NSLayoutAttribute.Baseline" /> should apply. The baseline for many <see cref="T:UIKit.UIView" />s is the bottom of the view but in a <see cref="T:UIKit.UILabel" />, for instance, the baseline should be the position of the text baseline.</para>
          <para>The returned value must be either <c>this</c> or a view in <c>this</c>'s subview hierarchy.</para>
        </remarks>
        <altmember cref="M:UIKit.UIView.AlignmentRectForFrame" />
        <altmember cref="M:UIKit.UIView.FrameForAlignmentRect" />
        <altmember cref="M:UIKit.UIView.AlignmentRectInsets" />
      </Docs>
    </Member>
    <Member MemberName="ViewForFirstBaselineLayout">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIView ViewForFirstBaselineLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIView ViewForFirstBaselineLayout" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.ViewForFirstBaselineLayout" />
      <MemberSignature Language="F#" Value="member this.ViewForFirstBaselineLayout : UIKit.UIView" Usage="UIKit.UIView.ViewForFirstBaselineLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("viewForFirstBaselineLayout")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>When overridden, allows the app dev to return a subview as the basis for baseline constraints.</summary>
        <value>The default value is <c>this</c>.</value>
        <remarks>
          <para>The returned <see cref="T:UIKit.UIView" /> must be in <c>this</c><see cref="T:UIKit.UIView" />'s view hierarchy.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewForLastBaselineLayout">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIView ViewForLastBaselineLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIView ViewForLastBaselineLayout" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.ViewForLastBaselineLayout" />
      <MemberSignature Language="F#" Value="member this.ViewForLastBaselineLayout : UIKit.UIView" Usage="UIKit.UIView.ViewForLastBaselineLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("viewForLastBaselineLayout")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>When overridden, allows the app dev to return a subview as the basis for baseline constraints.</summary>
        <value>The default value is <c>this</c>.</value>
        <remarks>
          <para>The returned <see cref="T:UIKit.UIView" /> must be in <c>this</c><see cref="T:UIKit.UIView" />'s view hierarchy.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewPrintFormatter">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIViewPrintFormatter ViewPrintFormatter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIViewPrintFormatter ViewPrintFormatter" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.ViewPrintFormatter" />
      <MemberSignature Language="F#" Value="member this.ViewPrintFormatter : UIKit.UIViewPrintFormatter" Usage="UIKit.UIView.ViewPrintFormatter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("viewPrintFormatter")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIViewPrintFormatter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns a <see cref="T:UIKit.UIViewPrintFormatter" /> appropriate for the <see cref="T:UIKit.UIView" />.</summary>
        <value>This method may return <see langword="null" /> if an appropriate <see cref="T:UIKit.UIViewPrintFormatter" /> could not be created.</value>
        <remarks>
          <para>This method produces a t<see cref="T:UIKit.UIViewPrintFormatter" /> that can be configured with the page layout options desired by the application.</para>
          <para>Every time this method is called, it creates a new <see cref="T:UIKit.UIViewPrintFormatter" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewWithTag">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIView ViewWithTag (nint tag);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class UIKit.UIView ViewWithTag(valuetype System.nint tag) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.ViewWithTag(System.nint)" />
      <MemberSignature Language="F#" Value="abstract member ViewWithTag : nint -&gt; UIKit.UIView&#xA;override this.ViewWithTag : nint -&gt; UIKit.UIView" Usage="uIView.ViewWithTag tag" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("viewWithTag:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIView</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tag" Type="System.nint" />
      </Parameters>
      <Docs>
        <param name="tag">
          <para>The identifier being searched for.</para>
        </param>
        <summary>Returns the <see cref="T:UIKit.UIView" /> identified by the <paramref name="tag" />. May return <see langword="null" />.</summary>
        <returns>
          <para>The view in the view hierarchy whose <see cref="P:UIKit.UIView.Tag" /> is equal to <paramref name="tag" />.</para>
        </returns>
        <remarks>
          <para>This method searches the current <see cref="T:UIKit.UIView" />'s view hierarchy (i.e., <c>this</c>, it's <see cref="P:UIKit.UIView.Subviews" /> and their descendants) and returns the <see cref="T:UIKit.UIView" />, if any, whose <see cref="P:UIKit.UIView.Tag" /> property is equal to the <paramref name="tag" /> parameter. If no such <see cref="T:UIKit.UIView" /> exists, this method returns <see langword="null" />.</para>
        </remarks>
        <altmember cref="P:UIKit.UIView.Tag" />
      </Docs>
    </Member>
    <Member MemberName="VoiceOverStatusChanged">
      <MemberSignature Language="C#" Value="public static Foundation.NSString VoiceOverStatusChanged { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString VoiceOverStatusChanged" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.VoiceOverStatusChanged" />
      <MemberSignature Language="F#" Value="member this.VoiceOverStatusChanged : Foundation.NSString" Usage="UIKit.UIView.VoiceOverStatusChanged" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UIAccessibilityVoiceOverStatusChanged", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.None, "Use 'VoiceOverStatusDidChangeNotification' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.None, "Use 'VoiceOverStatusDidChangeNotification' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.None, "Use 'VoiceOverStatusDidChangeNotification' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Deprecated(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.None, "Use 'VoiceOverStatusDidChangeNotification' instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An accessibility notification indicating that the status of voice-over has changed.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:UIKit.UIView.AnnouncementNotification" />
        <altmember cref="P:UIKit.UIView.AnnouncementDidFinishNotification" />
        <altmember cref="P:UIKit.UIView.ClosedCaptioningStatusDidChangeNotification" />
        <altmember cref="P:UIKit.UIView.GuidedAccessStatusDidChangeNotification" />
        <altmember cref="P:UIKit.UIView.InvertColorStatusDidChangeNotification" />
        <altmember cref="P:UIKit.UIView.AnnouncementNotification" />
        <altmember cref="P:UIKit.UIView.LayoutChangedNotification" />
        <altmember cref="P:UIKit.UIView.MonoAudioStatusDidChangeNotification" />
        <altmember cref="P:UIKit.UIView.PageScrolledNotification" />
        <altmember cref="P:UIKit.UIView.ScreenChangedNotification" />
        <altmember cref="P:UIKit.UIView.VoiceOverStatusChangedNotification" />
      </Docs>
    </Member>
    <Member MemberName="VoiceOverStatusDidChangeNotification">
      <MemberSignature Language="C#" Value="public static Foundation.NSString VoiceOverStatusDidChangeNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString VoiceOverStatusDidChangeNotification" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.VoiceOverStatusDidChangeNotification" />
      <MemberSignature Language="F#" Value="member this.VoiceOverStatusDidChangeNotification : Foundation.NSString" Usage="UIKit.UIView.VoiceOverStatusDidChangeNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Use UIView.Notifications.ObserveVoiceOverStatusDidChange helper method instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Field("UIAccessibilityVoiceOverStatusDidChangeNotification", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for VoiceOverStatusDidChange</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:Foundation.NSNotificationCenter" /> to register a listener for this notification, also developers can use the strongly typed notification <see cref="M:UIKit.UIView.Notifications.ObserveVoiceOverStatusDidChange*" /> instead.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIView.VoiceOverStatusDidChangeNotification, (notification) => {Console.WriteLine ("Received the notification UIView", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIView", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIView.VoiceOverStatusDidChangeNotification, Callback);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WidthAnchor">
      <MemberSignature Language="C#" Value="public virtual UIKit.NSLayoutDimension WidthAnchor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.NSLayoutDimension WidthAnchor" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.WidthAnchor" />
      <MemberSignature Language="F#" Value="member this.WidthAnchor : UIKit.NSLayoutDimension" Usage="UIKit.UIView.WidthAnchor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("widthAnchor")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.NSLayoutDimension</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The <see cref="T:UIKit.NSLayoutDimension" /> that defines the horizontal extent of this <see cref="T:UIKit.UIView" />.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WillDrawLayer">
      <MemberSignature Language="C#" Value="public virtual void WillDrawLayer (CoreAnimation.CALayer layer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WillDrawLayer(class CoreAnimation.CALayer layer) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.WillDrawLayer(CoreAnimation.CALayer)" />
      <MemberSignature Language="F#" Value="abstract member WillDrawLayer : CoreAnimation.CALayer -&gt; unit&#xA;override this.WillDrawLayer : CoreAnimation.CALayer -&gt; unit" Usage="uIView.WillDrawLayer layer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("layerWillDraw:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.WatchOS, 3, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 10, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.MacOSX, 10, 12, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 10, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="layer" Type="CoreAnimation.CALayer" />
      </Parameters>
      <Docs>
        <param name="layer">To be added.</param>
        <summary>Called shortly before the <param name="layer" /> is drawn.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WillMoveToSuperview">
      <MemberSignature Language="C#" Value="public virtual void WillMoveToSuperview (UIKit.UIView newsuper);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WillMoveToSuperview(class UIKit.UIView newsuper) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.WillMoveToSuperview(UIKit.UIView)" />
      <MemberSignature Language="F#" Value="abstract member WillMoveToSuperview : UIKit.UIView -&gt; unit&#xA;override this.WillMoveToSuperview : UIKit.UIView -&gt; unit" Usage="uIView.WillMoveToSuperview newsuper" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("willMoveToSuperview:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newsuper" Type="UIKit.UIView" />
      </Parameters>
      <Docs>
        <param name="newsuper">
          <para>The <see cref="T:UIKit.UIView" /> to which <c>this</c> <see cref="T:UIKit.UIView" /> is being moved.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Called before the <see cref="P:UIKit.UIView.Superview" /> changes.</summary>
        <remarks>
          <para>This method is called by the runtime when assigning the <see cref="P:UIKit.UIView.Superview" /> property and is invoked shortly before the change is made.</para>
          <para>By default, this method does nothing. Application developers can override the method in order to perform additional processing.</para>
        </remarks>
        <altmember cref="M:UIKit.UIView.MovedToSuperview" />
      </Docs>
    </Member>
    <Member MemberName="WillMoveToWindow">
      <MemberSignature Language="C#" Value="public virtual void WillMoveToWindow (UIKit.UIWindow window);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WillMoveToWindow(class UIKit.UIWindow window) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.WillMoveToWindow(UIKit.UIWindow)" />
      <MemberSignature Language="F#" Value="abstract member WillMoveToWindow : UIKit.UIWindow -&gt; unit&#xA;override this.WillMoveToWindow : UIKit.UIWindow -&gt; unit" Usage="uIView.WillMoveToWindow window" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("willMoveToWindow:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="window" Type="UIKit.UIWindow" />
      </Parameters>
      <Docs>
        <param name="window">
          <para>Called before the window at the root of the <see cref="T:UIKit.UIView" />'s view hierarchy changes.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>This method is called by the runtime when assigning a new <see cref="T:UIKit.UIWindow" /> to the <see cref="T:UIKit.UIView" />'s view hierarcy. This method will be called on all <see cref="T:UIKit.UIView" />s in the hierarchy, not just the top-level <see cref="T:UIKit.UIView" />. </summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WillRemoveSubview">
      <MemberSignature Language="C#" Value="public virtual void WillRemoveSubview (UIKit.UIView uiview);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WillRemoveSubview(class UIKit.UIView uiview) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UIView.WillRemoveSubview(UIKit.UIView)" />
      <MemberSignature Language="F#" Value="abstract member WillRemoveSubview : UIKit.UIView -&gt; unit&#xA;override this.WillRemoveSubview : UIKit.UIView -&gt; unit" Usage="uIView.WillRemoveSubview uiview" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("willRemoveSubview:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uiview" Type="UIKit.UIView" />
      </Parameters>
      <Docs>
        <param name="uiview">
          <para>The subview that will be removed.</para>
        </param>
        <summary>Called prior to the removal of a subview.</summary>
        <remarks>
          <para>This method is called by the runtime when a <see cref="T:UIKit.UIView" /> is removed from the <see cref="P:UIKit.UIView.Subviews" /> array. </para>
          <para>By default, this method does nothing. Application developers can override the method in order to perform additional processing.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Window">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIWindow Window { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIWindow Window" />
      <MemberSignature Language="DocId" Value="P:UIKit.UIView.Window" />
      <MemberSignature Language="F#" Value="member this.Window : UIKit.UIWindow" Usage="UIKit.UIView.Window" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("window")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIWindow</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The <see cref="T:UIKit.UIWindow" /> of the <see cref="T:UIKit.UIView" />.</summary>
        <value>The default value is <see langword="null" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
