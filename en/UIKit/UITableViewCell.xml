<Type Name="UITableViewCell" FullName="UIKit.UITableViewCell">
  <TypeSignature Language="C#" Value="public class UITableViewCell : UIKit.UIView, IDisposable, UIKit.IUIGestureRecognizerDelegate" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit UITableViewCell extends UIKit.UIView implements class Foundation.INSCoding, class ObjCRuntime.INativeObject, class System.IDisposable, class UIKit.IUIGestureRecognizerDelegate" />
  <AssemblyInfo>
    <AssemblyName>Xamarin.iOS</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>UIKit.UIView</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>UIKit.IUIGestureRecognizerDelegate</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>Foundation.Register("UITableViewCell", true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>A <see cref="T:UIKit.UIView" /> that displays an element displayed by the <see cref="T:UIKit.UITableView" />. Cells can be reused.</summary>
    <remarks>
      <para>

	A <see cref="T:UIKit.UITableViewCell" /> represents
	a single cell (row) in a <see cref="T:UIKit.UITableView" />. <see cref="T:UIKit.UITableViewCell" />s are typically
	allocated in the <see cref="M:UIKit.UITableViewSource.GetCell" /> method
	of <see cref="T:UIKit.UITableViewSource" /> if <see cref="M:UIKit.UITableView.DequeueReusableCell" />
	returns <see langword="null" />. (See discussion at <see cref="T:UIKit.UITableView" /> or <see cref="M:UIKit.UITableViewSource.GetCell" />).
      </para>
      <para>

	There are four predefined <see cref="T:UIKit.UITableViewCell" /> styles, which can
	be created by using the <see cref="C:UIKit.UITableViewCell(UITableViewCellStyle,NSString)" /> constructor. These predefined styles appear as follows:
      </para>
      <para>
        <img href="UIKit.UITableViewCellStyle.png" />
      </para>
      <para>

	All of the predefined styles have <see cref="P:UIKit.UITableViewCell.TextLabel" /> and <see cref="P:UIKit.UITableViewCell.DetailTextLabel" />
	properties of type <see cref="T:UIKit.UILabel" />
	and all but <see cref="F:UIKit.UITableViewCellStyle.Value2" /> have a
	<see cref="P:UIKit.UITableViewCell.Image" /> of type
	<see cref="T:UIKit.UIImage" />. Assignment to the
	<see cref="P:UIKit.UITableViewCell.Image" />
	property of a cell initialized with the <see cref="F:UIKit.UITableViewCellStyle.Value2" /> style
	will result in a runtime exception.
      </para>
      <para>
	A <see cref="T:UIKit.UITableViewCell" /> may combine
	its <see cref="P:UIKit.UITableViewCell.ContentView" /> with a <see cref="T:UIKit.UIView" /> assigned to
	its <see cref="P:UIKit.UITableViewCell.AccessoryView" />
	property. Accessory views are often used with standard <see cref="T:UIKit.UITableViewCellAccessory" />s, such as
	a checkmark or disclosure indicator. When being edited, a <see cref="T:UIKit.UITableViewCell" /> will combine its
	<see cref="P:UIKit.UITableViewCell.ContentView" />
	with an editing control on the left and, optionally, a
	reordering control on the right.
      </para>
      <para>
        <img href="UIKit.UITableViewCell.Structure.png" />
      </para>
      <para>

	In a non-selected cell, the <see cref="P:UIKit.UITableViewCell.BackgroundView" /> is
	displayed, while a selected cell will show its <see cref="P:UIKit.UITableViewCell.SelectedBackgroundView" /> view.
      </para>
      <para>

	To customize <see cref="T:UIKit.UITableViewCell" />s, application developers can either customize the views
	used by one of the predefined styles or can subclass <see cref="T:UIKit.UITableViewCell" />. (In addition,
	application developers will often override <see cref="M:UIKit.UITableViewSource.GetHeightForRow" />.)
      </para>
      <para>

	Starting with iOS 8, table view cells can be auto-sized, and
	no longer require the <see cref="M:UIKit.UITableViewSource.GetHeightForRow(UIKit.UITableView,Foundation.NSIndexPath)" /> to be implemented to size cells.  To do this, the cell
	constructor should set the <see cref="P:UIKit.UITableViewCell.ContentView" /> constraints.

      </para>
      <block subset="none" type="note">
        <para>
	  Application developers should prefer subclassing <see cref="T:UIKit.UITableViewCell" /> over extensive
	  customization of predefined styles. Xamarin's experience is
	  that subclassing is less error-prone. Although subclassing
	  introduces the normal overhead of a new class, this is
	  generally a minor trade-off in comparison to the importance
	  and complexity of the customized cell.
	</para>
        <para>
	  Because <see cref="T:UIKit.UITableViewCell" />s
	  appear rapidly during scrolling, application developers should
	  avoid layout recalculations and higher-cost rendering
	  techniques such as the use of transparent views.
	</para>
        <para>
	  Application developers should make a strong effort to reuse
	  cells with the <see cref="M:UIKit.UITableView.DequeueReusableCell" />
	  method of <see cref="T:UIKit.UITableView" />.
	</para>
      </block>
    </remarks>
    <related type="article" href="http://docs.xamarin.com/guides/ios/user_interface/tables">Working with Tables and Cells</related>
    <related type="sample" href="http://samples.xamarin.com/Samples/ByGuid?guid=4912a5a3-7b98-4886-9d50-1b0c417f6037">LazyTableImages</related>
    <related type="sample" href="http://samples.xamarin.com/Samples/ByGuid?guid=23a2571b-45eb-4889-bb67-d88937cb68c1">monocatalog</related>
    <related type="sample" href="http://samples.xamarin.com/Samples/ByGuid?guid=05e33228-333b-4150-b596-cd7696277a3c">Xamarin StudioTouchCells</related>
    <related type="sample" href="http://samples.xamarin.com/Samples/ByGuid?guid=a96da854-7c59-4e25-9fb5-78be262620dd">RecipesAndPrinting</related>
    <related type="PlatformDocAPI" href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITableViewCell_Class/index.html">Apple documentation for <c>UITableViewCell</c></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UITableViewCell ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("init")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Default constructor that initializes a new instance of this class with no parameters.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UITableViewCell (CoreGraphics.CGRect frame);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype CoreGraphics.CGRect frame) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("initWithFrame:")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="frame" Type="CoreGraphics.CGRect" />
      </Parameters>
      <Docs>
        <param name="frame">Frame used by the view, expressed in iOS points.</param>
        <summary>Initializes the UITableViewCell with the specified frame.</summary>
        <remarks>
          <para>This constructor is used to programmatically create a new instance of UITableViewCell with the specified dimension in the frame.   The object will only be displayed once it has been added to a view hierarchy by calling AddSubview in a containing view.</para>
          <para>This constructor is not invoked when deserializing objects from storyboards or XIB filesinstead the constructor that takes an NSCoder parameter is invoked.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UITableViewCell (Foundation.NSCoder coder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Foundation.NSCoder coder) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("initWithCoder:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.DesignatedInitializer</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="coder" Type="Foundation.NSCoder" />
      </Parameters>
      <Docs>
        <param name="coder">The unarchiver object.</param>
        <summary>A constructor that initializes the object from the data stored in the unarchiver object.</summary>
        <remarks>
          <para>This constructor is provided to allow the class to be initialized from an unarchiver (for example, during NIB deserialization).   This is part of the <see cref="T:Foundation.NSCoding" />  protocol.</para>
          <para>If developers want to create a subclass of this object and continue to support deserialization from an archive, they should implement a constructor with an identical signature: taking a single parameter of type <see cref="T:Foundation.NSCoder" /> and decorate it with the [Export("initWithCoder:"] attribute declaration.</para>
          <para>The state of this object can also be serialized by using the companion method, EncodeTo.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected UITableViewCell (Foundation.NSObjectFlag t);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class Foundation.NSObjectFlag t) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="t" Type="Foundation.NSObjectFlag" />
      </Parameters>
      <Docs>
        <param name="t">Unused sentinel value, pass NSObjectFlag.Empty.</param>
        <summary>Constructor to call on derived classes to skip initialization and merely allocate the object.</summary>
        <remarks>
          <para>This constructor should be called by derived classes when they completely construct the object in managed code and merely want the runtime to allocate and initialize the NSObject.   This is required to implement the two-step initialization process that Objective-C uses, the first step is to perform the object allocation, the second step is to initialize the object.   When developers invoke the constructor that takes the NSObjectFlag.Empty they take advantage of a direct path that goes all the way up to NSObject to merely allocate the object's memory and bind the Objective-C and C# objects together.    The actual initialization of the object is up to the developer.</para>
          <para>This constructor is typically used by the binding generator to allocate the object, but prevent the actual initialization to take place.   Once the allocation has taken place, the constructor has to initialize the object.   With constructors generated by the binding generator this means that it manually invokes one of the "init" methods to initialize the object.</para>
          <para>It is the developer's responsibility to completely initialize the object if they chain up using the NSObjectFlag.Empty path.</para>
          <para>In general, if the developer's constructor invokes the NSObjectFlag.Empty base implementation, then it should be calling an Objective-C init method.   If this is not the case, developers should instead chain to the proper constructor in their class. </para>
          <para>The argument value is ignored and merely ensures that the only code that is executed is the construction phase is the basic NSObject allocation and runtime type registration.  Typically the chaining would look like this:</para>
          <example>
            <code lang="C#"><![CDATA[
//
// The NSObjectFlag merely allocates the object and registers the
// C# class with the Objective-C runtime if necessary, but no actual
// initXxx method is invoked, that is done later in the constructor
//
// This is taken from Xamarin.iOS's source code:
//
[Export ("initWithFrame:")]
public UIView (System.Drawing.RectangleF frame) : base (NSObjectFlag.Empty)
{
// Invoke the init method now.
	var initWithFrame = new Selector ("initWithFrame:").Handle;
	if (IsDirectBinding)
		Handle = ObjCRuntime.Messaging.IntPtr_objc_msgSend_CGRect (this.Handle, initWithFrame, frame);
	else
		Handle = ObjCRuntime.Messaging.IntPtr_objc_msgSendSuper_CGRect (this.SuperHandle, initWithFrame, frame);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected UITableViewCell (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig specialname rtspecialname instance void .ctor(native int handle) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Pointer (handle) to the unmanaged object.</param>
        <summary>A constructor used when creating managed representations of unmanaged objects;  Called by the runtime.</summary>
        <remarks>
          <para>This constructor is invoked by the runtime infrastructure (<see cref="M:ObjCRuntime.Runtime.GetNSObject(System.IntPtr)" />) to create a new managed representation for a pointer to an unmanaged Objective-C object.    Developers should not invoke this method directly, instead they should call the GetNSObject method as it will prevent two instances of a managed object to point to the same native object.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UITableViewCell (UIKit.UITableViewCellStyle style, Foundation.NSString reuseIdentifier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype UIKit.UITableViewCellStyle style, class Foundation.NSString reuseIdentifier) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("initWithStyle:reuseIdentifier:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.DesignatedInitializer</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="style" Type="UIKit.UITableViewCellStyle" />
        <Parameter Name="reuseIdentifier" Type="Foundation.NSString" />
      </Parameters>
      <Docs>
        <param name="style">The style to use for this cell.</param>
        <param name="reuseIdentifier">
          <para>A string used to identify the cell object if it should be reused for mutiple rows in a table view. Pass <see langword="null" /> if the object should not be reused. The same reuse identifier string should be used for all cells that use the same class and layout.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Create a table cell with the given style and reuse identifier.</summary>
        <remarks>
          <para>The reuse identifier is associated with all cells (rows) in a table view that have the same layout (irrespective of their content) and can therefore be used interchangeably. The <see cref="M:UIKit.UITableViewSource.GetCell(UIKit.UITableView,Foundation.NSIndexPath)" /> implementation calls <see cref="M:UIKit.UITableView.DequeueReusableCell(Foundation.NSString)" /> with a specific reuse identifier string to obtain a cached cell object with a particular layout to use as the basis for the row being constructed for viewing.</para>
          <para>To produce a layout different to those built-in to <see cref="T:UIKit.UITableViewCell" />, create a custom cell. To set the row height of each cell differently, implement <see cref="M:UIKit.UITableViewSource.GetHeightForRow(UIKit.UITableView,Foundation.NSIndexPath)" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UITableViewCell (UIKit.UITableViewCellStyle style, string reuseIdentifier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype UIKit.UITableViewCellStyle style, string reuseIdentifier) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="style" Type="UIKit.UITableViewCellStyle" />
        <Parameter Name="reuseIdentifier" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="style">The style to use for this cell.</param>
        <param name="reuseIdentifier">A string used to identify the cell object if it should be reused for mutiple rows in a table view. Pass <see langword="null" /> if the object should not be reused. The same reuse identifier string should be used for all cells that use the same class and layout.</param>
        <summary>Create a table cell with the given style and reuse identifier.</summary>
        <remarks>
          <para>The reuse identifier is associated with all cells (rows) in a table view that have the same layout (irrespective of their content) and can therefore be used interchangeably. The <see cref="M:UIKit.UITableViewSource.GetCell(UIKit.UITableView,Foundation.NSIndexPath)" /> implementation calls <see cref="M:UIKit.UITableView.DequeueReusableCell(Foundation.NSString)" /> with a specific reuse identifier string to obtain a cached cell object with a particular layout to use as the basis for the row being constructed for viewing.</para>
          <para>To produce a layout different to those built-in to <see cref="T:UIKit.UITableViewCell" />, create a custom cell. To set the row height of each cell differently, implement <see cref="M:UIKit.UITableViewSource.GetHeightForRow(UIKit.UITableView,Foundation.NSIndexPath)" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Accessory">
      <MemberSignature Language="C#" Value="public virtual UIKit.UITableViewCellAccessory Accessory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype UIKit.UITableViewCellAccessory Accessory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Foundation.Export("accessoryType")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setAccessoryType:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UITableViewCellAccessory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The type of standard accessory the cell should use (in its normal state).</summary>
        <value>Default value is <see cref="F:UIKit.UITableViewCellAccessory.None" />.</value>
        <remarks>
          <para>If specified, the accessory view appears on the right side of a cell. Standard accessory view types include the 'disclosure indicator' right-chevron.</para>
          <para>If the accessory type is <see cref="F:UIKit.UITableViewCellAccessory.DetailDisclosureButton" /> (and the cell is enabled) then when tapped it will call the <see cref="M:UIKit.UITableViewSource.AccessoryButtonTapped(UIKit.UITableView,Foundation.NSIndexPath)" /> method. This method is seperate to the <see cref="M:UIKit.UITableViewSource.RowSelected(UIKit.UITableView,Foundation.NSIndexPath)" /> method that is called if the rest of the cell is tapped.</para>
          <para>If a custom accessory view is set via <see cref="P:UIKit.UITableViewCell.AccessoryView" /> then this Accessory property is ignored.</para>
          <para>The accessory image cross-fades between normal and editing states if it is set for both states; use the <see cref="P:UIKit.UITableViewCell.EditingAccessory" /> property to set the accessory type to be displayed in editing mode. If an accessory is not defined for both states (normal and editing) the the accessory is animated to slide in or out, as required.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessoryView">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIView AccessoryView { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIView AccessoryView" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Foundation.Export("accessoryView")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setAccessoryView:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A view on the right side of a UITableViewCell (normal state).</summary>
        <value>
          <para>
          </para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>
          <para>If this property is not  <see langword="null" /> then the cell uses the given view as the accessory (for the normal state). The value of the <see cref="P:UIKit.UITableViewCell.Accessory" /> is ignored when AccessoryView is set. The custom accessory view can be a control, a label or a custom view.</para>
          <para>The accessory view cross-fades between normal and editing states if it is set for both states; use the <see cref="P:UIKit.UITableViewCell.EditingAccessoryView" /> property to set a custom accessory view to be displayed in editing mode. If an accessory is not defined for both states (normal and editing) the the accessory view is animated to slide in or out, as required.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Appearance">
      <MemberSignature Language="C#" Value="public static UIKit.UITableViewCell.UITableViewCellAppearance Appearance { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class UIKit.UITableViewCell/UITableViewCellAppearance Appearance" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>UIKit.UITableViewCell+UITableViewCellAppearance</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Strongly-typed property that returns the UIAppearance class for this class.</summary>
        <value>
        </value>
        <remarks>
          <para>Setting any appearance properties on this instance will affect the appearance of all instances of UITableViewCell.</para>
          <para>If developers want to control the appearance of subclasses of UITableViewCell, they should use the <see cref="M:UIKit.UITableViewCell.GetAppearance" /> method.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppearanceWhenContainedIn">
      <MemberSignature Language="C#" Value="public static UIKit.UITableViewCell.UITableViewCellAppearance AppearanceWhenContainedIn (Type[] containers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class UIKit.UITableViewCell/UITableViewCellAppearance AppearanceWhenContainedIn(class System.Type[] containers) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>UIKit.UITableViewCell+UITableViewCellAppearance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containers" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="containers">List of types that developers want to have as the containers to apply this particular appearance</param>
        <summary>Returns a strongly typed UIAppearance for instances of this class when the view is hosted in the specified hierarchy.</summary>
        <returns>The appearance proxy object that developers can use to set properties when the given container hierarchy is active</returns>
        <remarks>
          <para>The returned object represents the UIAppearance proxy where developers can set appearance properties for instances of UITableViewCell when those instances are contained in the hierarchy specified by the <paramref name="containers" /> parameter.</para>
          <para>If developers want to control the appearance of subclasses of UITableViewCell, they should use the <see cref="M:UIKit.UITableViewCell.GetAppearance" /> method.</para>
          <para>The following example shows how the AppearanceWhenContainedIn method works</para>
          <example>
            <code lang="C#"><![CDATA[
var mySliders = UISlider.AppearanceWhenContainedIn (typeof (UINavigationBar), typeof (UIPopoverController));
mySliders.TintColor = UIColor.Red;
]]></code>
          </example>
          <para>For more information, see the documentation for the <see cref="T:UIKit.UIAppearance" /> class.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundView">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIView BackgroundView { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIView BackgroundView" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Foundation.Export("backgroundView")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setBackgroundView:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The UIView displayed in the background of this UITableViewCell.</summary>
        <value>
          <para>(More documentation for this node is coming)</para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClassHandle">
      <MemberSignature Language="C#" Value="public override IntPtr ClassHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ClassHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The handle for this class.</summary>
        <value>The pointer to the Objective-C class.</value>
        <remarks>Each Xamarin.iOS class mirrors an unmanaged Objective-C class.   This value contains the pointer to the Objective-C class, it is similar to calling objc_getClass with the object name.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentView">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIView ContentView { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIView ContentView" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Foundation.Export("contentView")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns the content view of the cell object (read-only).</summary>
        <value>
        </value>
        <remarks>This property returns the default superview for content displayed in the cell. To customize cells with additional views, add them to the content view so they will be positioned correctly as the cell transitions in and out of editing mode.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DetailTextLabel">
      <MemberSignature Language="C#" Value="public virtual UIKit.UILabel DetailTextLabel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UILabel DetailTextLabel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Foundation.Export("detailTextLabel")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UILabel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns the secondary label of the table cell (read-only).</summary>
        <value>
        </value>
        <remarks>
          <para>UITableViewCell automatically creates the secondary (detail) label if the cell is created with a <see cref="T:UIKit.UITableViewCellStyle" /> that supports a detail label.</para>
          <para>If the cell's style doesn't support a detail label, this property returns <see langword="null" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DidTransitionToState">
      <MemberSignature Language="C#" Value="public virtual void DidTransitionToState (UIKit.UITableViewCellState mask);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DidTransitionToState(valuetype UIKit.UITableViewCellState mask) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("didTransitionToState:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mask" Type="UIKit.UITableViewCellState" />
      </Parameters>
      <Docs>
        <param name="mask">A bit mask indicating the state (or combination of states) the cell is transitioning to.</param>
        <summary>Called on the cell just after it transitions between cell states.</summary>
        <remarks>
          <para>UITableViewCell subclasses can implement this method to perform additional animations when it is changing state (such as from a normal state to editing move). This method is called at the end of the animation block to clean up after the state change (such as removing the editing and reordering controls when transitioning from editing to normal mode).</para>
          <para>Subclasses must always call <see langword="base" /> when overriding this method.</para>
          <para>Note that when the user swipes to delete, the cell transitions to the <see cref="F:UIKit.UITableViewCellState.ShowingDeleteConfirmationMask" /> - but <see cref="F:UIKit.UITableViewCellState.ShowingEditControlMask" /> is not set. Remember to test for the correct value when handling this case.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragStateDidChange">
      <MemberSignature Language="C#" Value="public virtual void DragStateDidChange (UIKit.UITableViewCellDragState dragState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DragStateDidChange(valuetype UIKit.UITableViewCellDragState dragState) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("dragStateDidChange:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dragState" Type="UIKit.UITableViewCellDragState" />
      </Parameters>
      <Docs>
        <param name="dragState">The drag state that changed.</param>
        <summary>Method that is called when the cell's drag state changes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Editing">
      <MemberSignature Language="C#" Value="public virtual bool Editing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Editing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Foundation.Export("isEditing")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setEditing:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether the cell is in an editable state.</summary>
        <value>
          <see langword="true" /> if the cell is in the editing state, <see langword="false" /> if the cell is in the normal state.</value>
        <remarks>In the editing state, a cell displays the editing controls specified for it: the green insertion control or the red deletion control on the left, and/or the reordering control on the right. Use <see cref="P:UIKit.UITableViewCell.EditingStyle" /> and <see cref="P:UIKit.UITableViewCell.ShowsReorderControl" /> to specify which controls appear in the cell.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EditingAccessory">
      <MemberSignature Language="C#" Value="public virtual UIKit.UITableViewCellAccessory EditingAccessory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype UIKit.UITableViewCellAccessory EditingAccessory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Foundation.Export("editingAccessoryType")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setEditingAccessoryType:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UITableViewCellAccessory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The type of standard accessory the cell should use (in its editing state).</summary>
        <value>Default value is <see cref="F:UIKit.UITableViewCellAccessory.None" />.</value>
        <remarks>
          <para>If specified, the accessory view appears on the right side of a cell. Standard accessory types include the 'disclosure indicator' right-chevron.</para>
          <para>If the accessory type is <see cref="F:UIKit.UITableViewCellAccessory.DetailDisclosureButton" /> (and the cell is enabled) then when tapped it will call the <see cref="M:UIKit.UITableViewSource.AccessoryButtonTapped(UIKit.UITableView,Foundation.NSIndexPath)" /> method. This method is seperate to the <see cref="M:UIKit.UITableViewSource.RowSelected(UIKit.UITableView,Foundation.NSIndexPath)" /> method that is called if the rest of the cell is tapped.</para>
          <para>If a custom accessory view is set for the editing state via <see cref="P:UIKit.UITableViewCell.EditingAccessoryView" /> then this EditingAccessory property is ignored.</para>
          <para>The accessory image cross-fades between normal and editing states if it is set for both states; use the <see cref="P:UIKit.UITableViewCell.Accessory" /> property to set the accessory type to be displayed in the normal state. If an accessory is not defined for both states (normal and editing) the the accessory is animated to slide in or out, as required.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EditingAccessoryView">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIView EditingAccessoryView { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIView EditingAccessoryView" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Foundation.Export("editingAccessoryView")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setEditingAccessoryView:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A view on the right side of a UITableViewCell (editing state).</summary>
        <value>
          <para>
          </para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>
          <para>If this property is not <see langword="null" /> then the cell uses the given view as the accessory (for the editing state). The value of the <see cref="P:UIKit.UITableViewCell.EditingAccessory" /> is ignored when EditingAccessoryView is set. The custom accessory view can be a control, a label or a custom view.</para>
          <para>The accessory view cross-fades between normal and editing states if it is set for both states; use the <see cref="P:UIKit.UITableViewCell.AccessoryView" /> property to set a custom accessory view to be displayed in the normal state. If an accessory is not defined for both states (normal and editing) the the accessory view is animated to slide in or out, as required.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EditingStyle">
      <MemberSignature Language="C#" Value="public virtual UIKit.UITableViewCellEditingStyle EditingStyle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype UIKit.UITableViewCellEditingStyle EditingStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Foundation.Export("editingStyle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UITableViewCellEditingStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The editing style of the cell (read-only). Returns whether the cell is in an editable state, and if so whether it is showing an insertion or deletion control.</summary>
        <value>The default value is <see cref="F:UIKit.UITableViewCellEditingStyle.None" /> (the cell is not currently editable).</value>
        <remarks>
          <para>The <see cref="M:UIKit.UITableViewSource.EditingStyleForRow(UIKit.UITableView,Foundation.NSIndexPath)" /> method returns the value for each cell.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EncodeTo">
      <MemberSignature Language="C#" Value="public virtual void EncodeTo (Foundation.NSCoder encoder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EncodeTo(class Foundation.NSCoder encoder) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("encodeWithCoder:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="encoder" Type="Foundation.NSCoder" />
      </Parameters>
      <Docs>
        <param name="encoder">The encoder object where the state of the object will be stored</param>
        <summary>Encodes the state of the object on the provided encoder</summary>
        <remarks>
          <para>This method is part of the <see cref="T:Foundation.NSCoding" /> protocol and is used by applications to preserve the state of the object into an archive.</para>
          <para>Users will typically create a <see cref="T:Foundation.NSKeyedArchiver" /> and then invoke the <see cref="M:Foundation.NSKeyedArchiver.ArchiveRootObjectToFile" /> which will call into this method</para>
          <para>If developers want to allow their object to be archived, they should override this method and store their state in using the provided <paramref name="encoder" /> parameter.   In addition, developers should also implement a constructor that takes an NSCoder argument and is exported with [Export ("initWithCoder:")]</para>
          <example>
            <code lang="C#"><![CDATA[public void override EncodeTo (NSCoder coder){
    coder.Encode (1, key: "version");
    coder.Encode (userName, key: "userName");
    coder.Encode (hostName, key: "hostName");]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusStyle">
      <MemberSignature Language="C#" Value="public virtual UIKit.UITableViewCellFocusStyle FocusStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype UIKit.UITableViewCellFocusStyle FocusStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("focusStyle")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setFocusStyle:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UITableViewCellFocusStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the focus style.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAppearance">
      <MemberSignature Language="C#" Value="public static UIKit.UITableViewCell.UITableViewCellAppearance GetAppearance (UIKit.UITraitCollection traits);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class UIKit.UITableViewCell/UITableViewCellAppearance GetAppearance(class UIKit.UITraitCollection traits) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>UIKit.UITableViewCell+UITableViewCellAppearance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="traits" Type="UIKit.UITraitCollection" />
      </Parameters>
      <Docs>
        <param name="traits">To be added.</param>
        <summary>Returns an appearance proxy for the specified <paramref name="traits" />.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAppearance">
      <MemberSignature Language="C#" Value="public static UIKit.UITableViewCell.UITableViewCellAppearance GetAppearance (UIKit.UITraitCollection traits, Type[] containers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class UIKit.UITableViewCell/UITableViewCellAppearance GetAppearance(class UIKit.UITraitCollection traits, class System.Type[] containers) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>UIKit.UITableViewCell+UITableViewCellAppearance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="traits" Type="UIKit.UITraitCollection" />
        <Parameter Name="containers" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="traits">To be added.</param>
        <param name="containers">To be added.</param>
        <summary>Returns an appearance proxy for the specified <paramref name="traits" /> when found in the <paramref name="containers" /> containment hierarchy.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAppearance&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static UIKit.UITableViewCell.UITableViewCellAppearance GetAppearance&lt;T&gt; () where T : UIKit.UITableViewCell;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class UIKit.UITableViewCell/UITableViewCellAppearance GetAppearance&lt;(class UIKit.UITableViewCell) T&gt;() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>UIKit.UITableViewCell+UITableViewCellAppearance</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">The type for which the UIAppearance proxy must be returned.  This is a subclass of UITableViewCell.</typeparam>
        <summary>
          <para>Obtains the appearance proxy <see cref="T:UIKit.UITableViewCell.UITableViewCellAppearance" /> for the subclass of UITableViewCell.</para>
        </summary>
        <returns>
          <para>appearance proxy object for the specified type.</para>
        </returns>
        <remarks>
          <para>Setting any appearance properties on the returned object will affect the appearance of all classes and subclasses of the type parameter.</para>
          <para>Unlike the <see cref="P:UIKit.UITableViewCell.Appearance" /> property, or the <see cref="M:UIKit.UITableViewCellAppearanceWhenContainedIn" /> method which only work on instances of this particular class, the proxies returned by GetAppearance can be used to change the style of subclasses.</para>
          <para>The following example shows how the GetAppearance method works</para>
          <example>
            <code lang="C#"><![CDATA[
var myTheme = UITableViewCell.GetAppearance<MyUITableViewCellSubclass> ();
myTheme.TintColor = UIColor.Red;
]]></code>
          </example>
          <para>For more information, see the documentation for the <see cref="T:UIKit.UIAppearance" /> class.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAppearance&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static UIKit.UITableViewCell.UITableViewCellAppearance GetAppearance&lt;T&gt; (UIKit.UITraitCollection traits) where T : UIKit.UITableViewCell;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class UIKit.UITableViewCell/UITableViewCellAppearance GetAppearance&lt;(class UIKit.UITableViewCell) T&gt;(class UIKit.UITraitCollection traits) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>UIKit.UITableViewCell+UITableViewCellAppearance</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="traits" Type="UIKit.UITraitCollection" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type for which the UIAppearance proxy must be returned.  This is a subclass of UITableViewCell.</typeparam>
        <param name="traits">Trait collection to match.</param>
        <summary>
          <para>Obtains the appearance proxy <see cref="T:UIKit.UITableViewCell.UITableViewCellAppearance" /> for the subclass of UITableViewCell.</para>
        </summary>
        <returns>
          <para>appearance proxy object for the specified type.</para>
        </returns>
        <remarks>
          <para>The returned object represents the UIAppearance proxy where developers can set appearance properties for instances of UITableViewCell.</para>
          <para>Unlike the <see cref="P:UIKit.UITableViewCell.Appearance" /> property, or the <see cref="M:UIKit.UITableViewCellAppearanceWhenContainedIn" /> method which only work on instances of this particular class, the proxies returned by GetAppearance can be used to change the style of subclasses.</para>
          <para>The following example shows how the GetAppearance method works</para>
          <example>
            <code lang="C#"><![CDATA[
var myTheme = UITableViewCell.GetAppearance<MyUITableViewCellSubclass> (myTraits, );
myTheme.TintColor = UIColor.Red;
]]></code>
          </example>
          <para>For more information, see the documentation for the <see cref="T:UIKit.UIAppearance" /> class.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAppearance&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static UIKit.UITableViewCell.UITableViewCellAppearance GetAppearance&lt;T&gt; (UIKit.UITraitCollection traits, Type[] containers) where T : UIKit.UITableViewCell;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class UIKit.UITableViewCell/UITableViewCellAppearance GetAppearance&lt;(class UIKit.UITableViewCell) T&gt;(class UIKit.UITraitCollection traits, class System.Type[] containers) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>UIKit.UITableViewCell+UITableViewCellAppearance</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <BaseTypeName>UIKit.UITableViewCell</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="traits" Type="UIKit.UITraitCollection" />
        <Parameter Name="containers" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">The type for which the UIAppearance proxy must be returned.  This is a subclass of UITableViewCell.</typeparam>
        <param name="traits">Trait collection to match.</param>
        <param name="containers">List of types that the developer wishes to have as the containers to apply this particular appearance.</param>
        <summary>
          <para>Obtains the appearance proxy <see cref="T:UIKit.UITableViewCell.UITableViewCellAppearance" /> for the subclass of UITableViewCell that has the specified trait collection when the view is hosted in the specified hierarchy.</para>
        </summary>
        <returns>
          <para>appearance proxy object for the specified type.</para>
        </returns>
        <remarks>
          <para>The returned object represents the UIAppearance proxy where developers can set appearance properties for instances of UITableViewCell that has the specified trait collection when the view is hosted in the specified hierarchy when those instances are contained in the hierarchy specified by the <paramref name="containers" /> parameter.</para>
          <para>Unlike the <see cref="P:UIKit.UITableViewCell.Appearance" /> property, or the <see cref="M:UIKit.UITableViewCellAppearanceWhenContainedIn" /> method which only work on instances of this particular class, the proxies returned by GetAppearance can be used to change the style of subclasses.</para>
          <para>The following example shows how the GetAppearance method works</para>
          <example>
            <code lang="C#"><![CDATA[
var myTheme = UITableViewCell.GetAppearance<MyUITableViewCellSubclass> (myTraits, typeof (UINavigationBar), typeof (UIPopoverController));
myTheme.TintColor = UIColor.Red;
]]></code>
          </example>
          <para>For more information, see the documentation for the <see cref="T:UIKit.UIAppearance" /> class.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Highlighted">
      <MemberSignature Language="C#" Value="public virtual bool Highlighted { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Highlighted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Foundation.Export("isHighlighted")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setHighlighted:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether the cell is highlighted.</summary>
        <value>Default value is <see langword="false" />.</value>
        <remarks>
          <para>Highlighting affects the appearance of labels, the image and background. When Highlighted is <see langword="true" />, the labels in the cell are drawn in their highlighted text color (which is white by default).</para>
          <para>When this property is set to <see langword="true" />, the transition to the new appearance is not animated. Use the <see cref="M:UIKit.UITableViewCell.SetHighlighted(System.Boolean,System.Boolean)" /> method for animated highlight-state transitions.</para>
          <para>For highlighting to work properly, set the <see cref="P:UIKit.UILabel.HighlightedTextColor" /> for the two labels (<see cref="P:UIKit.UITableViewCell.TextLabel" /> and <see cref="P:UIKit.UITableViewCell.DetailTextLabel" />), and set the <see cref="P:UIKit.UImageView.HighlightedImage" /> property on the cell's <see cref="P:UIKit.UITableViewCell.ImageView" />. </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ImageView">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIImageView ImageView { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIImageView ImageView" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Foundation.Export("imageView")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIImageView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns the image view of the table cell (read-only).</summary>
        <value>
        </value>
        <remarks>The image appears on the left hand side of the cell, forcing the labels to move to the right. The image view object is created when the cell is created but initially there is no image set.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndentationLevel">
      <MemberSignature Language="C#" Value="public virtual nint IndentationLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.nint IndentationLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Foundation.Export("indentationLevel")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setIndentationLevel:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.nint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sets the indentation level of a cell, shifting the position of the cell's content.</summary>
        <value>Default value is zero (no indentation).</value>
        <remarks>The width of each level of indentation is determined by <see cref="P:UIKit.UITableViewCell.IndentationWidth" /> property.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndentationWidth">
      <MemberSignature Language="C#" Value="public virtual nfloat IndentationWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.nfloat IndentationWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Foundation.Export("indentationWidth")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setIndentationWidth:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.nfloat</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The width of each the indentation level.</summary>
        <value>Default indentation is 10 points.</value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MultipleSelectionBackgroundView">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIView MultipleSelectionBackgroundView { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIView MultipleSelectionBackgroundView" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 5, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("multipleSelectionBackgroundView")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 5, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setMultipleSelectionBackgroundView:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 5, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The background view used when a cell is selected inside a table view that allows multiple selection.</summary>
        <value>
          <para>
          </para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>If this property is not <see langword="null" />, it is used as the background view for any selected cells (when the containing table view allows mutiple selection). Mulitple selection is set on a <see cref="T:UIKit.UITableView" /> using the <see cref="P:UIKit.UITableView.AllowsMultipleSelection" /> and <see cref="P:UIKit.UITableView.AllowsMultipleSelectionDuringEditing" /> properties.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PrepareForReuse">
      <MemberSignature Language="C#" Value="public virtual void PrepareForReuse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PrepareForReuse() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("prepareForReuse")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Prepares a cell for reuse by the table view's <see cref="T:UIKit.UITableViewSource" />.</summary>
        <remarks>
          <para>If a <see cref="T:UIKit.UITableView" /> is reusable - it has a ReuseIdentifier - this method is called just before the object is returned by <see cref="M:UIKit.UITableView.DequeueReusableCell(System.String)" />. This method implementation should reset cell attributes that are not content-related, such as alpha, editing, and selection state. The <see cref="M:UIKit.UITableViewSource.GetCell(UIKit.UITableView,Foundation.NSIndexPath)" /> should always reset the content when reusing a cell.</para>
          <para>Subclasses must always call <see langword="base" /> when overriding this method.</para>
          <para>If the cell object does not have a <see cref="P:UIKit.UITableViewCell.ReuseIdentifier" />, this method is not called.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReuseIdentifier">
      <MemberSignature Language="C#" Value="public virtual Foundation.NSString ReuseIdentifier { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Foundation.NSString ReuseIdentifier" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Foundation.Export("reuseIdentifier")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A string that identifies a cell object so that it can be reused.</summary>
        <value>
        </value>
        <remarks>
          <para>The ReuseIdentifier is set in the cell's constructor and cannot be changed. When cells disappear from view, the <see cref="T:UIKit.UITableView" /> object maintains a queue of those cell objects so they can be reused. The <see cref="M:UIKit.UITableViewSource.GetCell(UIKit.UITableView,Foundation.NSIndexPath)" /> implementation then uses <see cref="M:UIKit.UITableView.DequeueReusableCell(System.String)" /> with a given ReuseIdentifier to retrieve an existing cell of the correct type for reuse.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Selected">
      <MemberSignature Language="C#" Value="public virtual bool Selected { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Selected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Foundation.Export("isSelected")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setSelected:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether the cell is selected.</summary>
        <value>Default value is <see langword="false" />.</value>
        <remarks>
          <para>Selection affects the appearance of labels, image and background. When the Selected property is set to <see langword="true" />, the labels are drawn in white and the background is set to the <see cref="P:UIKit.UITableViewCell.SelectedBackgroundView" /> (if set).</para>
          <para>When this property is set to <see langword="true" />, the transition to the new appearance is not animated. Use the <see cref="M:UIKit.UITableViewCell.SetSelected(System.Boolean,System.Boolean)" /> method for animated selection-state transitions.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectedBackgroundView">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIView SelectedBackgroundView { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIView SelectedBackgroundView" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Foundation.Export("selectedBackgroundView")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setSelectedBackgroundView:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The view that is used as the cell's background when it is selected.</summary>
        <value>
          <para>Default is <see langword="null" /> for Plain tables and non-<see langword="null" /> for Grouped style tables.</para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>
          <para>
            <see cref="T:UIKit.UITableView" /> adds the value of this proerty as a subview only when the cell is selected. It is added as a subview directly above the <see cref="P:UIKit.UITableView.BackgroundView" /> if that is not <see langword="null" />, otherwise behind all other views.</para>
          <para>If <see cref="P:UIKit.UITableViewCell.SetSelected(System.Boolean,System.Boolean)" /> is called, this view is animated in and out with an alpha fade.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionStyle">
      <MemberSignature Language="C#" Value="public virtual UIKit.UITableViewCellSelectionStyle SelectionStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype UIKit.UITableViewCellSelectionStyle SelectionStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Foundation.Export("selectionStyle")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setSelectionStyle:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UITableViewCellSelectionStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The selection style for a cell.</summary>
        <value>Default value is <see cref="F:UIKit.UITableViewCellSelectionStyle.Blue" />.</value>
        <remarks>The selection style determines the color of a cell when it is selected.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SeparatorInset">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIEdgeInsets SeparatorInset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype UIKit.UIEdgeInsets SeparatorInset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("separatorInset")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setSeparatorInset:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIEdgeInsets</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>How the separator between cells should be inset.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetEditing">
      <MemberSignature Language="C#" Value="public virtual void SetEditing (bool editing, bool animated);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetEditing(bool editing, bool animated) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("setEditing:animated:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="editing" Type="System.Boolean" />
        <Parameter Name="animated" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="editing">
          <see langword="true" /> to enter editing mode, <see langword="false" /> to leave it.</param>
        <param name="animated">
          <see langword="true" /> to animate the appearance/disappearance of the editing controls, <see langword="false" /> to immediately show/hide the controls.</param>
        <summary>Toggles the cell in and out of editing mode.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetHighlighted">
      <MemberSignature Language="C#" Value="public virtual void SetHighlighted (bool highlighted, bool animated);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetHighlighted(bool highlighted, bool animated) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("setHighlighted:animated:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="highlighted" Type="System.Boolean" />
        <Parameter Name="animated" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="highlighted">
          <see langword="true" /> to highlight the cell, <see langword="false" /> to unhighlight.</param>
        <param name="animated">
          <see langword="true" /> to animate the highlight transition, <see langword="false" /> to make the transition immediate.</param>
        <summary>Sets the highlighted state of the cell, optionally animating the transition between states.</summary>
        <remarks>
          <para>Highlights or unhighlights the cell, animating the transition if <paramref name="animated" /> is <see langword="true" />. Highlighting changes the appearance of the cell's labels, image, and background.</para>
          <para>For highlighting to work properly, set the <see cref="P:UIKit.UILabel.HighlightedTextColor" /> for the two labels (<see cref="P:UIKit.UITableViewCell.TextLabel" /> and <see cref="P:UIKit.UITableViewCell.DetailTextLabel" />), and set the <see cref="P:UIKit.UImageView.HighlightedImage" /> property on the cell's <see cref="P:UIKit.UITableViewCell.ImageView" />. </para>
          <para>Custom cells can override this method to make additional changes when transitioning between states.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSelected">
      <MemberSignature Language="C#" Value="public virtual void SetSelected (bool selected, bool animated);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetSelected(bool selected, bool animated) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("setSelected:animated:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="selected" Type="System.Boolean" />
        <Parameter Name="animated" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="selected">
          <see langword="true" /> to select the cell, <see langword="false" /> to deselect.</param>
        <param name="animated">
          <see langword="true" /> to animate the selected transition, <see langword="false" /> to make the transition immediate.</param>
        <summary>Sets the selected state of the cell, optionally animating the transition between the states.</summary>
        <remarks>Selection changes the the appearance of the cell's labels, image, and background.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldBegin">
      <MemberSignature Language="C#" Value="public virtual bool ShouldBegin (UIKit.UIGestureRecognizer recognizer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ShouldBegin(class UIKit.UIGestureRecognizer recognizer) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("gestureRecognizerShouldBegin:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 3, 2, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="recognizer" Type="UIKit.UIGestureRecognizer" />
      </Parameters>
      <Docs>
        <param name="recognizer">To be added.</param>
        <summary>Whether the gesture recognition should begin.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldBeRequiredToFailBy">
      <MemberSignature Language="C#" Value="public virtual bool ShouldBeRequiredToFailBy (UIKit.UIGestureRecognizer gestureRecognizer, UIKit.UIGestureRecognizer otherGestureRecognizer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ShouldBeRequiredToFailBy(class UIKit.UIGestureRecognizer gestureRecognizer, class UIKit.UIGestureRecognizer otherGestureRecognizer) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("gestureRecognizer:shouldBeRequiredToFailByGestureRecognizer:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 3, 2, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="gestureRecognizer" Type="UIKit.UIGestureRecognizer" />
        <Parameter Name="otherGestureRecognizer" Type="UIKit.UIGestureRecognizer" />
      </Parameters>
      <Docs>
        <param name="gestureRecognizer">To be added.</param>
        <param name="otherGestureRecognizer">To be added.</param>
        <summary>Whether there is a dynamic failure requirement between the specified gesture recognizers.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldIndentWhileEditing">
      <MemberSignature Language="C#" Value="public virtual bool ShouldIndentWhileEditing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShouldIndentWhileEditing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Foundation.Export("shouldIndentWhileEditing")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setShouldIndentWhileEditing:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether the cell background is indented while in editing mode.</summary>
        <value>Default value is <see langword="true" />.</value>
        <remarks>
          <para>This property is not related to <see cref="P:UIKit.UITableViewCell.IndentationLevel" />.</para>
          <para>This value can be overridden in <see cref="M:UIKit.UITableViewSource.ShouldIndentWhileEditing(UIKit.UITableView,Foundation.NSIndexPath)" />.</para>
          <para>Only Grouped style table views are affected by this property, Plain table views ignore it.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldReceivePress">
      <MemberSignature Language="C#" Value="public virtual bool ShouldReceivePress (UIKit.UIGestureRecognizer gestureRecognizer, UIKit.UIPress press);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ShouldReceivePress(class UIKit.UIGestureRecognizer gestureRecognizer, class UIKit.UIPress press) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("gestureRecognizer:shouldReceivePress:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 3, 2, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="gestureRecognizer" Type="UIKit.UIGestureRecognizer" />
        <Parameter Name="press" Type="UIKit.UIPress" />
      </Parameters>
      <Docs>
        <param name="gestureRecognizer">To be added.</param>
        <param name="press">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldReceiveTouch">
      <MemberSignature Language="C#" Value="public virtual bool ShouldReceiveTouch (UIKit.UIGestureRecognizer recognizer, UIKit.UITouch touch);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ShouldReceiveTouch(class UIKit.UIGestureRecognizer recognizer, class UIKit.UITouch touch) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("gestureRecognizer:shouldReceiveTouch:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 3, 2, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="recognizer" Type="UIKit.UIGestureRecognizer" />
        <Parameter Name="touch" Type="UIKit.UITouch" />
      </Parameters>
      <Docs>
        <param name="recognizer">To be added.</param>
        <param name="touch">To be added.</param>
        <summary>Whether the recognizer should receive the specified touch.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldRecognizeSimultaneously">
      <MemberSignature Language="C#" Value="public virtual bool ShouldRecognizeSimultaneously (UIKit.UIGestureRecognizer gestureRecognizer, UIKit.UIGestureRecognizer otherGestureRecognizer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ShouldRecognizeSimultaneously(class UIKit.UIGestureRecognizer gestureRecognizer, class UIKit.UIGestureRecognizer otherGestureRecognizer) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("gestureRecognizer:shouldRecognizeSimultaneouslyWithGestureRecognizer:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 3, 2, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="gestureRecognizer" Type="UIKit.UIGestureRecognizer" />
        <Parameter Name="otherGestureRecognizer" Type="UIKit.UIGestureRecognizer" />
      </Parameters>
      <Docs>
        <param name="gestureRecognizer">To be added.</param>
        <param name="otherGestureRecognizer">To be added.</param>
        <summary>Whether the two gesture recognizers should be allowed to recognize gestures simultaneously.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldRequireFailureOf">
      <MemberSignature Language="C#" Value="public virtual bool ShouldRequireFailureOf (UIKit.UIGestureRecognizer gestureRecognizer, UIKit.UIGestureRecognizer otherGestureRecognizer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ShouldRequireFailureOf(class UIKit.UIGestureRecognizer gestureRecognizer, class UIKit.UIGestureRecognizer otherGestureRecognizer) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("gestureRecognizer:shouldRequireFailureOfGestureRecognizer:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 3, 2, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="gestureRecognizer" Type="UIKit.UIGestureRecognizer" />
        <Parameter Name="otherGestureRecognizer" Type="UIKit.UIGestureRecognizer" />
      </Parameters>
      <Docs>
        <param name="gestureRecognizer">To be added.</param>
        <param name="otherGestureRecognizer">To be added.</param>
        <summary>Whether the specified gestureRecognizer should be required to fail by the otherGestureRecognizer.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowingDeleteConfirmation">
      <MemberSignature Language="C#" Value="public virtual bool ShowingDeleteConfirmation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowingDeleteConfirmation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Foundation.Export("showingDeleteConfirmation")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.NotImplemented</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether the delete confirmation button is currently showing in the cell (read-only).</summary>
        <value>Default value is <see langword="false" />.</value>
        <remarks>
          <para>When the deletion control (red cirle to the left of the cell) is showing and is tapped, the cell displays a Delete button on the right side of the cell (which is when this method returns <see langword="true" />).</para>
          <para>The text displayed in the Delete button is localized.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowsReorderControl">
      <MemberSignature Language="C#" Value="public virtual bool ShowsReorderControl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowsReorderControl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Foundation.Export("showsReorderControl")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setShowsReorderControl:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether the reordering control is currently showing in the cell (read-only).</summary>
        <value>Default value is <see langword="false" />.</value>
        <remarks>
          <para>The reordering control consists of three grey, horizontal lines on the right side of the cell. Dragging this control causes the entire cell to be moved to another position in the table.</para>
          <para>The reordering control only appears if this property is set and the <see cref="M:UIKit.UITableViewSource.MoveRow(UIKit.UITableView,Foundation.NSIndexPath,Foundation.NSIndexPath)" /> method has been implemented on the <see cref="T:UIKit.UITableViewSource" />. The reordering control can be selectively hidden on specific rows by returning <see langword="false" /> from <see cref="M:UIKit.UITableViewSource.CanMoveRow(UIKit.UITableView,Foundation.NSIndexPath)" /></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextLabel">
      <MemberSignature Language="C#" Value="public virtual UIKit.UILabel TextLabel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UILabel TextLabel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Foundation.Export("textLabel")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UILabel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns the label that displays the main text content in the cell (read-only).</summary>
        <value>
        </value>
        <remarks>
          <see cref="T:UIKit.UITableViewCell" /> creates the label control when the cell is constructed in with a style that supports it.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UserInteractionEnabledWhileDragging">
      <MemberSignature Language="C#" Value="public virtual bool UserInteractionEnabledWhileDragging { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UserInteractionEnabledWhileDragging" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("userInteractionEnabledWhileDragging")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setUserInteractionEnabledWhileDragging:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a Boolean value that controls whether the user can interact with the cell while it is being dragged.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WillTransitionToState">
      <MemberSignature Language="C#" Value="public virtual void WillTransitionToState (UIKit.UITableViewCellState mask);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WillTransitionToState(valuetype UIKit.UITableViewCellState mask) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("willTransitionToState:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mask" Type="UIKit.UITableViewCellState" />
      </Parameters>
      <Docs>
        <param name="mask">A bit mask indicating the state/s the cell is transitioning to.</param>
        <summary>Called on the cell just before it transitions between states.</summary>
        <remarks>
          <para>UITableViewCell subclasses can implement this method to perform additional animations when it is changing state (such as from a normal state to editing move). A custom cell may create any new views that are required in the new state. <see cref="M:UIKit.UIView.LayoutSubviews()" /> is then called which allows the code to position these new elements in their correct locations for the new state.</para>
          <para>Subclasses must always call <see langword="base" /> when overriding this method.</para>
          <para>Note that when the user swipes to delete, the cell transitions to the <see cref="F:UIKit.UITableViewCellState.ShowingDeleteConfirmationMask" /> - but <see cref="F:UIKit.UITableViewCellState.ShowingEditControlMask" /> is not set. Remember to test for the correct value when handling this case.</para>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
