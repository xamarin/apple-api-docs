<Type Name="UITableView" FullName="UIKit.UITableView">
  <TypeSignature Language="C#" Value="public class UITableView : UIKit.UIScrollView, IDisposable, UIKit.IUIDataSourceTranslating, UIKit.IUISpringLoadedInteractionSupporting" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit UITableView extends UIKit.UIScrollView implements class Foundation.INSCoding, class ObjCRuntime.INativeObject, class System.IDisposable, class UIKit.IUIDataSourceTranslating, class UIKit.IUISpringLoadedInteractionSupporting" />
  <TypeSignature Language="DocId" Value="T:UIKit.UITableView" />
  <TypeSignature Language="F#" Value="type UITableView = class&#xA;    inherit UIScrollView&#xA;    interface INSCoding&#xA;    interface INativeObject&#xA;    interface IDisposable&#xA;    interface IUIDataSourceTranslating&#xA;    interface IUISpringLoadedInteractionSupporting" />
  <AssemblyInfo>
    <AssemblyName>Xamarin.iOS</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>UIKit.UIScrollView</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>Foundation.INSCoding</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>ObjCRuntime.INativeObject</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>UIKit.IUIDataSourceTranslating</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>UIKit.IUISpringLoadedInteractionSupporting</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>Foundation.Register("UITableView", true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>A table view is used to display and edit hierarchical lists of information. A UITableView is limited to a single column because it is designed for a small screen.</summary>
    <remarks>
      <para>
        <see cref="T:UIKit.UITableView" /> is a subclass of <see cref="T:UIKit.UIScrollView" /> that allows users to scroll the table vertically (the closely-related <see cref="T:UIKit.UICollectionView" /> class allows for horizontal scrolling and complex two-dimensional layouts). The table consists of <see cref="T:UIKit.UITableViewCell" /> objects that are used to render the rows of the table. These cells have content -- labels, images, etc. -- and can also show accessories such as disclosure arrows or inputs controls. <see cref="T:UIKit.UITableView" />s can enter an edit-mode in which rows can be inserted, deleted, and reordered.
      </para>
      <para>
        The Xamarin article </para>
      <format type="text/html">
        <a href="https://docs.xamarin.com/guides/ios/user_interface/tables">Working with Tables</a>
      </format> provides guidance on all aspects of <see cref="T:UIKit.UITableView" /> use. 
      <para></para><para>For most use-cases, it is not necessary for application developers to subclass <see cref="T:UIKit.UITableView" /> or <see cref="T:UIKit.UITableViewController" />, which provide the generic table behavior. Instead, application developers will generally subclass <see cref="T:UIKit.UITableViewSource" /> to populate a table and, often, <see cref="T:UIKit.UITableViewCell" /> to customize appearance and row behavior.</para><format type="text/html"><h2>Table Parts and Functionality</h2></format><format type="text/html"><h3>Classes Overview</h3></format><para>The primary classes used to display table views are:</para><para><img href="~/UIKit/_images/UIKit.UITableView.Classes.png" /></para><list type="table"><listheader><term>Class</term><description>Responsibility</description></listheader><item><term><see cref="T:UIKit.UITableView" /></term><description>
            A view that contains a collection of cells inside a scrolling container. The table view typically uses the entire screen in an iPhone app but may exist as part of a larger view on the iPad (or appear in a popover).  
          </description></item><item><term><see cref="T:UIKit.UITableViewCell" /></term><description>
            A view that represents a single cell (or row) in a table view. There are four built-in cell types and it is possible to create custom cells both in C# or with Interface Builder.
          </description></item><item><term><see cref="T:UIKit.UITableViewSource" /></term><description>
            Xamarin.iOS-exclusive abstract class that provides all the methods required to display a table, including row count, returning a cell view for each row, handling row selection and many other optional features. You must subclass this to get a <see cref="T:UIKit.UITableView" /> working. (<see cref="T:UIKit.UITableViewSource" /> combines <see cref="T:UIKit.UITableViewDataSource" /> and <see cref="T:UIKit.UITableViewDelegate" />. These classes are still available if the application developer chooses not to use <see cref="T:UIKit.UITableViewSource" />.)
          </description></item><item><term><see cref="T:Foundation.NSIndexPath" /></term><description>
            Contains Row and Section properties that uniquely identify the position of a cell in a table.</description></item><item><term><see cref="T:UIKit.UITableViewController" /></term><description>
            A ready-to-use <see cref="T:UIKit.UIViewController" /> that has a <see cref="T:UIKit.UITableView" /> hardcoded as its view and made accessible via the <see cref="P:UIKit.UITableViewController.TableView" /> property. </description></item><item><term><see cref="T:UIKit.UIViewController" /></term><description>
            If the table does not occupy the entire screen you can add a <see cref="T:UIKit.UITableView" /> to any <see cref="T:UIKit.UIViewController" /> with its <see cref="P:UIKit.UIView.Frame" /> property set appropriately.</description></item></list><format type="text/html"><h3>Components of a UITableView</h3></format><para>There are two <see cref="T:UIKit.UITableViewStyle" /> styles: Plain and Grouped. The Plain style allows the section headers and footers to remain visible as the section is scrolled through, and can optionally support an index that appears along the right edge to quickly scroll to a specific section. The Grouped style displays sections in rounded-rectangles that visually group the rows, and provides a default background image behind the scrolling list. The style of the <see cref="T:UIKit.UITableView" /> is specified as an argument to the <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=C:UIKit.UITableView(System.Drawing.RectangleF, UITableViewStyle)&amp;scope=Xamarin" title="C:UIKit.UITableView(System.Drawing.RectangleF, UITableViewStyle)">C:UIKit.UITableView(System.Drawing.RectangleF, UITableViewStyle)</a></format> constructor and cannot be changed.  Grouped tables should not provide an index.</para><para>Tables consist of the following parts:</para><list type="table"><listheader><term>Element</term><description>Accessed via:</description><description>Type</description></listheader><item><term>Table Header</term><description><see cref="P:UIKit.UITableView.TableHeaderView" /></description><description><see cref="T:UIKit.UIView" /></description></item><item><term>Section Header</term><description><see cref="M:UIKit.UITableViewSource.GetViewForHeader(UIKit.UITableView,System.nint)" /></description><description><see cref="T:UIKit.UITableViewHeaderFooterView" /></description></item><item><term>Cells (also called Rows)</term><description><see cref="M:UIKit.UITableViewSource.GetCell(UIKit.UITableView,Foundation.NSIndexPath)" /></description><description><see cref="T:UIKit.UITableViewCell" /></description></item><item><term>Section Footer</term><description><see cref="M:UIKit.UITableViewSource.GetViewForFooter(UIKit.UITableView,System.nint)" /></description><description><see cref="T:UIKit.UITableViewHeaderFooterView" /></description></item><item><term>Index</term><description><see cref="M:UIKit.UITableViewSource.SectionIndexTitles(UIKit.UITableView)" /></description><description><see langword="string" /><c>[]</c></description></item><item><term>Edit mode (includes ‘swipe to delete’ and drag handles to change row order)</term><description /><description /></item><item><term>Table Footer</term><description><see cref="P:UIKit.UITableView.TableFooterView" /></description><description><see cref="T:UIKit.UIView" /></description></item></list><para>Section rows, headers, footers, edit controls and the index are displayed as follows:</para><para><img href="~/UIKit/_images/UIKit.UITableView.Components.png" /></para><format type="text/html"><h2>Populating Table Cells</h2></format><para><see cref="T:UIKit.UITableView" />s are designed to work efficiently with tables with thousands of rows. In order to achieve this, each <see cref="T:UIKit.UITableView" /> maintains a reusable cache of <see cref="T:UIKit.UITableViewCell" />s only a few items larger than can be shown on the screen at any given time.
      </para><para>A <see cref="T:UIKit.UITableViewSource" /> object is responsible for managing the relationship between the relatively few <see cref="T:UIKit.UITableViewCell" />s and the data is to be displayed. The <see cref="T:UIKit.UITableViewSource" />'s <see cref="M:UIKit.UITableViewSource.NumberOfSections(UIKit.UITableView)" /> and <see cref="M:UIKit.UITableViewSource.RowsInSection(UIKit.UITableView,System.nint)" /> methods allow the <see cref="T:UIKit.UITableView" /> to request only the data necessary for the cells on the screen. A specific cell is identified by an <see cref="T:Foundation.NSIndexPath" />, whose <see cref="P:Foundation.NSIndexPath.Section" /> and <see cref="P:Foundation.NSIndexPath.Row" />properties will specify a unique cell.</para><para>As cells are about to be scrolled onto the screen, the <see cref="T:UIKit.UITableView" /> automatically calls the <see cref="M:UIKit.UITableViewSource.GetCell(UIKit.UITableView,Foundation.NSIndexPath)" /> method of the <see cref="T:UIKit.UITableViewSource" /> object assigned to the <see cref="P:UIKit.UITableView.Source" /> property of the <see cref="T:UIKit.UITableView" /> (or, if the application developer prefers, the <see cref="M:UIKit.UITableViewDataSource.GetCell(UIKit.UITableView,Foundation.NSIndexPath)" /> method of the <see cref="T:UIKit.UITableViewDataSource" /> object referred to by the <see cref="P:UIKit.UITableView.DataSource" /> property). </para><para>The application developer's responsibilities when overriding <see cref="M:UIKit.UITableViewSource.GetCell(UIKit.UITableView,Foundation.NSIndexPath)" /> changed with the introduction of iOS 6. Application developers targeting iOS 6 and later should register a <see cref="T:UIKit.UITableViewCell" /> for reuse with the <see cref="T:UIKit.UITableView" /> by calling either the <see cref="M:UIKit.UITableView.RegisterClassForCellReuse(System.Type,System.String)" /> or <see cref="M:UIKit.UITableView.RegisterNibForCellReuse(UIKit.UINib,System.String)" /> method. Once that is done, application developers do not need to check for null in their override of the <see cref="M:UIKit.UITableViewSource.GetCell(UIKit.UITableView,Foundation.NSIndexPath)" /> method.</para><para>If application developers are using the <see cref="M:UIKit.UITableView.RegisterClassForCellReuse(System.Type,System.String)" /> with their own subclass of <see cref="T:UIKit.UITableViewCell" />, that implementation must override the <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=C:UIKit.UITableViewCell(IntPtr)&amp;scope=Xamarin" title="C:UIKit.UITableViewCell(IntPtr)">C:UIKit.UITableViewCell(IntPtr)</a></format> constructor and call the base constructor (i.e., <c>MyTableViewCell(IntPtr handle) : base(handle){}</c>).</para><para>The application developer overrides the <see cref="M:UIKit.UITableViewSource.GetCell(UIKit.UITableView,Foundation.NSIndexPath)" /> method so that it:</para><list type="bullet"><item><term>Attempts to retrieve a previously-allocated <see cref="T:UIKit.UITableViewCell" /> from the <see cref="T:UIKit.UITableView" />;</term></item><item><term>If programming in iOS 5 and earlier, if that fails, initializes a new <see cref="T:UIKit.UITableViewCell" /> of the appropriate type;</term></item><item><term>Change the state of the retrieved-or-created <see cref="T:UIKit.UITableViewCell" /> so that it reflects the values appropriate for the passed-in <see cref="T:Foundation.NSIndexPath" />.
          </term></item></list><para>Since the <see cref="M:UIKit.UITableViewSource.GetCell(UIKit.UITableView,Foundation.NSIndexPath)" /> method will be called whenever a cell comes into view, application developers should avoid unnecessary computation.</para><para>The <see cref="T:UIKit.UITableView" />'s reuse queue is accessed via the <see cref="M:UIKit.UITableView.DequeueReusableCell(System.String,Foundation.NSIndexPath)" /> method, which takes a <see langword="string" /> identifying the type of <see cref="T:UIKit.UITableViewCell" /> to retrieve. In iOS 5 and earlier, that method may return <see langword="null" />, in which case the application developer should instantiate a new <see cref="T:UIKit.UITableViewCell" />. In iOS 6 and later, while initializing the <see cref="T:UIKit.UITableView" />, the application developer must use either <see cref="M:UIKit.UITableView.RegisterClassForCellReuse(System.Type,System.String)" /> or <see cref="M:UIKit.UITableView.RegisterNibForCellReuse(UIKit.UINib,System.String)" /> to associate a <see cref="T:UIKit.UITableViewCell" /> type and it's reuse identifier so that the method <see cref="M:UIKit.UITableViewSource.GetCell(UIKit.UITableView,Foundation.NSIndexPath)" /> can instantiate instances as necessary.</para><para>The following shows a simple example of the <see cref="M:UIKit.UITableViewSource.GetCell(UIKit.UITableView,Foundation.NSIndexPath)" /> method:</para><example><code lang="C#"><![CDATA[
          public override UITableViewCell GetCell (UITableView tableView, NSIndexPath indexPath)
          {
          //Attempt to retrieve previously-allocated cell
          var cell = tableView.DequeueReusableCell (this.cellTypeIdentifier);
          //The following check and code-block only necessary in applications that do not use RegisterClassforCellReuse or RegisterNibForCellReuse
          if (cell == null) {
          //No reusable cell, so initialize a new one
          cell = new UITableViewCell (UITableViewCellStyle.Default, this.cellTypeIdentifier);
          cell.Tag = Environment.TickCount;
          }
          
          // Change the state of the cell
          cell.TextLabel.Text = //...etc...
          
          // return the cell
          return cell;
          }
          ]]></code></example><format type="text/html"><h2>Customizing Table Appearance</h2></format><para>Other than the <see cref="P:UIKit.UITableView.Style" /> property that specifies whether a <see cref="T:UIKit.UITableView" /> is grouped or continuous, the appearance of the table is primarily determined by the <see cref="T:UIKit.UITableViewCell" />s, the <see cref="T:UIKit.UITableViewHeaderFooterView" />s used for section headers and footers, and the <see cref="T:UIKit.UIView" />s used for the <see cref="P:UIKit.UITableView.TableHeaderView" /> and <see cref="P:UIKit.UITableView.TableFooterView" /> properties. The API documentation for <see cref="T:UIKit.UITableViewCell" /> describes customization in detail. </para><format type="text/html"><h2>Highlighting and Selection</h2></format><para>Selecting and highlighting in a <see cref="T:UIKit.UITableView" /> follows this sequence:</para><list type="table"><listheader><term>User Action</term><description>UITableViewDelegate (UITableViewSource) Methods</description><description>UITableViewCell Properties</description></listheader><item><term>Nothing touched</term><description /><description><c>Highlighted == <see langword="false" />; Selected == <see langword="false" /></c></description></item><item><term>Finger down in cell</term><description><see cref="M:UIKit.UITableViewDelegate.ShouldHighlightRow(UIKit.UITableView,Foundation.NSIndexPath)" /> is called. If it returns <see langword="false" />, processing stops. 
          </description><description /></item><item><term /><description><see cref="M:UIKit.UITableViewSource.RowHighlighted(UIKit.UITableView,Foundation.NSIndexPath)" /> is called.
          </description><description><c>Highlighted == <see langword="true" />; Selected == <see langword="false" /></c></description></item><item><term>Finger up</term><description><see cref="M:UIKit.UITableViewDelegate.WillSelectRow(UIKit.UITableView,Foundation.NSIndexPath)" /> is called. If it returns <see langword="null" />, processing stops. Otherwise, whatever <see cref="T:Foundation.NSIndexPath" /> it returns will be highlighted.
          </description><description /></item><item><term /><description><see cref="M:UIKit.UITableViewDelegate.RowSelected(UIKit.UITableView,Foundation.NSIndexPath)" /> is called. <see cref="M:UIKit.UITableViewDelegate.RowUnhighlighted(UIKit.UITableView,Foundation.NSIndexPath)" /> is called.
            
          </description><description><c>Highlighted == <see langword="false" />; Selected == <see langword="true" /></c></description></item></list><para><img href="~/UIKit/_images/UIKit.UITableView.HighlightAndSelect.png" /></para><para>Deselecting a <see cref="T:UIKit.UITableViewCell" /> follows a similar sequence:</para><list type="table"><listheader><term>User Action</term><description>UITableViewDelegate (UITableViewSource) Methods</description><description>UITableViewCell Properties</description></listheader><item><term>Nothing touched while some <see cref="T:UIKit.UITableViewCell" /> is highlighted.</term><description /><description><c>Highlighted == <see langword="false" />; Selected == <see langword="true" /></c></description></item><item><term>Finger taps cell (Deselect gesture)</term><description><see cref="M:UIKit.UITableViewDelegate.WillDeselectRow(UIKit.UITableView,Foundation.NSIndexPath)" /> is called. If it returns <see langword="null" />, processing stops. Otherwise, whatever <see cref="T:Foundation.NSIndexPath" /> is returned will be deselected. 
          </description><description /></item><item><term /><description><see cref="M:UIKit.UITableViewDelegate.RowDeselected(UIKit.UITableView,Foundation.NSIndexPath)" /> is called.
          </description><description><c>Highlighted == <see langword="false" />; Selected == <see langword="false" /></c></description></item></list><block subset="none" type="note"><para>UITableView caches <see cref="T:UIKit.UITableViewCell" /> objects only for visible rows, but caches the heights of rows, headers and footers for the entire table. It is possible to create custom <see cref="T:UIKit.UITableViewCell" /> objects with varying heights and custom layouts.</para><para>UITableView overrides <see cref="M:UIKit.UIView.LayoutSubviews" /> so that it calls <see cref="M:UIKit.UITableView.ReloadData" /> only when you create a new instance or when you assign a new <see cref="P:UIKit.UITableView.Source" /> (or <see cref="P:UIKit.UITableView.DataSource" />).Reloading the table view clears current state (including the current selection). However if you explicitly call <see cref="M:UIKit.UITableView.ReloadData" /> it clears this state and any subsequent direct or indirect call to <see cref="M:UIKit.UIView.LayoutSubviews" /> does not trigger a reload.</para></block></remarks>
    <altmember cref="T:UIKit.UICollectionView" />
    <related type="article" href="https://docs.xamarin.com/guides/ios/user_interface/tables">Working with Tables and Cells</related>
    <related type="recipe" href="https://docs.xamarin.com/recipes/ios/content_controls/tables">Tables and UITableViewController</related>
    <related type="sample" href="https://github.com/xamarin/ios-samples/tree/master/Data/">Example_Data</related>
    <related type="sample" href="https://github.com/xamarin/ios-samples/tree/master/MonoCatalog-MonoDevelop/">monocatalog</related>
    <related type="sample" href="https://github.com/xamarin/ios-samples/tree/master/RecipesAndPrinting/">RecipesAndPrinting</related>
    <related type="externalDocumentation" href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITableView_Class/index.html">Apple documentation for <c>UITableView</c></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UITableView ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("init")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Default constructor that initializes a new instance of this class with no parameters.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UITableView (CoreGraphics.CGRect frame);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype CoreGraphics.CGRect frame) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.#ctor(CoreGraphics.CGRect)" />
      <MemberSignature Language="F#" Value="new UIKit.UITableView : CoreGraphics.CGRect -&gt; UIKit.UITableView" Usage="new UIKit.UITableView frame" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("initWithFrame:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="frame" Type="CoreGraphics.CGRect" />
      </Parameters>
      <Docs>
        <param name="frame">Frame used by the view, expressed in iOS points.</param>
        <summary>Initializes the UITableView with the specified frame.</summary>
        <remarks>
          <para>This constructor is used to programmatically create a new instance of UITableView with the specified dimension in the frame.   The object will only be displayed once it has been added to a view hierarchy by calling AddSubview in a containing view.</para>
          <para>This constructor is not invoked when deserializing objects from storyboards or XIB filesinstead the constructor that takes an NSCoder parameter is invoked.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UITableView (Foundation.NSCoder coder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Foundation.NSCoder coder) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.#ctor(Foundation.NSCoder)" />
      <MemberSignature Language="F#" Value="new UIKit.UITableView : Foundation.NSCoder -&gt; UIKit.UITableView" Usage="new UIKit.UITableView coder" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("initWithCoder:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.DesignatedInitializer</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="coder" Type="Foundation.NSCoder" />
      </Parameters>
      <Docs>
        <param name="coder">The unarchiver object.</param>
        <summary>A constructor that initializes the object from the data stored in the unarchiver object.</summary>
        <remarks>
          <para>This constructor is provided to allow the class to be initialized from an unarchiver (for example, during NIB deserialization).   This is part of the <see cref="T:Foundation.NSCoding" />  protocol.</para>
          <para>If developers want to create a subclass of this object and continue to support deserialization from an archive, they should implement a constructor with an identical signature: taking a single parameter of type <see cref="T:Foundation.NSCoder" /> and decorate it with the [Export("initWithCoder:"] attribute declaration.</para>
          <para>The state of this object can also be serialized by using the companion method, EncodeTo.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected UITableView (Foundation.NSObjectFlag t);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class Foundation.NSObjectFlag t) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.#ctor(Foundation.NSObjectFlag)" />
      <MemberSignature Language="F#" Value="new UIKit.UITableView : Foundation.NSObjectFlag -&gt; UIKit.UITableView" Usage="new UIKit.UITableView t" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="t" Type="Foundation.NSObjectFlag" />
      </Parameters>
      <Docs>
        <param name="t">Unused sentinel value, pass NSObjectFlag.Empty.</param>
        <summary>Constructor to call on derived classes to skip initialization and merely allocate the object.</summary>
        <remarks>
          <para>This constructor should be called by derived classes when they completely construct the object in managed code and merely want the runtime to allocate and initialize the NSObject.   This is required to implement the two-step initialization process that Objective-C uses, the first step is to perform the object allocation, the second step is to initialize the object.   When developers invoke the constructor that takes the NSObjectFlag.Empty they take advantage of a direct path that goes all the way up to NSObject to merely allocate the object's memory and bind the Objective-C and C# objects together.    The actual initialization of the object is up to the developer.</para>
          <para>This constructor is typically used by the binding generator to allocate the object, but prevent the actual initialization to take place.   Once the allocation has taken place, the constructor has to initialize the object.   With constructors generated by the binding generator this means that it manually invokes one of the "init" methods to initialize the object.</para>
          <para>It is the developer's responsibility to completely initialize the object if they chain up using the NSObjectFlag.Empty path.</para>
          <para>In general, if the developer's constructor invokes the NSObjectFlag.Empty base implementation, then it should be calling an Objective-C init method.   If this is not the case, developers should instead chain to the proper constructor in their class. </para>
          <para>The argument value is ignored and merely ensures that the only code that is executed is the construction phase is the basic NSObject allocation and runtime type registration.  Typically the chaining would look like this:</para>
          <example>
            <code lang="C#"><![CDATA[
//
// The NSObjectFlag merely allocates the object and registers the
// C# class with the Objective-C runtime if necessary, but no actual
// initXxx method is invoked, that is done later in the constructor
//
// This is taken from Xamarin.iOS's source code:
//
[Export ("initWithFrame:")]
public UIView (System.Drawing.RectangleF frame) : base (NSObjectFlag.Empty)
{
// Invoke the init method now.
	var initWithFrame = new Selector ("initWithFrame:").Handle;
	if (IsDirectBinding)
		Handle = ObjCRuntime.Messaging.IntPtr_objc_msgSend_CGRect (this.Handle, initWithFrame, frame);
	else
		Handle = ObjCRuntime.Messaging.IntPtr_objc_msgSendSuper_CGRect (this.SuperHandle, initWithFrame, frame);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected internal UITableView (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig specialname rtspecialname instance void .ctor(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.#ctor(System.IntPtr)" />
      <MemberSignature Language="F#" Value="new UIKit.UITableView : nativeint -&gt; UIKit.UITableView" Usage="new UIKit.UITableView handle" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Pointer (handle) to the unmanaged object.</param>
        <summary>A constructor used when creating managed representations of unmanaged objects;  Called by the runtime.</summary>
        <remarks>
          <para>This constructor is invoked by the runtime infrastructure (<see cref="M:ObjCRuntime.Runtime.GetNSObject(System.IntPtr)" />) to create a new managed representation for a pointer to an unmanaged Objective-C object.    Developers should not invoke this method directly, instead they should call the GetNSObject method as it will prevent two instances of a managed object to point to the same native object.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UITableView (CoreGraphics.CGRect frame, UIKit.UITableViewStyle style);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype CoreGraphics.CGRect frame, valuetype UIKit.UITableViewStyle style) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.#ctor(CoreGraphics.CGRect,UIKit.UITableViewStyle)" />
      <MemberSignature Language="F#" Value="new UIKit.UITableView : CoreGraphics.CGRect * UIKit.UITableViewStyle -&gt; UIKit.UITableView" Usage="new UIKit.UITableView (frame, style)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("initWithFrame:style:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.DesignatedInitializer</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="frame" Type="CoreGraphics.CGRect" />
        <Parameter Name="style" Type="UIKit.UITableViewStyle" />
      </Parameters>
      <Docs>
        <param name="frame">To be added.</param>
        <param name="style">To be added.</param>
        <summary>Constructuor that creates a <see cref="T:UIKit.UITableView" /> with the specified <param name="frame" /> and <param name="style" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowsMultipleSelection">
      <MemberSignature Language="C#" Value="public virtual bool AllowsMultipleSelection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowsMultipleSelection" />
      <MemberSignature Language="DocId" Value="P:UIKit.UITableView.AllowsMultipleSelection" />
      <MemberSignature Language="F#" Value="member this.AllowsMultipleSelection : bool with get, set" Usage="UIKit.UITableView.AllowsMultipleSelection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("allowsMultipleSelection")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setAllowsMultipleSelection:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether more than one row can be selected (outside of editing mode).</summary>
        <value>
          <see langword="false" /> if multiple selection is prohibited, <see langword="true" /> if it is allowed.</value>
        <remarks>
          <para>When this property is <see langword="true" />, a check mark is placed next to each row that is tapped. Tapping the row again removes the check mark.</para>
          <para>Call <see cref="P:UIKit.UITableView.IndexPathsForSelectedRows" /> to identify the selected rows.</para>
          <para>The default value of this property is <see langword="false" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowsMultipleSelectionDuringEditing">
      <MemberSignature Language="C#" Value="public virtual bool AllowsMultipleSelectionDuringEditing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowsMultipleSelectionDuringEditing" />
      <MemberSignature Language="DocId" Value="P:UIKit.UITableView.AllowsMultipleSelectionDuringEditing" />
      <MemberSignature Language="F#" Value="member this.AllowsMultipleSelectionDuringEditing : bool with get, set" Usage="UIKit.UITableView.AllowsMultipleSelectionDuringEditing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("allowsMultipleSelectionDuringEditing")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setAllowsMultipleSelectionDuringEditing:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether more than one row can be selected while in editing mode.</summary>
        <value>
          <see langword="false" /> if multiple selection is prohibited, <see langword="true" /> if it is allowed.</value>
        <remarks>
          <para>When this property is <see langword="true" />, a check mark is placed next to each row that is tapped. Tapping the row again removes the check mark. In addition, the UITableView does not query for editing styles when it goes into editing mode.</para>
          <para>Call <see cref="P:UIKit.UITableView.IndexPathsForSelectedRows" /> to identify the selected rows.</para>
          <para>The default value of this property is <see langword="false" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowsSelection">
      <MemberSignature Language="C#" Value="public virtual bool AllowsSelection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowsSelection" />
      <MemberSignature Language="DocId" Value="P:UIKit.UITableView.AllowsSelection" />
      <MemberSignature Language="F#" Value="member this.AllowsSelection : bool with get, set" Usage="UIKit.UITableView.AllowsSelection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("allowsSelection")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setAllowsSelection:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether a row can be selected.</summary>
        <value>
          <see langword="true" /> if row selection is allowed, <see langword="false" /> if not.</value>
        <remarks>If <see langword="true" /> (the default) then row selection is allowed. This property only affects cell selection when the table view is not in editing mode. To control selection in edting mode, use <see cref="P:UIKit.UITableView.AllowsSelectionDuringEditing" />.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowsSelectionDuringEditing">
      <MemberSignature Language="C#" Value="public virtual bool AllowsSelectionDuringEditing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowsSelectionDuringEditing" />
      <MemberSignature Language="DocId" Value="P:UIKit.UITableView.AllowsSelectionDuringEditing" />
      <MemberSignature Language="F#" Value="member this.AllowsSelectionDuringEditing : bool with get, set" Usage="UIKit.UITableView.AllowsSelectionDuringEditing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("allowsSelectionDuringEditing")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setAllowsSelectionDuringEditing:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether a row can be selected while in editing mode.</summary>
        <value>
          <see langword="true" /> if row selection is allowed, <see langword="false" /> if not. The default is <see langword="false" />.</value>
        <remarks>If <see langword="true" /> then row selection is allowed during editing. This property only affects cell selection when the table view is in editing mode. To control selection in normal mode, use <see cref="P:UIKit.UITableView.AllowsSelection" />.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Appearance">
      <MemberSignature Language="C#" Value="public static UIKit.UITableView.UITableViewAppearance Appearance { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class UIKit.UITableView/UITableViewAppearance Appearance" />
      <MemberSignature Language="DocId" Value="P:UIKit.UITableView.Appearance" />
      <MemberSignature Language="F#" Value="member this.Appearance : UIKit.UITableView.UITableViewAppearance" Usage="UIKit.UITableView.Appearance" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>UIKit.UITableView+UITableViewAppearance</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Strongly-typed property that returns the UIAppearance class for this class.</summary>
        <value>
        </value>
        <remarks>
          <para>Setting any appearance properties on this instance will affect the appearance of all instances of UITableView.</para>
          <para>If developers want to control the appearance of subclasses of UITableView, they should use the <see cref="M:UIKit.UITableViewHeaderFooterView.GetAppearance``1(UIKit.UITraitCollection,System.Type[])" /> method.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppearanceWhenContainedIn">
      <MemberSignature Language="C#" Value="public static UIKit.UITableView.UITableViewAppearance AppearanceWhenContainedIn (params Type[] containers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class UIKit.UITableView/UITableViewAppearance AppearanceWhenContainedIn(class System.Type[] containers) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.AppearanceWhenContainedIn(System.Type[])" />
      <MemberSignature Language="F#" Value="static member AppearanceWhenContainedIn : Type[] -&gt; UIKit.UITableView.UITableViewAppearance" Usage="UIKit.UITableView.AppearanceWhenContainedIn containers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>UIKit.UITableView+UITableViewAppearance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containers" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="containers">List of types that developers want to have as the containers to apply this particular appearance</param>
        <summary>Returns a strongly typed UIAppearance for instances of this class when the view is hosted in the specified hierarchy.</summary>
        <returns>The appearance proxy object that developers can use to set properties when the given container hierarchy is active</returns>
        <remarks>
          <para>The returned object represents the UIAppearance proxy where developers can set appearance properties for instances of UITableView when those instances are contained in the hierarchy specified by the <paramref name="containers" /> parameter.</para>
          <para>If developers want to control the appearance of subclasses of UITableView, they should use the <see cref="M:UIKit.UITableViewHeaderFooterView.GetAppearance``1(UIKit.UITraitCollection,System.Type[])" /> method.</para>
          <para>The following example shows how the AppearanceWhenContainedIn method works</para>
          <example>
            <code lang="C#"><![CDATA[
var mySliders = UISlider.AppearanceWhenContainedIn (typeof (UINavigationBar), typeof (UIPopoverController));
mySliders.TintColor = UIColor.Red;
]]></code>
          </example>
          <para>For more information, see the documentation for the <see cref="T:UIKit.UIAppearance" /> class.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutomaticDimension">
      <MemberSignature Language="C#" Value="public static nfloat AutomaticDimension { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.nfloat AutomaticDimension" />
      <MemberSignature Language="DocId" Value="P:UIKit.UITableView.AutomaticDimension" />
      <MemberSignature Language="F#" Value="member this.AutomaticDimension : nfloat" Usage="UIKit.UITableView.AutomaticDimension" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UITableViewAutomaticDimension", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.nfloat</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UITableViewAutomaticDimension</summary>
        <value>
        </value>
        <remarks>Return this value from <see cref="T:UIKit.UITableViewSource" /> (or <see cref="T:UIKit.UITableViewDelegate" />) methods that request dimension metrics when you want the UITableView to use a default value. For example, return this constant from <see cref="M:UIKit.UITableViewSource.GetHeightForHeader(UIKit.UITableView,System.nint)" /> or <see cref="M:UIKit.UITableViewSource.GetHeightForFooter(UIKit.UITableView,System.nint)" /> and the table view will use automatically use a height that accomodates the value returned from <see cref="M:UIKit.UITableViewSource.TitleForHeader(UIKit.UITableView,System.nint)" /> or <see cref="M:UIKit.UITableViewSource.TitleForFooter(UIKit.UITableView,System.nint)" /> respectively.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundView">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIView BackgroundView { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIView BackgroundView" />
      <MemberSignature Language="DocId" Value="P:UIKit.UITableView.BackgroundView" />
      <MemberSignature Language="F#" Value="member this.BackgroundView : UIKit.UIView with get, set" Usage="UIKit.UITableView.BackgroundView" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("backgroundView", ObjCRuntime.ArgumentSemantic.Strong)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setBackgroundView:", ObjCRuntime.ArgumentSemantic.Strong)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The background view of the table.</summary>
        <value>
          <para>A <see cref="T:UIKit.UIView" /></para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>A table view's background view is automatically resized to match the size of the table view. The background view is placed as a subview of the table behind all cell, header and footer views.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginUpdates">
      <MemberSignature Language="C#" Value="public virtual void BeginUpdates ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginUpdates() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.BeginUpdates" />
      <MemberSignature Language="F#" Value="abstract member BeginUpdates : unit -&gt; unit&#xA;override this.BeginUpdates : unit -&gt; unit" Usage="uITableView.BeginUpdates " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("beginUpdates")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Call this method before inserting, updating or selecting rows that should be animated as one operation. <see cref="M:UIKit.UITableView.EndUpdates" /> must be called after the modifications are complete.</summary>
        <remarks>
          <para>After calling this method, subsequent insertions, deletions and selection operations (eg. <see cref="P:UIKit.UITableView.IndexPathsForVisibleRows" /> or <see cref="M:UIKit.UITableView.CellAt(Foundation.NSIndexPath)" />) will be animated simultaneously. This group of methods must conclude with a call to <see cref="M:UIKit.UITableView.EndUpdates" />. These method pairs can be nested.</para>
          <para>If the developer does not make the insertion, deletion and selection calls inside this block, table attributes such as row count might become invalid. Developers should not call <see cref="M:UIKit.UITableView.ReloadData" /> within the group, otherwise they will need to perform any animations manually.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CellAt">
      <MemberSignature Language="C#" Value="public virtual UIKit.UITableViewCell CellAt (Foundation.NSIndexPath ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class UIKit.UITableViewCell CellAt(class Foundation.NSIndexPath ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.CellAt(Foundation.NSIndexPath)" />
      <MemberSignature Language="F#" Value="abstract member CellAt : Foundation.NSIndexPath -&gt; UIKit.UITableViewCell&#xA;override this.CellAt : Foundation.NSIndexPath -&gt; UIKit.UITableViewCell" Usage="uITableView.CellAt ns" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("cellForRowAtIndexPath:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UITableViewCell</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ns" Type="Foundation.NSIndexPath" />
      </Parameters>
      <Docs>
        <param name="ns">An <see cref="T:Foundation.NSIndexPath" /> that references a row in the table view.</param>
        <summary>Returns the table cell at the specified index path.</summary>
        <returns>A <see cref="T:UIKit.UITableViewCell" /> object that represents a row in the table, or <see langword="null" /> if the row is not visible or the <see cref="T:Foundation.NSIndexPath" /> is out of range.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CellLayoutMarginsFollowReadableWidth">
      <MemberSignature Language="C#" Value="public virtual bool CellLayoutMarginsFollowReadableWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CellLayoutMarginsFollowReadableWidth" />
      <MemberSignature Language="DocId" Value="P:UIKit.UITableView.CellLayoutMarginsFollowReadableWidth" />
      <MemberSignature Language="F#" Value="member this.CellLayoutMarginsFollowReadableWidth : bool with get, set" Usage="UIKit.UITableView.CellLayoutMarginsFollowReadableWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("cellLayoutMarginsFollowReadableWidth")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setCellLayoutMarginsFollowReadableWidth:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether the layout margins of the cell's contents are set by the system to have a comfortable, legible width for the user.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClassHandle">
      <MemberSignature Language="C#" Value="public override IntPtr ClassHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ClassHandle" />
      <MemberSignature Language="DocId" Value="P:UIKit.UITableView.ClassHandle" />
      <MemberSignature Language="F#" Value="member this.ClassHandle : nativeint" Usage="UIKit.UITableView.ClassHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The handle for this class.</summary>
        <value>The pointer to the Objective-C class.</value>
        <remarks>Each Xamarin.iOS class mirrors an unmanaged Objective-C class.   This value contains the pointer to the Objective-C class, it is similar to calling objc_getClass with the object name.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataSource">
      <MemberSignature Language="C#" Value="public UIKit.IUITableViewDataSource DataSource { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.IUITableViewDataSource DataSource" />
      <MemberSignature Language="DocId" Value="P:UIKit.UITableView.DataSource" />
      <MemberSignature Language="F#" Value="member this.DataSource : UIKit.IUITableViewDataSource with get, set" Usage="UIKit.UITableView.DataSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.IUITableViewDataSource</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The object that acts as the data source for the table view.</summary>
        <value>
          <para>
          </para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>
          <para>The data source must subclass <see cref="T:UIKit.UITableViewDataSource" />. MonoTouch provides an alternative to implementing both <see cref="T:UIKit.UITableViewDataSource" /> and <see cref="T:UIKit.UITableViewDelegate" />: the <see cref="T:UIKit.UITableViewSource" /> class which should be assigned to <see cref="P:UIKit.UITableView.Source" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Delegate">
      <MemberSignature Language="C#" Value="public UIKit.IUITableViewDelegate Delegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.IUITableViewDelegate Delegate" />
      <MemberSignature Language="DocId" Value="P:UIKit.UITableView.Delegate" />
      <MemberSignature Language="F#" Value="member this.Delegate : UIKit.IUITableViewDelegate with get, set" Usage="UIKit.UITableView.Delegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.IUITableViewDelegate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An instance of the UIKit.IUITableViewDelegate model class which acts as the class delegate.</summary>
        <value>The instance of the UIKit.IUITableViewDelegate model class</value>
        <remarks>
          <para>The delegate instance assigned to this object will be used to handle events or provide data on demand to this class.</para>
          <para>When setting the Delegate or WeakDelegate values events will be delivered to the specified instance instead of being delivered to the C#-style events</para>
          <para>This is the strongly typed version of the object, developers should use the WeakDelegate property instead if they want to merely assign a class derived from NSObject that has been decorated with [Export] attributes.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteRows">
      <MemberSignature Language="C#" Value="public virtual void DeleteRows (Foundation.NSIndexPath[] atIndexPaths, UIKit.UITableViewRowAnimation withRowAnimation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DeleteRows(class Foundation.NSIndexPath[] atIndexPaths, valuetype UIKit.UITableViewRowAnimation withRowAnimation) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.DeleteRows(Foundation.NSIndexPath[],UIKit.UITableViewRowAnimation)" />
      <MemberSignature Language="F#" Value="abstract member DeleteRows : Foundation.NSIndexPath[] * UIKit.UITableViewRowAnimation -&gt; unit&#xA;override this.DeleteRows : Foundation.NSIndexPath[] * UIKit.UITableViewRowAnimation -&gt; unit" Usage="uITableView.DeleteRows (atIndexPaths, withRowAnimation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("deleteRowsAtIndexPaths:withRowAnimation:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="atIndexPaths" Type="Foundation.NSIndexPath[]" />
        <Parameter Name="withRowAnimation" Type="UIKit.UITableViewRowAnimation" />
      </Parameters>
      <Docs>
        <param name="atIndexPaths">Array of <see cref="T:Foundation.NSIndexPath" /> objects that identify which rows to delete.</param>
        <param name="withRowAnimation">What type of animation to use when deleting the rows (eg. fade out or slide out from bottom). </param>
        <summary>Delete the rows referenced in the <paramref name="atIndexPaths" /> array. The deletion can optionally be animated.</summary>
        <remarks>
          <para>When this method is called inside an animation block defined by <see cref="M:UIKit.UITableView.BeginUpdates" /> and <see cref="M:UIKit.UITableView.EndUpdates" />, any insertions of rows or sections are deferred until after deletions have been processed. This happens regardless of the ordering of the insertion and deletion method calls within the animation block.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteSections">
      <MemberSignature Language="C#" Value="public virtual void DeleteSections (Foundation.NSIndexSet sections, UIKit.UITableViewRowAnimation withRowAnimation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DeleteSections(class Foundation.NSIndexSet sections, valuetype UIKit.UITableViewRowAnimation withRowAnimation) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.DeleteSections(Foundation.NSIndexSet,UIKit.UITableViewRowAnimation)" />
      <MemberSignature Language="F#" Value="abstract member DeleteSections : Foundation.NSIndexSet * UIKit.UITableViewRowAnimation -&gt; unit&#xA;override this.DeleteSections : Foundation.NSIndexSet * UIKit.UITableViewRowAnimation -&gt; unit" Usage="uITableView.DeleteSections (sections, withRowAnimation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("deleteSections:withRowAnimation:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sections" Type="Foundation.NSIndexSet" />
        <Parameter Name="withRowAnimation" Type="UIKit.UITableViewRowAnimation" />
      </Parameters>
      <Docs>
        <param name="sections">A set of section identifiers to delete. If a section exists after one that is deleted, it is moved up one index location.</param>
        <param name="withRowAnimation">What type of animation to use when deleting the rows (eg. fade out or slide out from bottom).</param>
        <summary>Deletes a section (or sections) from a table view, with an option to animate the operation.</summary>
        <remarks>
          <para>When this method is called inside an animation block defined by <see cref="M:UIKit.UITableView.BeginUpdates" /> and <see cref="M:UIKit.UITableView.EndUpdates" />, any insertions of rows or sections are deferred until after deletions have been processed. This happens regardless of the ordering of the insertion and deletion method calls within the animation block.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DequeueReusableCell">
      <MemberSignature Language="C#" Value="public UIKit.UITableViewCell DequeueReusableCell (Foundation.NSString identifier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class UIKit.UITableViewCell DequeueReusableCell(class Foundation.NSString identifier) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.DequeueReusableCell(Foundation.NSString)" />
      <MemberSignature Language="F#" Value="member this.DequeueReusableCell : Foundation.NSString -&gt; UIKit.UITableViewCell" Usage="uITableView.DequeueReusableCell identifier" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UITableViewCell</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identifier" Type="Foundation.NSString" />
      </Parameters>
      <Docs>
        <param name="identifier">A string identifying the cell type being requested.</param>
        <summary>Returns a reusable table view cell that was created with the given ReuseIdentifier.</summary>
        <returns>A <see cref="T:UIKit.UITableViewCell" /> associated with the <paramref name="identifier" />, or <see langword="null" /> if there is no cells in the queue with that particular <paramref name="identifier" />.</returns>
        <remarks>
          <para>The cell reuse cache is important for efficiency and application developers should use it for dynamic tables. </para>
          <para>Application developers targeting iOS 6 and later should use <see cref="M:UIKit.UITableView.RegisterClassForCellReuse(System.Type,System.String)" /> or <see cref="M:UIKit.UITableView.RegisterNibForCellReuse(UIKit.UINib,System.String)" />. Once a <see cref="T:UIKit.UITableViewCell" /> class is registered, calls to <see cref="M:UIKit.UITableView.DequeueReusableCell(System.String,Foundation.NSIndexPath)" /> will return a newly-instantiated object as necessary, rather than returning <see langword="null" />.</para>
          <para>Application developers should prefer the use of <see cref="T:UIKit.UITableView.DequeueReusableCell(Foundation.NSString,Foundation.NSIndexPath)" />, which returns a <see cref="T:UIKit.UITableViewCell" /> that is properly sized for the index path.</para>
        </remarks>
        <altmember cref="M:UIKit.UITableView.RegisterClassForCellReuse" />
        <altmember cref="M:UIKit.UITableView.RegisterNibForCellReuse" />
      </Docs>
    </Member>
    <Member MemberName="DequeueReusableCell">
      <MemberSignature Language="C#" Value="public virtual UIKit.UITableViewCell DequeueReusableCell (string identifier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class UIKit.UITableViewCell DequeueReusableCell(string identifier) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.DequeueReusableCell(System.String)" />
      <MemberSignature Language="F#" Value="abstract member DequeueReusableCell : string -&gt; UIKit.UITableViewCell&#xA;override this.DequeueReusableCell : string -&gt; UIKit.UITableViewCell" Usage="uITableView.DequeueReusableCell identifier" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("dequeueReusableCellWithIdentifier:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UITableViewCell</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identifier" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="identifier">A string identifying the cell type being requested.</param>
        <summary>Returns a reusable table view cell that was created with the given ReuseIdentifier.</summary>
        <returns>A <see cref="T:UIKit.UITableViewCell" /> associated with the <paramref name="identifier" />, or <see langword="null" /> if there is no cells in the queue with that particular <paramref name="identifier" />.</returns>
        <remarks>
          <para>The cell reuse cache is important for efficiency and application developers should use it for dynamic tables. </para>
          <para>Application developers targeting iOS 6 and later should use <see cref="M:UIKit.UITableView.RegisterClassForCellReuse(System.Type,System.String)" /> or <see cref="M:UIKit.UITableView.RegisterNibForCellReuse(UIKit.UINib,System.String)" />. Once a <see cref="T:UIKit.UITableViewCell" /> class is registered, calls to <see cref="M:UIKit.UITableView.DequeueReusableCell(System.String,Foundation.NSIndexPath)" /> will return a newly-instantiated object as necessary, rather than returning <see langword="null" />.</para>
          <para>Application developers should prefer the use of <see cref="T:UIKit.UITableView.DequeueReusableCell(Foundation.NSString,Foundation.NSIndexPath)" />, which returns a <see cref="T:UIKit.UITableViewCell" /> that is properly sized for the index path.</para>
        </remarks>
        <altmember cref="M:UIKit.UITableView.RegisterClassForCellReuse" />
        <altmember cref="M:UIKit.UITableView.RegisterNibForCellReuse" />
      </Docs>
    </Member>
    <Member MemberName="DequeueReusableCell">
      <MemberSignature Language="C#" Value="public virtual UIKit.UITableViewCell DequeueReusableCell (Foundation.NSString reuseIdentifier, Foundation.NSIndexPath indexPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class UIKit.UITableViewCell DequeueReusableCell(class Foundation.NSString reuseIdentifier, class Foundation.NSIndexPath indexPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.DequeueReusableCell(Foundation.NSString,Foundation.NSIndexPath)" />
      <MemberSignature Language="F#" Value="abstract member DequeueReusableCell : Foundation.NSString * Foundation.NSIndexPath -&gt; UIKit.UITableViewCell&#xA;override this.DequeueReusableCell : Foundation.NSString * Foundation.NSIndexPath -&gt; UIKit.UITableViewCell" Usage="uITableView.DequeueReusableCell (reuseIdentifier, indexPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("dequeueReusableCellWithIdentifier:forIndexPath:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UITableViewCell</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseIdentifier" Type="Foundation.NSString" />
        <Parameter Name="indexPath" Type="Foundation.NSIndexPath" />
      </Parameters>
      <Docs>
        <param name="reuseIdentifier">A string identifying the cell type being requested.</param>
        <param name="indexPath">The specific cell being requested.</param>
        <summary>Returns a reusable table view cell for the given <paramref name="reuseIdentifier" />, properly sized for the <paramref name="indexPath" />. </summary>
        <returns>A <see cref="T:UIKit.UITableViewCell" /> associated with the <paramref name="identifier" />. </returns>
        <remarks>
          <para>This is the preferred method to call for cell reuse, as it calls <see cref="M:UIKit.UITableViewSource.GetHeightForRow(UIKit.UITableView,Foundation.NSIndexPath)" /> and returns a properly-sized <see cref="T:UIKit.UITableViewCell" />.</para>
          <para>This method must be preceded by cell registration using <see cref="M:UIKit.UITableView.RegisterClassForCellReuse(System.Type,System.String)" /> or <see cref="M:UIKit.UITableView.RegisterNibForCellReuse(UIKit.UINib,System.String)" />. Otherwise, an <c>NSInternalInconsistencyException</c> exception will be raised at runtime. </para>
          <para>The cell reuse cache is important for efficiency and application developers should use it for dynamic tables. </para>
        </remarks>
        <altmember cref="M:UIKit.UITableView.RegisterClassForCellReuse" />
        <altmember cref="M:UIKit.UITableView.RegisterNibForCellReuse" />
      </Docs>
    </Member>
    <Member MemberName="DequeueReusableCell">
      <MemberSignature Language="C#" Value="public UIKit.UITableViewCell DequeueReusableCell (string reuseIdentifier, Foundation.NSIndexPath indexPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class UIKit.UITableViewCell DequeueReusableCell(string reuseIdentifier, class Foundation.NSIndexPath indexPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.DequeueReusableCell(System.String,Foundation.NSIndexPath)" />
      <MemberSignature Language="F#" Value="member this.DequeueReusableCell : string * Foundation.NSIndexPath -&gt; UIKit.UITableViewCell" Usage="uITableView.DequeueReusableCell (reuseIdentifier, indexPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>UIKit.UITableViewCell</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseIdentifier" Type="System.String" />
        <Parameter Name="indexPath" Type="Foundation.NSIndexPath" />
      </Parameters>
      <Docs>
        <param name="reuseIdentifier">To be added.</param>
        <param name="indexPath">To be added.</param>
        <summary>Returns a reusable cell identified by <paramref name="reuseIdentifier" /> and located at <paramref name="indexPath" />.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DequeueReusableHeaderFooterView">
      <MemberSignature Language="C#" Value="public virtual UIKit.UITableViewHeaderFooterView DequeueReusableHeaderFooterView (Foundation.NSString reuseIdentifier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class UIKit.UITableViewHeaderFooterView DequeueReusableHeaderFooterView(class Foundation.NSString reuseIdentifier) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.DequeueReusableHeaderFooterView(Foundation.NSString)" />
      <MemberSignature Language="F#" Value="abstract member DequeueReusableHeaderFooterView : Foundation.NSString -&gt; UIKit.UITableViewHeaderFooterView&#xA;override this.DequeueReusableHeaderFooterView : Foundation.NSString -&gt; UIKit.UITableViewHeaderFooterView" Usage="uITableView.DequeueReusableHeaderFooterView reuseIdentifier" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("dequeueReusableHeaderFooterViewWithIdentifier:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UITableViewHeaderFooterView</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseIdentifier" Type="Foundation.NSString" />
      </Parameters>
      <Docs>
        <param name="reuseIdentifier">A string identify the type of <see cref="T:UIKit.UITableViewHeaderFooterView" /> being requested.</param>
        <summary>Returns a reusable <see cref="T:UIKit.UITableViewHeaderFooterView" /> for the given <paramref name="reuseIdentifier" />.</summary>
        <returns>A <see cref="T:UIKit.UITableViewHeaderFooterView" /> associated with the <paramref name="reuseIdentifier" />.</returns>
        <remarks>
          <para>The table reuse cache is important for efficiency and application developers should use it for dynamic tables.</para>
          <para>Application developers targeting iOS 6 and later should use <see cref="M:UIKit.UITableView.RegisterClassForHeaderFooterViewReuse(System.Type,System.String)" /> or <see cref="M:UIKit.UITableView.RegisterNibForHeaderFooterViewReuse(UIKit.UINib,System.String)" />. Once a <see cref="T:UIKit.UITableViewHeaderFooterView" /> class is registered, calls to <see cref="M:UIKit.UITableView.DequeueReusableHeaderFooterView(System.String)" /> will return a newly-instantiated object as necessary, rather than returning <see langword="null" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DequeueReusableHeaderFooterView">
      <MemberSignature Language="C#" Value="public UIKit.UITableViewHeaderFooterView DequeueReusableHeaderFooterView (string reuseIdentifier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class UIKit.UITableViewHeaderFooterView DequeueReusableHeaderFooterView(string reuseIdentifier) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.DequeueReusableHeaderFooterView(System.String)" />
      <MemberSignature Language="F#" Value="member this.DequeueReusableHeaderFooterView : string -&gt; UIKit.UITableViewHeaderFooterView" Usage="uITableView.DequeueReusableHeaderFooterView reuseIdentifier" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>UIKit.UITableViewHeaderFooterView</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseIdentifier" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="reuseIdentifier">To be added.</param>
        <summary>Returns a reusable header/footer view identified by <paramref name="reuseIdentifier" /></summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeselectRow">
      <MemberSignature Language="C#" Value="public virtual void DeselectRow (Foundation.NSIndexPath indexPath, bool animated);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DeselectRow(class Foundation.NSIndexPath indexPath, bool animated) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.DeselectRow(Foundation.NSIndexPath,System.Boolean)" />
      <MemberSignature Language="F#" Value="abstract member DeselectRow : Foundation.NSIndexPath * bool -&gt; unit&#xA;override this.DeselectRow : Foundation.NSIndexPath * bool -&gt; unit" Usage="uITableView.DeselectRow (indexPath, animated)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("deselectRowAtIndexPath:animated:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indexPath" Type="Foundation.NSIndexPath" />
        <Parameter Name="animated" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="indexPath">
          <para>An <see cref="T:Foundation.NSIndexPath" /> identifying a row in the table view.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <param name="animated">
          <see langword="true" /> if the deseletion should be animated, <see langword="false" /> if it should occur immediately.</param>
        <summary>Deselect a given row in a table view, with an option to animate the deselection.</summary>
        <remarks>
          <para>Calling this method does not trigger <see cref="M:UIKit.UITableViewSource.WillSelectRow(UIKit.UITableView,Foundation.NSIndexPath)" /> nor will it send <see cref="P:UIKit.UITableView.SelectionDidChangeNotification" /> notifications.</para>
          <para>This method does not cause any scrolling to the deselected row.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.Dispose(System.Boolean)" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="uITableView.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <para>If set to <see langword="true" />, the method is invoked directly and will dispose manage and unmanaged resources;   If set to <see langword="false" /> the method is being called by the garbage collector finalizer and should only release unmanaged resources.</para>
        </param>
        <summary>Releases the resources used by the UITableView object.</summary>
        <remarks>
          <para>This Dispose method releases the resources used by the UITableView class.</para>
          <para>This method is called by both the Dispose() method and the object finalizer (Finalize).    When invoked by the Dispose method, the parameter disposing <paramref name="disposing" /> is set to <see langword="true" /> and any managed object references that this object holds are also disposed or released;  when invoked by the object finalizer, on the finalizer thread the value is set to <see langword="false" />. </para>
          <para>Calling the Dispose method when the application is finished using the UITableView ensures that all external resources used by this managed object are released as soon as possible.  Once developers have invoked the Dispose method, the object is no longer useful and developers should no longer make any calls to it.</para>
          <para>  For more information on how to override this method and on the Dispose/IDisposable pattern, read the ``Implementing a Dispose Method'' document at https://msdn.microsoft.com/en-us/library/fs2xkftw.aspx</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragDelegate">
      <MemberSignature Language="C#" Value="public virtual UIKit.IUITableViewDragDelegate DragDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.IUITableViewDragDelegate DragDelegate" />
      <MemberSignature Language="DocId" Value="P:UIKit.UITableView.DragDelegate" />
      <MemberSignature Language="F#" Value="member this.DragDelegate : UIKit.IUITableViewDragDelegate with get, set" Usage="UIKit.UITableView.DragDelegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("dragDelegate", ObjCRuntime.ArgumentSemantic.Weak)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setDragDelegate:", ObjCRuntime.ArgumentSemantic.Weak)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.IUITableViewDragDelegate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the delegate for responding to the user dragging items from the table view.</summary>
        <value>
          <para>(More documentation for this node is coming)</para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DragInteractionEnabled">
      <MemberSignature Language="C#" Value="public virtual bool DragInteractionEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DragInteractionEnabled" />
      <MemberSignature Language="DocId" Value="P:UIKit.UITableView.DragInteractionEnabled" />
      <MemberSignature Language="F#" Value="member this.DragInteractionEnabled : bool with get, set" Usage="UIKit.UITableView.DragInteractionEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("dragInteractionEnabled")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setDragInteractionEnabled:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a Boolean value that tells whether drag and drop is enabled.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DropDelegate">
      <MemberSignature Language="C#" Value="public virtual UIKit.IUITableViewDropDelegate DropDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.IUITableViewDropDelegate DropDelegate" />
      <MemberSignature Language="DocId" Value="P:UIKit.UITableView.DropDelegate" />
      <MemberSignature Language="F#" Value="member this.DropDelegate : UIKit.IUITableViewDropDelegate with get, set" Usage="UIKit.UITableView.DropDelegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("dropDelegate", ObjCRuntime.ArgumentSemantic.Weak)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setDropDelegate:", ObjCRuntime.ArgumentSemantic.Weak)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.IUITableViewDropDelegate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the delegate for responding to the user dropping items to the table view.</summary>
        <value>
          <para>(More documentation for this node is coming)</para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Editing">
      <MemberSignature Language="C#" Value="public virtual bool Editing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Editing" />
      <MemberSignature Language="DocId" Value="P:UIKit.UITableView.Editing" />
      <MemberSignature Language="F#" Value="member this.Editing : bool with get, set" Usage="UIKit.UITableView.Editing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("isEditing")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setEditing:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether the table view is in editing mode.</summary>
        <value>
          <see langword="true" /> if the table is currently in editing mode, <see langword="false" /> if not. The default is <see langword="false" />.</value>
        <remarks>When this property is <see langword="true" />, the table view is in editing mode: cells may show an insertion or deletion control on their left side and a reordering control on the right (depending on how the cell is configured). Tapping a control causes the table view to invoke the <see cref="T:UIKit.UITableViewSource" /> method <see cref="M:UIKit.UITableViewSource.CommitEditingStyle(UIKit.UITableView,UIKit.UITableViewCellEditingStyle,Foundation.NSIndexPath)" />.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EncodeTo">
      <MemberSignature Language="C#" Value="public virtual void EncodeTo (Foundation.NSCoder encoder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EncodeTo(class Foundation.NSCoder encoder) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.EncodeTo(Foundation.NSCoder)" />
      <MemberSignature Language="F#" Value="override this.EncodeTo : Foundation.NSCoder -&gt; unit" Usage="uITableView.EncodeTo encoder" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Foundation.INSCoding.EncodeTo(Foundation.NSCoder)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("encodeWithCoder:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="encoder" Type="Foundation.NSCoder" />
      </Parameters>
      <Docs>
        <param name="encoder">The encoder object where the state of the object will be stored</param>
        <summary>Encodes the state of the object on the provided encoder</summary>
        <remarks>
          <para>This method is part of the <see cref="T:Foundation.NSCoding" /> protocol and is used by applications to preserve the state of the object into an archive.</para>
          <para>Users will typically create a <see cref="T:Foundation.NSKeyedArchiver" /> and then invoke the <see cref="M:Foundation.NSKeyedArchiver.ArchiveRootObjectToFile(Foundation.NSObject,System.String)" /> which will call into this method</para>
          <para>If developers want to allow their object to be archived, they should override this method and store their state in using the provided <paramref name="encoder" /> parameter.   In addition, developers should also implement a constructor that takes an NSCoder argument and is exported with [Export ("initWithCoder:")]</para>
          <example>
            <code lang="C#"><![CDATA[public void override EncodeTo (NSCoder coder){
    coder.Encode (1, key: "version");
    coder.Encode (userName, key: "userName");
    coder.Encode (hostName, key: "hostName");]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndUpdates">
      <MemberSignature Language="C#" Value="public virtual void EndUpdates ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndUpdates() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.EndUpdates" />
      <MemberSignature Language="F#" Value="abstract member EndUpdates : unit -&gt; unit&#xA;override this.EndUpdates : unit -&gt; unit" Usage="uITableView.EndUpdates " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("endUpdates")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Finalize a series of method calls that insert, update or select rows to animate as one operation. <see cref="M:UIKit.UITableView.BeginUpdates" /> must be called before the modifications are made.</summary>
        <remarks>Call this method to bracket a series of table modifications (insert, delete or select rows) that began with <see cref="M:UIKit.UITableView.BeginUpdates" />. When EndUpdates is called the table view animates the operations simultaneously. Calls to <see cref="M:UIKit.UITableView.BeginUpdates" /> and EndUpdates can be nested. If you make insertion, deletion or selection calls outside of a <see cref="M:UIKit.UITableView.BeginUpdates" />/EndUpdates block then table attributes such as row count might become invalid.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EstimatedRowHeight">
      <MemberSignature Language="C#" Value="public virtual nfloat EstimatedRowHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.nfloat EstimatedRowHeight" />
      <MemberSignature Language="DocId" Value="P:UIKit.UITableView.EstimatedRowHeight" />
      <MemberSignature Language="F#" Value="member this.EstimatedRowHeight : nfloat with get, set" Usage="UIKit.UITableView.EstimatedRowHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("estimatedRowHeight", ObjCRuntime.ArgumentSemantic.UnsafeUnretained)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setEstimatedRowHeight:", ObjCRuntime.ArgumentSemantic.UnsafeUnretained)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.nfloat</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The estimated height of individual rows in this UITableView.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EstimatedSectionFooterHeight">
      <MemberSignature Language="C#" Value="public virtual nfloat EstimatedSectionFooterHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.nfloat EstimatedSectionFooterHeight" />
      <MemberSignature Language="DocId" Value="P:UIKit.UITableView.EstimatedSectionFooterHeight" />
      <MemberSignature Language="F#" Value="member this.EstimatedSectionFooterHeight : nfloat with get, set" Usage="UIKit.UITableView.EstimatedSectionFooterHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("estimatedSectionFooterHeight", ObjCRuntime.ArgumentSemantic.UnsafeUnretained)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setEstimatedSectionFooterHeight:", ObjCRuntime.ArgumentSemantic.UnsafeUnretained)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.nfloat</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The estimated height of section foots in this UITableView.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EstimatedSectionHeaderHeight">
      <MemberSignature Language="C#" Value="public virtual nfloat EstimatedSectionHeaderHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.nfloat EstimatedSectionHeaderHeight" />
      <MemberSignature Language="DocId" Value="P:UIKit.UITableView.EstimatedSectionHeaderHeight" />
      <MemberSignature Language="F#" Value="member this.EstimatedSectionHeaderHeight : nfloat with get, set" Usage="UIKit.UITableView.EstimatedSectionHeaderHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("estimatedSectionHeaderHeight", ObjCRuntime.ArgumentSemantic.UnsafeUnretained)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setEstimatedSectionHeaderHeight:", ObjCRuntime.ArgumentSemantic.UnsafeUnretained)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.nfloat</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The estimated height of section headers in this UITableView.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAppearance">
      <MemberSignature Language="C#" Value="public static UIKit.UITableView.UITableViewAppearance GetAppearance (UIKit.UITraitCollection traits);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class UIKit.UITableView/UITableViewAppearance GetAppearance(class UIKit.UITraitCollection traits) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.GetAppearance(UIKit.UITraitCollection)" />
      <MemberSignature Language="F#" Value="static member GetAppearance : UIKit.UITraitCollection -&gt; UIKit.UITableView.UITableViewAppearance" Usage="UIKit.UITableView.GetAppearance traits" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>UIKit.UITableView+UITableViewAppearance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="traits" Type="UIKit.UITraitCollection" />
      </Parameters>
      <Docs>
        <param name="traits">To be added.</param>
        <summary>Gets an appearance object for the specified <paramref name="traits" />.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAppearance">
      <MemberSignature Language="C#" Value="public static UIKit.UITableView.UITableViewAppearance GetAppearance (UIKit.UITraitCollection traits, params Type[] containers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class UIKit.UITableView/UITableViewAppearance GetAppearance(class UIKit.UITraitCollection traits, class System.Type[] containers) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.GetAppearance(UIKit.UITraitCollection,System.Type[])" />
      <MemberSignature Language="F#" Value="static member GetAppearance : UIKit.UITraitCollection * Type[] -&gt; UIKit.UITableView.UITableViewAppearance" Usage="UIKit.UITableView.GetAppearance (traits, containers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>UIKit.UITableView+UITableViewAppearance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="traits" Type="UIKit.UITraitCollection" />
        <Parameter Name="containers" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="traits">To be added.</param>
        <param name="containers">To be added.</param>
        <summary>Returns an appearance object that is derived by merging <paramref name="traits" /> from <paramref name="containers" />.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAppearance&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static UIKit.UITableView.UITableViewAppearance GetAppearance&lt;T&gt; () where T : UIKit.UITableView;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class UIKit.UITableView/UITableViewAppearance GetAppearance&lt;(class UIKit.UITableView) T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.GetAppearance``1" />
      <MemberSignature Language="F#" Value="static member GetAppearance : unit -&gt; UIKit.UITableView.UITableViewAppearance (requires 'T :&gt; UIKit.UITableView)" Usage="UIKit.UITableView.GetAppearance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>UIKit.UITableView+UITableViewAppearance</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">The type for which the UIAppearance proxy must be returned.  This is a subclass of UITableView.</typeparam>
        <summary>Obtains the appearance proxy <see cref="T:UIKit.UITableView.UITableViewAppearance" /> for the subclass of UITableView.</summary>
        <returns>
          <para>appearance proxy object for the specified type.</para>
        </returns>
        <remarks>
          <para>Setting any appearance properties on the returned object will affect the appearance of all classes and subclasses of the type parameter.</para>
          <para>Unlike the <see cref="P:UIKit.UITableView.Appearance" /> property, or the <see cref="M:UIKit.UITableViewHeaderFooterView.AppearanceWhenContainedIn(System.Type[])" /> method which only work on instances of this particular class, the proxies returned by GetAppearance can be used to change the style of subclasses.</para>
          <para>The following example shows how the GetAppearance method works</para>
          <example>
            <code lang="C#"><![CDATA[
var myTheme = UITableView.GetAppearance<MyUITableViewSubclass> ();
myTheme.TintColor = UIColor.Red;
]]></code>
          </example>
          <para>For more information, see the documentation for the <see cref="T:UIKit.UIAppearance" /> class.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAppearance&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static UIKit.UITableView.UITableViewAppearance GetAppearance&lt;T&gt; (UIKit.UITraitCollection traits) where T : UIKit.UITableView;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class UIKit.UITableView/UITableViewAppearance GetAppearance&lt;(class UIKit.UITableView) T&gt;(class UIKit.UITraitCollection traits) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.GetAppearance``1(UIKit.UITraitCollection)" />
      <MemberSignature Language="F#" Value="static member GetAppearance : UIKit.UITraitCollection -&gt; UIKit.UITableView.UITableViewAppearance (requires 'T :&gt; UIKit.UITableView)" Usage="UIKit.UITableView.GetAppearance traits" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>UIKit.UITableView+UITableViewAppearance</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <BaseTypeName>UIKit.UITableView</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="traits" Type="UIKit.UITraitCollection" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type for which the UIAppearance proxy must be returned.  This is a subclass of UITableView.</typeparam>
        <param name="traits">Trait collection to match.</param>
        <summary>Obtains the appearance proxy <see cref="T:UIKit.UITableView.UITableViewAppearance" /> for the subclass of UITableView.</summary>
        <returns>
          <para>appearance proxy object for the specified type.</para>
        </returns>
        <remarks>
          <para>The returned object represents the UIAppearance proxy where developers can set appearance properties for instances of UITableView.</para>
          <para>Unlike the <see cref="P:UIKit.UITableView.Appearance" /> property, or the <see cref="M:UIKit.UITableViewHeaderFooterView.AppearanceWhenContainedIn(System.Type[])" /> method which only work on instances of this particular class, the proxies returned by GetAppearance can be used to change the style of subclasses.</para>
          <para>The following example shows how the GetAppearance method works</para>
          <example>
            <code lang="C#"><![CDATA[
var myTheme = UITableView.GetAppearance<MyUITableViewSubclass> (myTraits, );
myTheme.TintColor = UIColor.Red;
]]></code>
          </example>
          <para>For more information, see the documentation for the <see cref="T:UIKit.UIAppearance" /> class.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAppearance&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static UIKit.UITableView.UITableViewAppearance GetAppearance&lt;T&gt; (UIKit.UITraitCollection traits, params Type[] containers) where T : UIKit.UITableView;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class UIKit.UITableView/UITableViewAppearance GetAppearance&lt;(class UIKit.UITableView) T&gt;(class UIKit.UITraitCollection traits, class System.Type[] containers) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.GetAppearance``1(UIKit.UITraitCollection,System.Type[])" />
      <MemberSignature Language="F#" Value="static member GetAppearance : UIKit.UITraitCollection * Type[] -&gt; UIKit.UITableView.UITableViewAppearance (requires 'T :&gt; UIKit.UITableView)" Usage="UIKit.UITableView.GetAppearance (traits, containers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>UIKit.UITableView+UITableViewAppearance</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <BaseTypeName>UIKit.UITableView</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="traits" Type="UIKit.UITraitCollection" />
        <Parameter Name="containers" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">The type for which the UIAppearance proxy must be returned.  This is a subclass of UITableView.</typeparam>
        <param name="traits">Trait collection to match.</param>
        <param name="containers">List of types that the developer wishes to have as the containers to apply this particular appearance.</param>
        <summary>Obtains the appearance proxy <see cref="T:UIKit.UITableView.UITableViewAppearance" /> for the subclass of UITableView that has the specified trait collection when the view is hosted in the specified hierarchy.</summary>
        <returns>
          <para>appearance proxy object for the specified type.</para>
        </returns>
        <remarks>
          <para>The returned object represents the UIAppearance proxy where developers can set appearance properties for instances of UITableView that has the specified trait collection when the view is hosted in the specified hierarchy when those instances are contained in the hierarchy specified by the <paramref name="containers" /> parameter.</para>
          <para>Unlike the <see cref="P:UIKit.UITableView.Appearance" /> property, or the <see cref="M:UIKit.UITableViewHeaderFooterView.AppearanceWhenContainedIn(System.Type[])" /> method which only work on instances of this particular class, the proxies returned by GetAppearance can be used to change the style of subclasses.</para>
          <para>The following example shows how the GetAppearance method works</para>
          <example>
            <code lang="C#"><![CDATA[
var myTheme = UITableView.GetAppearance<MyUITableViewSubclass> (myTraits, typeof (UINavigationBar), typeof (UIPopoverController));
myTheme.TintColor = UIColor.Red;
]]></code>
          </example>
          <para>For more information, see the documentation for the <see cref="T:UIKit.UIAppearance" /> class.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDataSourceIndexPath">
      <MemberSignature Language="C#" Value="public virtual Foundation.NSIndexPath GetDataSourceIndexPath (Foundation.NSIndexPath presentationIndexPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Foundation.NSIndexPath GetDataSourceIndexPath(class Foundation.NSIndexPath presentationIndexPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.GetDataSourceIndexPath(Foundation.NSIndexPath)" />
      <MemberSignature Language="F#" Value="abstract member GetDataSourceIndexPath : Foundation.NSIndexPath -&gt; Foundation.NSIndexPath&#xA;override this.GetDataSourceIndexPath : Foundation.NSIndexPath -&gt; Foundation.NSIndexPath" Usage="uITableView.GetDataSourceIndexPath presentationIndexPath" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:UIKit.IUIDataSourceTranslating.GetDataSourceIndexPath(Foundation.NSIndexPath)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("dataSourceIndexPathForPresentationIndexPath:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSIndexPath</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="presentationIndexPath" Type="Foundation.NSIndexPath" />
      </Parameters>
      <Docs>
        <param name="presentationIndexPath">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDataSourceSectionIndex">
      <MemberSignature Language="C#" Value="public virtual nint GetDataSourceSectionIndex (nint presentationSectionIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.nint GetDataSourceSectionIndex(valuetype System.nint presentationSectionIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.GetDataSourceSectionIndex(System.nint)" />
      <MemberSignature Language="F#" Value="abstract member GetDataSourceSectionIndex : nint -&gt; nint&#xA;override this.GetDataSourceSectionIndex : nint -&gt; nint" Usage="uITableView.GetDataSourceSectionIndex presentationSectionIndex" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:UIKit.IUIDataSourceTranslating.GetDataSourceSectionIndex(System.nint)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("dataSourceSectionIndexForPresentationSectionIndex:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.nint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="presentationSectionIndex" Type="System.nint" />
      </Parameters>
      <Docs>
        <param name="presentationSectionIndex">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFooterView">
      <MemberSignature Language="C#" Value="public virtual UIKit.UITableViewHeaderFooterView GetFooterView (nint section);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class UIKit.UITableViewHeaderFooterView GetFooterView(valuetype System.nint section) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.GetFooterView(System.nint)" />
      <MemberSignature Language="F#" Value="abstract member GetFooterView : nint -&gt; UIKit.UITableViewHeaderFooterView&#xA;override this.GetFooterView : nint -&gt; UIKit.UITableViewHeaderFooterView" Usage="uITableView.GetFooterView section" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("footerViewForSection:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UITableViewHeaderFooterView</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="section" Type="System.nint" />
      </Parameters>
      <Docs>
        <param name="section">To be added.</param>
        <summary>The footer view for the specified section.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHeaderView">
      <MemberSignature Language="C#" Value="public virtual UIKit.UITableViewHeaderFooterView GetHeaderView (nint section);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class UIKit.UITableViewHeaderFooterView GetHeaderView(valuetype System.nint section) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.GetHeaderView(System.nint)" />
      <MemberSignature Language="F#" Value="abstract member GetHeaderView : nint -&gt; UIKit.UITableViewHeaderFooterView&#xA;override this.GetHeaderView : nint -&gt; UIKit.UITableViewHeaderFooterView" Usage="uITableView.GetHeaderView section" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("headerViewForSection:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UITableViewHeaderFooterView</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="section" Type="System.nint" />
      </Parameters>
      <Docs>
        <param name="section">A zero-based index specifying which section's header is being requested.</param>
        <summary>Returns the <see cref="T:UIKit.UITableViewHeaderFooterView" /> for the specified <paramref name="section" />. Returns <see langword="null" /> if there is no corresponding view.</summary>
        <returns>The <see cref="T:UIKit.UITableViewHeaderFooterView" /> for the specified <paramref name="section" />. Returns <see langword="null" /> if there is no corresponding view</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPresentationIndexPath">
      <MemberSignature Language="C#" Value="public virtual Foundation.NSIndexPath GetPresentationIndexPath (Foundation.NSIndexPath dataSourceIndexPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Foundation.NSIndexPath GetPresentationIndexPath(class Foundation.NSIndexPath dataSourceIndexPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.GetPresentationIndexPath(Foundation.NSIndexPath)" />
      <MemberSignature Language="F#" Value="abstract member GetPresentationIndexPath : Foundation.NSIndexPath -&gt; Foundation.NSIndexPath&#xA;override this.GetPresentationIndexPath : Foundation.NSIndexPath -&gt; Foundation.NSIndexPath" Usage="uITableView.GetPresentationIndexPath dataSourceIndexPath" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:UIKit.IUIDataSourceTranslating.GetPresentationIndexPath(Foundation.NSIndexPath)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("presentationIndexPathForDataSourceIndexPath:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSIndexPath</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSourceIndexPath" Type="Foundation.NSIndexPath" />
      </Parameters>
      <Docs>
        <param name="dataSourceIndexPath">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPresentationSectionIndex">
      <MemberSignature Language="C#" Value="public virtual nint GetPresentationSectionIndex (nint dataSourceSectionIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.nint GetPresentationSectionIndex(valuetype System.nint dataSourceSectionIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.GetPresentationSectionIndex(System.nint)" />
      <MemberSignature Language="F#" Value="abstract member GetPresentationSectionIndex : nint -&gt; nint&#xA;override this.GetPresentationSectionIndex : nint -&gt; nint" Usage="uITableView.GetPresentationSectionIndex dataSourceSectionIndex" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:UIKit.IUIDataSourceTranslating.GetPresentationSectionIndex(System.nint)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("presentationSectionIndexForDataSourceSectionIndex:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.nint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSourceSectionIndex" Type="System.nint" />
      </Parameters>
      <Docs>
        <param name="dataSourceSectionIndex">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasActiveDrag">
      <MemberSignature Language="C#" Value="public virtual bool HasActiveDrag { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasActiveDrag" />
      <MemberSignature Language="DocId" Value="P:UIKit.UITableView.HasActiveDrag" />
      <MemberSignature Language="F#" Value="member this.HasActiveDrag : bool" Usage="UIKit.UITableView.HasActiveDrag" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("hasActiveDrag")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a Boolean value that tells whether there is an active drag operation for the table view.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasActiveDrop">
      <MemberSignature Language="C#" Value="public virtual bool HasActiveDrop { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasActiveDrop" />
      <MemberSignature Language="DocId" Value="P:UIKit.UITableView.HasActiveDrop" />
      <MemberSignature Language="F#" Value="member this.HasActiveDrop : bool" Usage="UIKit.UITableView.HasActiveDrop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("hasActiveDrop")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a Boolean value that tells whether there is an active drop operation for the table view.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasUncommittedUpdates">
      <MemberSignature Language="C#" Value="public virtual bool HasUncommittedUpdates { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasUncommittedUpdates" />
      <MemberSignature Language="DocId" Value="P:UIKit.UITableView.HasUncommittedUpdates" />
      <MemberSignature Language="F#" Value="member this.HasUncommittedUpdates : bool" Usage="UIKit.UITableView.HasUncommittedUpdates" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("hasUncommittedUpdates")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a Boolean value that tells whether the table view is reordering items for a drop or has a placeholder view.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexPathForCell">
      <MemberSignature Language="C#" Value="public virtual Foundation.NSIndexPath IndexPathForCell (UIKit.UITableViewCell cell);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Foundation.NSIndexPath IndexPathForCell(class UIKit.UITableViewCell cell) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.IndexPathForCell(UIKit.UITableViewCell)" />
      <MemberSignature Language="F#" Value="abstract member IndexPathForCell : UIKit.UITableViewCell -&gt; Foundation.NSIndexPath&#xA;override this.IndexPathForCell : UIKit.UITableViewCell -&gt; Foundation.NSIndexPath" Usage="uITableView.IndexPathForCell cell" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("indexPathForCell:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSIndexPath</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cell" Type="UIKit.UITableViewCell" />
      </Parameters>
      <Docs>
        <param name="cell">The <see cref="T:UIKit.UITableViewCell" /> for which the index path is desired.</param>
        <summary>Calculates the index path for the specified <paramref name="cell" />.</summary>
        <returns>The <see cref="T:Foundation.NSIndexPath" /> for the <paramref name="cell" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexPathForRowAtPoint">
      <MemberSignature Language="C#" Value="public virtual Foundation.NSIndexPath IndexPathForRowAtPoint (CoreGraphics.CGPoint point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Foundation.NSIndexPath IndexPathForRowAtPoint(valuetype CoreGraphics.CGPoint point) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.IndexPathForRowAtPoint(CoreGraphics.CGPoint)" />
      <MemberSignature Language="F#" Value="abstract member IndexPathForRowAtPoint : CoreGraphics.CGPoint -&gt; Foundation.NSIndexPath&#xA;override this.IndexPathForRowAtPoint : CoreGraphics.CGPoint -&gt; Foundation.NSIndexPath" Usage="uITableView.IndexPathForRowAtPoint point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("indexPathForRowAtPoint:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSIndexPath</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="CoreGraphics.CGPoint" />
      </Parameters>
      <Docs>
        <param name="point">A location, in the coordinate system of <c>this</c>, in the row for which the index path is desired.</param>
        <summary>Returns the <see cref="T:Foundation.NSIndexPath" /> for the row at the indicated <paramref name="point" />.</summary>
        <returns>The <see cref="T:Foundation.NSIndexPath" /> for the row at the indicated <paramref name="point" />. Returns <see langword="null" /> if <paramref name="point" /> is not within a row.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexPathForSelectedRow">
      <MemberSignature Language="C#" Value="public virtual Foundation.NSIndexPath IndexPathForSelectedRow { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Foundation.NSIndexPath IndexPathForSelectedRow" />
      <MemberSignature Language="DocId" Value="P:UIKit.UITableView.IndexPathForSelectedRow" />
      <MemberSignature Language="F#" Value="member this.IndexPathForSelectedRow : Foundation.NSIndexPath" Usage="UIKit.UITableView.IndexPathForSelectedRow" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("indexPathForSelectedRow")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSIndexPath</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The <see cref="T:Foundation.NSIndexPath" /> for the currently-selected row.</summary>
        <value>The <see cref="T:Foundation.NSIndexPath" /> for the most-recently-selected of the currently-selected rows. Returns <see langword="null" /> if there are no selected rows.</value>
        <remarks>
          <para>If the <see cref="T:UIKit.UITableView" /> contains more than one selected row, this property holds the most-recently-selected of the rows (see also <see cref="P:UIKit.UITableView.IndexPathsForSelectedRows" />).</para>
        </remarks>
        <altmember cref="P:UIKit.UITableView.SelectedRow" />
      </Docs>
    </Member>
    <Member MemberName="IndexPathsForSelectedRows">
      <MemberSignature Language="C#" Value="public virtual Foundation.NSIndexPath[] IndexPathsForSelectedRows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Foundation.NSIndexPath[] IndexPathsForSelectedRows" />
      <MemberSignature Language="DocId" Value="P:UIKit.UITableView.IndexPathsForSelectedRows" />
      <MemberSignature Language="F#" Value="member this.IndexPathsForSelectedRows : Foundation.NSIndexPath[]" Usage="UIKit.UITableView.IndexPathsForSelectedRows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("indexPathsForSelectedRows")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSIndexPath[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An array of <see cref="T:Foundation.NSIndexPath" />s for the selected rows.</summary>
        <value>An array of <see cref="T:Foundation.NSIndexPath" />s corresponding to the currently-selected set of rows. Returns <see langword="null" /> if there are no selected rows.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexPathsForVisibleRows">
      <MemberSignature Language="C#" Value="public virtual Foundation.NSIndexPath[] IndexPathsForVisibleRows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Foundation.NSIndexPath[] IndexPathsForVisibleRows" />
      <MemberSignature Language="DocId" Value="P:UIKit.UITableView.IndexPathsForVisibleRows" />
      <MemberSignature Language="F#" Value="member this.IndexPathsForVisibleRows : Foundation.NSIndexPath[]" Usage="UIKit.UITableView.IndexPathsForVisibleRows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("indexPathsForVisibleRows")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSIndexPath[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An array of <see cref="T:Foundation.NSIndexPath" />s for the set of currently-visible rows.</summary>
        <value>An array of <see cref="T:Foundation.NSIndexPath" />s corresponding to the set of currently-visible rows.<para tool="nullallowed">This value can be <see langword="null" />.</para></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexSearch">
      <MemberSignature Language="C#" Value="public static Foundation.NSString IndexSearch { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString IndexSearch" />
      <MemberSignature Language="DocId" Value="P:UIKit.UITableView.IndexSearch" />
      <MemberSignature Language="F#" Value="member this.IndexSearch : Foundation.NSString" Usage="UIKit.UITableView.IndexSearch" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Field("UITableViewIndexSearch", "UIKit")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant <c>UITableViewIndexSearch</c></summary>
        <value>
        </value>
        <remarks>To be added.</remarks>
        <altmember cref="M:UIKit.UITableViewSource.SectionIndexTitles" />
      </Docs>
    </Member>
    <Member MemberName="InsertRows">
      <MemberSignature Language="C#" Value="public virtual void InsertRows (Foundation.NSIndexPath[] atIndexPaths, UIKit.UITableViewRowAnimation withRowAnimation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void InsertRows(class Foundation.NSIndexPath[] atIndexPaths, valuetype UIKit.UITableViewRowAnimation withRowAnimation) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.InsertRows(Foundation.NSIndexPath[],UIKit.UITableViewRowAnimation)" />
      <MemberSignature Language="F#" Value="abstract member InsertRows : Foundation.NSIndexPath[] * UIKit.UITableViewRowAnimation -&gt; unit&#xA;override this.InsertRows : Foundation.NSIndexPath[] * UIKit.UITableViewRowAnimation -&gt; unit" Usage="uITableView.InsertRows (atIndexPaths, withRowAnimation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("insertRowsAtIndexPaths:withRowAnimation:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="atIndexPaths" Type="Foundation.NSIndexPath[]" />
        <Parameter Name="withRowAnimation" Type="UIKit.UITableViewRowAnimation" />
      </Parameters>
      <Docs>
        <param name="atIndexPaths">An array of <see cref="T:Foundation.NSIndexPath" />s that indicate the desired insertion points.</param>
        <param name="withRowAnimation">What type of animation to use.</param>
        <summary>Inserts rows into the <see cref="T:UIKit.UITableView" />.</summary>
        <remarks>
          <para>
            <c>UITableView</c> calls the relevant <see cref="T:UIKit.UITableViewSource" /> methods (e.g., <see cref="M:UIKit.UITableViewSource.GetCell(UIKit.UITableView,Foundation.NSIndexPath)" /> and related methods) immediately afterwards to get the cells and other content to display the visible rows.</para>
          <para>When this method is called within a <see cref="M:UIKit.UITableView.BeginUpdates" />-<see cref="M:UIKit.UITableView.EndUpdates" /> animation block, any insertions of rows or sections are deferred until after deletions have been processed. This happens regardless of the ordering of the insertion and deletion method calls within the animation block..</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertSections">
      <MemberSignature Language="C#" Value="public virtual void InsertSections (Foundation.NSIndexSet sections, UIKit.UITableViewRowAnimation withRowAnimation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void InsertSections(class Foundation.NSIndexSet sections, valuetype UIKit.UITableViewRowAnimation withRowAnimation) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.InsertSections(Foundation.NSIndexSet,UIKit.UITableViewRowAnimation)" />
      <MemberSignature Language="F#" Value="abstract member InsertSections : Foundation.NSIndexSet * UIKit.UITableViewRowAnimation -&gt; unit&#xA;override this.InsertSections : Foundation.NSIndexSet * UIKit.UITableViewRowAnimation -&gt; unit" Usage="uITableView.InsertSections (sections, withRowAnimation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("insertSections:withRowAnimation:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sections" Type="Foundation.NSIndexSet" />
        <Parameter Name="withRowAnimation" Type="UIKit.UITableViewRowAnimation" />
      </Parameters>
      <Docs>
        <param name="sections">A set of section identifiers to insert. If a section already exists at a given index, it is moved up down one index location.</param>
        <param name="withRowAnimation">What type of animation to use when inserting the rows (eg. fade in or slide in from left)</param>
        <summary>Inserts a section (or sections) from a table view, with an option to animate the operation.</summary>
        <remarks>
          <para>
            <c>UITableView</c> calls the relevant <see cref="T:UIKit.UITableViewSource" /> methods immediately afterwards to get the cells and other content to display the visible rows.</para>
          <para>When this method is called inside an animation block defined by <see cref="M:UIKit.UITableView.BeginUpdates" /> and <see cref="M:UIKit.UITableView.EndUpdates" />, any insertions of rows or sections are deferred until after deletions have been processed. This happens regardless of the ordering of the insertion and deletion method calls within the animation block.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsetsContentViewsToSafeArea">
      <MemberSignature Language="C#" Value="public virtual bool InsetsContentViewsToSafeArea { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool InsetsContentViewsToSafeArea" />
      <MemberSignature Language="DocId" Value="P:UIKit.UITableView.InsetsContentViewsToSafeArea" />
      <MemberSignature Language="F#" Value="member this.InsetsContentViewsToSafeArea : bool with get, set" Usage="UIKit.UITableView.InsetsContentViewsToSafeArea" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("insetsContentViewsToSafeArea")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setInsetsContentViewsToSafeArea:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets whether this <see cref="T:UIKit.UITableView" /> insets its contents to the display's safe area.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveRow">
      <MemberSignature Language="C#" Value="public virtual void MoveRow (Foundation.NSIndexPath fromIndexPath, Foundation.NSIndexPath toIndexPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MoveRow(class Foundation.NSIndexPath fromIndexPath, class Foundation.NSIndexPath toIndexPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.MoveRow(Foundation.NSIndexPath,Foundation.NSIndexPath)" />
      <MemberSignature Language="F#" Value="abstract member MoveRow : Foundation.NSIndexPath * Foundation.NSIndexPath -&gt; unit&#xA;override this.MoveRow : Foundation.NSIndexPath * Foundation.NSIndexPath -&gt; unit" Usage="uITableView.MoveRow (fromIndexPath, toIndexPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("moveRowAtIndexPath:toIndexPath:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromIndexPath" Type="Foundation.NSIndexPath" />
        <Parameter Name="toIndexPath" Type="Foundation.NSIndexPath" />
      </Parameters>
      <Docs>
        <param name="fromIndexPath">An <see cref="T:Foundation.NSIndexPath" /> indicating the original row.</param>
        <param name="toIndexPath">The desired location.</param>
        <summary>Moves a row from <paramref name="fromIndexPath" /> to <paramref name="toIndexPath" />.</summary>
        <remarks>
          <para>There is no function for moving an array of rows (in contrast to <see cref="M:UIKit.UITableView.InsertRows(Foundation.NSIndexPath[],UIKit.UITableViewRowAnimation)" /> or <see cref="M:UIKit.UITableView.DeleteRows(Foundation.NSIndexPath[],UIKit.UITableViewRowAnimation)" />). The applicatin developer must instead repeatedly call this function. If this function is called within a <see cref="M:UIKit.UITableView.BeginUpdates" />-<see cref="M:UIKit.UITableView.EndUpdates" /> animation block, all the row manipulation will occur as a single animation.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveSection">
      <MemberSignature Language="C#" Value="public virtual void MoveSection (nint fromSection, nint toSection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MoveSection(valuetype System.nint fromSection, valuetype System.nint toSection) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.MoveSection(System.nint,System.nint)" />
      <MemberSignature Language="F#" Value="abstract member MoveSection : nint * nint -&gt; unit&#xA;override this.MoveSection : nint * nint -&gt; unit" Usage="uITableView.MoveSection (fromSection, toSection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("moveSection:toSection:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromSection" Type="System.nint" />
        <Parameter Name="toSection" Type="System.nint" />
      </Parameters>
      <Docs>
        <param name="fromSection">Index of the section to move.</param>
        <param name="toSection">Destination index for the section. The section currently at this index is moved up or down to accomodate the moved section.</param>
        <summary>Moves a section to a new location in the table view.</summary>
        <remarks>
          <para>This method can be combined with other MoveSection, <see cref="M:UIKit.UITableView.InsertSections(Foundation.NSIndexSet,UIKit.UITableViewRowAnimation)" /> and <see cref="M:UIKit.UITableView.DeleteSections(Foundation.NSIndexSet,UIKit.UITableViewRowAnimation)" /> operations within an animation block defined by <see cref="M:UIKit.UITableView.BeginUpdates" /> and <see cref="M:UIKit.UITableView.EndUpdates" />, so that all the changes occur in a single animation.</para>
          <para>Unlike the insertion and deletion methods, moving a section does not use an animation paramter. Moved sections always animate straight from their starting position to their new position. Only one section can be moved per method call, however to move multiple sections application developers can call this method repeatedly within a <see cref="M:UIKit.UITableView.BeginUpdates" />-<see cref="M:UIKit.UITableView.EndUpdates" /> animation block.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NumberOfRowsInSection">
      <MemberSignature Language="C#" Value="public virtual nint NumberOfRowsInSection (nint section);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.nint NumberOfRowsInSection(valuetype System.nint section) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.NumberOfRowsInSection(System.nint)" />
      <MemberSignature Language="F#" Value="abstract member NumberOfRowsInSection : nint -&gt; nint&#xA;override this.NumberOfRowsInSection : nint -&gt; nint" Usage="uITableView.NumberOfRowsInSection section" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("numberOfRowsInSection:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.nint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="section" Type="System.nint" />
      </Parameters>
      <Docs>
        <param name="section">The index of the section to query. Section indexes start at zero.</param>
        <summary>Returns the number of rows (table cells) in a given section.</summary>
        <returns>Number of rows in the section.</returns>
        <remarks>UITableView retrieves this value from the <see cref="T:UIKit.UITableViewSource" /> (or <see cref="T:UIKit.UITableViewDataSource" />) and caches it.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NumberOfSections">
      <MemberSignature Language="C#" Value="public virtual nint NumberOfSections ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.nint NumberOfSections() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.NumberOfSections" />
      <MemberSignature Language="F#" Value="abstract member NumberOfSections : unit -&gt; nint&#xA;override this.NumberOfSections : unit -&gt; nint" Usage="uITableView.NumberOfSections " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("numberOfSections")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.nint</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the number of sections in the table view.</summary>
        <returns>Number of sections in the table view.</returns>
        <remarks>UITableView retrieves this value from the <see cref="T:UIKit.UITableViewSource" /> (or <see cref="T:UIKit.UITableViewDataSource" />) and caches it.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformBatchUpdates">
      <MemberSignature Language="C#" Value="public virtual void PerformBatchUpdates (Action updates, Action&lt;bool&gt; completion);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PerformBatchUpdates(class System.Action updates, class System.Action`1&lt;bool&gt; completion) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.PerformBatchUpdates(System.Action,System.Action{System.Boolean})" />
      <MemberSignature Language="F#" Value="abstract member PerformBatchUpdates : Action * Action&lt;bool&gt; -&gt; unit&#xA;override this.PerformBatchUpdates : Action * Action&lt;bool&gt; -&gt; unit" Usage="uITableView.PerformBatchUpdates (updates, completion)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("performBatchUpdates:completion:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="updates" Type="System.Action">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="completion" Type="System.Action&lt;System.Boolean&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDActionArity1V2))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="updates">
          <para>The updates to perform.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <param name="completion">
          <para>The handler to run after the updates complete. Takes a Boolean that tells whether all the animations completed.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Applies and simultaneously animates multiple manipulations of the <see cref="T:UIKit.UITableView" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformBatchUpdatesAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;bool&gt; PerformBatchUpdatesAsync (Action updates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;bool&gt; PerformBatchUpdatesAsync(class System.Action updates) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.PerformBatchUpdatesAsync(System.Action)" />
      <MemberSignature Language="F#" Value="abstract member PerformBatchUpdatesAsync : Action -&gt; System.Threading.Tasks.Task&lt;bool&gt;&#xA;override this.PerformBatchUpdatesAsync : Action -&gt; System.Threading.Tasks.Task&lt;bool&gt;" Usage="uITableView.PerformBatchUpdatesAsync updates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="updates" Type="System.Action">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="updates">The updates to perform.This parameter can be .</param>
        <summary>Applies and simultaneously animates multiple manipulations of the <see cref="T:UIKit.UITableView" />.</summary>
        <returns>
          <para class="improve-task-t-return-type-description">A task that represents the asynchronous PerformBatchUpdates operation.  The value of the TResult parameter is of type System.Action&lt;System.Boolean&gt;.</para>
        </returns>
        <remarks>
          <para copied="true">The PerformBatchUpdatesAsync method is suitable to be used with C# async by returning control to the caller with a Task representing the operation.</para>
          <para copied="true">To be added.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformUsingPresentationValues">
      <MemberSignature Language="C#" Value="public virtual void PerformUsingPresentationValues (Action actionsToTranslate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PerformUsingPresentationValues(class System.Action actionsToTranslate) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.PerformUsingPresentationValues(System.Action)" />
      <MemberSignature Language="F#" Value="abstract member PerformUsingPresentationValues : Action -&gt; unit&#xA;override this.PerformUsingPresentationValues : Action -&gt; unit" Usage="uITableView.PerformUsingPresentationValues actionsToTranslate" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:UIKit.IUIDataSourceTranslating.PerformUsingPresentationValues(System.Action)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("performUsingPresentationValues:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="actionsToTranslate" Type="System.Action">
          <Attributes>
            <Attribute>
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDAction))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="actionsToTranslate">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PrefetchDataSource">
      <MemberSignature Language="C#" Value="public virtual UIKit.IUITableViewDataSourcePrefetching PrefetchDataSource { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.IUITableViewDataSourcePrefetching PrefetchDataSource" />
      <MemberSignature Language="DocId" Value="P:UIKit.UITableView.PrefetchDataSource" />
      <MemberSignature Language="F#" Value="member this.PrefetchDataSource : UIKit.IUITableViewDataSourcePrefetching with get, set" Usage="UIKit.UITableView.PrefetchDataSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 10, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 10, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 10, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 10, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 10, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 10, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("prefetchDataSource", ObjCRuntime.ArgumentSemantic.Weak)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setPrefetchDataSource:", ObjCRuntime.ArgumentSemantic.Weak)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.IUITableViewDataSourcePrefetching</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the prefetch-capable source for this collection view.</summary>
        <value>
          <para>(More documentation for this node is coming)</para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RectForFooterInSection">
      <MemberSignature Language="C#" Value="public virtual CoreGraphics.CGRect RectForFooterInSection (nint section);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype CoreGraphics.CGRect RectForFooterInSection(valuetype System.nint section) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.RectForFooterInSection(System.nint)" />
      <MemberSignature Language="F#" Value="abstract member RectForFooterInSection : nint -&gt; CoreGraphics.CGRect&#xA;override this.RectForFooterInSection : nint -&gt; CoreGraphics.CGRect" Usage="uITableView.RectForFooterInSection section" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("rectForFooterInSection:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>CoreGraphics.CGRect</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="section" Type="System.nint" />
      </Parameters>
      <Docs>
        <param name="section">The index of a section.</param>
        <summary>Returns the drawing area for the specified section's footer.</summary>
        <returns>A rectangle defining where the section footer is drawn by the table view.</returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RectForHeaderInSection">
      <MemberSignature Language="C#" Value="public virtual CoreGraphics.CGRect RectForHeaderInSection (nint section);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype CoreGraphics.CGRect RectForHeaderInSection(valuetype System.nint section) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.RectForHeaderInSection(System.nint)" />
      <MemberSignature Language="F#" Value="abstract member RectForHeaderInSection : nint -&gt; CoreGraphics.CGRect&#xA;override this.RectForHeaderInSection : nint -&gt; CoreGraphics.CGRect" Usage="uITableView.RectForHeaderInSection section" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("rectForHeaderInSection:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>CoreGraphics.CGRect</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="section" Type="System.nint" />
      </Parameters>
      <Docs>
        <param name="section">The index of a section.</param>
        <summary>Returns the drawing area for the specified section's header.</summary>
        <returns>A rectangle defining where the section header is drawn by the table view.</returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RectForRowAtIndexPath">
      <MemberSignature Language="C#" Value="public virtual CoreGraphics.CGRect RectForRowAtIndexPath (Foundation.NSIndexPath indexPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype CoreGraphics.CGRect RectForRowAtIndexPath(class Foundation.NSIndexPath indexPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.RectForRowAtIndexPath(Foundation.NSIndexPath)" />
      <MemberSignature Language="F#" Value="abstract member RectForRowAtIndexPath : Foundation.NSIndexPath -&gt; CoreGraphics.CGRect&#xA;override this.RectForRowAtIndexPath : Foundation.NSIndexPath -&gt; CoreGraphics.CGRect" Usage="uITableView.RectForRowAtIndexPath indexPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("rectForRowAtIndexPath:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>CoreGraphics.CGRect</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indexPath" Type="Foundation.NSIndexPath" />
      </Parameters>
      <Docs>
        <param name="indexPath">An index path to a specific row in the table view.</param>
        <summary>Returns the drawing area for the specified row.</summary>
        <returns>A rectangle defining where the row is drawn by the table view, or <see cref="F:System.Drawing.RectangleF.Empty" /> if the <paramref name="indexPath" /> is not valid.</returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RectForSection">
      <MemberSignature Language="C#" Value="public virtual CoreGraphics.CGRect RectForSection (nint section);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype CoreGraphics.CGRect RectForSection(valuetype System.nint section) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.RectForSection(System.nint)" />
      <MemberSignature Language="F#" Value="abstract member RectForSection : nint -&gt; CoreGraphics.CGRect&#xA;override this.RectForSection : nint -&gt; CoreGraphics.CGRect" Usage="uITableView.RectForSection section" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("rectForSection:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>CoreGraphics.CGRect</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="section" Type="System.nint" />
      </Parameters>
      <Docs>
        <param name="section">The index of a section.</param>
        <summary>Returns the drawing area for the specified section.</summary>
        <returns>A rectangle defining where the section is drawn by the table view.</returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterClassForCellReuse">
      <MemberSignature Language="C#" Value="public void RegisterClassForCellReuse (Type cellType, Foundation.NSString reuseIdentifier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClassForCellReuse(class System.Type cellType, class Foundation.NSString reuseIdentifier) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.RegisterClassForCellReuse(System.Type,Foundation.NSString)" />
      <MemberSignature Language="F#" Value="member this.RegisterClassForCellReuse : Type * Foundation.NSString -&gt; unit" Usage="uITableView.RegisterClassForCellReuse (cellType, reuseIdentifier)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cellType" Type="System.Type" />
        <Parameter Name="reuseIdentifier" Type="Foundation.NSString" />
      </Parameters>
      <Docs>
        <param name="cellType">The type of a UITableViewCell to create when the specified reuseIdentifier is passed to DequeueReusableCell.</param>
        <param name="reuseIdentifier">The reuse identifier.</param>
        <summary>Registers a type to provide UITableViewCells for a specific reuseIdentifier.</summary>
        <remarks>
          <para>
              
              Mono can use this method to register the type of a class
              that should be instantiated if the UITableView needs to
              create a new cell in response to a request in
              DequeueReusableCell for the specified reuseIdentifier.
              
            </para>
          <para>
              
              Registering types with cell identifiers helps reduce the
              amount of code that you have to write in your GetCell
              method.  It means that your GetCell method only needs to
              call DequeueReusableCell with the reuse identifier, and
              if there is no available cell, the UITableView will
              create an instance of the specified type and return it.
              
            </para>
          <para> 
              
              The type that you register must provide a constructor
              that takes an IntPtr constructor and needs to chain to
              the <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=C:UIKit.UITableViewCell(IntPtr)&amp;scope=Xamarin" title="C:UIKit.UITableViewCell(IntPtr)">C:UIKit.UITableViewCell(IntPtr)</a></format>
              constructor.
              
            </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterClassForCellReuse">
      <MemberSignature Language="C#" Value="public void RegisterClassForCellReuse (Type cellType, string reuseIdentifier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClassForCellReuse(class System.Type cellType, string reuseIdentifier) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.RegisterClassForCellReuse(System.Type,System.String)" />
      <MemberSignature Language="F#" Value="member this.RegisterClassForCellReuse : Type * string -&gt; unit" Usage="uITableView.RegisterClassForCellReuse (cellType, reuseIdentifier)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cellType" Type="System.Type" />
        <Parameter Name="reuseIdentifier" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="cellType">To be added.</param>
        <param name="reuseIdentifier">To be added.</param>
        <summary>Registers the <paramref name="cellType" /> type for reuse, keyed by the identifier <paramref name="reuseIdentifier" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterClassForHeaderFooterViewReuse">
      <MemberSignature Language="C#" Value="public void RegisterClassForHeaderFooterViewReuse (Type cellType, Foundation.NSString reuseIdentifier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClassForHeaderFooterViewReuse(class System.Type cellType, class Foundation.NSString reuseIdentifier) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.RegisterClassForHeaderFooterViewReuse(System.Type,Foundation.NSString)" />
      <MemberSignature Language="F#" Value="member this.RegisterClassForHeaderFooterViewReuse : Type * Foundation.NSString -&gt; unit" Usage="uITableView.RegisterClassForHeaderFooterViewReuse (cellType, reuseIdentifier)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cellType" Type="System.Type" />
        <Parameter Name="reuseIdentifier" Type="Foundation.NSString" />
      </Parameters>
      <Docs>
        <param name="cellType">The type of a UIView to create when the specified reuseIdentifier is passed to DequeueReusableCell.</param>
        <param name="reuseIdentifier">The reuse identifier.</param>
        <summary>Registers a type to provide UIViews for headers or footers for a specific reuseIdentifier.</summary>
        <remarks>
          <para>
              
              You can use this method to register the type of a class
              that should be instantiated if the UITableView needs to
              create a new header or footer in response to a request in
              DequeueReusableHeaderFooterView for the specified reuseIdentifier.
              
            </para>
          <para>
              
              Registering types with reuse identifiers helps reduce the
              amount of code that you have to write in your GetFooterView or GetHeaderView methods.
              It means that your code only needs to
              call DequeueReusableHeaderFooterView with the reuse identifier, and
              if there is no available cell, the UITableView will
              create an instance of the specified type and return it.
              
            </para>
          <para> 
              The type that you register must provide a constructor
              that takes an IntPtr constructor and needs to chain to
              the <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=C:UIKit.UIView(IntPtr)&amp;scope=Xamarin" title="C:UIKit.UIView(IntPtr)">C:UIKit.UIView(IntPtr)</a></format>
              constructor.
            </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterClassForHeaderFooterViewReuse">
      <MemberSignature Language="C#" Value="public void RegisterClassForHeaderFooterViewReuse (Type cellType, string reuseIdentifier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClassForHeaderFooterViewReuse(class System.Type cellType, string reuseIdentifier) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.RegisterClassForHeaderFooterViewReuse(System.Type,System.String)" />
      <MemberSignature Language="F#" Value="member this.RegisterClassForHeaderFooterViewReuse : Type * string -&gt; unit" Usage="uITableView.RegisterClassForHeaderFooterViewReuse (cellType, reuseIdentifier)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cellType" Type="System.Type" />
        <Parameter Name="reuseIdentifier" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="cellType">To be added.</param>
        <param name="reuseIdentifier">To be added.</param>
        <summary>Registers the <paramref name="cellType" /> type for reuse, keyed by the identifier <paramref name="reuseIdentifier" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterNibForCellReuse">
      <MemberSignature Language="C#" Value="public virtual void RegisterNibForCellReuse (UIKit.UINib nib, Foundation.NSString reuseIdentifier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterNibForCellReuse(class UIKit.UINib nib, class Foundation.NSString reuseIdentifier) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.RegisterNibForCellReuse(UIKit.UINib,Foundation.NSString)" />
      <MemberSignature Language="F#" Value="abstract member RegisterNibForCellReuse : UIKit.UINib * Foundation.NSString -&gt; unit&#xA;override this.RegisterNibForCellReuse : UIKit.UINib * Foundation.NSString -&gt; unit" Usage="uITableView.RegisterNibForCellReuse (nib, reuseIdentifier)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("registerNib:forCellReuseIdentifier:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nib" Type="UIKit.UINib" />
        <Parameter Name="reuseIdentifier" Type="Foundation.NSString" />
      </Parameters>
      <Docs>
        <param name="nib">
          <para>To be added.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <param name="reuseIdentifier">To be added.</param>
        <summary>Specifies the nib file to use for cells with the specified identifier.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterNibForCellReuse">
      <MemberSignature Language="C#" Value="public void RegisterNibForCellReuse (UIKit.UINib nib, string reuseIdentifier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterNibForCellReuse(class UIKit.UINib nib, string reuseIdentifier) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.RegisterNibForCellReuse(UIKit.UINib,System.String)" />
      <MemberSignature Language="F#" Value="member this.RegisterNibForCellReuse : UIKit.UINib * string -&gt; unit" Usage="uITableView.RegisterNibForCellReuse (nib, reuseIdentifier)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nib" Type="UIKit.UINib" />
        <Parameter Name="reuseIdentifier" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="nib">A nib object created from a nib file. This value cannot be <see langword="null" />.</param>
        <param name="reuseIdentifier">A string to use as an identifier for the cell. This value cannot be <see langword="null" />.</param>
        <summary>Registers a nib object (containing a <see cref="T:UIKit.UITableViewCell" />) with the given identifer string.</summary>
        <remarks>After a nib object has been registered with a table view, calling <see cref="M:UIKit.UITableView.DequeueReusableCell(Foundation.NSString)" /> with the correct identifer will cause the table view to instantiate the cell from the nib object if there is not already an instance in the reuse queue.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterNibForHeaderFooterViewReuse">
      <MemberSignature Language="C#" Value="public virtual void RegisterNibForHeaderFooterViewReuse (UIKit.UINib nib, Foundation.NSString reuseIdentifier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterNibForHeaderFooterViewReuse(class UIKit.UINib nib, class Foundation.NSString reuseIdentifier) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.RegisterNibForHeaderFooterViewReuse(UIKit.UINib,Foundation.NSString)" />
      <MemberSignature Language="F#" Value="abstract member RegisterNibForHeaderFooterViewReuse : UIKit.UINib * Foundation.NSString -&gt; unit&#xA;override this.RegisterNibForHeaderFooterViewReuse : UIKit.UINib * Foundation.NSString -&gt; unit" Usage="uITableView.RegisterNibForHeaderFooterViewReuse (nib, reuseIdentifier)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("registerNib:forHeaderFooterViewReuseIdentifier:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nib" Type="UIKit.UINib" />
        <Parameter Name="reuseIdentifier" Type="Foundation.NSString" />
      </Parameters>
      <Docs>
        <param name="nib">To be added.</param>
        <param name="reuseIdentifier">To be added.</param>
        <summary>Specifies the nib file to use for headers or footers.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterNibForHeaderFooterViewReuse">
      <MemberSignature Language="C#" Value="public void RegisterNibForHeaderFooterViewReuse (UIKit.UINib nib, string reuseIdentifier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterNibForHeaderFooterViewReuse(class UIKit.UINib nib, string reuseIdentifier) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.RegisterNibForHeaderFooterViewReuse(UIKit.UINib,System.String)" />
      <MemberSignature Language="F#" Value="member this.RegisterNibForHeaderFooterViewReuse : UIKit.UINib * string -&gt; unit" Usage="uITableView.RegisterNibForHeaderFooterViewReuse (nib, reuseIdentifier)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nib" Type="UIKit.UINib" />
        <Parameter Name="reuseIdentifier" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="nib">A nib object created from a nib file. This value cannot be <see langword="null" />.</param>
        <param name="reuseIdentifier">To be added.</param>
        <summary>Registers a nib object (containing a <see cref="T:UIKit.UITableViewHeaderFooterView" />) with the given identifier string.</summary>
        <remarks>
          <para>After a nib object has been registered with a table view, as section header and footer views come into view, the appropriate <see cref="T:UIKit.UITableViewHeaderFooterView" />s will be instantiated as necessary from the nib object if there is not already an instance in the reuse queue.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReloadData">
      <MemberSignature Language="C#" Value="public virtual void ReloadData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReloadData() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.ReloadData" />
      <MemberSignature Language="F#" Value="abstract member ReloadData : unit -&gt; unit&#xA;override this.ReloadData : unit -&gt; unit" Usage="uITableView.ReloadData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("reloadData")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reloads the rows and sections in the table view.</summary>
        <remarks>
          <para>This method reloads all the data in the table, including cells, headers, footers and the index array. For efficiency, only visible rows are have their cells loaded and displayed.</para>
          <para>A table view's <see cref="P:UIKit.UITableView.Source" /> calls this method when it wants to completely reload data. This method should not be called inside other methods that insert or delete rows, especially within a <see cref="M:UIKit.UITableView.BeginUpdates" />-<see cref="M:UIKit.UITableView.EndUpdates" /> animation block.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReloadRows">
      <MemberSignature Language="C#" Value="public virtual void ReloadRows (Foundation.NSIndexPath[] atIndexPaths, UIKit.UITableViewRowAnimation withRowAnimation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReloadRows(class Foundation.NSIndexPath[] atIndexPaths, valuetype UIKit.UITableViewRowAnimation withRowAnimation) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.ReloadRows(Foundation.NSIndexPath[],UIKit.UITableViewRowAnimation)" />
      <MemberSignature Language="F#" Value="abstract member ReloadRows : Foundation.NSIndexPath[] * UIKit.UITableViewRowAnimation -&gt; unit&#xA;override this.ReloadRows : Foundation.NSIndexPath[] * UIKit.UITableViewRowAnimation -&gt; unit" Usage="uITableView.ReloadRows (atIndexPaths, withRowAnimation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("reloadRowsAtIndexPaths:withRowAnimation:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="atIndexPaths" Type="Foundation.NSIndexPath[]" />
        <Parameter Name="withRowAnimation" Type="UIKit.UITableViewRowAnimation" />
      </Parameters>
      <Docs>
        <param name="atIndexPaths">An array of <see cref="T:Foundation.NSIndexPath" /> objects that indicate which rows to reload.</param>
        <param name="withRowAnimation">The type of animation to use. The animation chosen affects both the way the old cell is animated out as well as how the new cell is animated into view.</param>
        <summary>Reloads specific rows with the given animation effect.</summary>
        <remarks>
          <para>Reloading a row means the data source is asked for a new cell for that row, which the table animates into place (animating the old cell off screen). Use this method to alert the user that the value of the cell is changing. If notifying the user is not important simply get the cell for a particular row and update its value.</para>
          <para>When this method is called within a <see cref="M:UIKit.UITableView.BeginUpdates" />-<see cref="M:UIKit.UITableView.EndUpdates" /> animation block it behaves like <see cref="M:UIKit.UITableView.DeleteRows(Foundation.NSIndexPath[],UIKit.UITableViewRowAnimation)" /> - the indexes passed to the method are specified in the state of the table view prior to any updates. This happens regardless of the order of the insertion, deletion and reloading method calls within the animation block.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReloadSectionIndexTitles">
      <MemberSignature Language="C#" Value="public virtual void ReloadSectionIndexTitles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReloadSectionIndexTitles() cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.ReloadSectionIndexTitles" />
      <MemberSignature Language="F#" Value="abstract member ReloadSectionIndexTitles : unit -&gt; unit&#xA;override this.ReloadSectionIndexTitles : unit -&gt; unit" Usage="uITableView.ReloadSectionIndexTitles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("reloadSectionIndexTitles")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reloads the index bar long the right edge of a table view.</summary>
        <remarks>Use this method to update the index after inserting or deleting sections, without having to reload the entire table.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReloadSections">
      <MemberSignature Language="C#" Value="public virtual void ReloadSections (Foundation.NSIndexSet sections, UIKit.UITableViewRowAnimation withRowAnimation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReloadSections(class Foundation.NSIndexSet sections, valuetype UIKit.UITableViewRowAnimation withRowAnimation) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.ReloadSections(Foundation.NSIndexSet,UIKit.UITableViewRowAnimation)" />
      <MemberSignature Language="F#" Value="abstract member ReloadSections : Foundation.NSIndexSet * UIKit.UITableViewRowAnimation -&gt; unit&#xA;override this.ReloadSections : Foundation.NSIndexSet * UIKit.UITableViewRowAnimation -&gt; unit" Usage="uITableView.ReloadSections (sections, withRowAnimation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("reloadSections:withRowAnimation:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sections" Type="Foundation.NSIndexSet" />
        <Parameter Name="withRowAnimation" Type="UIKit.UITableViewRowAnimation" />
      </Parameters>
      <Docs>
        <param name="sections">The sections to be reloaded.</param>
        <param name="withRowAnimation">Specifies which animation effect to use. This determines how the old sections are animated out as well as how the new sections are animated into view.</param>
        <summary>Reloads specific sections with an animation effect.</summary>
        <remarks>
          <para>Reloading a section means the data source is asked for news cell for the specified sections, which the table animates into place (animating the old cells off screen). Use this method to alert the user that the cells in the given sections are changing. If notifying the user is not important simply get the relevant cells and update their values directly.</para>
          <para>When this method is called within a <see cref="M:UIKit.UITableView.BeginUpdates" />-<see cref="M:UIKit.UITableView.EndUpdates" /> animation block it behaves like <see cref="M:UIKit.UITableView.DeleteRows(Foundation.NSIndexPath[],UIKit.UITableViewRowAnimation)" /> - the indexes passed to the method are specified in the state of the table view prior to any updates. This happens regardless of the order of the insertion, deletion and reloading method calls within the animation block.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemembersLastFocusedIndexPath">
      <MemberSignature Language="C#" Value="public virtual bool RemembersLastFocusedIndexPath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RemembersLastFocusedIndexPath" />
      <MemberSignature Language="DocId" Value="P:UIKit.UITableView.RemembersLastFocusedIndexPath" />
      <MemberSignature Language="F#" Value="member this.RemembersLastFocusedIndexPath : bool with get, set" Usage="UIKit.UITableView.RemembersLastFocusedIndexPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("remembersLastFocusedIndexPath")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setRemembersLastFocusedIndexPath:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a Boolean value that controls whther the table view will return focus to the most recently focused index path.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RowHeight">
      <MemberSignature Language="C#" Value="public virtual nfloat RowHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.nfloat RowHeight" />
      <MemberSignature Language="DocId" Value="P:UIKit.UITableView.RowHeight" />
      <MemberSignature Language="F#" Value="member this.RowHeight : nfloat with get, set" Usage="UIKit.UITableView.RowHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("rowHeight")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setRowHeight:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.nfloat</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The height of each row in this UITableView.</summary>
        <value>Row height in points.</value>
        <remarks>
          <para>This property can be set if the <see cref="M:UIKit.UITableViewSource.GetHeightForRow(UIKit.UITableView,Foundation.NSIndexPath)" /> has not been implemented. If the row height is not set explicity the table view uses a default value.</para>
          <para>There are performance implications to using <see cref="M:UIKit.UITableViewSource.GetHeightForRow(UIKit.UITableView,Foundation.NSIndexPath)" /> instead of this property: every time a table view is displayed it calls <see cref="M:UIKit.UITableViewSource.GetHeightForRow(UIKit.UITableView,Foundation.NSIndexPath)" /> for each of its rows. This can result in poor performance when the table has a large number of rows (for example, 1000 rows or more).</para>
          <para>If every row in a table has the same height, use this property. If rows have different heights (for example, they are sized around a variable amount of text) then <see cref="M:UIKit.UITableViewSource.GetHeightForRow(UIKit.UITableView,Foundation.NSIndexPath)" /> is more appropriate.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToNearestSelected">
      <MemberSignature Language="C#" Value="public virtual void ScrollToNearestSelected (UIKit.UITableViewScrollPosition atScrollPosition, bool animated);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ScrollToNearestSelected(valuetype UIKit.UITableViewScrollPosition atScrollPosition, bool animated) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.ScrollToNearestSelected(UIKit.UITableViewScrollPosition,System.Boolean)" />
      <MemberSignature Language="F#" Value="abstract member ScrollToNearestSelected : UIKit.UITableViewScrollPosition * bool -&gt; unit&#xA;override this.ScrollToNearestSelected : UIKit.UITableViewScrollPosition * bool -&gt; unit" Usage="uITableView.ScrollToNearestSelected (atScrollPosition, animated)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("scrollToNearestSelectedRowAtScrollPosition:animated:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="atScrollPosition" Type="UIKit.UITableViewScrollPosition" />
        <Parameter Name="animated" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="atScrollPosition">Position that the target row should appear (e. top, middle, bottom) once the scrolling is complete.</param>
        <param name="animated">
          <paramref name="true" /> to animate the scroll,  <paramref name="false" /> if the table view should just jump immediately to the new position.</param>
        <summary>Automatically scrolls the rows so that the selected row nearest to a given position is moved to that position.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToRow">
      <MemberSignature Language="C#" Value="public virtual void ScrollToRow (Foundation.NSIndexPath indexPath, UIKit.UITableViewScrollPosition atScrollPosition, bool animated);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ScrollToRow(class Foundation.NSIndexPath indexPath, valuetype UIKit.UITableViewScrollPosition atScrollPosition, bool animated) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.ScrollToRow(Foundation.NSIndexPath,UIKit.UITableViewScrollPosition,System.Boolean)" />
      <MemberSignature Language="F#" Value="abstract member ScrollToRow : Foundation.NSIndexPath * UIKit.UITableViewScrollPosition * bool -&gt; unit&#xA;override this.ScrollToRow : Foundation.NSIndexPath * UIKit.UITableViewScrollPosition * bool -&gt; unit" Usage="uITableView.ScrollToRow (indexPath, atScrollPosition, animated)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("scrollToRowAtIndexPath:atScrollPosition:animated:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indexPath" Type="Foundation.NSIndexPath" />
        <Parameter Name="atScrollPosition" Type="UIKit.UITableViewScrollPosition" />
        <Parameter Name="animated" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="indexPath">Identifies which row should appear <paramref name="atScrollPosition" />.   You can pass <see cref="F:Foundation.NSRange.NotFound" /> to scroll to a section with zero rows.</param>
        <param name="atScrollPosition">Position that the target row should appear (e. top, middle, bottom) once the scrolling is complete.</param>
        <param name="animated">
          <paramref name="true" /> to animate the scroll,  <paramref name="false" /> if the table view should just jump immediately to the new position.</param>
        <summary>Automatically scrolls the table view until the specified row appears in the required position.</summary>
        <remarks>Calling this method does not trigger <see cref="M:UIKit.UIScrollViewDelegate.Scrolled(UIKit.UIScrollView)" />, which would normally occur after a programmatically-invoked UI operation.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SectionFooterHeight">
      <MemberSignature Language="C#" Value="public virtual nfloat SectionFooterHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.nfloat SectionFooterHeight" />
      <MemberSignature Language="DocId" Value="P:UIKit.UITableView.SectionFooterHeight" />
      <MemberSignature Language="F#" Value="member this.SectionFooterHeight : nfloat with get, set" Usage="UIKit.UITableView.SectionFooterHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("sectionFooterHeight")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setSectionFooterHeight:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.nfloat</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The height of section foots in this UITableView.</summary>
        <value>Height in points.</value>
        <remarks>This property is used only in section group tables, and only if <see cref="M:UIKit.UITableViewSource.GetHeightForFooter(UIKit.UITableView,System.nint)" /> has not been implemented.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SectionHeaderHeight">
      <MemberSignature Language="C#" Value="public virtual nfloat SectionHeaderHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.nfloat SectionHeaderHeight" />
      <MemberSignature Language="DocId" Value="P:UIKit.UITableView.SectionHeaderHeight" />
      <MemberSignature Language="F#" Value="member this.SectionHeaderHeight : nfloat with get, set" Usage="UIKit.UITableView.SectionHeaderHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("sectionHeaderHeight")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setSectionHeaderHeight:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.nfloat</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The height of section headers in this UITableView.</summary>
        <value>Height in points.</value>
        <remarks>This property is used only in section group tables, and only if <see cref="M:UIKit.UITableViewSource.GetHeightForHeader(UIKit.UITableView,System.nint)" /> has not been implemented.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SectionIndexBackgroundColor">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIColor SectionIndexBackgroundColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIColor SectionIndexBackgroundColor" />
      <MemberSignature Language="DocId" Value="P:UIKit.UITableView.SectionIndexBackgroundColor" />
      <MemberSignature Language="F#" Value="member this.SectionIndexBackgroundColor : UIKit.UIColor with get, set" Usage="UIKit.UITableView.SectionIndexBackgroundColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("sectionIndexBackgroundColor", ObjCRuntime.ArgumentSemantic.Strong)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setSectionIndexBackgroundColor:", ObjCRuntime.ArgumentSemantic.Strong)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIColor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The color used for the background of this UITableView's section index when it is not being touched.</summary>
        <value>
          <para>(More documentation for this node is coming)</para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>
          <para id="tool-remark">This member participates in the <see cref="T:UIKit.UIAppearance" /> styling system.  See the <see cref="P:UIKit.UITableView.Appearance" /> property and the <see cref="M:UIKit.UITableView.AppearanceWhenContainedIn(System.Type[])" /> method.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SectionIndexColor">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIColor SectionIndexColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIColor SectionIndexColor" />
      <MemberSignature Language="DocId" Value="P:UIKit.UITableView.SectionIndexColor" />
      <MemberSignature Language="F#" Value="member this.SectionIndexColor : UIKit.UIColor with get, set" Usage="UIKit.UITableView.SectionIndexColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("sectionIndexColor", ObjCRuntime.ArgumentSemantic.Strong)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setSectionIndexColor:", ObjCRuntime.ArgumentSemantic.Strong)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIColor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The color used for the index text of this UITableView.</summary>
        <value>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>
          <para id="tool-remark">This member participates in the <see cref="T:UIKit.UIAppearance" /> styling system.  See the <see cref="P:UIKit.UITableView.Appearance" /> property and the <see cref="M:UIKit.UITableView.AppearanceWhenContainedIn(System.Type[])" /> method.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SectionIndexMinimumDisplayRowCount">
      <MemberSignature Language="C#" Value="public virtual nint SectionIndexMinimumDisplayRowCount { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.nint SectionIndexMinimumDisplayRowCount" />
      <MemberSignature Language="DocId" Value="P:UIKit.UITableView.SectionIndexMinimumDisplayRowCount" />
      <MemberSignature Language="F#" Value="member this.SectionIndexMinimumDisplayRowCount : nint with get, set" Usage="UIKit.UITableView.SectionIndexMinimumDisplayRowCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("sectionIndexMinimumDisplayRowCount")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setSectionIndexMinimumDisplayRowCount:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.nint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The number of rows required in a table view before the index list is displayed.</summary>
        <value>The default value is 0.</value>
        <remarks>Only <see cref="T:UIKit.UITableViewStyle" />.Plain styled tables should have an index. </remarks>
      </Docs>
    </Member>
    <Member MemberName="SectionIndexTrackingBackgroundColor">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIColor SectionIndexTrackingBackgroundColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIColor SectionIndexTrackingBackgroundColor" />
      <MemberSignature Language="DocId" Value="P:UIKit.UITableView.SectionIndexTrackingBackgroundColor" />
      <MemberSignature Language="F#" Value="member this.SectionIndexTrackingBackgroundColor : UIKit.UIColor with get, set" Usage="UIKit.UITableView.SectionIndexTrackingBackgroundColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("sectionIndexTrackingBackgroundColor", ObjCRuntime.ArgumentSemantic.Strong)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setSectionIndexTrackingBackgroundColor:", ObjCRuntime.ArgumentSemantic.Strong)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIColor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies the background color of the index as the application user drags.</summary>
        <value>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>
          <para id="tool-remark">This member participates in the <see cref="T:UIKit.UIAppearance" /> styling system.  See the <see cref="P:UIKit.UITableView.Appearance" /> property and the <see cref="M:UIKit.UITableView.AppearanceWhenContainedIn(System.Type[])" /> method.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionDidChangeNotification">
      <MemberSignature Language="C#" Value="public static Foundation.NSString SelectionDidChangeNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSString SelectionDidChangeNotification" />
      <MemberSignature Language="DocId" Value="P:UIKit.UITableView.SelectionDidChangeNotification" />
      <MemberSignature Language="F#" Value="member this.SelectionDidChangeNotification : Foundation.NSString" Usage="UIKit.UITableView.SelectionDidChangeNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Advice("Use UITableView.Notifications.ObserveSelectionDidChange helper method instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Field("UITableViewSelectionDidChangeNotification", "UIKit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for SelectionDidChange</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIKit.UITableView.Notifications" />.<see cref="M:UIKit.UITableView.Notifications.ObserveSelectionDidChange*" /> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="C#"><![CDATA[
//
// Lambda style
//

// listening
notification = UITableView.Notifications.ObserveSelectionDidChange ((sender, args) => {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, Foundation.NSNotificationEventArgs args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UITableView.Notifications.ObserveSelectionDidChange (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}]]></code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="C#"><![CDATA[
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UITableView.SelectionDidChangeNotification, (notification) => {Console.WriteLine ("Received the notification UITableView", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UITableView", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UITableView.SelectionDidChangeNotification, Callback);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectRow">
      <MemberSignature Language="C#" Value="public virtual void SelectRow (Foundation.NSIndexPath indexPath, bool animated, UIKit.UITableViewScrollPosition scrollPosition);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SelectRow(class Foundation.NSIndexPath indexPath, bool animated, valuetype UIKit.UITableViewScrollPosition scrollPosition) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.SelectRow(Foundation.NSIndexPath,System.Boolean,UIKit.UITableViewScrollPosition)" />
      <MemberSignature Language="F#" Value="abstract member SelectRow : Foundation.NSIndexPath * bool * UIKit.UITableViewScrollPosition -&gt; unit&#xA;override this.SelectRow : Foundation.NSIndexPath * bool * UIKit.UITableViewScrollPosition -&gt; unit" Usage="uITableView.SelectRow (indexPath, animated, scrollPosition)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("selectRowAtIndexPath:animated:scrollPosition:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indexPath" Type="Foundation.NSIndexPath" />
        <Parameter Name="animated" Type="System.Boolean" />
        <Parameter Name="scrollPosition" Type="UIKit.UITableViewScrollPosition" />
      </Parameters>
      <Docs>
        <param name="indexPath">
          <para>Identifies the row to be selected.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <param name="animated">
          <see langword="true" /> to animate the selection and position change, <see langword="false" /> if the change should occur immediately.</param>
        <param name="scrollPosition">Position that the selected row should be scrolled to (top, middle, bottom).</param>
        <summary>Selects the given row, optionall scrolling the row to a specific location.</summary>
        <remarks>
          <para>Calling this method does not trigger <see cref="M:UIKit.UITableViewSource.WillSelectRow(UIKit.UITableView,Foundation.NSIndexPath)" /> nor will it send <see cref="P:UIKit.UITableView.SelectionDidChangeNotification" /> notifications.</para>
        </remarks>
        <example>
          <para>Passing <see cref="F:UIKit.UITableViewScrollPosition.None" />. will result in no scrolling (despite that constant normally causing minimal scrolling). To scroll to the newly selected row with minimum scrolling, select the row using this method with <see cref="F:UIKit.UITableViewScrollPosition.None" /> then call <see cref="M:UIKit.UITableView.ScrollToRow(Foundation.NSIndexPath,UIKit.UITableViewScrollPosition,System.Boolean)" /> also with <see cref="F:UIKit.UITableViewScrollPosition.None" />.</para>
          <code lang="C#"><![CDATA[
              NSIndexPath rowToSelect; // assume this is valid
              UITableView myTableView; // assume this is valid
              
              myTableView.SelectRow (rowToSelect, true, UITableViewScrollPosition.None);
              myTableView.ScrollToRow (rowToSelect, UITableViewScrollPosition.None, true);
            ]]></code>
        </example>
      </Docs>
    </Member>
    <Member MemberName="SeparatorColor">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIColor SeparatorColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIColor SeparatorColor" />
      <MemberSignature Language="DocId" Value="P:UIKit.UITableView.SeparatorColor" />
      <MemberSignature Language="F#" Value="member this.SeparatorColor : UIKit.UIColor with get, set" Usage="UIKit.UITableView.SeparatorColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("separatorColor", ObjCRuntime.ArgumentSemantic.Strong)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setSeparatorColor:", ObjCRuntime.ArgumentSemantic.Strong)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIColor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The color of the separator between rows in the table view.</summary>
        <value>
          <para>The default color is grey.</para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>
          <para id="tool-remark">This member participates in the <see cref="T:UIKit.UIAppearance" /> styling system.  See the <see cref="P:UIKit.UITableView.Appearance" /> property and the <see cref="M:UIKit.UITableView.AppearanceWhenContainedIn(System.Type[])" /> method.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SeparatorEffect">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIVisualEffect SeparatorEffect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIVisualEffect SeparatorEffect" />
      <MemberSignature Language="DocId" Value="P:UIKit.UITableView.SeparatorEffect" />
      <MemberSignature Language="F#" Value="member this.SeparatorEffect : UIKit.UIVisualEffect with get, set" Usage="UIKit.UITableView.SeparatorEffect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("separatorEffect", ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setSeparatorEffect:", ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIVisualEffect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The <see cref="T:UIKit.UIVisualEffect" /> to be used on table separators.</summary>
        <value>
          <para>(More documentation for this node is coming)</para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>
          <para id="tool-remark">This member participates in the <see cref="T:UIKit.UIAppearance" /> styling system.  See the <see cref="P:UIKit.UITableView.Appearance" /> property and the <see cref="M:UIKit.UITableView.AppearanceWhenContainedIn(System.Type[])" /> method.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SeparatorInset">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIEdgeInsets SeparatorInset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype UIKit.UIEdgeInsets SeparatorInset" />
      <MemberSignature Language="DocId" Value="P:UIKit.UITableView.SeparatorInset" />
      <MemberSignature Language="F#" Value="member this.SeparatorInset : UIKit.UIEdgeInsets with get, set" Usage="UIKit.UITableView.SeparatorInset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("separatorInset")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setSeparatorInset:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIEdgeInsets</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The default inset of cell separators.</summary>
        <value>To be added.</value>
        <remarks>
          <para id="tool-remark">This member participates in the <see cref="T:UIKit.UIAppearance" /> styling system.  See the <see cref="P:UIKit.UITableView.Appearance" /> property and the <see cref="M:UIKit.UITableView.AppearanceWhenContainedIn(System.Type[])" /> method.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SeparatorInsetReference">
      <MemberSignature Language="C#" Value="public virtual UIKit.UITableViewSeparatorInsetReference SeparatorInsetReference { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype UIKit.UITableViewSeparatorInsetReference SeparatorInsetReference" />
      <MemberSignature Language="DocId" Value="P:UIKit.UITableView.SeparatorInsetReference" />
      <MemberSignature Language="F#" Value="member this.SeparatorInsetReference : UIKit.UITableViewSeparatorInsetReference with get, set" Usage="UIKit.UITableView.SeparatorInsetReference" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.TvOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("separatorInsetReference", ObjCRuntime.ArgumentSemantic.UnsafeUnretained)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setSeparatorInsetReference:", ObjCRuntime.ArgumentSemantic.UnsafeUnretained)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UITableViewSeparatorInsetReference</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that controls how <see cref="P:UIKit.UITableView.SeparatorInset" /> is interpreted.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SeparatorStyle">
      <MemberSignature Language="C#" Value="public virtual UIKit.UITableViewCellSeparatorStyle SeparatorStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype UIKit.UITableViewCellSeparatorStyle SeparatorStyle" />
      <MemberSignature Language="DocId" Value="P:UIKit.UITableView.SeparatorStyle" />
      <MemberSignature Language="F#" Value="member this.SeparatorStyle : UIKit.UITableViewCellSeparatorStyle with get, set" Usage="UIKit.UITableView.SeparatorStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("separatorStyle")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setSeparatorStyle:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UITableViewCellSeparatorStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The style of the separator between rows in the table view.</summary>
        <value>.</value>
        <remarks>UITableView uses this property to set the separator style on cells returned by <see cref="M:UIKit.UITableViewSource.GetCell(UIKit.UITableView,Foundation.NSIndexPath)" /></remarks>
      </Docs>
    </Member>
    <Member MemberName="SetEditing">
      <MemberSignature Language="C#" Value="public virtual void SetEditing (bool editing, bool animated);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetEditing(bool editing, bool animated) cil managed" />
      <MemberSignature Language="DocId" Value="M:UIKit.UITableView.SetEditing(System.Boolean,System.Boolean)" />
      <MemberSignature Language="F#" Value="abstract member SetEditing : bool * bool -&gt; unit&#xA;override this.SetEditing : bool * bool -&gt; unit" Usage="uITableView.SetEditing (editing, animated)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("setEditing:animated:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="editing" Type="System.Boolean" />
        <Parameter Name="animated" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="editing">
          <see langword="true" /> to enter editing mode, <see langword="false" /> to end editing. The default is <see langword="false" />.</param>
        <param name="animated">
          <see langword="true" /> to animate the transition to or from editing mode, or <see langword="false" /> to change modes immediately.</param>
        <summary>Turns editing mode on or off.</summary>
        <remarks>
          <para>Calling this method with  <paramref name="editing" /> == <see langword="true" />, the table view enters editing mode and calls <see cref="M:UIKit.UITableViewCell.SetEditing(System.Boolean,System.Boolean)" /> on each visible row's <see cref="T:UIKit.UITableViewCell" /> object.</para>
          <para>In editing mode the cells might show </para>
          <para>The <see cref="T:UIKit.UITableViewSource" /> (or <see cref="P:UIKit.UITableView.DataSource" />) can selectively exclude cells from editing mode by returning <see langword="false" /> from <see cref="M:UIKit.UITableViewSource.CanEditRow(UIKit.UITableView,Foundation.NSIndexPath)" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public UIKit.UITableViewSource Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UITableViewSource Source" />
      <MemberSignature Language="DocId" Value="P:UIKit.UITableView.Source" />
      <MemberSignature Language="F#" Value="member this.Source : UIKit.UITableViewSource with get, set" Usage="UIKit.UITableView.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>UIKit.UITableViewSource</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A MonoTouch-specific feature that uses a <see cref="T:UIKit.UITableViewSource" /> subclass to act as both <see cref="P:UIKit.UITableView.Delegate" /> or <see cref="P:UIKit.UITableView.DataSource" />.</summary>
        <value>A class that can behave as both <see cref="P:UIKit.UITableView.Delegate" /> and <see cref="P:UIKit.UITableView.DataSource" /> for the table view.</value>
        <remarks>
          <para>MonoTouch provides the <see cref="T:UIKit.UITableViewSource" /> class as an alternative to implementing both <see cref="T:UIKit.UITableViewDataSource" /> and <see cref="T:UIKit.UITableViewDelegate" />. If a subclass of <see cref="T:UIKit.UITableViewSource" /> is created and assigned to this property, the <see cref="P:UIKit.UITableView.DataSource" /> and <see cref="P:UIKit.UITableView.Delegate" /> properties should not be set.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SpringLoaded">
      <MemberSignature Language="C#" Value="public virtual bool SpringLoaded { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SpringLoaded" />
      <MemberSignature Language="DocId" Value="P:UIKit.UITableView.SpringLoaded" />
      <MemberSignature Language="F#" Value="member this.SpringLoaded : bool with get, set" Usage="UIKit.UITableView.SpringLoaded" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:UIKit.IUISpringLoadedInteractionSupporting.SpringLoaded</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("isSpringLoaded")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setSpringLoaded:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs tool="CopiedFromAncestor">
        <summary>Gets or sets a Boolean value that controls whether the object participates in spring-loaded interactions.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Style">
      <MemberSignature Language="C#" Value="public virtual UIKit.UITableViewStyle Style { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype UIKit.UITableViewStyle Style" />
      <MemberSignature Language="DocId" Value="P:UIKit.UITableView.Style" />
      <MemberSignature Language="F#" Value="member this.Style : UIKit.UITableViewStyle" Usage="UIKit.UITableView.Style" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("style")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UITableViewStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns the style of the table view (read-only).</summary>
        <value>
        </value>
        <remarks>A table view's style is set in the constructor and cannot be changed.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TableFooterView">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIView TableFooterView { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIView TableFooterView" />
      <MemberSignature Language="DocId" Value="P:UIKit.UITableView.TableFooterView" />
      <MemberSignature Language="F#" Value="member this.TableFooterView : UIKit.UIView with get, set" Usage="UIKit.UITableView.TableFooterView" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("tableFooterView", ObjCRuntime.ArgumentSemantic.Strong)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setTableFooterView:", ObjCRuntime.ArgumentSemantic.Strong)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns a view that is displayed below the table view.</summary>
        <value>
          <para>The default value is <see langword="null" />.</para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>The table footer view is different to a section footer.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TableHeaderView">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIView TableHeaderView { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIView TableHeaderView" />
      <MemberSignature Language="DocId" Value="P:UIKit.UITableView.TableHeaderView" />
      <MemberSignature Language="F#" Value="member this.TableHeaderView : UIKit.UIView with get, set" Usage="UIKit.UITableView.TableHeaderView" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("tableHeaderView", ObjCRuntime.ArgumentSemantic.Strong)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setTableHeaderView:", ObjCRuntime.ArgumentSemantic.Strong)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns a view that is displayed above the table view.</summary>
        <value>
          <para>The default value is <see langword="null" />.</para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>The table header view is different from a section header.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisibleCells">
      <MemberSignature Language="C#" Value="public virtual UIKit.UITableViewCell[] VisibleCells { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UITableViewCell[] VisibleCells" />
      <MemberSignature Language="DocId" Value="P:UIKit.UITableView.VisibleCells" />
      <MemberSignature Language="F#" Value="member this.VisibleCells : UIKit.UITableViewCell[]" Usage="UIKit.UITableView.VisibleCells" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("visibleCells")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UITableViewCell[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns an array of <see cref="T:UIKit.UITableViewCell" /> that are currently visible in the table view.</summary>
        <value>An array containing <see cref="T:UIKit.UITableViewCell" /> corresponding to the visible rows in the table view.</value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WeakDataSource">
      <MemberSignature Language="C#" Value="public virtual Foundation.NSObject WeakDataSource { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Foundation.NSObject WeakDataSource" />
      <MemberSignature Language="DocId" Value="P:UIKit.UITableView.WeakDataSource" />
      <MemberSignature Language="F#" Value="member this.WeakDataSource : Foundation.NSObject with get, set" Usage="UIKit.UITableView.WeakDataSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("dataSource", ObjCRuntime.ArgumentSemantic.UnsafeUnretained)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setDataSource:", ObjCRuntime.ArgumentSemantic.UnsafeUnretained)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The data source for this UITableView. </summary>
        <value>
          <para>(More documentation for this node is coming)</para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WeakDelegate">
      <MemberSignature Language="C#" Value="public virtual Foundation.NSObject WeakDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Foundation.NSObject WeakDelegate" />
      <MemberSignature Language="DocId" Value="P:UIKit.UITableView.WeakDelegate" />
      <MemberSignature Language="F#" Value="member this.WeakDelegate : Foundation.NSObject with get, set" Usage="UIKit.UITableView.WeakDelegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("delegate", ObjCRuntime.ArgumentSemantic.UnsafeUnretained)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setDelegate:", ObjCRuntime.ArgumentSemantic.UnsafeUnretained)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An object that can respond to the delegate protocol for this type</summary>
        <value>The instance that will respond to events and data requests.</value>
        <remarks>
          <para>The delegate instance assigned to this object will be used to handle events or provide data on demand to this class.</para>
          <para>When setting the Delegate or WeakDelegate values events will be delivered to the specified instance instead of being delivered to the C#-style events</para>
          <para>   Methods must be decorated with the [Export ("selectorName")] attribute to respond to each method from the protocol.   Alternatively use the Delegate method which is strongly typed and does not require the [Export] attributes on methods.</para>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
