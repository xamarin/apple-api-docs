<Type Name="UIResponder" FullName="UIKit.UIResponder">
  <TypeSignature Language="C#" Value="public class UIResponder : Foundation.NSObject, IDisposable, UIKit.IUIPasteConfigurationSupporting" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit UIResponder extends Foundation.NSObject implements class ObjCRuntime.INativeObject, class System.IDisposable, class UIKit.IUIPasteConfigurationSupporting" />
  <AssemblyInfo>
    <AssemblyName>Xamarin.iOS</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Foundation.NSObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>UIKit.IUIPasteConfigurationSupporting</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>Foundation.Register("UIResponder", true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Base class for objects that respond or handle events.</summary>
    <remarks>
      <para>
        
        This is the base class for <see cref="T:UIKit.UIView" /> (and by extension, <see cref="T:UIKit.UIWindow" />), <see cref="T:UIKit.UIViewController" /> and <see cref="T:UIKit.UIApplication" />.
      </para>
      <format type="text/html">
        <h4>Responder Chain</h4>
      </format>
      <para>
        
        iOS implements a responder chain that allows various events
        (Touch events, device motion events, actions and menu editing
        options) to be handled at various levels depending on who is
        interested in handling the event.  
      </para>
      <para>
        
        When a touch takes place, the operating system packages the
        event and processes it like this:
        <img href="UIResponderChain.png" /></para>
      <list type="number">
        <item>
          <term>
            The <see cref="T:UIKit.UIView" /> where the touch took place is determined by using the <see cref="M:UIKit.UIView.HitTest(System.Drawing.PointF, UIKit.UIEvent" /> 
            and the touch is sent to that view.   
          </term>
        </item>
        <item>
          <term>
            
            If the view did not handle the event, the message is sents
            to its <see cref="T:UIKit.UIViewController" /> if
            there is one, or to its <see cref="P:UIKit.UIView.SuperView" /> if there is no
            view controller.
            
          </term>
        </item>
        <item>
          <term>
            The process is repeated for each superview, until it reaches the topmost <see cref="T:UIKit.UIWindow" />.
          </term>
        </item>
        <item>
          <term>
            If the topmost UIWindow does not handle the event, the message is sent to the <see cref="T:UIKit.UIApplication" />.
          </term>
        </item>
      </list>
      <para>
        
        To receive messages UIResponders override the <see cref="P:UIKit.UIResponder.CanBecomeFirstResponder" />
        property to return true and are notified that they became the
        first responder when the <see cref="M:UIKit.UIResponder.BecomeFirstResponder()" />
        is invoked.  The system calls <see cref="M:UIKit.UIResponder.ResignFirstResponder()" />
        to notify a the first responder that the first responder is
        changing.  Text input responders will typically override both
        methods to activate and deactivate the virtual keyboard.
        
      </para>
      <para>
        
        For action messages, editing menu messages, remote events and
        motion events are sent to the designated first responder.
        These events, if they are not handled are bubbled up the
        responder chain by sending the message to the <see cref="P:UIKit.UIResponder.NextResponder" />.
        Developers that override any of the UIResponder methods for
        these kinds of events should avoid directly calling the
        NextResponder methods, instead they should just call the base
        implementation which takes care of the proper event bubbling.
        
      </para>
      <format type="text/html">
        <h4>Touch Events</h4>
      </format>
      <para>
        When an event is delivered to the topmost <see cref="T:UIKit.UIView" />, if the event is not
        handled, it is sent to its container recursively.  The
        container can be a<see cref="T:UIKit.UIView" />, a
        <see cref="T:UIKit.UIWindow" />, a <see cref="T:UIKit.UIViewController" /> or the <see cref="T:UIKit.UIApplication" />.  This allows
        developers to override the event handling methods at the level
        that is most convenient for them.   
      </para>
      <para>
        iOS creates a <see cref="T:UIKit.UIEvent" /> object any time a
        finger touches the screen, moves or is removed from the
        screen.  The touch events are processed by the UIResponder by calling one of <see cref="M:UIKit.UIResponder.TouchesBegan" />, <see cref="M:UIKit.UIResponder.TouchesMoved" />, <see cref="M:UIKit.UIResponder.TouchesEnded" />, and <see cref="M:UIKit.UIResponder.TouchesCancelled" />.
      </para>
      <para>
        An <see cref="T:UIKit.UIEvent" /> encapsulates all of the
        touches that are taking place on the screen at this point,
        even those that do not belong to the particular view.  In addition to
        the <see cref="T:UIKit.UIEvent" />, an <see cref="T:Foundation.NSSet" /> containing
        <see cref="T:UIKit.UITouch" /> objects that represent the state of
        each finger on the screen is sent to the various Touch methods.  
      </para>
      <para>
        It is considered a good coding practice to override all of the
        touch event methods.  If your application is tracking state in
        response to a <see cref="M:UIKit.UIResponder.TouchesBegan(Foundation.NSSet, UIKit.UIEvent)" /> or a <see cref="M:UIKit.UIResponder.TouchesMoved(Foundation.NSSet , UIKit.UIEvent)" /> they should reset their state on the <see cref="M:UIKit.UIResponder.TouchesEnded(Foundation.NSSet, UIKit.UIEvent)" /> and <see cref="M:UIKit.UIResponder.TouchesCancelled(Foundation.NSSet, UIKit.UIEvent)" /> methods.
      </para>
      <format type="text/html">
        <h4>Motion Events</h4>
      </format>
      <para>
        Device motion events are also delivered to UIResponders.
        These are generated when the device moves (shakes).  The
        operating system calls the <see cref="M:UIKit.UIResponder.MotionBegan(UIKit.UIEventSubtype, UIKit.UIEvent)" />
        when the motion begins, the <see cref="M:UIKit.UIResponder.MotionCancelled(UIKit.UIEventSubtype, UIKit.UIEvent)" />
        if the motion event is cancelled, and <see cref="M:UIKit.UIResponder.MotionEnded(UIKit.UIEventSubtype, UIKit.UIEvent)" />
        when the shaking stops.   Shakes are aggregated.
      </para>
      <para>
        In particular, <see cref="T:UIKit.UIView" /> bubbles
        the events up the responder chain.
      </para>
      <para>
        Just like touch events, developers that override these methods
        are encouraged to override them all and ensure that any
        resources allocated during an initial motion event are
        properly disposed either during the MotionENded or
        MotionCancelled methods.
      </para>
      <format type="text/html">
        <h4>Standard Edit Actions</h4>
      </format>
      <para>
        The following methods are part of the standard edit protocol.
        You can implement these in your UIResponder to participate in
        these standard operations: <see cref="M:UIKit.UIResponder.Copy(Foundation.NSObject)" />, <see cref="M:UIKit.UIResponder.Cut(Foundation.NSObject)" />, <see cref="M:UIKit.UIResponder.Delete(Foundation.NSObject)" />, <see cref="M:UIKit.UIResponder.Select(Foundation.NSObject)" />, <see cref="M:UIKit.UIResponder.SelectAll(Foundation.NSObject)" /> and <see cref="M:UIKit.UIResponder.Paste(Foundation.NSObject)" />.
      </para>
      <para>
        The following methods are used to change the styling of text:
        <see cref="M:UIKit.UIResponder.ToggleBoldface(Foundation.NSObject)" />,
        <see cref="M:UIKit.UIResponder.ToggleItalics(Foundation.NSObject)" /> and
        <see cref="M:UIKit.UIResponder.ToggleUnderline(Foundation.NSObject)" />.
      </para>
      <para>
        
        If you are implementing a UIResponder subclass (like your own
        UIView) and you want it to display the standard editing menu,
        you must: override <see cref="P:UIKit.UIResponder.CanBecomeFirstResponder" />
        and return true, override the <see cref="M:UIKit.UIResponder.CanPerform" /> method and
        return true for all actions that you support and override the
        methods that actually carry out the action (the ones listed in
        "Standard Edit Actions" above)
        
      </para>
      <example>
        <code lang="C#"><![CDATA[
          //
          // Selectable label: a label that shows the "Copy" menu when the user
          // long presses
          //
          public class SelectableLabel : UILabel {
          
          public SelectableLabel (RectangleF rect) : base (rect)
          {
          UserInteractionEnabled = true;
          var gesture = new UILongPressGestureRecognizer (LongPress);
          AddGestureRecognizer (gesture);
          }
          
          void LongPress (UILongPressGestureRecognizer r)
          {
          var location = r.LocationInView (r.View);
          var menu = UIMenuController.SharedMenuController;
          
          r.View.BecomeFirstResponder ();
          
          menu.SetTargetRect (r.View.Frame, r.View);
          menu.SetMenuVisible (true, true);
          }
          
          
          public override bool CanBecomeFirstResponder { 
          get { return true; } 
          }
          
          Selector copyAction = new Selector ("copy");
          
          public override bool CanPerform (Selector action, NSObject withSender)
          {
          if (action == copyAction);
          return true;
          return false;
          }
          
          public override void Copy (NSObject sender)
          {
          UIPasteboard.General.String = this.Text;
          }
          }
        ]]></code>
      </example>
    </remarks>
    <altmember cref="T:UIKit.UIResponder_NSObjectExtension" />
    <related type="PlatformDocAPI" href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIResponder_Class/index.html">Apple documentation for <c>UIResponder</c></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIResponder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("init")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Default constructor that initializes a new instance of this class with no parameters.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected UIResponder (Foundation.NSObjectFlag t);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class Foundation.NSObjectFlag t) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="t" Type="Foundation.NSObjectFlag" />
      </Parameters>
      <Docs>
        <param name="t">Unused sentinel value, pass NSObjectFlag.Empty.</param>
        <summary>Constructor to call on derived classes to skip initialization and merely allocate the object.</summary>
        <remarks>
          <para>This constructor should be called by derived classes when they completely construct the object in managed code and merely want the runtime to allocate and initialize the NSObject.   This is required to implement the two-step initialization process that Objective-C uses, the first step is to perform the object allocation, the second step is to initialize the object.   When developers invoke the constructor that takes the NSObjectFlag.Empty they take advantage of a direct path that goes all the way up to NSObject to merely allocate the object's memory and bind the Objective-C and C# objects together.    The actual initialization of the object is up to the developer.</para>
          <para>This constructor is typically used by the binding generator to allocate the object, but prevent the actual initialization to take place.   Once the allocation has taken place, the constructor has to initialize the object.   With constructors generated by the binding generator this means that it manually invokes one of the "init" methods to initialize the object.</para>
          <para>It is the developer's responsibility to completely initialize the object if they chain up using the NSObjectFlag.Empty path.</para>
          <para>In general, if the developer's constructor invokes the NSObjectFlag.Empty base implementation, then it should be calling an Objective-C init method.   If this is not the case, developers should instead chain to the proper constructor in their class. </para>
          <para>The argument value is ignored and merely ensures that the only code that is executed is the construction phase is the basic NSObject allocation and runtime type registration.  Typically the chaining would look like this:</para>
          <example>
            <code lang="C#"><![CDATA[
//
// The NSObjectFlag merely allocates the object and registers the
// C# class with the Objective-C runtime if necessary, but no actual
// initXxx method is invoked, that is done later in the constructor
//
// This is taken from Xamarin's source code:
//
[Export ("initWithFrame:")]
public UIView (System.Drawing.RectangleF frame) : base (NSObjectFlag.Empty)
{
// Invoke the init method now.
	var initWithFrame = new Selector ("initWithFrame:").Handle;
	if (IsDirectBinding)
		Handle = ObjCRuntime.Messaging.IntPtr_objc_msgSend_RectangleF (this.Handle, initWithFrame, frame);
	else
		Handle = ObjCRuntime.Messaging.IntPtr_objc_msgSendSuper_RectangleF (this.SuperHandle, initWithFrame, frame);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected UIResponder (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig specialname rtspecialname instance void .ctor(native int handle) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Pointer (handle) to the unmanaged object.</param>
        <summary>A constructor used when creating managed representations of unmanaged objects;  Called by the runtime.</summary>
        <remarks>
          <para>This constructor is invoked by the runtime infrastructure (<see cref="M:ObjCRuntime.Runtime.GetNSObject(System.IntPtr)" />) to create a new managed representation for a pointer to an unmanaged Objective-C object.    Developers should not invoke this method directly, instead they should call the GetNSObject method as it will prevent two instances of a managed object to point to the same native object.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityAssistiveTechnologyFocusedIdentifiers">
      <MemberSignature Language="C#" Value="public virtual Foundation.NSSet&lt;Foundation.NSString&gt; AccessibilityAssistiveTechnologyFocusedIdentifiers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Foundation.NSSet`1&lt;class Foundation.NSString&gt; AccessibilityAssistiveTechnologyFocusedIdentifiers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("accessibilityAssistiveTechnologyFocusedIdentifiers")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSSet&lt;Foundation.NSString&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityCustomActions">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIAccessibilityCustomAction[] AccessibilityCustomActions { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIAccessibilityCustomAction[] AccessibilityCustomActions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("accessibilityCustomActions")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setAccessibilityCustomActions:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIAccessibilityCustomAction[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Allows methods to be added to <see cref="P:UIKit.UIResponder.AccessibilityCustomActions" /> as accessibility-supporting supplementary actions.</summary>
        <value>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityDecrement">
      <MemberSignature Language="C#" Value="public virtual void AccessibilityDecrement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AccessibilityDecrement() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("accessibilityDecrement")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tells the accessibility element to decrement the value of its content.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityDragSourceDescriptors">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIAccessibilityLocationDescriptor[] AccessibilityDragSourceDescriptors { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIAccessibilityLocationDescriptor[] AccessibilityDragSourceDescriptors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("accessibilityDragSourceDescriptors", ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setAccessibilityDragSourceDescriptors:", ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIAccessibilityLocationDescriptor[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityDropPointDescriptors">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIAccessibilityLocationDescriptor[] AccessibilityDropPointDescriptors { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIAccessibilityLocationDescriptor[] AccessibilityDropPointDescriptors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("accessibilityDropPointDescriptors", ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setAccessibilityDropPointDescriptors:", ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIAccessibilityLocationDescriptor[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityElementDidBecomeFocused">
      <MemberSignature Language="C#" Value="public virtual void AccessibilityElementDidBecomeFocused ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AccessibilityElementDidBecomeFocused() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("accessibilityElementDidBecomeFocused")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indicates that an assistive technology has set its focus to <c>this</c> <see cref="T:UIKit.UIResponder" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityElementDidLoseFocus">
      <MemberSignature Language="C#" Value="public virtual void AccessibilityElementDidLoseFocus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AccessibilityElementDidLoseFocus() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("accessibilityElementDidLoseFocus")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indicates that an assistive technology has changed its focus from <c>this</c> <see cref="T:UIKit.UIResponder" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityElementIsFocused">
      <MemberSignature Language="C#" Value="public virtual bool AccessibilityElementIsFocused ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool AccessibilityElementIsFocused() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("accessibilityElementIsFocused")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indicates whether an assistive technology is focused on <c>this</c> <see cref="T:UIKit.UIResponder" />.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityIncrement">
      <MemberSignature Language="C#" Value="public virtual void AccessibilityIncrement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AccessibilityIncrement() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("accessibilityIncrement")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tells the accessibility element to increment the value of its content.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityPerformEscape">
      <MemberSignature Language="C#" Value="public virtual bool AccessibilityPerformEscape ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool AccessibilityPerformEscape() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("accessibilityPerformEscape")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 5, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tells the accessibility system to dismiss a modal popover or hierarchically-displayed element.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityPerformMagicTap">
      <MemberSignature Language="C#" Value="public virtual bool AccessibilityPerformMagicTap ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool AccessibilityPerformMagicTap() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("accessibilityPerformMagicTap")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Toggles the application-defined "most important state" of the app. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityScroll">
      <MemberSignature Language="C#" Value="public virtual bool AccessibilityScroll (UIKit.UIAccessibilityScrollDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool AccessibilityScroll(valuetype UIKit.UIAccessibilityScrollDirection direction) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("accessibilityScroll:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 4, 2, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="UIKit.UIAccessibilityScrollDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Direction of scrolling.</param>
        <summary>When overridden, allows the accessibility system to perform scrolling.</summary>
        <returns>
          <see langword="true" /> if the accessibility system may perform scrolling.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BecomeFirstResponder">
      <MemberSignature Language="C#" Value="public virtual bool BecomeFirstResponder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool BecomeFirstResponder() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("becomeFirstResponder")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Request the object to become the first responder.</summary>
        <returns>Returns true if the object accepts becoming the first responder, or false if it does not.   The default is to accept.</returns>
        <remarks>
          <para>
            
            You can overwrite this method to detect when your
            UIResponder object becomes the first responder and to
            either accept or reject the request.
            
          </para>
          <para>
            
            Typically this method is invoked by application code to
            request that a specific object become the first responder.
            Typically to give the focus to a UIView, for example, to
            focus a <see cref="T:UIKit.UITextField" /> or a
            <see cref="T:UIKit.UITextView" />.
            
          </para>
          <para>
            
            It is possible for this call to fail if the current first
            responder refuses to give up control.  This condition can
            be detected by probing the <see cref="P:UIKit.UIResponder.CanResignFirstResponder" />.
            
          </para>
          <para>
            
            This method is only valid if invoked in a UIResponder that
            is part of the currently active responder chain.  Sending
            this to a UIView that has not been added to a responder
            chain does nothing.
            
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanBecomeFirstResponder">
      <MemberSignature Language="C#" Value="public virtual bool CanBecomeFirstResponder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanBecomeFirstResponder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Foundation.Export("canBecomeFirstResponder")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determines whether this UIREsponder is willing to become the first responder.</summary>
        <value>
        </value>
        <remarks>
          <para>
            
            Developers that want to write UIResponders that are
            interested in receiving touch events or action messages
            must override this method and return true.
            
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanPaste">
      <MemberSignature Language="C#" Value="public virtual bool CanPaste (Foundation.NSItemProvider[] itemProviders);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanPaste(class Foundation.NSItemProvider[] itemProviders) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("canPasteItemProviders:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemProviders" Type="Foundation.NSItemProvider[]" />
      </Parameters>
      <Docs>
        <param name="itemProviders">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanPerform">
      <MemberSignature Language="C#" Value="public virtual bool CanPerform (ObjCRuntime.Selector action, Foundation.NSObject withSender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanPerform(class ObjCRuntime.Selector action, class Foundation.NSObject withSender) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("canPerformAction:withSender:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="ObjCRuntime.Selector" />
        <Parameter Name="withSender" Type="Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="action">The selector that represents the action that is being probed.  For editing operations, these selectors are "copy:", "cut:", "delete:", "paste:", "select:", "selectAll:", "toggleBoldface:", "toggleItalics:", "toggleUnderline:".</param>
        <param name="withSender">
          <para>The object invoking this method.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Determines if this UIResponder can perform the specified action.  Typically used to probe for editing commands.</summary>
        <returns>True if the specified action can be performed with the specified sender.</returns>
        <remarks>
          <para>
            This method should return true if the action specified by the selector can be performed by the object.
          </para>
          <example>
            <code lang="C#"><![CDATA[
              //
              // Selectable label: a label that shows the "Copy" menu when the user
              // long presses
              //
              public class SelectableLabel : UILabel {
              
              public SelectableLabel (RectangleF rect) : base (rect)
              {
              UserInteractionEnabled = true;
              var gesture = new UILongPressGestureRecognizer (LongPress);
              AddGestureRecognizer (gesture);
              }
              
              void LongPress (UILongPressGestureRecognizer r)
              {
              var location = r.LocationInView (r.View);
              var menu = UIMenuController.SharedMenuController;
              
              r.View.BecomeFirstResponder ();
              
              menu.SetTargetRect (r.View.Frame, r.View);
              menu.SetMenuVisible (true, true);
              }
              
              
              public override bool CanBecomeFirstResponder { 
              get { return true; } 
              }
              
              Selector copyAction = new Selector ("copy");
              
              public override bool CanPerform (Selector action, NSObject withSender)
              {
              if (action == copyAction);
              return true;
              return false;
              }
              
              public override void Copy (NSObject sender)
              {
              UIPasteboard.General.String = this.Text;
              }
              }
            ]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanResignFirstResponder">
      <MemberSignature Language="C#" Value="public virtual bool CanResignFirstResponder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanResignFirstResponder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Foundation.Export("canResignFirstResponder")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determines whether this UIResponder is willing to give up its first responder status.</summary>
        <value>
        </value>
        <remarks>Developers can override this method if they want to prevent their view from relinquishing their first responder status.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClassHandle">
      <MemberSignature Language="C#" Value="public override IntPtr ClassHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ClassHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The handle for this class.</summary>
        <value>The pointer to the Objective-C class.</value>
        <remarks>Each Xamarin class mirrors an unmanaged Objective-C class.   This value contains the pointer to the Objective-C class, it is similar to calling objc_getClass with the object name.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearTextInputContextIdentifier">
      <MemberSignature Language="C#" Value="public static void ClearTextInputContextIdentifier (Foundation.NSString identifier);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ClearTextInputContextIdentifier(class Foundation.NSString identifier) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("clearTextInputContextIdentifier:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identifier" Type="Foundation.NSString" />
      </Parameters>
      <Docs>
        <param name="identifier">Identifier that is assigned to the textInputContextIdentifier property for one of your responders.</param>
        <summary>Clears the text input mode information from the application's user defaults.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public virtual void Copy (Foundation.NSObject sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Copy(class Foundation.NSObject sender) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("copy:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="sender">
          <para>Object calling this method.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Indicates a "Copy" editing operation.</summary>
        <remarks>
          <para>
            Applications overriding this method should expose the selected information and pass it to the <see cref="T:UIKit.UIPasteboard" />. 
          </para>
          <para>
            You can invoke the Copy method to retrieve the contents of the object and have them on the pasteboard, for example:
          </para>
          <example>
            <code lang="C#"><![CDATA[
              void MakeCopy (UITextField field)
              {
              field.Copy (this);
              }
            ]]></code>
          </example>
          <para>
            The following example shows how to implement the Copy method on your own subclass of UIResponder.
          </para>
          <example>
            <code lang="C#"><![CDATA[
              //
              // Selectable label: a label that shows the "Copy" menu when the user
              // long presses
              //
              public class SelectableLabel : UILabel {
              
              public SelectableLabel (RectangleF rect) : base (rect)
              {
              UserInteractionEnabled = true;
              var gesture = new UILongPressGestureRecognizer (LongPress);
              AddGestureRecognizer (gesture);
              }
              
              void LongPress (UILongPressGestureRecognizer r)
              {
              var location = r.LocationInView (r.View);
              var menu = UIMenuController.SharedMenuController;
              
              r.View.BecomeFirstResponder ();
              
              menu.SetTargetRect (r.View.Frame, r.View);
              menu.SetMenuVisible (true, true);
              }
              
              
              public override bool CanBecomeFirstResponder { 
              get { return true; } 
              }
              
              Selector copyAction = new Selector ("copy");
              
              public override bool CanPerform (Selector action, NSObject withSender)
              {
              if (action == copyAction);
              return true;
              return false;
              }
              
              public override void Copy (NSObject sender)
              {
              UIPasteboard.General.String = this.Text;
              }
              }
            ]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cut">
      <MemberSignature Language="C#" Value="public virtual void Cut (Foundation.NSObject sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Cut(class Foundation.NSObject sender) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("cut:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="sender">
          <para>Object calling this method.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Indicates a "Cut" editing operation.</summary>
        <remarks>
          <para>
            
            Applications overriding this method should expose the
            selected information and pass it to the <see cref="T:UIKit.UIPasteboard" /> and also remove
            the selected element from the user interface.
            
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public virtual void Delete (Foundation.NSObject sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Delete(class Foundation.NSObject sender) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("delete:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="sender">
          <para>Object calling this method.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Indicates a "Delete" editing operation.</summary>
        <remarks>Applications should remove the selected element from the user interface.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTargetForAction">
      <MemberSignature Language="C#" Value="public virtual Foundation.NSObject GetTargetForAction (ObjCRuntime.Selector action, Foundation.NSObject sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Foundation.NSObject GetTargetForAction(class ObjCRuntime.Selector action, class Foundation.NSObject sender) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("targetForAction:withSender:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="ObjCRuntime.Selector" />
        <Parameter Name="sender" Type="Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="action">The selector that represents the action that is being probed.  For editing operations, these selectors are "copy:", "cut:", "delete:", "paste:", "select:", "selectAll:", "toggleBoldface:", "toggleItalics:", "toggleUnderline:".</param>
        <param name="sender">
          <para>Object calling this method.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Returns the object that responds to an action.</summary>
        <returns>The object that can handle the action.</returns>
        <remarks>
          <para> 
            The default implementation of this method calls the <see cref="M:UIKit.UIResponder.CanPerform" /> method, and if it returns true, it returns this instance.   
          </para>
          <para>
            This method can be overwritten to provide a different behavior than the default.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputAccessoryView">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIView InputAccessoryView { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIView InputAccessoryView" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 3, 2, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("inputAccessoryView")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 3, 2, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Custom view that can be attached when the object becomes the first responder.</summary>
        <value>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InputAccessoryViewController">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIInputViewController InputAccessoryViewController { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIInputViewController InputAccessoryViewController" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("inputAccessoryViewController")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIInputViewController</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the custom accessory <see cref="T:UIKit.UIInputViewController" /> to display when <c>this</c> <see cref="T:UIKit.UIResponder" /> becomes the first responder.</summary>
        <value>The value for this read-only property is <see langword="null" /></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InputAssistantItem">
      <MemberSignature Language="C#" Value="public virtual UIKit.UITextInputAssistantItem InputAssistantItem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UITextInputAssistantItem InputAssistantItem" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("inputAssistantItem", ObjCRuntime.ArgumentSemantic.Strong)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UITextInputAssistantItem</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the assistant that will be used to configure the shortcut bar.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InputView">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIView InputView { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIView InputView" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 3, 2, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("inputView")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 3, 2, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Custom view to display when the object becomes the first responder. Read-only.</summary>
        <value>The value for this read-only property is <see langword="null" /></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InputViewController">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIInputViewController InputViewController { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIInputViewController InputViewController" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("inputViewController")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIInputViewController</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the custom <see cref="T:UIKit.UIInputViewController" /> to display when <c>this</c> <see cref="T:UIKit.UIResponder" /> becomes the first responder.</summary>
        <value>The value for this read-only property is <see langword="null" /></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFirstResponder">
      <MemberSignature Language="C#" Value="public virtual bool IsFirstResponder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFirstResponder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Foundation.Export("isFirstResponder")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns whether this UIResponder is the First Responder.</summary>
        <value>
        </value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyCommands">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIKeyCommand[] KeyCommands { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIKeyCommand[] KeyCommands" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("keyCommands")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIKeyCommand[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The key commands that should trigger action on this UIResponder. Read-only.</summary>
        <value>an array of <see cref="T:UIKit.UIKeyCommand" /> objects</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeTextWritingDirectionLeftToRight">
      <MemberSignature Language="C#" Value="public virtual void MakeTextWritingDirectionLeftToRight (Foundation.NSObject sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MakeTextWritingDirectionLeftToRight(class Foundation.NSObject sender) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("makeTextWritingDirectionLeftToRight:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 5, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="sender">
          <para>Object calling this method.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Sets the direction in which text is written to be left-to-right.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeTextWritingDirectionRightToLeft">
      <MemberSignature Language="C#" Value="public virtual void MakeTextWritingDirectionRightToLeft (Foundation.NSObject sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MakeTextWritingDirectionRightToLeft(class Foundation.NSObject sender) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("makeTextWritingDirectionRightToLeft:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 5, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="sender">
          <para>Object calling this method.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Sets the direction in which text is written to be right-to-left.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MotionBegan">
      <MemberSignature Language="C#" Value="public virtual void MotionBegan (UIKit.UIEventSubtype motion, UIKit.UIEvent evt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MotionBegan(valuetype UIKit.UIEventSubtype motion, class UIKit.UIEvent evt) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("motionBegan:withEvent:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="motion" Type="UIKit.UIEventSubtype" />
        <Parameter Name="evt" Type="UIKit.UIEvent" />
      </Parameters>
      <Docs>
        <param name="motion">Event-subtype that specifies the kind of motion.</param>
        <param name="evt">
          <para>UIEvent describing the specified motion..</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Method invoked when a motion (a shake) has started.</summary>
        <remarks>
          <para>
            In particular, <see cref="T:UIKit.UIView" /> bubbles
            the events up the responder chain.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MotionCancelled">
      <MemberSignature Language="C#" Value="public virtual void MotionCancelled (UIKit.UIEventSubtype motion, UIKit.UIEvent evt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MotionCancelled(valuetype UIKit.UIEventSubtype motion, class UIKit.UIEvent evt) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("motionCancelled:withEvent:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="motion" Type="UIKit.UIEventSubtype" />
        <Parameter Name="evt" Type="UIKit.UIEvent" />
      </Parameters>
      <Docs>
        <param name="motion">Event-subtype that specifies the kind of motion.</param>
        <param name="evt">
          <para>UIEvent describing the specified motion.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Method invoked if the operating system cancels a motion (shake) event.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MotionEnded">
      <MemberSignature Language="C#" Value="public virtual void MotionEnded (UIKit.UIEventSubtype motion, UIKit.UIEvent evt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MotionEnded(valuetype UIKit.UIEventSubtype motion, class UIKit.UIEvent evt) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("motionEnded:withEvent:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="motion" Type="UIKit.UIEventSubtype" />
        <Parameter Name="evt" Type="UIKit.UIEvent" />
      </Parameters>
      <Docs>
        <param name="motion">The event subtype.</param>
        <param name="evt">
          <para>UIEvent describing the specifiemotion.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Method invoked when a motion (shake) has finished.</summary>
        <remarks>
          <para>
            In particular, <see cref="T:UIKit.UIView" /> bubbles
            the events up the responder chain.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NextResponder">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIResponder NextResponder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIResponder NextResponder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Foundation.Export("nextResponder")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIResponder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The next responder on the response chain</summary>
        <value>Next responder in the specified chain to be presented with an event for handling.</value>
        <remarks>
          <para>
            This property returns the next responder in the chain.   For <see cref="T:UIKit.UIView" /> objects, this returns the managing <see cref="T:UIKit.UIViewController" />, or the <see cref="P:UIKit.UIView.Superview" /> if the controller is not set.   For the <see cref="T:UIKit.UIViewController" />, this returns its view's <see cref="P:UIKit.UIView.Superview" />.   For <see cref="T:UIKit.UIWindow" />s, this returns the <see cref="T:UIKit.UIApplication" /> object.   <see cref="T:UIKit.UIApplication" /> objects return null.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Paste">
      <MemberSignature Language="C#" Value="public virtual void Paste (Foundation.NSItemProvider[] itemProviders);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Paste(class Foundation.NSItemProvider[] itemProviders) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("pasteItemProviders:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemProviders" Type="Foundation.NSItemProvider[]" />
      </Parameters>
      <Docs>
        <param name="itemProviders">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Paste">
      <MemberSignature Language="C#" Value="public virtual void Paste (Foundation.NSObject sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Paste(class Foundation.NSObject sender) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("paste:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="sender">
          <para>Object calling this method.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Indicates a "Paste" editing operation.</summary>
        <remarks>
          <para>
            
            Applications overriding this method should probe the <see cref="T:UIKit.UIPasteboard" /> and try to fetch
            the information available there and insert it.
            
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PasteConfiguration">
      <MemberSignature Language="C#" Value="public virtual UIKit.UIPasteConfiguration PasteConfiguration { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UIPasteConfiguration PasteConfiguration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Xamarin.iOS</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 11, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.WatchOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Unavailable(ObjCRuntime.PlatformName.TvOS, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("pasteConfiguration", ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setPasteConfiguration:", ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UIPasteConfiguration</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PressesBegan">
      <MemberSignature Language="C#" Value="public virtual void PressesBegan (Foundation.NSSet&lt;UIKit.UIPress&gt; presses, UIKit.UIPressesEvent evt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PressesBegan(class Foundation.NSSet`1&lt;class UIKit.UIPress&gt; presses, class UIKit.UIPressesEvent evt) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("pressesBegan:withEvent:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="presses" Type="Foundation.NSSet&lt;UIKit.UIPress&gt;" />
        <Parameter Name="evt" Type="UIKit.UIPressesEvent" />
      </Parameters>
      <Docs>
        <param name="presses">The set of <see cref="T:UIKit.UIPress" /> objects involved in the event.</param>
        <param name="evt">The <see cref="T:UIKit.UIPressesEvent" /> describing the event.</param>
        <summary>Indicates that a physical button has been pressed on a remote or game controller.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PressesCancelled">
      <MemberSignature Language="C#" Value="public virtual void PressesCancelled (Foundation.NSSet&lt;UIKit.UIPress&gt; presses, UIKit.UIPressesEvent evt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PressesCancelled(class Foundation.NSSet`1&lt;class UIKit.UIPress&gt; presses, class UIKit.UIPressesEvent evt) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("pressesCancelled:withEvent:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="presses" Type="Foundation.NSSet&lt;UIKit.UIPress&gt;" />
        <Parameter Name="evt" Type="UIKit.UIPressesEvent" />
      </Parameters>
      <Docs>
        <param name="presses">The set of <see cref="T:UIKit.UIPress" /> objects involved in the event.</param>
        <param name="evt">The <see cref="T:UIKit.UIPressesEvent" /> describing the event.</param>
        <summary>Indicates a physical button-press event has been cancelled due to a system event.</summary>
        <remarks>
          <para>Developers who handle press events must implement this method.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PressesChanged">
      <MemberSignature Language="C#" Value="public virtual void PressesChanged (Foundation.NSSet&lt;UIKit.UIPress&gt; presses, UIKit.UIPressesEvent evt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PressesChanged(class Foundation.NSSet`1&lt;class UIKit.UIPress&gt; presses, class UIKit.UIPressesEvent evt) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("pressesChanged:withEvent:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="presses" Type="Foundation.NSSet&lt;UIKit.UIPress&gt;" />
        <Parameter Name="evt" Type="UIKit.UIPressesEvent" />
      </Parameters>
      <Docs>
        <param name="presses">The set of <see cref="T:UIKit.UIPress" /> objects involved in the event.</param>
        <param name="evt">The <see cref="T:UIKit.UIPressesEvent" /> describing the event.</param>
        <summary>Indicates that the <see cref="P:UIKit.UIPress.Force" /> value of the <paramref name="evt" /> has changed.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PressesEnded">
      <MemberSignature Language="C#" Value="public virtual void PressesEnded (Foundation.NSSet&lt;UIKit.UIPress&gt; presses, UIKit.UIPressesEvent evt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PressesEnded(class Foundation.NSSet`1&lt;class UIKit.UIPress&gt; presses, class UIKit.UIPressesEvent evt) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("pressesEnded:withEvent:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="presses" Type="Foundation.NSSet&lt;UIKit.UIPress&gt;" />
        <Parameter Name="evt" Type="UIKit.UIPressesEvent" />
      </Parameters>
      <Docs>
        <param name="presses">The set of <see cref="T:UIKit.UIPress" /> objects involved in the event.</param>
        <param name="evt">The <see cref="T:UIKit.UIPressesEvent" /> describing the event.</param>
        <summary>Indicates the ending of a press of a physical button on a remote or game controller.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReloadInputViews">
      <MemberSignature Language="C#" Value="public virtual void ReloadInputViews ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReloadInputViews() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("reloadInputViews")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 3, 2, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Updates custom input and accessory views when this object is the first responder.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoteControlReceived">
      <MemberSignature Language="C#" Value="public virtual void RemoteControlReceived (UIKit.UIEvent theEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoteControlReceived(class UIKit.UIEvent theEvent) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("remoteControlReceivedWithEvent:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 4, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="theEvent" Type="UIKit.UIEvent" />
      </Parameters>
      <Docs>
        <param name="theEvent">
          <para>Event that encapsulates a remote-control command.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Indicates that a remote-control event was received.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResignFirstResponder">
      <MemberSignature Language="C#" Value="public virtual bool ResignFirstResponder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ResignFirstResponder() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("resignFirstResponder")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Called when this UIResponder has been asked to resign its first responder status.</summary>
        <returns>
          <see langword="true" /> if the <see cref="T:UIKit.UIResponder" /> resigned first responder status.</returns>
        <remarks>
          <para>Even if this method returns <see langword="false" />, the resignation can be forced by the application developer calling <see cref="M:UIKit.UIView.EndEditing" /> with its <c>force</c> parameter set to <see langword="true" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RestoreUserActivityState">
      <MemberSignature Language="C#" Value="public virtual void RestoreUserActivityState (Foundation.NSUserActivity activity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RestoreUserActivityState(class Foundation.NSUserActivity activity) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("restoreUserActivityState:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activity" Type="Foundation.NSUserActivity" />
      </Parameters>
      <Docs>
        <param name="activity">User activity that is to be continued.</param>
        <summary>Restores the state that is necessary for continuance of the specified user activity.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public virtual void Select (Foundation.NSObject sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Select(class Foundation.NSObject sender) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("select:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="sender">
          <para>Object calling this method.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Indicates a "Select" editing operation.|b</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectAll">
      <MemberSignature Language="C#" Value="public virtual void SelectAll (Foundation.NSObject sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SelectAll(class Foundation.NSObject sender) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("selectAll:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="sender">
          <para>Object calling this method.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Indicates a "Select All" editing operation.</summary>
        <remarks>
          <para>
            Classes overriding this method should select all of the information available in the current object.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextInputContextIdentifier">
      <MemberSignature Language="C#" Value="public virtual Foundation.NSString TextInputContextIdentifier { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Foundation.NSString TextInputContextIdentifier" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("textInputContextIdentifier")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An identifier indicating that this UIResponder should preserve its text input mode information. Read-only.</summary>
        <value>Ordinarily returns an identifier that signifies that the responder needs to preserve the text input mode information. When redefined, returns a string value that indicates that the responder should preserve the text input mode information.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TextInputMode">
      <MemberSignature Language="C#" Value="public virtual UIKit.UITextInputMode TextInputMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class UIKit.UITextInputMode TextInputMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("textInputMode")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 7, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>UIKit.UITextInputMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The text input mode for this UIResponder. Read-only.</summary>
        <value>Ordinarily displays the  keyboard based on the user’s language preferences. It can be redefined to return a different text input mode where you want a responder to use a specific keyboard.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToggleBoldface">
      <MemberSignature Language="C#" Value="public virtual void ToggleBoldface (Foundation.NSObject sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ToggleBoldface(class Foundation.NSObject sender) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("toggleBoldface:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="sender">
          <para>Object calling this method.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Toggles the use of a bold font.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToggleItalics">
      <MemberSignature Language="C#" Value="public virtual void ToggleItalics (Foundation.NSObject sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ToggleItalics(class Foundation.NSObject sender) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("toggleItalics:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="sender">
          <para>Object calling this method.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Toggles the use of an italic font.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToggleUnderline">
      <MemberSignature Language="C#" Value="public virtual void ToggleUnderline (Foundation.NSObject sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ToggleUnderline(class Foundation.NSObject sender) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("toggleUnderline:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 6, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="sender">
          <para>Object calling this method.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Toggles the use of underlining.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesBegan">
      <MemberSignature Language="C#" Value="public virtual void TouchesBegan (Foundation.NSSet touches, UIKit.UIEvent evt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void TouchesBegan(class Foundation.NSSet touches, class UIKit.UIEvent evt) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("touchesBegan:withEvent:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="touches" Type="Foundation.NSSet" />
        <Parameter Name="evt" Type="UIKit.UIEvent" />
      </Parameters>
      <Docs>
        <param name="touches">Set containing the touches as objects of type <see cref="T:UIKit.UITouch" />.</param>
        <param name="evt">
          <para>The UIEvent that encapsulates all of the touches and the event information.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Sent when one or more fingers touches the screen.</summary>
        <remarks>
          <para>
            The <paramref name="touches" /> set containing all of the touch events.
          </para>
          <para>
            
            If your application tracks the touches starting with this
            method, it should also override both the <see cref="M:UIKit.UIResponder.TouchesEnded(Foundation.NSSet,&#xA;     UIKit.UIEvent)" /> and <see cref="M:UIKit.UIResponder.TouchesCancelled(Foundation.NSSet,&#xA;     UIKit.UIEvent)" /> methods to track the end of
            the touch processing.
            
          </para>
          <para>
            UIViews by default only receive a single touch event at
            once, if you want to receive multiple touches at the same
            time, set the <see cref="P:UIView.MultipleTouchEnabled" /> property
            to true.
          </para>
          <para>
            If you only want to handle a single touch, the following idiom can be used:
          </para>
          <example>
            <code lang="C#"><![CDATA[
public override void TouchesBegan (NSSet touches, UIEvent evt)
{
    var touch = touches.AnyObject as UITouch;

    Console.WriteLine (touch);
}
]]></code>
          </example>
          <para>
            If you want to handle multiple touches, you can use this idiom:
          </para>
          <example>
            <code lang="C#"><![CDATA[
public override void TouchesBegan (NSSet touches, UIEvent evt)
{
    foreach (UITouch touch in touches.ToArray<UITouch> ()){
        Console.WriteLine (touch);
    }
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesCancelled">
      <MemberSignature Language="C#" Value="public virtual void TouchesCancelled (Foundation.NSSet touches, UIKit.UIEvent evt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void TouchesCancelled(class Foundation.NSSet touches, class UIKit.UIEvent evt) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("touchesCancelled:withEvent:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="touches" Type="Foundation.NSSet" />
        <Parameter Name="evt" Type="UIKit.UIEvent" />
      </Parameters>
      <Docs>
        <param name="touches">Set containing the touches as objects of type <see cref="T:UIKit.UITouch" />.</param>
        <param name="evt">
          <para>The UIEvent that encapsulates all of the touches and the event information.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Sent when the touch processing has been cancelled.</summary>
        <remarks>
          <para>
            This method is typically involved because the application
            was interrupted by an external source, like for example,
            an incoming phone call.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesEnded">
      <MemberSignature Language="C#" Value="public virtual void TouchesEnded (Foundation.NSSet touches, UIKit.UIEvent evt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void TouchesEnded(class Foundation.NSSet touches, class UIKit.UIEvent evt) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("touchesEnded:withEvent:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="touches" Type="Foundation.NSSet" />
        <Parameter Name="evt" Type="UIKit.UIEvent" />
      </Parameters>
      <Docs>
        <param name="touches">Set containing the touches as objects of type <see cref="T:UIKit.UITouch" />.</param>
        <param name="evt">
          <para>The UIEvent that encapsulates all of the touches and the event information.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Sent when one or more fingers are lifted from the screen.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesEstimatedPropertiesUpdated">
      <MemberSignature Language="C#" Value="public virtual void TouchesEstimatedPropertiesUpdated (Foundation.NSSet touches);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void TouchesEstimatedPropertiesUpdated(class Foundation.NSSet touches) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("touchesEstimatedPropertiesUpdated:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 9, 1, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="touches" Type="Foundation.NSSet" />
      </Parameters>
      <Docs>
        <param name="touches">To be added.</param>
        <summary>Called when the estimated properties of <paramref name="touches" /> have been updated.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesMoved">
      <MemberSignature Language="C#" Value="public virtual void TouchesMoved (Foundation.NSSet touches, UIKit.UIEvent evt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void TouchesMoved(class Foundation.NSSet touches, class UIKit.UIEvent evt) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("touchesMoved:withEvent:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="touches" Type="Foundation.NSSet" />
        <Parameter Name="evt" Type="UIKit.UIEvent" />
      </Parameters>
      <Docs>
        <param name="touches">Set containing the touches as objects of type <see cref="T:UIKit.UITouch" />.</param>
        <param name="evt">
          <para>The UIEvent that encapsulates all of the touches and the event information.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Sent when one or more fingers move on the screen.</summary>
        <remarks>
          <para>Since iOS 9.0, <see cref="M:UIKit.UIResponder.TouchesMoved(Foundation.NSSet,UIKit.UIEvent)" /> events are raised on supported hardware and configurations for changes in user-applied pressure. The <see cref="P:UIKit.UITouch.Force" /> property of the <see cref="T:UIKit.UITouch" /> object in the <paramref name="touches" /> set argument contains the magnitude of the touch that raised the event. The following example shows a basic use:</para>
          <example>
            <code lang="C#"><![CDATA[
if (TraitCollection.ForceTouchCapability == UIForceTouchCapability.Available) {
      UITouch t = touches.AnyObject as UITouch;
      ForceLabel.Text = "Force: " + t.Force.ToString ();
}
else {
      ForceLabel.Text = "Force Not Active";
}]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UndoManager">
      <MemberSignature Language="C#" Value="public virtual Foundation.NSUndoManager UndoManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Foundation.NSUndoManager UndoManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Foundation.Export("undoManager")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSUndoManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The nearest shared NSUndoManager in the responder chain. Read-only.</summary>
        <value>Returns the nearest usable instance of an undo manager.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateUserActivityState">
      <MemberSignature Language="C#" Value="public virtual void UpdateUserActivityState (Foundation.NSUserActivity activity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UpdateUserActivityState(class Foundation.NSUserActivity activity) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("updateUserActivityState:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activity" Type="Foundation.NSUserActivity" />
      </Parameters>
      <Docs>
        <param name="activity">User activity that is to be updated.</param>
        <summary>Updates a given user activity state.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UserActivity">
      <MemberSignature Language="C#" Value="public virtual Foundation.NSUserActivity UserActivity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Foundation.NSUserActivity UserActivity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("userActivity")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Foundation.Export("setUserActivity:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.None, null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSUserActivity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Action that encapsulates a user activity that is supported by this responder.</summary>
        <value>
          <para>(More documentation for this node is coming)</para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
