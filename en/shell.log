2018-11-27 12:23:05 - Microsoft (R) F# Interactive version 10.2.3 for F# 4.5
2018-11-27 12:23:05 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2018-11-27 12:23:05 - For help type #help;;
2018-11-27 12:23:05 - > val it :
2018-11-27 12:23:05 -   ResizeArray<System.Type *
2018-11-27 12:23:05 -               (obj ->
2018-11-27 12:23:05 -                  seq<string *
2018-11-27 12:23:05 -                      string> *
2018-11-27 12:23:05 -                  string)>
2018-11-27 12:23:05 - = seq []
2018-11-27 12:23:05 - --> Added '/Users/larryobrien/Downloads' to library include path
2018-11-27 12:23:05 - --> Referenced '/Users/larryobrien/Downloads/IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2018-11-27 12:23:05 - --> Referenced '/Users/larryobrien/Downloads/NetMQ.dll' (file may be locked by F# Interactive process)
2018-11-27 12:23:05 - Reporting 0 opened comms
2018-11-27 12:23:49 - Reporting 0 opened comms
2018-11-27 12:25:55 - Reporting 0 opened comms
2018-11-27 12:26:57 - Reporting 0 opened comms
2018-11-27 12:27:41 - let samplesDir = "/Users/larryobrien/Documents/src/xamarin/ios-samples"
2018-11-27 12:27:41 - let ecmaDir = "/Users/larryobrien/Documents/src/xamarin/apple-api-docs/en"
2018-11-27 12:29:22 - #r "System.Xml.Linq"
2018-11-27 12:29:22 - open System.Xml.Linq
2018-11-27 12:29:22 - let xn s = XName.Get(s)
2018-11-27 12:29:22 - let baseDir = "/Users/larryobrien/Documents/src/xamarin/apple-api-docs"
2018-11-27 12:29:22 - let doc (f : string) : XDocument = XDocument.Load(f)
2018-11-27 12:29:36 - open System.IO
2018-11-27 12:29:36 - let sampleXmlFiles = Directory.GetFiles(samplesDir, "*.xml", SearchOption.AllDirectories)
2018-11-27 12:32:53 - sampleXmlFiles |> Seq.map (fun p -> (p, doc p)) |> Seq.filter (fun (_, d) -> d.Descendants(xn "ID") |> Seq.length |> (>) 0)
2018-11-27 12:33:30 - sampleXmlFiles |> Seq.head
2018-11-27 12:33:45 - doc <| sampleXmlFiles |> Seq.head
2018-11-27 12:33:45 - This expression was expected to have type
2018-11-27 12:33:45 -     'string'    
2018-11-27 12:33:45 - but here has type
2018-11-27 12:33:45 -     'string []'    
2018-11-27 12:33:45 - The type 'XDocument' is not compatible with the type 'seq<obj>'
2018-11-27 12:33:56 - sampleXmlFiles |> Seq.head |> doc
2018-11-27 12:34:16 - sampleXmlFiles |> Seq.head |> doc |> fun d -> d.Descendants(xn "ID")
2018-11-27 12:34:44 - sampleXmlFiles 
2018-11-27 12:34:44 - |> Seq.map (fun p -> (p, doc p)) 
2018-11-27 12:34:44 - |> Seq.filter (fun (_, d) -> d.Descendants(xn "ID") |> Seq.length |> (>0) )
2018-11-27 12:34:44 - Unexpected integer literal in expression. Expected ')' or other token.
2018-11-27 12:34:44 - Unmatched '('
2018-11-27 12:34:51 - sampleXmlFiles 
2018-11-27 12:34:51 - |> Seq.map (fun p -> (p, doc p)) 
2018-11-27 12:34:51 - |> Seq.filter (fun (_, d) -> d.Descendants(xn "ID") |> Seq.length |> (>0)
2018-11-27 12:34:51 - Unexpected integer literal in expression. Expected ')' or other token.
2018-11-27 12:34:51 - Unmatched '('
2018-11-27 12:34:51 - Unmatched '('
2018-11-27 12:35:00 - sampleXmlFiles 
2018-11-27 12:35:00 - |> Seq.map (fun p -> (p, doc p)) 
2018-11-27 12:35:00 - |> Seq.filter (fun (_, d) -> d.Descendants(xn "ID")) |> Seq.length |> (>0)
2018-11-27 12:35:00 - Unexpected integer literal in expression. Expected ')' or other token.
2018-11-27 12:35:00 - Unmatched '('
2018-11-27 12:35:26 - sampleXmlFiles |> Seq.head |> doc |> fun d -> d.Descendants(xn "ID") |> Seq.head |> fun el -> el.Value
2018-11-27 12:35:52 - sampleXmlFiles |> Seq.map (fun d -> d.Descendants(xn "ID") |> Seq.head |> fun el -> el.Value)
2018-11-27 12:35:52 - Type constraint mismatch. The type 
2018-11-27 12:35:52 -     'string'    
2018-11-27 12:35:52 - is not compatible with type
2018-11-27 12:35:52 -     'System.Collections.Generic.IEnumerable<char>'    
2018-11-27 12:36:26 - sampleXmlFiles |> Seq.map doc |> Seq.map (fun d -> d.Descendants(xn "ID") |> Seq.head |> fun el -> el.Value)
2018-11-27 12:36:48 - sampleXmlFiles 
2018-11-27 12:36:48 - |> Seq.map doc 
2018-11-27 12:36:48 - |> Seq.map (fun d -> d.Descendants(xn "ID") |> Seq.head |> fun el -> el.Value)
2018-11-27 12:36:48 - |> Seq.zip sampleXmlFiles
2018-11-27 12:50:48 - sampleXmlFiles 
2018-11-27 12:50:48 - |> Seq.map doc 
2018-11-27 12:50:48 - |> Seq.map (fun d -> d.Descendants(xn "ID") |> Seq.head |> fun el -> el.Value)
2018-11-27 12:50:48 - |> Seq.zip sampleXmlFiles |> Seq.map (fun (a,b)->(b,a))
2018-11-27 12:50:54 - sampleXmlFiles 
2018-11-27 12:50:54 - |> Seq.map doc 
2018-11-27 12:50:54 - |> Seq.map (fun d -> d.Descendants(xn "ID") |> Seq.head |> fun el -> el.Value)
2018-11-27 12:50:54 - |> Seq.zip sampleXmlFiles |> Seq.map (fun (a,b)->(b,a)) |> dict
2018-11-27 12:50:54 - Expression evaluation failed: The input sequence was empty.
2018-11-27 12:50:54 - Parameter name: source
2018-11-27 12:50:54 - ArgumentExceptionThe input sequence was empty.
2018-11-27 12:50:54 - Parameter name: source
2018-11-27 12:50:54 -   at Microsoft.FSharp.Collections.SeqModule.Head[T] (System.Collections.Generic.IEnumerable`1[T] source) [0x00033] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 12:50:54 -   at FSI_0028+it@3-10.Invoke (System.Xml.Linq.XDocument d) [0x00013] in <c82a4923d09b454bb7c7eb31a0d22fe1>:0 
2018-11-27 12:50:54 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+map@74[b,a].DoMoveNext (b& curr) [0x0001f] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 12:50:54 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+MapEnumerator`1[T].System-Collections-IEnumerator-MoveNext () [0x0000b] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 12:50:54 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+map2@102[c,a,b].DoMoveNext (c& curr) [0x0000c] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 12:50:54 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+MapEnumerator`1[T].System-Collections-IEnumerator-MoveNext () [0x0000b] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 12:50:54 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+map@74[b,a].DoMoveNext (b& curr) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 12:50:54 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+MapEnumerator`1[T].System-Collections-IEnumerator-MoveNext () [0x0000b] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 12:50:54 -   at Microsoft.FSharp.Core.ExtraTopLevelOperators.dictRefType[TKey,T] (System.Collections.Generic.IEnumerable`1[T] l) [0x00021] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 12:50:54 -   at Microsoft.FSharp.Core.ExtraTopLevelOperators.CreateDictionary[TKey,TValue] (System.Collections.Generic.IEnumerable`1[T] keyValuePairs) [0x00018] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 12:50:54 -   at <StartupCode$FSI_0028>.$FSI_0028.main@ () [0x00037] in <c82a4923d09b454bb7c7eb31a0d22fe1>:0 
2018-11-27 12:50:54 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-11-27 12:50:54 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x00032] in <14a60dd6a7d84d269fce235fa522c903>:0 
2018-11-27 12:51:02 - sampleXmlFiles 
2018-11-27 12:51:02 - |> Seq.map doc 
2018-11-27 12:51:02 - |> Seq.map (fun d -> d.Descendants(xn "ID") |> Seq.head |> fun el -> el.Value)
2018-11-27 12:51:02 - |> Seq.zip sampleXmlFiles |> Seq.map (fun (a,b)->(b,a)) 
2018-11-27 12:52:09 - sampleXmlFiles 
2018-11-27 12:52:09 - |> Seq.map doc 
2018-11-27 12:52:09 - |> Seq.map (fun d -> d.Descendants(xn "ID") |> Seq.head |> fun el -> el.Value)
2018-11-27 12:52:09 - |> Seq.zip sampleXmlFiles |> Seq.map (fun (a,b)-> [b, a]) |> dict
2018-11-27 12:52:09 - Type mismatch. Expecting a
2018-11-27 12:52:09 -     'seq<(string * string) list> -> obj'    
2018-11-27 12:52:09 - but given a
2018-11-27 12:52:09 -     'seq<(string * string) list> -> System.Collections.Generic.IDictionary<obj,obj>'    
2018-11-27 12:52:09 - The type 'obj * obj' does not match the type '(string * string) list'
2018-11-27 12:52:50 - sampleXmlFiles 
2018-11-27 12:52:50 - |> Seq.map doc 
2018-11-27 12:52:50 - |> Seq.map (fun d -> d.Descendants(xn "ID") |> Seq.head |> fun el -> el.Value)
2018-11-27 12:52:50 - |> Seq.zip sampleXmlFiles 
2018-11-27 12:52:50 - |> Seq.map (fun (a,b)-> (b,a)) 
2018-11-27 12:52:50 - |> dict
2018-11-27 12:52:50 - Expression evaluation failed: The input sequence was empty.
2018-11-27 12:52:50 - Parameter name: source
2018-11-27 12:52:50 - ArgumentExceptionThe input sequence was empty.
2018-11-27 12:52:50 - Parameter name: source
2018-11-27 12:52:50 -   at Microsoft.FSharp.Collections.SeqModule.Head[T] (System.Collections.Generic.IEnumerable`1[T] source) [0x00033] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 12:52:50 -   at FSI_0032+it@3-16.Invoke (System.Xml.Linq.XDocument d) [0x00013] in <c82a4923d09b454bb7c7eb31a0d22fe1>:0 
2018-11-27 12:52:50 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+map@74[b,a].DoMoveNext (b& curr) [0x0001f] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 12:52:50 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+MapEnumerator`1[T].System-Collections-IEnumerator-MoveNext () [0x0000b] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 12:52:50 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+map2@102[c,a,b].DoMoveNext (c& curr) [0x0000c] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 12:52:50 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+MapEnumerator`1[T].System-Collections-IEnumerator-MoveNext () [0x0000b] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 12:52:50 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+map@74[b,a].DoMoveNext (b& curr) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 12:52:50 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+MapEnumerator`1[T].System-Collections-IEnumerator-MoveNext () [0x0000b] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 12:52:50 -   at Microsoft.FSharp.Core.ExtraTopLevelOperators.dictRefType[TKey,T] (System.Collections.Generic.IEnumerable`1[T] l) [0x00021] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 12:52:50 -   at Microsoft.FSharp.Core.ExtraTopLevelOperators.CreateDictionary[TKey,TValue] (System.Collections.Generic.IEnumerable`1[T] keyValuePairs) [0x00018] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 12:52:50 -   at <StartupCode$FSI_0032>.$FSI_0032.main@ () [0x00037] in <c82a4923d09b454bb7c7eb31a0d22fe1>:0 
2018-11-27 12:52:50 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-11-27 12:52:50 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x00032] in <14a60dd6a7d84d269fce235fa522c903>:0 
2018-11-27 12:53:18 - sampleXmlFiles 
2018-11-27 12:53:18 - |> Seq.map doc 
2018-11-27 12:53:18 - |> Seq.map (fun d -> d.Descendants(xn "ID") |> Seq.head |> fun el -> el.Value)
2018-11-27 12:53:18 - |> Seq.zip sampleXmlFiles 
2018-11-27 12:53:18 - |> Seq.map (fun (a,b)-> (b,a)) 
2018-11-27 12:53:18 - |> Seq.iter (fun t -> printfn "%A" t; t)
2018-11-27 12:53:18 - |> dict
2018-11-27 12:53:18 - This expression was expected to have type
2018-11-27 12:53:18 -     'unit'    
2018-11-27 12:53:18 - but here has type
2018-11-27 12:53:18 -     'string * string'    
2018-11-27 12:53:18 - The type 'unit' is not compatible with the type 'seq<obj * obj>'
2018-11-27 12:53:23 - sampleXmlFiles 
2018-11-27 12:53:23 - |> Seq.map doc 
2018-11-27 12:53:23 - |> Seq.map (fun d -> d.Descendants(xn "ID") |> Seq.head |> fun el -> el.Value)
2018-11-27 12:53:23 - |> Seq.zip sampleXmlFiles 
2018-11-27 12:53:23 - |> Seq.map (fun (a,b)-> (b,a)) 
2018-11-27 12:53:23 - |> Seq.map (fun t -> printfn "%A" t; t)
2018-11-27 12:53:23 - |> dict
2018-11-27 12:53:23 - Expression evaluation failed: The input sequence was empty.
2018-11-27 12:53:23 - Parameter name: source
2018-11-27 12:53:23 - ArgumentExceptionThe input sequence was empty.
2018-11-27 12:53:23 - Parameter name: source
2018-11-27 12:53:23 -   at Microsoft.FSharp.Collections.SeqModule.Head[T] (System.Collections.Generic.IEnumerable`1[T] source) [0x00033] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 12:53:23 -   at FSI_0034+it@3-20.Invoke (System.Xml.Linq.XDocument d) [0x00013] in <c82a4923d09b454bb7c7eb31a0d22fe1>:0 
2018-11-27 12:53:23 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+map@74[b,a].DoMoveNext (b& curr) [0x0001f] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 12:53:23 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+MapEnumerator`1[T].System-Collections-IEnumerator-MoveNext () [0x0000b] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 12:53:23 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+map2@102[c,a,b].DoMoveNext (c& curr) [0x0000c] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 12:53:23 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+MapEnumerator`1[T].System-Collections-IEnumerator-MoveNext () [0x0000b] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 12:53:23 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+map@74[b,a].DoMoveNext (b& curr) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 12:53:23 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+MapEnumerator`1[T].System-Collections-IEnumerator-MoveNext () [0x0000b] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 12:53:23 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+map@74[b,a].DoMoveNext (b& curr) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 12:53:23 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+MapEnumerator`1[T].System-Collections-IEnumerator-MoveNext () [0x0000b] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 12:53:23 -   at Microsoft.FSharp.Core.ExtraTopLevelOperators.dictRefType[TKey,T] (System.Collections.Generic.IEnumerable`1[T] l) [0x00021] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 12:53:23 -   at Microsoft.FSharp.Core.ExtraTopLevelOperators.CreateDictionary[TKey,TValue] (System.Collections.Generic.IEnumerable`1[T] keyValuePairs) [0x00018] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 12:53:23 -   at <StartupCode$FSI_0034>.$FSI_0034.main@ () [0x00041] in <c82a4923d09b454bb7c7eb31a0d22fe1>:0 
2018-11-27 12:53:23 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-11-27 12:53:23 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x00032] in <14a60dd6a7d84d269fce235fa522c903>:0 
2018-11-27 12:53:38 - sampleXmlFiles 
2018-11-27 12:53:38 - |> Seq.map doc 
2018-11-27 12:53:38 - |> Seq.map (fun d -> d.Descendants(xn "ID") |> Seq.head |> fun el -> el.Value)
2018-11-27 12:53:38 - |> Seq.zip sampleXmlFiles 
2018-11-27 12:53:38 - |> Seq.map (fun (a,b)-> (b,a)) 
2018-11-27 12:53:38 - |> Seq.iter (fun t -> printfn "%A" t)
2018-11-27 12:53:38 - Expression evaluation failed: The input sequence was empty.
2018-11-27 12:53:38 - Parameter name: source
2018-11-27 12:53:38 - ArgumentExceptionThe input sequence was empty.
2018-11-27 12:53:38 - Parameter name: source
2018-11-27 12:53:38 -   at Microsoft.FSharp.Collections.SeqModule.Head[T] (System.Collections.Generic.IEnumerable`1[T] source) [0x00033] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 12:53:38 -   at FSI_0035+it@3-24.Invoke (System.Xml.Linq.XDocument d) [0x00013] in <c82a4923d09b454bb7c7eb31a0d22fe1>:0 
2018-11-27 12:53:38 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+map@74[b,a].DoMoveNext (b& curr) [0x0001f] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 12:53:38 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+MapEnumerator`1[T].System-Collections-IEnumerator-MoveNext () [0x0000b] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 12:53:38 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+map2@102[c,a,b].DoMoveNext (c& curr) [0x0000c] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 12:53:38 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+MapEnumerator`1[T].System-Collections-IEnumerator-MoveNext () [0x0000b] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 12:53:38 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+map@74[b,a].DoMoveNext (b& curr) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 12:53:38 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+MapEnumerator`1[T].System-Collections-IEnumerator-MoveNext () [0x0000b] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 12:53:38 -   at Microsoft.FSharp.Collections.SeqModule.Iterate[T] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] action, System.Collections.Generic.IEnumerable`1[T] source) [0x0001d] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 12:53:38 -   at <StartupCode$FSI_0035>.$FSI_0035.main@ () [0x0003c] in <c82a4923d09b454bb7c7eb31a0d22fe1>:0 
2018-11-27 12:53:38 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-11-27 12:53:38 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x00032] in <14a60dd6a7d84d269fce235fa522c903>:0 
2018-11-27 12:53:58 - sampleXmlFiles 
2018-11-27 12:53:58 - |> Seq.map doc 
2018-11-27 12:53:58 - |> Seq.map (fun d -> d.Descendants(xn "ID") |> Seq.head |> fun el -> el.Value)
2018-11-27 12:53:58 - |> Seq.zip sampleXmlFiles 
2018-11-27 12:53:58 - |> Seq.map (fun (a,b)-> (b,a)) 
2018-11-27 12:54:19 - let pathForGuid = 
2018-11-27 12:54:19 - sampleXmlFiles 
2018-11-27 12:54:19 - |> Seq.map doc 
2018-11-27 12:54:19 - |> Seq.map (fun d -> d.Descendants(xn "ID") |> Seq.head |> fun el -> el.Value)
2018-11-27 12:54:19 - |> Seq.zip sampleXmlFiles 
2018-11-27 12:54:19 - |> Seq.map (fun (a,b)-> (b,a)) 
2018-11-27 12:54:19 - Possible incorrect indentation: this token is offside of context started at position (1:1). Try indenting this token further or using standard formatting conventions.
2018-11-27 12:54:19 - Possible incorrect indentation: this token is offside of context started at position (1:1). Try indenting this token further or using standard formatting conventions.
2018-11-27 12:54:34 - let pathForGuid = 
2018-11-27 12:54:34 -     sampleXmlFiles 
2018-11-27 12:54:34 -     |> Seq.map doc 
2018-11-27 12:54:34 -     |> Seq.map (fun d -> d.Descendants(xn "ID") |> Seq.head |> fun el -> el.Value)
2018-11-27 12:54:34 -     |> Seq.zip sampleXmlFiles 
2018-11-27 12:54:34 -     |> Seq.map (fun (a,b)-> (b,a)) 
2018-11-27 12:54:46 - pathForGuid |> Seq.take 3
2018-11-27 12:54:52 - pathForGuid |> Seq.take 30
2018-11-27 12:54:58 - pathForGuid |> Seq.take 3 |> dict
2018-11-27 12:55:05 - pathForGuid |> Seq.take 30 |> dict
2018-11-27 12:55:08 - pathForGuid |> Seq.take 300 |> dict
2018-11-27 12:55:08 - Expression evaluation failed: The input sequence was empty.
2018-11-27 12:55:08 - Parameter name: source
2018-11-27 12:55:08 - ArgumentExceptionThe input sequence was empty.
2018-11-27 12:55:08 - Parameter name: source
2018-11-27 12:55:08 -   at Microsoft.FSharp.Collections.SeqModule.Head[T] (System.Collections.Generic.IEnumerable`1[T] source) [0x00033] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 12:55:08 -   at FSI_0039+pathForGuid@4-4.Invoke (System.Xml.Linq.XDocument d) [0x00013] in <c82a4923d09b454bb7c7eb31a0d22fe1>:0 
2018-11-27 12:55:08 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+map@74[b,a].DoMoveNext (b& curr) [0x0001f] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 12:55:08 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+MapEnumerator`1[T].System-Collections-IEnumerator-MoveNext () [0x0000b] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 12:55:08 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+map2@102[c,a,b].DoMoveNext (c& curr) [0x0000c] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 12:55:08 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+MapEnumerator`1[T].System-Collections-IEnumerator-MoveNext () [0x0000b] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 12:55:08 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+map@74[b,a].DoMoveNext (b& curr) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 12:55:08 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+MapEnumerator`1[T].System-Collections-IEnumerator-MoveNext () [0x0000b] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 12:55:08 -   at Microsoft.FSharp.Collections.SeqModule+Take@678[T].GenerateNext (System.Collections.Generic.IEnumerable`1[T]& next) [0x00092] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 12:55:08 -   at Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1[T].MoveNextImpl () [0x00016] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 12:55:08 -   at Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1[T].System-Collections-IEnumerator-MoveNext () [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 12:55:08 -   at Microsoft.FSharp.Core.ExtraTopLevelOperators.dictRefType[TKey,T] (System.Collections.Generic.IEnumerable`1[T] l) [0x00021] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 12:55:08 -   at Microsoft.FSharp.Core.ExtraTopLevelOperators.CreateDictionary[TKey,TValue] (System.Collections.Generic.IEnumerable`1[T] keyValuePairs) [0x00018] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 12:55:08 -   at <StartupCode$FSI_0048>.$FSI_0048.main@ () [0x0000f] in <c82a4923d09b454bb7c7eb31a0d22fe1>:0 
2018-11-27 12:55:08 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-11-27 12:55:08 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x00032] in <14a60dd6a7d84d269fce235fa522c903>:0 
2018-11-27 12:56:02 - let pathForGuid = 
2018-11-27 12:56:02 -     sampleXmlFiles 
2018-11-27 12:56:02 -     |> Seq.map doc 
2018-11-27 12:56:02 -     |> Seq.filter (fun (_, d) -> d.Descendants(xn "ID") |> fun ds -> Seq.length ds > 0)
2018-11-27 12:56:02 -     |> Seq.map (fun d -> d.Descendants(xn "ID") |> Seq.head |> fun el -> el.Value)
2018-11-27 12:56:02 -     |> Seq.zip sampleXmlFiles 
2018-11-27 12:56:02 -     |> Seq.map (fun (a,b)-> (b,a)) 
2018-11-27 12:56:02 - This expression was expected to have type
2018-11-27 12:56:02 -     'XDocument'    
2018-11-27 12:56:02 - but here has type
2018-11-27 12:56:02 -     ''a * 'b'    
2018-11-27 12:57:09 - let pathForGuid = 
2018-11-27 12:57:09 -     sampleXmlFiles 
2018-11-27 12:57:09 -     |> Seq.map doc 
2018-11-27 12:57:09 -     |> Seq.filter (fun (_, d) -> d.Descendants(xn "ID") |> fun ds -> Seq.length ds > 0)
2018-11-27 12:57:09 -     |> Seq.map (fun (p, d) -> (p, (d.Descendants(xn "ID") |> Seq.head |> fun el -> el.Value))
2018-11-27 12:57:09 -     |> Seq.map (fun (a,b)-> (b,a)) 
2018-11-27 12:57:09 - Unmatched '('
2018-11-27 12:57:40 - let pathForGuid = 
2018-11-27 12:57:40 -     sampleXmlFiles 
2018-11-27 12:57:40 -     |> Seq.map doc 
2018-11-27 12:57:40 -     |> Seq.filter (fun (_, d) -> d.Descendants(xn "ID") |> fun ds -> Seq.length ds > 0)
2018-11-27 12:57:40 -     |> Seq.map (fun (p, d) -> ((d.Descendants(xn "ID") |> Seq.head |> fun el -> el.Value), p))
2018-11-27 12:57:40 - This expression was expected to have type
2018-11-27 12:57:40 -     'XDocument'    
2018-11-27 12:57:40 - but here has type
2018-11-27 12:57:40 -     ''a * 'b'    
2018-11-27 12:57:40 - This expression was expected to have type
2018-11-27 12:57:40 -     'XDocument'    
2018-11-27 12:57:40 - but here has type
2018-11-27 12:57:40 -     ''a * 'b'    
2018-11-27 12:58:10 - let pathForGuid = 
2018-11-27 12:58:10 -     sampleXmlFiles 
2018-11-27 12:58:10 -     |> Seq.map doc 
2018-11-27 12:58:10 -     |> Seq.filter (fun (_, d) -> d.Descendants(xn "ID") |> fun ds -> Seq.length ds > 0)
2018-11-27 12:58:10 -     |> Seq.map (fun d -> d.Descendants(xn "ID") |> Seq.head |> fun el -> el.Value)
2018-11-27 12:58:10 - This expression was expected to have type
2018-11-27 12:58:10 -     'XDocument'    
2018-11-27 12:58:10 - but here has type
2018-11-27 12:58:10 -     ''a * 'b'    
2018-11-27 12:58:32 - let pathForGuid = 
2018-11-27 12:58:32 -     sampleXmlFiles 
2018-11-27 12:58:32 -     |> Seq.map doc 
2018-11-27 12:58:32 -     |> Seq.filter (fun d -> d.Descendants(xn "ID") |> fun ds -> Seq.length ds > 0)
2018-11-27 12:58:32 -     |> Seq.map (fun d -> d.Descendants(xn "ID") |> Seq.head |> fun el -> el.Value)
2018-11-27 12:58:40 - pathForGuid |> Seq.take 3
2018-11-27 12:59:03 - let pathForGuid = 
2018-11-27 12:59:03 -     sampleXmlFiles 
2018-11-27 12:59:03 -     |> Seq.map doc 
2018-11-27 12:59:03 -     |> Seq.filter (fun d -> d.Descendants(xn "ID") |> fun ds -> Seq.length ds > 0)
2018-11-27 12:59:03 -     |> Seq.map (fun d -> d.Descendants(xn "ID") |> Seq.head |> fun el -> el.Value)
2018-11-27 12:59:03 -     |> Seq.zip sampleXmlFiles
2018-11-27 12:59:07 - pathForGuid |> Seq.take 3
2018-11-27 12:59:18 - let pathForGuid = 
2018-11-27 12:59:18 -     sampleXmlFiles 
2018-11-27 12:59:18 -     |> Seq.map doc 
2018-11-27 12:59:18 -     |> Seq.filter (fun d -> d.Descendants(xn "ID") |> fun ds -> Seq.length ds > 0)
2018-11-27 12:59:18 -     |> Seq.map (fun d -> d.Descendants(xn "ID") |> Seq.head |> fun el -> el.Value)
2018-11-27 12:59:18 -     |> Seq.zip sampleXmlFiles |> dict
2018-11-27 12:59:24 - pathForGuid |> Seq.take 3
2018-11-27 12:59:51 - let pathForGuid = 
2018-11-27 12:59:51 -     sampleXmlFiles 
2018-11-27 12:59:51 -     |> Seq.map doc 
2018-11-27 12:59:51 -     |> Seq.filter (fun d -> d.Descendants(xn "ID") |> fun ds -> Seq.length ds > 0)
2018-11-27 12:59:51 -     |> Seq.map (fun d -> d.Descendants(xn "ID") |> Seq.head |> fun el -> el.Value)
2018-11-27 12:59:51 -     |> Seq.zip sampleXmlFiles 
2018-11-27 12:59:51 -     |> Seq.map (fun (path, guid) -> (guid, path))
2018-11-27 12:59:51 -     |> dict
2018-11-27 12:59:59 - pathForGuid |> Seq.take 3
2018-11-27 13:00:24 - pathForGuid.["22ab91f1-babe-433e-92ff-5847a5928a34"]
2018-11-27 13:02:16 - let ecmaXmlFiles = Directory.GetFiles(ecmaDir, "*.xml", SearchOption.AllDirectories)
2018-11-27 13:02:16 - let pathsAndDocs = ecmaXmlFiles |> Seq.map (fun path -> (path, doc path))
2018-11-27 13:05:45 - let hasGuidSample doc = 
2018-11-27 13:05:45 -     doc.Descendants(xn "related")
2018-11-27 13:05:45 -     |> Seq.filter (fun el -> el.Attribute(xn "type") |> Option.bind (fun att -> att.Value = "related"))
2018-11-27 13:05:45 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-11-27 13:05:45 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-11-27 13:05:45 - Type mismatch. Expecting a
2018-11-27 13:05:45 -     'SimpleDeclaration option -> bool'    
2018-11-27 13:05:45 - but given a
2018-11-27 13:05:45 -     'SimpleDeclaration option -> obj option'    
2018-11-27 13:05:45 - The type 'bool' does not match the type 'obj option'
2018-11-27 13:05:45 - This expression was expected to have type
2018-11-27 13:05:45 -     'obj option'    
2018-11-27 13:05:45 - but here has type
2018-11-27 13:05:45 -     'bool'    
2018-11-27 13:05:45 - This expression was expected to have type
2018-11-27 13:05:45 -     'obj option'    
2018-11-27 13:05:45 - but here has type
2018-11-27 13:05:45 -     'bool'    
2018-11-27 13:05:45 - Type mismatch. Expecting a
2018-11-27 13:05:45 -     'SimpleDeclaration option -> bool'    
2018-11-27 13:05:45 - but given a
2018-11-27 13:05:45 -     'SimpleDeclaration option -> obj option'    
2018-11-27 13:05:45 - The type 'bool' does not match the type 'obj option'
2018-11-27 13:05:55 - let hasGuidSample (doc : XDocument) = 
2018-11-27 13:05:55 -     doc.Descendants(xn "related")
2018-11-27 13:05:55 -     |> Seq.filter (fun el -> el.Attribute(xn "type") |> Option.bind (fun att -> att.Value = "related"))
2018-11-27 13:05:55 - Type mismatch. Expecting a
2018-11-27 13:05:55 -     'XAttribute -> bool'    
2018-11-27 13:05:55 - but given a
2018-11-27 13:05:55 -     'SimpleDeclaration option -> obj option'    
2018-11-27 13:05:55 - The type 'XAttribute' does not match the type 'SimpleDeclaration option'
2018-11-27 13:05:55 - This expression was expected to have type
2018-11-27 13:05:55 -     'obj option'    
2018-11-27 13:05:55 - but here has type
2018-11-27 13:05:55 -     'bool'    
2018-11-27 13:05:55 - This expression was expected to have type
2018-11-27 13:05:55 -     'obj option'    
2018-11-27 13:05:55 - but here has type
2018-11-27 13:05:55 -     'bool'    
2018-11-27 13:05:55 - Type mismatch. Expecting a
2018-11-27 13:05:55 -     'XAttribute -> bool'    
2018-11-27 13:05:55 - but given a
2018-11-27 13:05:55 -     'SimpleDeclaration option -> obj option'    
2018-11-27 13:05:55 - The type 'XAttribute' does not match the type 'SimpleDeclaration option'
2018-11-27 13:06:55 - let hasGuidSample (doc : XDocument) = 
2018-11-27 13:06:55 -     doc.Descendants(xn "related")
2018-11-27 13:06:55 -     |> Seq.filter (fun el -> el.Attribute(xn "type") |> Option.HasValue)
2018-11-27 13:06:55 - The value, constructor, namespace or type 'HasValue' is not defined.
2018-11-27 13:07:05 - let hasGuidSample (doc : XDocument) = 
2018-11-27 13:07:05 -     doc.Descendants(xn "related")
2018-11-27 13:07:05 -     |> Seq.filter (fun el -> el.Attribute(xn "type") |> Option.IsSome)
2018-11-27 13:07:05 - The instantiation of the generic type 'Option' is missing and can't be inferred from the arguments or return type of this member. Consider providing a type instantiation when accessing this type, e.g. 'Option<_>'.
2018-11-27 13:07:05 - Property 'IsSome' is not static
2018-11-27 13:07:50 - let hasGuidSample (doc : XDocument) = 
2018-11-27 13:07:50 -     doc.Descendants(xn "related")
2018-11-27 13:07:50 -     |> Seq.filter (fun el -> el.Attribute(xn "type") |> Option.isSome)
2018-11-27 13:07:50 - Type mismatch. Expecting a
2018-11-27 13:07:50 -     'XAttribute -> bool'    
2018-11-27 13:07:50 - but given a
2018-11-27 13:07:50 -     'obj option -> bool'    
2018-11-27 13:07:50 - The type 'XAttribute' does not match the type 'obj option'
2018-11-27 13:08:07 - let hasGuidSample (doc : XDocument) = 
2018-11-27 13:08:07 -     doc.Descendants(xn "related")
2018-11-27 13:08:07 -     |> Seq.filter (fun el -> el.Attribute(xn "type") <> null)
2018-11-27 13:08:36 - let hasGuidSample (doc : XDocument) = 
2018-11-27 13:08:36 -     doc.Descendants(xn "related")
2018-11-27 13:08:36 -     |> Seq.filter (fun el -> el.Attribute(xn "type") <> null)
2018-11-27 13:08:36 -     |> Seq.filter (fun el -> el.Attribute(xn "type").Value = "sample")
2018-11-27 13:08:58 - let sampleEls (doc : XDocument) = 
2018-11-27 13:08:58 -     doc.Descendants(xn "related")
2018-11-27 13:08:58 -     |> Seq.filter (fun el -> el.Attribute(xn "type") <> null)
2018-11-27 13:08:58 -     |> Seq.filter (fun el -> el.Attribute(xn "type").Value = "sample")
2018-11-27 13:10:14 - let sampleEls (doc : XDocument) = 
2018-11-27 13:10:14 -     doc.Descendants(xn "related")
2018-11-27 13:10:14 -     |> Seq.filter (fun el -> el.Attribute(xn "type") <> null)
2018-11-27 13:10:14 -     |> Seq.filter (fun el -> el.Attribute(xn "type").Value = "sample")
2018-11-27 13:10:14 -     |> Seq.filter (fun el -> el.Value.Contains("ByGuid?guid="))
2018-11-27 13:11:48 - let sampleEls (doc : XDocument) = 
2018-11-27 13:11:48 -     let guidSamples = 
2018-11-27 13:11:48 -         doc.Descendants(xn "related")
2018-11-27 13:11:48 -         |> Seq.filter (fun el -> el.Attribute(xn "type") <> null)
2018-11-27 13:11:48 -         |> Seq.filter (fun el -> el.Attribute(xn "type").Value = "sample")
2018-11-27 13:11:48 -         |> Seq.filter (fun el -> el.Value.Contains("ByGuid?guid="))
2018-11-27 13:11:48 -     match guidSamples |> Seq.length with 
2018-11-27 13:11:48 -     | 0 -> None
2018-11-27 13:11:48 -     | _ -> Some guidSamples
2018-11-27 13:12:17 - pathsAndDocs |> Seq.map (fun (path, doc) -> (path, sampleEls doc))
2018-11-27 13:12:27 - pathsAndDocs 
2018-11-27 13:12:27 - |> Seq.map (fun (path, doc) -> (path, sampleEls doc))
2018-11-27 13:12:27 - |> Seq.collect id 
2018-11-27 13:12:27 - The type 'string * seq<XElement> option' is not compatible with the type 'seq<obj>'
2018-11-27 13:12:58 - pathsAndDocs 
2018-11-27 13:12:58 - |> Seq.map (fun (path, doc) -> (path, sampleEls doc))
2018-11-27 13:12:58 - |> Seq.choose id 
2018-11-27 13:12:58 - Type mismatch. Expecting a
2018-11-27 13:12:58 -     'string * seq<XElement> option -> obj option'    
2018-11-27 13:12:58 - but given a
2018-11-27 13:12:58 -     'string * seq<XElement> option -> string * seq<XElement> option'    
2018-11-27 13:12:58 - The type 'obj option' does not match the type 'string * seq<XElement> option'
2018-11-27 13:14:07 - pathsAndDocs 
2018-11-27 13:14:07 - |> Seq.map (fun (path, doc) -> (path, sampleEls doc))
2018-11-27 13:14:07 - |> Seq.filter (fun (path, sampleEls) -> sampleEls.isSome)
2018-11-27 13:14:07 - The field, constructor or member 'isSome' is not defined. Maybe you want one of the following:
2018-11-27 13:14:07 -    IsSome
2018-11-27 13:14:07 -    Some
2018-11-27 13:14:07 -    IsNone
2018-11-27 13:14:14 - pathsAndDocs 
2018-11-27 13:14:14 - |> Seq.map (fun (path, doc) -> (path, sampleEls doc))
2018-11-27 13:14:14 - |> Seq.filter (fun (path, sampleEls) -> sampleEls.IsSome)
2018-11-27 13:14:47 - let sampleEls (doc : XDocument) = 
2018-11-27 13:14:47 -     let guidSamples = 
2018-11-27 13:14:47 -         doc.Descendants(xn "related")
2018-11-27 13:14:47 -         |> Seq.filter (fun el -> el.Attribute(xn "type") <> null)
2018-11-27 13:14:47 -         |> Seq.filter (fun el -> el.Attribute(xn "type").Value = "sample")
2018-11-27 13:14:47 -         //|> Seq.filter (fun el -> el.Value.Contains("ByGuid?guid="))
2018-11-27 13:14:47 -     match guidSamples |> Seq.length with 
2018-11-27 13:14:47 -     | 0 -> None
2018-11-27 13:14:47 -     | _ -> Some guidSamples
2018-11-27 13:14:50 - pathsAndDocs 
2018-11-27 13:14:50 - |> Seq.map (fun (path, doc) -> (path, sampleEls doc))
2018-11-27 13:14:50 - |> Seq.filter (fun (path, sampleEls) -> sampleEls.IsSome)
2018-11-27 13:15:25 - let sampleEls (doc : XDocument) = 
2018-11-27 13:15:25 -     let guidSamples = 
2018-11-27 13:15:25 -         doc.Descendants(xn "related")
2018-11-27 13:15:25 -         |> Seq.filter (fun el -> el.Attribute(xn "type") <> null)
2018-11-27 13:15:25 -         |> Seq.filter (fun el -> el.Attribute(xn "type").Value = "sample")
2018-11-27 13:15:25 -         |> Seq.filter (fun el -> el.Attribute(xn "href".Value.Contains("ByGuid?guid="))
2018-11-27 13:15:25 -     match guidSamples |> Seq.length with 
2018-11-27 13:15:25 -     | 0 -> None
2018-11-27 13:15:25 -     | _ -> Some guidSamples
2018-11-27 13:15:25 - Successive arguments should be separated by spaces or tupled, and arguments involving function or method applications should be parenthesized
2018-11-27 13:15:25 - Possible incorrect indentation: this token is offside of context started at position (3:9). Try indenting this token further or using standard formatting conventions.
2018-11-27 13:15:25 - Unexpected keyword 'match' in expression
2018-11-27 13:15:25 - The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.
2018-11-27 13:15:33 - let sampleEls (doc : XDocument) = 
2018-11-27 13:15:33 -     let guidSamples = 
2018-11-27 13:15:33 -         doc.Descendants(xn "related")
2018-11-27 13:15:33 -         |> Seq.filter (fun el -> el.Attribute(xn "type") <> null)
2018-11-27 13:15:33 -         |> Seq.filter (fun el -> el.Attribute(xn "type").Value = "sample")
2018-11-27 13:15:33 -         |> Seq.filter (fun el -> el.Attribute(xn "href").Value.Contains("ByGuid?guid="))
2018-11-27 13:15:33 -     match guidSamples |> Seq.length with 
2018-11-27 13:15:33 -     | 0 -> None
2018-11-27 13:15:33 -     | _ -> Some guidSamples
2018-11-27 13:15:36 - pathsAndDocs 
2018-11-27 13:15:36 - |> Seq.map (fun (path, doc) -> (path, sampleEls doc))
2018-11-27 13:15:36 - |> Seq.filter (fun (path, sampleEls) -> sampleEls.IsSome)
2018-11-27 13:16:12 - let pathsAndSamplesEls = 
2018-11-27 13:16:12 -     pathsAndDocs 
2018-11-27 13:16:12 -     |> Seq.map (fun (path, doc) -> (path, sampleEls doc))
2018-11-27 13:16:12 -     |> Seq.filter (fun (path, sampleEls) -> sampleEls.IsSome)
2018-11-27 13:16:25 - pathsAndSampleEls |> Seq.head
2018-11-27 13:16:25 - The value or constructor 'pathsAndSampleEls' is not defined. Maybe you want one of the following:
2018-11-27 13:16:25 -    pathsAndSamplesEls
2018-11-27 13:16:25 -    pathsAndDocs
2018-11-27 13:16:39 - let pathsAndSampleEls = 
2018-11-27 13:16:39 -     pathsAndDocs 
2018-11-27 13:16:39 -     |> Seq.map (fun (path, doc) -> (path, sampleEls doc))
2018-11-27 13:16:39 -     |> Seq.filter (fun (path, sampleEls) -> sampleEls.IsSome)
2018-11-27 13:16:41 - pathsAndSampleEls |> Seq.head
2018-11-27 13:19:43 - let guidInCref cref = cref.Substring(cref.IndexOf("ByGuid?guid=")+"ByGuid?guid=".length)
2018-11-27 13:19:43 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-11-27 13:19:52 - let guidInCref (cref : string) = cref.Substring(cref.IndexOf("ByGuid?guid=")+"ByGuid?guid=".length)
2018-11-27 13:19:52 - The field, constructor or member 'length' is not defined. Maybe you want one of the following:
2018-11-27 13:19:52 -    Length
2018-11-27 13:19:59 - let guidInCref (cref : string) = cref.Substring(cref.IndexOf("ByGuid?guid=")+"ByGuid?guid=".Length)
2018-11-27 13:20:15 - guidInCref "http://samples.xamarin.com/Samples/ByGuid?guid=2c1eba2d-8abc-408e-8ee8-a03ffac6ffde"
2018-11-27 13:51:58 - let fixEl el guid = el.Attribute(xn "href").Value <- relativePathForGuid.[guid]
2018-11-27 13:51:58 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2018-11-27 13:52:14 - let fixEl (el : XElement) (guid : string) = el.Attribute(xn "href").Value <- relativePathForGuid.[guid]
2018-11-27 13:52:14 - The value or constructor 'relativePathForGuid' is not defined.
2018-11-27 13:52:14 - The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints
2018-11-27 13:56:56 - let githubLinkFor (path : string) = sprintf "https://github.com/xamarin/ios-samples/tree/master/%s" path.Substring(path.IndexOf("xamarin/ios-samples")+"xamarin/ios-samples".Length)
2018-11-27 13:56:56 - Successive arguments should be separated by spaces or tupled, and arguments involving function or method applications should be parenthesized
2018-11-27 13:57:05 - let githubLinkFor (path : string) = sprintf "https://github.com/xamarin/ios-samples/tree/master/%s" <| h.Substring(path.IndexOf("xamarin/ios-samples")+"xamarin/ios-samples".Length)
2018-11-27 13:57:05 - The value, namespace, type or module 'h' is not defined.
2018-11-27 13:57:18 - let githubLinkFor (path : string) = sprintf "https://github.com/xamarin/ios-samples/tree/master/%s" <| path.Substring(path.IndexOf("xamarin/ios-samples")+"xamarin/ios-samples".Length)
2018-11-27 13:57:26 - sampleXmlFiles 
2018-11-27 13:57:26 - |> Seq.map (fun p -> (githubLinkFor p, doc p)) 
2018-11-27 13:57:26 - |> Seq.filter (fun (_, d) -> d.Descendants(xn "ID")) |> Seq.length |> (>0)
2018-11-27 13:57:26 - Unexpected integer literal in expression. Expected ')' or other token.
2018-11-27 13:57:26 - Unmatched '('
2018-11-27 13:58:05 - let pathForGuid = 
2018-11-27 13:58:05 -     sampleXmlFiles 
2018-11-27 13:58:05 -     |> Seq.map doc 
2018-11-27 13:58:05 -     |> Seq.filter (fun d -> d.Descendants(xn "ID") |> fun ds -> Seq.length ds > 0)
2018-11-27 13:58:05 -     |> Seq.map (fun d -> d.Descendants(xn "ID") |> Seq.head |> fun el -> el.Value)
2018-11-27 13:58:05 -     |> Seq.zip (sampleXmlFiles |> Seq.map githubLinkFor)
2018-11-27 13:58:05 -     |> Seq.map (fun (path, guid) -> (guid, path))
2018-11-27 13:58:05 -     |> dict
2018-11-27 13:58:13 - pathForGuid.["22ab91f1-babe-433e-92ff-5847a5928a34"]
2018-11-27 13:58:38 - let githubLinkFor (path : string) = sprintf "https://github.com/xamarin/ios-samples/tree/master/%s" <| path.Substring(path.IndexOf("xamarin/ios-samples/")+"xamarin/ios-samples/".Length)
2018-11-27 13:58:44 - sampleXmlFiles |> Seq.head
2018-11-27 13:58:48 - let pathForGuid = 
2018-11-27 13:58:48 -     sampleXmlFiles 
2018-11-27 13:58:48 -     |> Seq.map doc 
2018-11-27 13:58:48 -     |> Seq.filter (fun d -> d.Descendants(xn "ID") |> fun ds -> Seq.length ds > 0)
2018-11-27 13:58:48 -     |> Seq.map (fun d -> d.Descendants(xn "ID") |> Seq.head |> fun el -> el.Value)
2018-11-27 13:58:48 -     |> Seq.zip (sampleXmlFiles |> Seq.map githubLinkFor)
2018-11-27 13:58:48 -     |> Seq.map (fun (path, guid) -> (guid, path))
2018-11-27 13:58:48 -     |> dict
2018-11-27 13:58:56 - pathForGuid.["22ab91f1-babe-433e-92ff-5847a5928a34"]
2018-11-27 13:59:37 - let githubLinkFor (path : string) = 
2018-11-27 13:59:37 -     sprintf "https://github.com/xamarin/ios-samples/tree/master/%s" <| path.Substring(path.IndexOf("xamarin/ios-samples/")+"xamarin/ios-samples/".Length)
2018-11-27 13:59:37 -     |> fun s -> s.Substring(0, s.IndexOf("Metadata.xml"))
2018-11-27 13:59:42 - let pathForGuid = 
2018-11-27 13:59:42 -     sampleXmlFiles 
2018-11-27 13:59:42 -     |> Seq.map doc 
2018-11-27 13:59:42 -     |> Seq.filter (fun d -> d.Descendants(xn "ID") |> fun ds -> Seq.length ds > 0)
2018-11-27 13:59:42 -     |> Seq.map (fun d -> d.Descendants(xn "ID") |> Seq.head |> fun el -> el.Value)
2018-11-27 13:59:42 -     |> Seq.zip (sampleXmlFiles |> Seq.map githubLinkFor)
2018-11-27 13:59:42 -     |> Seq.map (fun (path, guid) -> (guid, path))
2018-11-27 13:59:42 -     |> dict
2018-11-27 13:59:42 - Expression evaluation failed: Length cannot be less than zero.
2018-11-27 13:59:42 - Parameter name: length
2018-11-27 13:59:42 - ArgumentOutOfRangeExceptionLength cannot be less than zero.
2018-11-27 13:59:42 - Parameter name: length
2018-11-27 13:59:42 -   at System.String.Substring (System.Int32 startIndex, System.Int32 length) [0x0004a] in <14a60dd6a7d84d269fce235fa522c903>:0 
2018-11-27 13:59:42 -   at FSI_0117.githubLinkFor (System.String path) [0x00051] in <c82a4923d09b454bb7c7eb31a0d22fe1>:0 
2018-11-27 13:59:42 -   at FSI_0118+pathForGuid@6-33.Invoke (System.String path) [0x00000] in <c82a4923d09b454bb7c7eb31a0d22fe1>:0 
2018-11-27 13:59:42 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+map@74[b,a].DoMoveNext (b& curr) [0x0001f] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 13:59:42 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+MapEnumerator`1[T].System-Collections-IEnumerator-MoveNext () [0x0000b] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 13:59:42 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+map2@102[c,a,b].DoMoveNext (c& curr) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 13:59:42 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+MapEnumerator`1[T].System-Collections-IEnumerator-MoveNext () [0x0000b] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 13:59:42 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+map@74[b,a].DoMoveNext (b& curr) [0x00000] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 13:59:42 -   at Microsoft.FSharp.Collections.Internal+IEnumerator+MapEnumerator`1[T].System-Collections-IEnumerator-MoveNext () [0x0000b] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 13:59:42 -   at Microsoft.FSharp.Core.ExtraTopLevelOperators.dictRefType[TKey,T] (System.Collections.Generic.IEnumerable`1[T] l) [0x00021] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 13:59:42 -   at Microsoft.FSharp.Core.ExtraTopLevelOperators.CreateDictionary[TKey,TValue] (System.Collections.Generic.IEnumerable`1[T] keyValuePairs) [0x00018] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 13:59:42 -   at <StartupCode$FSI_0118>.$FSI_0118.main@ () [0x0004b] in <c82a4923d09b454bb7c7eb31a0d22fe1>:0 
2018-11-27 13:59:42 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-11-27 13:59:42 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x00032] in <14a60dd6a7d84d269fce235fa522c903>:0 
2018-11-27 14:00:14 - sampleXmlFiles |> Seq.head
2018-11-27 14:00:32 - let githubLinkFor (path : string) = 
2018-11-27 14:00:32 -     sprintf "https://github.com/xamarin/ios-samples/tree/master/%s" <| path.Substring(path.IndexOf("xamarin/ios-samples/")+"xamarin/ios-samples/".Length)
2018-11-27 14:00:32 -   //  |> fun s -> s.Substring(0, s.IndexOf("Metadata.xml"))
2018-11-27 14:00:36 - let pathForGuid = 
2018-11-27 14:00:36 -     sampleXmlFiles 
2018-11-27 14:00:36 -     |> Seq.map doc 
2018-11-27 14:00:36 -     |> Seq.filter (fun d -> d.Descendants(xn "ID") |> fun ds -> Seq.length ds > 0)
2018-11-27 14:00:36 -     |> Seq.map (fun d -> d.Descendants(xn "ID") |> Seq.head |> fun el -> el.Value)
2018-11-27 14:00:36 -     |> Seq.zip (sampleXmlFiles |> Seq.map githubLinkFor)
2018-11-27 14:00:36 -     |> Seq.map (fun (path, guid) -> (guid, path))
2018-11-27 14:00:36 -     |> dict
2018-11-27 14:01:14 - pathForGuid.Values |> Seq.filter(fun p -> p.IndexOf("Metadata.xml") = -1)
2018-11-27 14:01:38 - let samplesDir = "/Users/larryobrien/Documents/src/xamarin/ios-samples"
2018-11-27 14:01:38 - let ecmaDir = "/Users/larryobrien/Documents/src/xamarin/apple-api-docs/en"
2018-11-27 14:01:38 - #r "System.Xml.Linq"
2018-11-27 14:01:38 - open System.Xml.Linq
2018-11-27 14:01:38 - let xn s = XName.Get(s)
2018-11-27 14:01:38 - let doc (f : string) : XDocument = XDocument.Load(f)
2018-11-27 14:01:38 - open System.IO
2018-11-27 14:01:38 - let sampleXmlFiles = Directory.GetFiles(samplesDir, "Metadata.xml", SearchOption.AllDirectories)
2018-11-27 14:01:40 - let githubLinkFor (path : string) = 
2018-11-27 14:01:40 -     sprintf "https://github.com/xamarin/ios-samples/tree/master/%s" <| path.Substring(path.IndexOf("xamarin/ios-samples/")+"xamarin/ios-samples/".Length)
2018-11-27 14:01:40 -   //  |> fun s -> s.Substring(0, s.IndexOf("Metadata.xml"))
2018-11-27 14:01:40 - sampleXmlFiles |> Seq.head
2018-11-27 14:01:40 - let pathForGuid = 
2018-11-27 14:01:40 -     sampleXmlFiles 
2018-11-27 14:01:40 -     |> Seq.map doc 
2018-11-27 14:01:40 -     |> Seq.filter (fun d -> d.Descendants(xn "ID") |> fun ds -> Seq.length ds > 0)
2018-11-27 14:01:40 -     |> Seq.map (fun d -> d.Descendants(xn "ID") |> Seq.head |> fun el -> el.Value)
2018-11-27 14:01:40 -     |> Seq.zip (sampleXmlFiles |> Seq.map githubLinkFor)
2018-11-27 14:01:40 -     |> Seq.map (fun (path, guid) -> (guid, path))
2018-11-27 14:01:40 -     |> dict
2018-11-27 14:01:40 - pathForGuid.Values |> Seq.filter(fun p -> p.IndexOf("Metadata.xml") = -1)
2018-11-27 14:01:40 - pathForGuid.["22ab91f1-babe-433e-92ff-5847a5928a34"]
2018-11-27 14:01:40 - let ecmaXmlFiles = Directory.GetFiles(ecmaDir, "*.xml", SearchOption.AllDirectories)
2018-11-27 14:01:40 - let pathsAndDocs = ecmaXmlFiles |> Seq.map (fun path -> (path, doc path))
2018-11-27 14:01:41 - let sampleEls (doc : XDocument) = 
2018-11-27 14:01:41 -     let guidSamples = 
2018-11-27 14:01:41 -         doc.Descendants(xn "related")
2018-11-27 14:01:41 -         |> Seq.filter (fun el -> el.Attribute(xn "type") <> null)
2018-11-27 14:01:41 -         |> Seq.filter (fun el -> el.Attribute(xn "type").Value = "sample")
2018-11-27 14:01:41 -         |> Seq.filter (fun el -> el.Attribute(xn "href").Value.Contains("ByGuid?guid="))
2018-11-27 14:01:41 -     match guidSamples |> Seq.length with 
2018-11-27 14:01:41 -     | 0 -> None
2018-11-27 14:01:41 -     | _ -> Some guidSamples
2018-11-27 14:01:41 - let pathsAndSampleEls = 
2018-11-27 14:01:41 -     pathsAndDocs 
2018-11-27 14:01:41 -     |> Seq.map (fun (path, doc) -> (path, sampleEls doc))
2018-11-27 14:01:41 -     |> Seq.filter (fun (path, sampleEls) -> sampleEls.IsSome)
2018-11-27 14:01:41 - pathsAndSampleEls |> Seq.head
2018-11-27 14:01:41 - let guidInCref (cref : string) = cref.Substring(cref.IndexOf("ByGuid?guid=")+"ByGuid?guid=".Length)
2018-11-27 14:01:41 - guidInCref "http://samples.xamarin.com/Samples/ByGuid?guid=2c1eba2d-8abc-408e-8ee8-a03ffac6ffde"
2018-11-27 14:01:41 - let fixEl (el : XElement) (guid : string) = el.Attribute(xn "href").Value <- relativePathForGuid.[guid]
2018-11-27 14:01:41 - The value or constructor 'relativePathForGuid' is not defined.
2018-11-27 14:01:41 - The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints
2018-11-27 14:01:57 - let samplesDir = "/Users/larryobrien/Documents/src/xamarin/ios-samples"
2018-11-27 14:01:57 - let ecmaDir = "/Users/larryobrien/Documents/src/xamarin/apple-api-docs/en"
2018-11-27 14:01:57 - #r "System.Xml.Linq"
2018-11-27 14:01:57 - open System.Xml.Linq
2018-11-27 14:01:57 - let xn s = XName.Get(s)
2018-11-27 14:01:57 - let doc (f : string) : XDocument = XDocument.Load(f)
2018-11-27 14:01:57 - open System.IO
2018-11-27 14:01:57 - let sampleXmlFiles = Directory.GetFiles(samplesDir, "Metadata.xml", SearchOption.AllDirectories)
2018-11-27 14:01:58 - let githubLinkFor (path : string) = 
2018-11-27 14:01:58 -     sprintf "https://github.com/xamarin/ios-samples/tree/master/%s" <| path.Substring(path.IndexOf("xamarin/ios-samples/")+"xamarin/ios-samples/".Length)
2018-11-27 14:01:58 -     |> fun s -> s.Substring(0, s.IndexOf("Metadata.xml"))
2018-11-27 14:01:58 - sampleXmlFiles |> Seq.head
2018-11-27 14:01:58 - let pathForGuid = 
2018-11-27 14:01:58 -     sampleXmlFiles 
2018-11-27 14:01:58 -     |> Seq.map doc 
2018-11-27 14:01:58 -     |> Seq.filter (fun d -> d.Descendants(xn "ID") |> fun ds -> Seq.length ds > 0)
2018-11-27 14:01:58 -     |> Seq.map (fun d -> d.Descendants(xn "ID") |> Seq.head |> fun el -> el.Value)
2018-11-27 14:01:58 -     |> Seq.zip (sampleXmlFiles |> Seq.map githubLinkFor)
2018-11-27 14:01:58 -     |> Seq.map (fun (path, guid) -> (guid, path))
2018-11-27 14:01:58 -     |> dict
2018-11-27 14:01:58 - pathForGuid.Values |> Seq.filter(fun p -> p.IndexOf("Metadata.xml") = -1)
2018-11-27 14:01:58 - pathForGuid.["22ab91f1-babe-433e-92ff-5847a5928a34"]
2018-11-27 14:01:58 - let ecmaXmlFiles = Directory.GetFiles(ecmaDir, "*.xml", SearchOption.AllDirectories)
2018-11-27 14:01:58 - let pathsAndDocs = ecmaXmlFiles |> Seq.map (fun path -> (path, doc path))
2018-11-27 14:01:58 - let sampleEls (doc : XDocument) = 
2018-11-27 14:01:58 -     let guidSamples = 
2018-11-27 14:01:58 -         doc.Descendants(xn "related")
2018-11-27 14:01:58 -         |> Seq.filter (fun el -> el.Attribute(xn "type") <> null)
2018-11-27 14:01:58 -         |> Seq.filter (fun el -> el.Attribute(xn "type").Value = "sample")
2018-11-27 14:01:58 -         |> Seq.filter (fun el -> el.Attribute(xn "href").Value.Contains("ByGuid?guid="))
2018-11-27 14:01:58 -     match guidSamples |> Seq.length with 
2018-11-27 14:01:58 -     | 0 -> None
2018-11-27 14:01:58 -     | _ -> Some guidSamples
2018-11-27 14:01:58 - let pathsAndSampleEls = 
2018-11-27 14:01:58 -     pathsAndDocs 
2018-11-27 14:01:58 -     |> Seq.map (fun (path, doc) -> (path, sampleEls doc))
2018-11-27 14:01:58 -     |> Seq.filter (fun (path, sampleEls) -> sampleEls.IsSome)
2018-11-27 14:01:58 - pathsAndSampleEls |> Seq.head
2018-11-27 14:01:59 - let guidInCref (cref : string) = cref.Substring(cref.IndexOf("ByGuid?guid=")+"ByGuid?guid=".Length)
2018-11-27 14:01:59 - guidInCref "http://samples.xamarin.com/Samples/ByGuid?guid=2c1eba2d-8abc-408e-8ee8-a03ffac6ffde"
2018-11-27 14:01:59 - let fixEl (el : XElement) (guid : string) = el.Attribute(xn "href").Value <- relativePathForGuid.[guid]
2018-11-27 14:01:59 - The value or constructor 'relativePathForGuid' is not defined.
2018-11-27 14:01:59 - The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints
2018-11-27 14:02:21 - let fixEl (el : XElement) (guid : string) = el.Attribute(xn "href").Value <- pathForGuid.[guid]
2018-11-27 14:03:25 - fixEl
2018-11-27 14:09:15 - open System.Text
2018-11-27 14:09:15 - open System.Xml 
2018-11-27 14:09:15 - let fixAllElsAndSave (path : string) (els : XElement seq) = 
2018-11-27 14:09:15 -     els |> Seq.iter (fun el -> el.Attribute(xn "href").Value |> guidInCref |> fixEl el)
2018-11-27 14:09:15 -     let doc = els |> Seq.head |> fun el -> el.Document
2018-11-27 14:09:15 -     use fs = new FileStream(path, FileMode.Create)
2018-11-27 14:09:15 -     use swWriter = new StreamWriter(fs, new UTF8Encoding(false))
2018-11-27 14:09:15 -     use writer = new XmlTextWriter(swWriter)
2018-11-27 14:09:15 -     writer.Formatting <- Formatting.Indented
2018-11-27 14:09:15 -     writer.Indentation <- 2
2018-11-27 14:09:15 -     writer.IndentChar <- ' '
2018-11-27 14:09:15 -     doc.Root.WriteTo(writer)
2018-11-27 14:09:15 -     swWriter.WriteLine()
2018-11-27 14:09:15 -     writer.Dispose()
2018-11-27 14:09:15 -     swWriter.Dispose()
2018-11-27 14:09:15 -     fs.Dispose()
2018-11-27 14:11:04 - let pathsAndSampleEls = 
2018-11-27 14:11:04 -     pathsAndDocs 
2018-11-27 14:11:04 -     |> Seq.map (fun (path, doc) -> (path, sampleEls doc))
2018-11-27 14:11:04 -     |> Seq.filter (fun (path, sampleEls) -> sampleEls.IsSome)
2018-11-27 14:11:04 -     |> Seq.map (fun (path, samplesEls) -> (path, samplesEls |> Seq.choose id)
2018-11-27 14:11:04 - Unmatched '('
2018-11-27 14:12:17 - let pathsAndSampleEls = 
2018-11-27 14:12:17 -     pathsAndDocs 
2018-11-27 14:12:17 -     |> Seq.map (fun (path, doc) -> (path, sampleEls doc))
2018-11-27 14:12:17 -     |> Seq.filter (fun (path, sampleEls) -> sampleEls.IsSome)
2018-11-27 14:12:17 -     |> Seq.map (fun (path, samplesEls) -> (path, Seq.choose sampleEls))
2018-11-27 14:12:17 - Value restriction. The value 'pathsAndSampleEls' has been inferred to have generic type
2018-11-27 14:12:17 -     val pathsAndSampleEls : seq<string * (seq<XDocument> -> seq<seq<XElement>>)>    
2018-11-27 14:12:17 - Either define 'pathsAndSampleEls' as a simple data term, make it a function with explicit arguments or, if you do not intend for it to be generic, add a type annotation.
2018-11-27 14:13:45 - let pathsAndSampleEls = 
2018-11-27 14:13:45 -     pathsAndDocs 
2018-11-27 14:13:45 -     |> Seq.map (fun (path, doc) -> (path, sampleEls doc))
2018-11-27 14:13:45 -     |> Seq.filter (fun (path, sampleEls) -> sampleEls.IsSome)
2018-11-27 14:13:45 -     |> Seq.map (fun (path, Some samplesEls) -> (path, sampleEls))
2018-11-27 14:13:45 - Incomplete pattern matches on this expression. For example, the value 'None' may indicate a case not covered by the pattern(s).
2018-11-27 14:13:45 - Value restriction. The value 'pathsAndSampleEls' has been inferred to have generic type
2018-11-27 14:13:45 -     val pathsAndSampleEls : seq<string * (XDocument -> seq<XElement> option)>    
2018-11-27 14:13:45 - Either define 'pathsAndSampleEls' as a simple data term, make it a function with explicit arguments or, if you do not intend for it to be generic, add a type annotation.
2018-11-27 14:18:44 - let pathsAndSampleEls = 
2018-11-27 14:18:44 -     pathsAndDocs 
2018-11-27 14:18:44 -     |> Seq.map (fun (path, doc) -> (path, sampleEls doc))
2018-11-27 14:18:44 -     |> Seq.filter (fun (path, sampleEls) ->  
2018-11-27 14:18:44 -         match sampleEls with 
2018-11-27 14:18:44 -         | Some els -> true
2018-11-27 14:18:44 -         | None -> false
2018-11-27 14:18:44 -     )
2018-11-27 14:18:44 -     |> Seq.map (fun (path, samplesEls) -> (path, sampleEls.Value))
2018-11-27 14:18:44 - Type constraint mismatch. The type 
2018-11-27 14:18:44 -     ''a -> seq<XElement> option'    
2018-11-27 14:18:44 - is not compatible with type
2018-11-27 14:18:44 -     'SimpleDeclaration'    
2018-11-27 14:19:27 - let pathsAndSampleEls = 
2018-11-27 14:19:27 -     pathsAndDocs 
2018-11-27 14:19:27 -     |> Seq.map (fun (path, doc) -> (path, sampleEls doc))
2018-11-27 14:19:27 -     |> Seq.filter (fun (path, sampleEls) -> sampleEls.IsSome)
2018-11-27 14:19:27 -     
2018-11-27 14:21:11 - open System.Text
2018-11-27 14:21:11 - open System.Xml 
2018-11-27 14:21:11 - let fixAllElsAndSave (path : string, maybeEls : XElement seq option) = 
2018-11-27 14:21:11 -     match maybeEls with 
2018-11-27 14:21:11 -     | None -> ignore()
2018-11-27 14:21:11 -     | Some els -> 
2018-11-27 14:21:11 -         els |> Seq.iter (fun el -> el.Attribute(xn "href").Value |> guidInCref |> fixEl el)
2018-11-27 14:21:11 -         let doc = els |> Seq.head |> fun el -> el.Document
2018-11-27 14:21:11 -         use fs = new FileStream(path, FileMode.Create)
2018-11-27 14:21:11 -         use swWriter = new StreamWriter(fs, new UTF8Encoding(false))
2018-11-27 14:21:11 -         use writer = new XmlTextWriter(swWriter)
2018-11-27 14:21:11 -         writer.Formatting <- Formatting.Indented
2018-11-27 14:21:11 -         writer.Indentation <- 2
2018-11-27 14:21:11 -         writer.IndentChar <- ' '
2018-11-27 14:21:11 -         doc.Root.WriteTo(writer)
2018-11-27 14:21:11 -         swWriter.WriteLine()
2018-11-27 14:21:11 -         writer.Dispose()
2018-11-27 14:21:11 -         swWriter.Dispose()
2018-11-27 14:21:11 -         fs.Dispose()
2018-11-27 14:21:14 - pathsAndSampleEls |> Seq.iter fixAllElsAndSave
2018-11-27 14:21:14 - Expression evaluation failed: The input sequence was empty.
2018-11-27 14:21:14 - Parameter name: source
2018-11-27 14:21:14 - ArgumentExceptionThe input sequence was empty.
2018-11-27 14:21:14 - Parameter name: source
2018-11-27 14:21:14 -   at Microsoft.FSharp.Collections.SeqModule.Head[T] (System.Collections.Generic.IEnumerable`1[T] source) [0x00033] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:21:14 -   at FSI_0174.fixAllElsAndSave (System.String path, Microsoft.FSharp.Core.FSharpOption`1[T] maybeEls) [0x0002d] in <c82a4923d09b454bb7c7eb31a0d22fe1>:0 
2018-11-27 14:21:14 -   at FSI_0175+it@1-40.Invoke (System.Tuple`2[T1,T2] tupledArg) [0x0001a] in <c82a4923d09b454bb7c7eb31a0d22fe1>:0 
2018-11-27 14:21:14 -   at Microsoft.FSharp.Collections.SeqModule.Iterate[T] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] action, System.Collections.Generic.IEnumerable`1[T] source) [0x0002c] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:21:14 -   at <StartupCode$FSI_0175>.$FSI_0175.main@ () [0x0000a] in <c82a4923d09b454bb7c7eb31a0d22fe1>:0 
2018-11-27 14:21:14 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-11-27 14:21:14 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x00032] in <14a60dd6a7d84d269fce235fa522c903>:0 
2018-11-27 14:21:52 - let samplesDir = "/Users/larryobrien/Documents/src/xamarin/ios-samples"
2018-11-27 14:21:52 - let ecmaDir = "/Users/larryobrien/Documents/src/xamarin/apple-api-docs/en"
2018-11-27 14:21:52 - #r "System.Xml.Linq"
2018-11-27 14:21:52 - open System.Xml.Linq
2018-11-27 14:21:52 - let xn s = XName.Get(s)
2018-11-27 14:21:52 - let doc (f : string) : XDocument = XDocument.Load(f)
2018-11-27 14:21:52 - open System.IO
2018-11-27 14:21:52 - let sampleXmlFiles = Directory.GetFiles(samplesDir, "Metadata.xml", SearchOption.AllDirectories)
2018-11-27 14:21:53 - let githubLinkFor (path : string) = 
2018-11-27 14:21:53 -     sprintf "https://github.com/xamarin/ios-samples/tree/master/%s" <| path.Substring(path.IndexOf("xamarin/ios-samples/")+"xamarin/ios-samples/".Length)
2018-11-27 14:21:53 -     |> fun s -> s.Substring(0, s.IndexOf("Metadata.xml"))
2018-11-27 14:21:53 - sampleXmlFiles |> Seq.head
2018-11-27 14:21:53 - let pathForGuid = 
2018-11-27 14:21:53 -     sampleXmlFiles 
2018-11-27 14:21:53 -     |> Seq.map doc 
2018-11-27 14:21:53 -     |> Seq.filter (fun d -> d.Descendants(xn "ID") |> fun ds -> Seq.length ds > 0)
2018-11-27 14:21:53 -     |> Seq.map (fun d -> d.Descendants(xn "ID") |> Seq.head |> fun el -> el.Value)
2018-11-27 14:21:53 -     |> Seq.zip (sampleXmlFiles |> Seq.map githubLinkFor)
2018-11-27 14:21:53 -     |> Seq.map (fun (path, guid) -> (guid, path))
2018-11-27 14:21:53 -     |> dict
2018-11-27 14:21:53 - pathForGuid.Values |> Seq.filter(fun p -> p.IndexOf("Metadata.xml") = -1)
2018-11-27 14:21:53 - pathForGuid.["22ab91f1-babe-433e-92ff-5847a5928a34"]
2018-11-27 14:21:53 - let ecmaXmlFiles = Directory.GetFiles(ecmaDir, "*.xml", SearchOption.AllDirectories)
2018-11-27 14:21:53 - let pathsAndDocs = ecmaXmlFiles |> Seq.map (fun path -> (path, doc path))
2018-11-27 14:21:53 - let sampleEls (doc : XDocument) = 
2018-11-27 14:21:53 -     let guidSamples = 
2018-11-27 14:21:53 -         doc.Descendants(xn "related")
2018-11-27 14:21:53 -         |> Seq.filter (fun el -> el.Attribute(xn "type") <> null)
2018-11-27 14:21:53 -         |> Seq.filter (fun el -> el.Attribute(xn "type").Value = "sample")
2018-11-27 14:21:53 -         |> Seq.filter (fun el -> el.Attribute(xn "href").Value.Contains("ByGuid?guid="))
2018-11-27 14:21:53 -     match guidSamples |> Seq.length with 
2018-11-27 14:21:53 -     | 0 -> None
2018-11-27 14:21:53 -     | _ -> Some guidSamples
2018-11-27 14:21:53 - let pathsAndSampleEls = 
2018-11-27 14:21:53 -     pathsAndDocs 
2018-11-27 14:21:53 -     |> Seq.map (fun (path, doc) -> (path, sampleEls doc))
2018-11-27 14:21:53 -     |> Seq.filter (fun (path, sampleEls) -> sampleEls.IsSome)
2018-11-27 14:21:53 -     
2018-11-27 14:21:53 - pathsAndSampleEls |> Seq.head
2018-11-27 14:21:53 - let guidInCref (cref : string) = cref.Substring(cref.IndexOf("ByGuid?guid=")+"ByGuid?guid=".Length)
2018-11-27 14:21:53 - guidInCref "http://samples.xamarin.com/Samples/ByGuid?guid=2c1eba2d-8abc-408e-8ee8-a03ffac6ffde"
2018-11-27 14:21:53 - let fixEl (el : XElement) (guid : string) = el.Attribute(xn "href").Value <- pathForGuid.[guid]
2018-11-27 14:21:54 - open System.Text
2018-11-27 14:21:54 - open System.Xml 
2018-11-27 14:21:54 - let fixAllElsAndSave (path : string, maybeEls : XElement seq option) = 
2018-11-27 14:21:54 -     match maybeEls with 
2018-11-27 14:21:54 -     | None -> ignore()
2018-11-27 14:21:54 -     | Some els -> 
2018-11-27 14:21:54 -         els |> Seq.iter (fun el -> el.Attribute(xn "href").Value |> guidInCref |> fixEl el)
2018-11-27 14:21:54 -         let doc = els |> Seq.head |> fun el -> el.Document
2018-11-27 14:21:54 -         use fs = new FileStream(path, FileMode.Create)
2018-11-27 14:21:54 -         use swWriter = new StreamWriter(fs, new UTF8Encoding(false))
2018-11-27 14:21:54 -         use writer = new XmlTextWriter(swWriter)
2018-11-27 14:21:54 -         writer.Formatting <- Formatting.Indented
2018-11-27 14:21:54 -         writer.Indentation <- 2
2018-11-27 14:21:54 -         writer.IndentChar <- ' '
2018-11-27 14:21:54 -         doc.Root.WriteTo(writer)
2018-11-27 14:21:54 -         swWriter.WriteLine()
2018-11-27 14:21:54 -         writer.Dispose()
2018-11-27 14:21:54 -         swWriter.Dispose()
2018-11-27 14:21:54 -         fs.Dispose()
2018-11-27 14:21:54 - pathsAndSampleEls |> Seq.iter fixAllElsAndSave
2018-11-27 14:21:54 - Expression evaluation failed: The input sequence was empty.
2018-11-27 14:21:54 - Parameter name: source
2018-11-27 14:21:54 - ArgumentExceptionThe input sequence was empty.
2018-11-27 14:21:54 - Parameter name: source
2018-11-27 14:21:54 -   at Microsoft.FSharp.Collections.SeqModule.Head[T] (System.Collections.Generic.IEnumerable`1[T] source) [0x00033] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:21:54 -   at FSI_0196.fixAllElsAndSave (System.String path, Microsoft.FSharp.Core.FSharpOption`1[T] maybeEls) [0x0002d] in <c82a4923d09b454bb7c7eb31a0d22fe1>:0 
2018-11-27 14:21:54 -   at FSI_0197+it@1-42.Invoke (System.Tuple`2[T1,T2] tupledArg) [0x0001a] in <c82a4923d09b454bb7c7eb31a0d22fe1>:0 
2018-11-27 14:21:54 -   at Microsoft.FSharp.Collections.SeqModule.Iterate[T] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] action, System.Collections.Generic.IEnumerable`1[T] source) [0x0002c] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:21:54 -   at <StartupCode$FSI_0197>.$FSI_0197.main@ () [0x0000a] in <c82a4923d09b454bb7c7eb31a0d22fe1>:0 
2018-11-27 14:21:54 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-11-27 14:21:54 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x00032] in <14a60dd6a7d84d269fce235fa522c903>:0 
2018-11-27 14:22:52 - pathAndSampleEls |> Seq.iter printfn "%A"
2018-11-27 14:22:52 - The value or constructor 'pathAndSampleEls' is not defined. Maybe you want one of the following:
2018-11-27 14:22:52 -    pathsAndSampleEls
2018-11-27 14:22:52 -    pathsAndSamplesEls
2018-11-27 14:22:52 -    Path
2018-11-27 14:22:52 - This expression was expected to have type
2018-11-27 14:22:52 -     'obj -> obj'    
2018-11-27 14:22:52 - but here has type
2018-11-27 14:22:52 -     'unit'    
2018-11-27 14:22:52 - The type 'char' is not compatible with the type 'Printf.TextWriterFormat<unit>'
2018-11-27 14:22:52 - This expression was expected to have type
2018-11-27 14:22:52 -     'obj -> obj'    
2018-11-27 14:22:52 - but here has type
2018-11-27 14:22:52 -     'unit'    
2018-11-27 14:23:00 - pathsAndSampleEls |> Seq.iter printfn "%A"
2018-11-27 14:23:00 - This expression was expected to have type
2018-11-27 14:23:00 -     'seq<string * seq<XElement> option> -> obj'    
2018-11-27 14:23:00 - but here has type
2018-11-27 14:23:00 -     'unit'    
2018-11-27 14:23:00 - The type 'char' is not compatible with the type 'Printf.TextWriterFormat<unit>'
2018-11-27 14:23:00 - This expression was expected to have type
2018-11-27 14:23:00 -     'seq<string * seq<XElement> option> -> obj'    
2018-11-27 14:23:00 - but here has type
2018-11-27 14:23:00 -     'unit'    
2018-11-27 14:23:07 - pathsAndSampleEls |> Seq.map printfn "%A"
2018-11-27 14:23:07 - This expression was expected to have type
2018-11-27 14:23:07 -     'seq<string * seq<XElement> option> -> obj'    
2018-11-27 14:23:07 - but here has type
2018-11-27 14:23:07 -     'seq<obj>'    
2018-11-27 14:23:07 - The type 'char' is not compatible with the type 'Printf.TextWriterFormat<obj>'
2018-11-27 14:23:07 - This expression was expected to have type
2018-11-27 14:23:07 -     'seq<string * seq<XElement> option> -> obj'    
2018-11-27 14:23:07 - but here has type
2018-11-27 14:23:07 -     'seq<obj>'    
2018-11-27 14:23:18 - pathsAndSampleEls |> Seq.map (fun t -> printfn "%A" t)
2018-11-27 14:24:32 - pathsAndSampleEls |> Seq.map (fun t -> sprintfn "%A" t) |> Seq.sum |> printfn "%A"
2018-11-27 14:24:32 - The value or constructor 'sprintfn' is not defined. Maybe you want one of the following:
2018-11-27 14:24:32 -    sprintf
2018-11-27 14:24:32 -    printfn
2018-11-27 14:24:32 -    eprintfn
2018-11-27 14:24:32 -    fprintfn
2018-11-27 14:24:32 -    printf
2018-11-27 14:25:44 - pathsAndSampleEls |> Seq.map (fun t -> sprintf "%A" t) |> String.concat "\n" |> printfn "%A"
2018-11-27 14:26:43 - pathsAndSampleEls |> Seq.head |> fixAllElsAndSave
2018-11-27 14:26:43 - Expression evaluation failed: The input sequence was empty.
2018-11-27 14:26:43 - Parameter name: source
2018-11-27 14:26:43 - ArgumentExceptionThe input sequence was empty.
2018-11-27 14:26:43 - Parameter name: source
2018-11-27 14:26:43 -   at Microsoft.FSharp.Collections.SeqModule.Head[T] (System.Collections.Generic.IEnumerable`1[T] source) [0x00033] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:26:43 -   at FSI_0196.fixAllElsAndSave (System.String path, Microsoft.FSharp.Core.FSharpOption`1[T] maybeEls) [0x0002d] in <c82a4923d09b454bb7c7eb31a0d22fe1>:0 
2018-11-27 14:26:43 -   at <StartupCode$FSI_0206>.$FSI_0206.main@ () [0x00023] in <c82a4923d09b454bb7c7eb31a0d22fe1>:0 
2018-11-27 14:26:43 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-11-27 14:26:43 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x00032] in <14a60dd6a7d84d269fce235fa522c903>:0 
2018-11-27 14:27:13 - pathsAndSampleEls |> Seq.head |> fun (path, maybeEls) -> printfn "%A" maybeEls
2018-11-27 14:28:07 - pathsAndSampleEls 
2018-11-27 14:28:07 - |> Seq.head 
2018-11-27 14:28:07 - |> fun (path, maybeEls) ->
2018-11-27 14:28:07 -     match maybeEls with 
2018-11-27 14:28:07 -     | None -> ignore()
2018-11-27 14:28:07 -     | Some els -> 
2018-11-27 14:28:07 -         els |> Seq.iter (fun el -> el.Attribute(xn "href").Value |> guidInCref |> fixEl el)
2018-11-27 14:28:07 -         let doc = els |> Seq.head |> fun el -> el.Document
2018-11-27 14:28:07 -         use fs = new FileStream(path, FileMode.Create)
2018-11-27 14:28:07 -         use swWriter = new StreamWriter(fs, new UTF8Encoding(false))
2018-11-27 14:28:07 -         use writer = new XmlTextWriter(swWriter)
2018-11-27 14:28:07 -         writer.Formatting <- Formatting.Indented
2018-11-27 14:28:07 -         writer.Indentation <- 2
2018-11-27 14:28:07 -         writer.IndentChar <- ' '
2018-11-27 14:28:07 -         doc.Root.WriteTo(writer)
2018-11-27 14:28:07 -         swWriter.WriteLine()
2018-11-27 14:28:07 -         writer.Dispose()
2018-11-27 14:28:07 -         swWriter.Dispose()
2018-11-27 14:28:07 -         fs.Dispose()
2018-11-27 14:28:07 - Expression evaluation failed: The input sequence was empty.
2018-11-27 14:28:07 - Parameter name: source
2018-11-27 14:28:07 - ArgumentExceptionThe input sequence was empty.
2018-11-27 14:28:07 - Parameter name: source
2018-11-27 14:28:07 -   at Microsoft.FSharp.Collections.SeqModule.Head[T] (System.Collections.Generic.IEnumerable`1[T] source) [0x00033] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:28:07 -   at <StartupCode$FSI_0209>.$FSI_0209.main@ () [0x00066] in <c82a4923d09b454bb7c7eb31a0d22fe1>:0 
2018-11-27 14:28:07 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-11-27 14:28:07 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x00032] in <14a60dd6a7d84d269fce235fa522c903>:0 
2018-11-27 14:28:18 - pathsAndSampleEls 
2018-11-27 14:28:18 - |> Seq.head 
2018-11-27 14:28:18 - |> fun (path, maybeEls) ->
2018-11-27 14:28:18 -     match maybeEls with 
2018-11-27 14:28:18 -     | None -> ignore()
2018-11-27 14:28:18 -     | Some els -> 
2018-11-27 14:28:18 -         els |> Seq.iter (fun el -> el.Attribute(xn "href").Value |> guidInCref |> fixEl el)
2018-11-27 14:28:18 - //         let doc = els |> Seq.head |> fun el -> el.Document
2018-11-27 14:28:18 - //         use fs = new FileStream(path, FileMode.Create)
2018-11-27 14:28:18 - //         use swWriter = new StreamWriter(fs, new UTF8Encoding(false))
2018-11-27 14:28:18 - //         use writer = new XmlTextWriter(swWriter)
2018-11-27 14:28:18 - //         writer.Formatting <- Formatting.Indented
2018-11-27 14:28:18 - //         writer.Indentation <- 2
2018-11-27 14:28:18 - //         writer.IndentChar <- ' '
2018-11-27 14:28:18 - //         doc.Root.WriteTo(writer)
2018-11-27 14:28:18 - //         swWriter.WriteLine()
2018-11-27 14:28:18 - //         writer.Dispose()
2018-11-27 14:28:18 - //         swWriter.Dispose()
2018-11-27 14:28:18 - //         fs.Dispose()
2018-11-27 14:28:27 - pathsAndSampleEls 
2018-11-27 14:28:27 - |> Seq.head 
2018-11-27 14:28:27 - |> fun (path, maybeEls) ->
2018-11-27 14:28:27 -     match maybeEls with 
2018-11-27 14:28:27 -     | None -> ignore()
2018-11-27 14:28:27 -     | Some els -> 
2018-11-27 14:28:27 -         els |> Seq.iter (fun el -> el.Attribute(xn "href").Value |> guidInCref |> fixEl el)
2018-11-27 14:28:27 -         let doc = els |> Seq.head |> fun el -> el.Document
2018-11-27 14:28:27 - //         use fs = new FileStream(path, FileMode.Create)
2018-11-27 14:28:27 - //         use swWriter = new StreamWriter(fs, new UTF8Encoding(false))
2018-11-27 14:28:27 - //         use writer = new XmlTextWriter(swWriter)
2018-11-27 14:28:27 - //         writer.Formatting <- Formatting.Indented
2018-11-27 14:28:27 - //         writer.Indentation <- 2
2018-11-27 14:28:27 - //         writer.IndentChar <- ' '
2018-11-27 14:28:27 - //         doc.Root.WriteTo(writer)
2018-11-27 14:28:27 - //         swWriter.WriteLine()
2018-11-27 14:28:27 - //         writer.Dispose()
2018-11-27 14:28:27 - //         swWriter.Dispose()
2018-11-27 14:28:27 - //         fs.Dispose()
2018-11-27 14:28:27 - The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.
2018-11-27 14:28:39 - pathsAndSampleEls 
2018-11-27 14:28:39 - |> Seq.head 
2018-11-27 14:28:39 - |> fun (path, maybeEls) ->
2018-11-27 14:28:39 -     match maybeEls with 
2018-11-27 14:28:39 -     | None -> ignore()
2018-11-27 14:28:39 -     | Some els -> 
2018-11-27 14:28:39 -         els |> Seq.iter (fun el -> el.Attribute(xn "href").Value |> guidInCref |> fixEl el)
2018-11-27 14:28:39 -         let doc = els |> Seq.head |> fun el -> el.Document
2018-11-27 14:28:39 - //         use fs = new FileStream(path, FileMode.Create)
2018-11-27 14:28:39 - //         use swWriter = new StreamWriter(fs, new UTF8Encoding(false))
2018-11-27 14:28:39 - //         use writer = new XmlTextWriter(swWriter)
2018-11-27 14:28:39 - //         writer.Formatting <- Formatting.Indented
2018-11-27 14:28:39 - //         writer.Indentation <- 2
2018-11-27 14:28:39 - //         writer.IndentChar <- ' '
2018-11-27 14:28:39 - //         doc.Root.WriteTo(writer)
2018-11-27 14:28:39 - //         swWriter.WriteLine()
2018-11-27 14:28:39 - //         writer.Dispose()
2018-11-27 14:28:39 - //         swWriter.Dispose()
2018-11-27 14:28:39 - //         fs.Dispose()
2018-11-27 14:28:39 -         ignore()
2018-11-27 14:28:39 - Expression evaluation failed: The input sequence was empty.
2018-11-27 14:28:39 - Parameter name: source
2018-11-27 14:28:39 - ArgumentExceptionThe input sequence was empty.
2018-11-27 14:28:39 - Parameter name: source
2018-11-27 14:28:39 -   at Microsoft.FSharp.Collections.SeqModule.Head[T] (System.Collections.Generic.IEnumerable`1[T] source) [0x00033] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:28:39 -   at <StartupCode$FSI_0213>.$FSI_0213.main@ () [0x00057] in <c82a4923d09b454bb7c7eb31a0d22fe1>:0 
2018-11-27 14:28:39 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-11-27 14:28:39 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x00032] in <14a60dd6a7d84d269fce235fa522c903>:0 
2018-11-27 14:29:39 - pathsAndSampleEls 
2018-11-27 14:29:39 - |> Seq.head 
2018-11-27 14:29:39 - |> fun (path, maybeEls) ->
2018-11-27 14:29:39 -     match maybeEls with 
2018-11-27 14:29:39 -     | None -> ignore()
2018-11-27 14:29:39 -     | Some els -> 
2018-11-27 14:29:39 -         els |> Seq.iter (fun el -> el.Attribute(xn "href").Value |> guidInCref |> fixEl el)
2018-11-27 14:29:39 -         let doc = 
2018-11-27 14:29:39 -             els |> Seq.head |> printfn "%A" //|> fun el -> el.Document
2018-11-27 14:29:39 - //         use fs = new FileStream(path, FileMode.Create)
2018-11-27 14:29:39 - //         use swWriter = new StreamWriter(fs, new UTF8Encoding(false))
2018-11-27 14:29:39 - //         use writer = new XmlTextWriter(swWriter)
2018-11-27 14:29:39 - //         writer.Formatting <- Formatting.Indented
2018-11-27 14:29:39 - //         writer.Indentation <- 2
2018-11-27 14:29:39 - //         writer.IndentChar <- ' '
2018-11-27 14:29:39 - //         doc.Root.WriteTo(writer)
2018-11-27 14:29:39 - //         swWriter.WriteLine()
2018-11-27 14:29:39 - //         writer.Dispose()
2018-11-27 14:29:39 - //         swWriter.Dispose()
2018-11-27 14:29:39 - //         fs.Dispose()
2018-11-27 14:29:39 -         ignore()
2018-11-27 14:29:39 - Expression evaluation failed: The input sequence was empty.
2018-11-27 14:29:39 - Parameter name: source
2018-11-27 14:29:39 - ArgumentExceptionThe input sequence was empty.
2018-11-27 14:29:39 - Parameter name: source
2018-11-27 14:29:39 -   at Microsoft.FSharp.Collections.SeqModule.Head[T] (System.Collections.Generic.IEnumerable`1[T] source) [0x00033] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:29:39 -   at <StartupCode$FSI_0214>.$FSI_0214.main@ () [0x00057] in <c82a4923d09b454bb7c7eb31a0d22fe1>:0 
2018-11-27 14:29:39 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-11-27 14:29:39 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x00032] in <14a60dd6a7d84d269fce235fa522c903>:0 
2018-11-27 14:30:32 - pathsAndSampleEls 
2018-11-27 14:30:32 - |> Seq.head 
2018-11-27 14:30:32 - |> fun (path, maybeEls) ->
2018-11-27 14:30:32 -     match maybeEls with 
2018-11-27 14:30:32 -     | None -> ignore()
2018-11-27 14:30:32 -     | Some els -> 
2018-11-27 14:30:32 -         let doc = Seq.head els |> fun el -> el.Document 
2018-11-27 14:30:32 -         els |> Seq.iter (fun el -> el.Attribute(xn "href").Value |> guidInCref |> fixEl el)
2018-11-27 14:30:32 - //         use fs = new FileStream(path, FileMode.Create)
2018-11-27 14:30:32 - //         use swWriter = new StreamWriter(fs, new UTF8Encoding(false))
2018-11-27 14:30:32 - //         use writer = new XmlTextWriter(swWriter)
2018-11-27 14:30:32 - //         writer.Formatting <- Formatting.Indented
2018-11-27 14:30:32 - //         writer.Indentation <- 2
2018-11-27 14:30:32 - //         writer.IndentChar <- ' '
2018-11-27 14:30:32 - //         doc.Root.WriteTo(writer)
2018-11-27 14:30:32 - //         swWriter.WriteLine()
2018-11-27 14:30:32 - //         writer.Dispose()
2018-11-27 14:30:32 - //         swWriter.Dispose()
2018-11-27 14:30:32 - //         fs.Dispose()
2018-11-27 14:30:32 -         ignore()
2018-11-27 14:30:47 - pathsAndSampleEls 
2018-11-27 14:30:47 - |> Seq.head 
2018-11-27 14:30:47 - |> fun (path, maybeEls) ->
2018-11-27 14:30:47 -     match maybeEls with 
2018-11-27 14:30:47 -     | None -> ignore()
2018-11-27 14:30:47 -     | Some els -> 
2018-11-27 14:30:47 -         let doc = Seq.head els |> fun el -> el.Document 
2018-11-27 14:30:47 -         els |> Seq.iter (fun el -> el.Attribute(xn "href").Value |> guidInCref |> fixEl el)
2018-11-27 14:30:47 -         use fs = new FileStream(path, FileMode.Create)
2018-11-27 14:30:47 -         use swWriter = new StreamWriter(fs, new UTF8Encoding(false))
2018-11-27 14:30:47 -         use writer = new XmlTextWriter(swWriter)
2018-11-27 14:30:47 -         writer.Formatting <- Formatting.Indented
2018-11-27 14:30:47 -         writer.Indentation <- 2
2018-11-27 14:30:47 -         writer.IndentChar <- ' '
2018-11-27 14:30:47 -         doc.Root.WriteTo(writer)
2018-11-27 14:30:47 -         swWriter.WriteLine()
2018-11-27 14:30:47 -         writer.Dispose()
2018-11-27 14:30:47 -         swWriter.Dispose()
2018-11-27 14:30:47 -         fs.Dispose()
2018-11-27 14:31:31 - pathsAndSampleEls |> Seq.iter fixAllElsAndSave
2018-11-27 14:31:31 - Expression evaluation failed: The input sequence was empty.
2018-11-27 14:31:31 - Parameter name: source
2018-11-27 14:31:31 - ArgumentExceptionThe input sequence was empty.
2018-11-27 14:31:31 - Parameter name: source
2018-11-27 14:31:31 -   at Microsoft.FSharp.Collections.SeqModule.Head[T] (System.Collections.Generic.IEnumerable`1[T] source) [0x00033] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:31:31 -   at FSI_0196.fixAllElsAndSave (System.String path, Microsoft.FSharp.Core.FSharpOption`1[T] maybeEls) [0x0002d] in <c82a4923d09b454bb7c7eb31a0d22fe1>:0 
2018-11-27 14:31:31 -   at FSI_0219+it@1-51.Invoke (System.Tuple`2[T1,T2] tupledArg) [0x0001a] in <c82a4923d09b454bb7c7eb31a0d22fe1>:0 
2018-11-27 14:31:31 -   at Microsoft.FSharp.Collections.SeqModule.Iterate[T] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] action, System.Collections.Generic.IEnumerable`1[T] source) [0x0002c] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:31:31 -   at <StartupCode$FSI_0219>.$FSI_0219.main@ () [0x0000a] in <c82a4923d09b454bb7c7eb31a0d22fe1>:0 
2018-11-27 14:31:31 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-11-27 14:31:31 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x00032] in <14a60dd6a7d84d269fce235fa522c903>:0 
2018-11-27 14:31:37 - let samplesDir = "/Users/larryobrien/Documents/src/xamarin/ios-samples"
2018-11-27 14:31:37 - let ecmaDir = "/Users/larryobrien/Documents/src/xamarin/apple-api-docs/en"
2018-11-27 14:31:37 - #r "System.Xml.Linq"
2018-11-27 14:31:37 - open System.Xml.Linq
2018-11-27 14:31:37 - let xn s = XName.Get(s)
2018-11-27 14:31:37 - let doc (f : string) : XDocument = XDocument.Load(f)
2018-11-27 14:31:37 - open System.IO
2018-11-27 14:31:37 - let sampleXmlFiles = Directory.GetFiles(samplesDir, "Metadata.xml", SearchOption.AllDirectories)
2018-11-27 14:31:38 - let githubLinkFor (path : string) = 
2018-11-27 14:31:38 -     sprintf "https://github.com/xamarin/ios-samples/tree/master/%s" <| path.Substring(path.IndexOf("xamarin/ios-samples/")+"xamarin/ios-samples/".Length)
2018-11-27 14:31:38 -     |> fun s -> s.Substring(0, s.IndexOf("Metadata.xml"))
2018-11-27 14:31:38 - sampleXmlFiles |> Seq.head
2018-11-27 14:31:38 - let pathForGuid = 
2018-11-27 14:31:38 -     sampleXmlFiles 
2018-11-27 14:31:38 -     |> Seq.map doc 
2018-11-27 14:31:38 -     |> Seq.filter (fun d -> d.Descendants(xn "ID") |> fun ds -> Seq.length ds > 0)
2018-11-27 14:31:38 -     |> Seq.map (fun d -> d.Descendants(xn "ID") |> Seq.head |> fun el -> el.Value)
2018-11-27 14:31:38 -     |> Seq.zip (sampleXmlFiles |> Seq.map githubLinkFor)
2018-11-27 14:31:38 -     |> Seq.map (fun (path, guid) -> (guid, path))
2018-11-27 14:31:38 -     |> dict
2018-11-27 14:31:39 - pathForGuid.Values |> Seq.filter(fun p -> p.IndexOf("Metadata.xml") = -1)
2018-11-27 14:31:39 - pathForGuid.["22ab91f1-babe-433e-92ff-5847a5928a34"]
2018-11-27 14:31:39 - let ecmaXmlFiles = Directory.GetFiles(ecmaDir, "*.xml", SearchOption.AllDirectories)
2018-11-27 14:31:39 - let pathsAndDocs = ecmaXmlFiles |> Seq.map (fun path -> (path, doc path))
2018-11-27 14:31:39 - let sampleEls (doc : XDocument) = 
2018-11-27 14:31:39 -     let guidSamples = 
2018-11-27 14:31:39 -         doc.Descendants(xn "related")
2018-11-27 14:31:39 -         |> Seq.filter (fun el -> el.Attribute(xn "type") <> null)
2018-11-27 14:31:39 -         |> Seq.filter (fun el -> el.Attribute(xn "type").Value = "sample")
2018-11-27 14:31:39 -         |> Seq.filter (fun el -> el.Attribute(xn "href").Value.Contains("ByGuid?guid="))
2018-11-27 14:31:39 -     match guidSamples |> Seq.length with 
2018-11-27 14:31:39 -     | 0 -> None
2018-11-27 14:31:39 -     | _ -> Some guidSamples
2018-11-27 14:31:39 - let pathsAndSampleEls = 
2018-11-27 14:31:39 -     pathsAndDocs 
2018-11-27 14:31:39 -     |> Seq.map (fun (path, doc) -> (path, sampleEls doc))
2018-11-27 14:31:39 -     |> Seq.filter (fun (path, sampleEls) -> sampleEls.IsSome)
2018-11-27 14:31:39 -     
2018-11-27 14:31:39 - pathsAndSampleEls |> Seq.head
2018-11-27 14:31:39 - let guidInCref (cref : string) = cref.Substring(cref.IndexOf("ByGuid?guid=")+"ByGuid?guid=".Length)
2018-11-27 14:31:39 - guidInCref "http://samples.xamarin.com/Samples/ByGuid?guid=2c1eba2d-8abc-408e-8ee8-a03ffac6ffde"
2018-11-27 14:31:39 - let fixEl (el : XElement) (guid : string) = el.Attribute(xn "href").Value <- pathForGuid.[guid]
2018-11-27 14:31:39 - open System.Text
2018-11-27 14:31:39 - open System.Xml 
2018-11-27 14:31:39 - let fixAllElsAndSave (path : string, maybeEls : XElement seq option) = 
2018-11-27 14:31:39 -     match maybeEls with 
2018-11-27 14:31:39 -     | None -> ignore()
2018-11-27 14:31:39 -     | Some els -> 
2018-11-27 14:31:39 -         els |> Seq.iter (fun el -> el.Attribute(xn "href").Value |> guidInCref |> fixEl el)
2018-11-27 14:31:39 -         let doc = els |> Seq.head |> fun el -> el.Document
2018-11-27 14:31:39 -         use fs = new FileStream(path, FileMode.Create)
2018-11-27 14:31:39 -         use swWriter = new StreamWriter(fs, new UTF8Encoding(false))
2018-11-27 14:31:39 -         use writer = new XmlTextWriter(swWriter)
2018-11-27 14:31:39 -         writer.Formatting <- Formatting.Indented
2018-11-27 14:31:39 -         writer.Indentation <- 2
2018-11-27 14:31:39 -         writer.IndentChar <- ' '
2018-11-27 14:31:39 -         doc.Root.WriteTo(writer)
2018-11-27 14:31:39 -         swWriter.WriteLine()
2018-11-27 14:31:39 -         writer.Dispose()
2018-11-27 14:31:39 -         swWriter.Dispose()
2018-11-27 14:31:39 -         fs.Dispose()
2018-11-27 14:31:39 - pathsAndSampleEls |> Seq.map (fun t -> sprintf "%A" t) |> String.concat "\n" |> printfn "%A"
2018-11-27 14:31:45 - pathsAndSampleEls |> Seq.head |> fun (path, maybeEls) -> printfn "%A" maybeEls
2018-11-27 14:31:45 - pathsAndSampleEls 
2018-11-27 14:31:45 - |> Seq.head 
2018-11-27 14:31:45 - |> fun (path, maybeEls) ->
2018-11-27 14:31:45 -     match maybeEls with 
2018-11-27 14:31:45 -     | None -> ignore()
2018-11-27 14:31:45 -     | Some els -> 
2018-11-27 14:31:45 -         let doc = Seq.head els |> fun el -> el.Document 
2018-11-27 14:31:45 -         els |> Seq.iter (fun el -> el.Attribute(xn "href").Value |> guidInCref |> fixEl el)
2018-11-27 14:31:45 -         use fs = new FileStream(path, FileMode.Create)
2018-11-27 14:31:45 -         use swWriter = new StreamWriter(fs, new UTF8Encoding(false))
2018-11-27 14:31:45 -         use writer = new XmlTextWriter(swWriter)
2018-11-27 14:31:45 -         writer.Formatting <- Formatting.Indented
2018-11-27 14:31:45 -         writer.Indentation <- 2
2018-11-27 14:31:45 -         writer.IndentChar <- ' '
2018-11-27 14:31:45 -         doc.Root.WriteTo(writer)
2018-11-27 14:31:45 -         swWriter.WriteLine()
2018-11-27 14:31:45 -         writer.Dispose()
2018-11-27 14:31:45 -         swWriter.Dispose()
2018-11-27 14:31:45 -         fs.Dispose()
2018-11-27 14:31:45 - pathsAndSampleEls |> Seq.iter fixAllElsAndSave
2018-11-27 14:31:46 - Expression evaluation failed: The input sequence was empty.
2018-11-27 14:31:46 - Parameter name: source
2018-11-27 14:31:46 - ArgumentExceptionThe input sequence was empty.
2018-11-27 14:31:46 - Parameter name: source
2018-11-27 14:31:46 -   at Microsoft.FSharp.Collections.SeqModule.Head[T] (System.Collections.Generic.IEnumerable`1[T] source) [0x00033] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:31:46 -   at FSI_0240.fixAllElsAndSave (System.String path, Microsoft.FSharp.Core.FSharpOption`1[T] maybeEls) [0x0002d] in <c82a4923d09b454bb7c7eb31a0d22fe1>:0 
2018-11-27 14:31:46 -   at FSI_0247+it@1-55.Invoke (System.Tuple`2[T1,T2] tupledArg) [0x0001a] in <c82a4923d09b454bb7c7eb31a0d22fe1>:0 
2018-11-27 14:31:46 -   at Microsoft.FSharp.Collections.SeqModule.Iterate[T] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] action, System.Collections.Generic.IEnumerable`1[T] source) [0x0002c] in <5b5a6cc1904cf4daa7450383c16c5a5b>:0 
2018-11-27 14:31:46 -   at <StartupCode$FSI_0247>.$FSI_0247.main@ () [0x0000a] in <c82a4923d09b454bb7c7eb31a0d22fe1>:0 
2018-11-27 14:31:46 -   at (wrapper managed-to-native) System.Reflection.MonoMethod.InternalInvoke(System.Reflection.MonoMethod,object,object[],System.Exception&)
2018-11-27 14:31:46 -   at System.Reflection.MonoMethod.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x00032] in <14a60dd6a7d84d269fce235fa522c903>:0 
2018-11-27 14:33:44 - pathsAndSampleEls 
2018-11-27 14:33:44 - |> Seq.head 
2018-11-27 14:33:44 - |> fun (path, maybeEls) ->
2018-11-27 14:33:44 -     match maybeEls with 
2018-11-27 14:33:44 -     | None -> ignore()
2018-11-27 14:33:44 -     | Some els -> 
2018-11-27 14:33:44 -         try
2018-11-27 14:33:44 -             let doc = Seq.head els |> fun el -> el.Document
2018-11-27 14:33:44 -             els |> Seq.iter (fun el -> el.Attribute(xn "href").Value |> guidInCref |> fixEl el)
2018-11-27 14:33:44 -             use fs = new FileStream(path, FileMode.Create)
2018-11-27 14:33:44 -             use swWriter = new StreamWriter(fs, new UTF8Encoding(false))
2018-11-27 14:33:44 -             use writer = new XmlTextWriter(swWriter)
2018-11-27 14:33:44 -             writer.Formatting <- Formatting.Indented
2018-11-27 14:33:44 -             writer.Indentation <- 2
2018-11-27 14:33:44 -             writer.IndentChar <- ' '
2018-11-27 14:33:44 -             doc.Root.WriteTo(writer)
2018-11-27 14:33:44 -             swWriter.WriteLine()
2018-11-27 14:33:44 -             writer.Dispose()
2018-11-27 14:33:44 -             swWriter.Dispose()
2018-11-27 14:33:44 -             fs.Dispose()
2018-11-27 14:33:44 -         with
2018-11-27 14:33:44 -         | _ -> printfn "Error with %s" path
2018-11-27 14:34:18 - open System.Text
2018-11-27 14:34:18 - open System.Xml 
2018-11-27 14:34:18 - let fixAllElsAndSave (path : string, maybeEls : XElement seq option) = 
2018-11-27 14:34:18 -     match maybeEls with 
2018-11-27 14:34:18 -     | None -> ignore()
2018-11-27 14:34:18 -     | Some els -> 
2018-11-27 14:34:18 -         try
2018-11-27 14:34:18 -             let doc = Seq.head els |> fun el -> el.Document
2018-11-27 14:34:18 -             els |> Seq.iter (fun el -> el.Attribute(xn "href").Value |> guidInCref |> fixEl el)
2018-11-27 14:34:18 -             use fs = new FileStream(path, FileMode.Create)
2018-11-27 14:34:18 -             use swWriter = new StreamWriter(fs, new UTF8Encoding(false))
2018-11-27 14:34:18 -             use writer = new XmlTextWriter(swWriter)
2018-11-27 14:34:18 -             writer.Formatting <- Formatting.Indented
2018-11-27 14:34:18 -             writer.Indentation <- 2
2018-11-27 14:34:18 -             writer.IndentChar <- ' '
2018-11-27 14:34:18 -             doc.Root.WriteTo(writer)
2018-11-27 14:34:18 -             swWriter.WriteLine()
2018-11-27 14:34:18 -             writer.Dispose()
2018-11-27 14:34:18 -             swWriter.Dispose()
2018-11-27 14:34:18 -             fs.Dispose()
2018-11-27 14:34:18 -         with
2018-11-27 14:34:18 -         | _ -> printfn "Error with %s" path
2018-11-27 14:34:25 - pathsAndSampleEls |> Seq.iter fixAllElsAndSave
2018-11-27 14:44:53 - open System.Text
2018-11-27 14:44:53 - open System.Xml 
2018-11-27 14:44:53 - let fixAllElsAndSave (path : string, maybeEls : XElement seq option) = 
2018-11-27 14:44:53 -         let md = maybeEls |> Option.bind (fun els -> els |> Seq.head |> fun el -> el.Document |> Some)
2018-11-27 14:44:53 -         match (maybeEls, md) with 
2018-11-27 14:44:53 -         | (None, _) -> ignore()
2018-11-27 14:44:53 -         | (_, None) -> ignore()
2018-11-27 14:44:53 -         | (Some els, Some doc) -> 
2018-11-27 14:44:53 -             try
2018-11-27 14:44:53 -                 els |> Seq.iter (fun el -> el.Attribute(xn "href").Value |> guidInCref |> fixEl el)
2018-11-27 14:44:53 -                 use fs = new FileStream(path, FileMode.Create)
2018-11-27 14:44:53 -                 use swWriter = new StreamWriter(fs, new UTF8Encoding(false))
2018-11-27 14:44:53 -                 use writer = new XmlTextWriter(swWriter)
2018-11-27 14:44:53 -                 writer.Formatting <- Formatting.Indented
2018-11-27 14:44:53 -                 writer.Indentation <- 2
2018-11-27 14:44:53 -                 writer.IndentChar <- ' '
2018-11-27 14:44:53 -                 doc.Root.WriteTo(writer)
2018-11-27 14:44:53 -                 swWriter.WriteLine()
2018-11-27 14:44:53 -                 writer.Dispose()
2018-11-27 14:44:53 -                 swWriter.Dispose()
2018-11-27 14:44:53 -                 fs.Dispose()
2018-11-27 14:44:53 -             with
2018-11-27 14:44:53 -             | _ -> printfn "Error with %s" path
2018-11-27 14:44:57 - pathsAndSampleEls |> Seq.iter fixAllElsAndSave
2018-11-27 14:49:41 - open System.Text
2018-11-27 14:49:41 - open System.Xml 
2018-11-27 14:49:41 - let fixAllElsAndSave (path : string, maybeEls : XElement seq option) = 
2018-11-27 14:49:41 -         let md = maybeEls |> Option.bind (fun els -> els |> Seq.head |> fun el -> el.Document |> Some)
2018-11-27 14:49:41 -         match (maybeEls, md) with 
2018-11-27 14:49:41 -         | (None, _) -> ignore()
2018-11-27 14:49:41 -         | (_, None) -> ignore()
2018-11-27 14:49:41 -         | (Some els, Some doc) -> 
2018-11-27 14:49:41 -             try
2018-11-27 14:49:41 -                 els 
2018-11-27 14:49:41 -                 |> Seq.iter (fun el -> 
2018-11-27 14:49:41 -                     el.Attribute(xn "href").Value 
2018-11-27 14:49:41 -                     |> guidInCref
2018-11-27 14:49:41 -                     |> fun guid -> 
2018-11-27 14:49:41 -                         match pathForGuid.ContainsKey(guid) with 
2018-11-27 14:49:41 -                         | true -> 
2018-11-27 14:49:41 -                             fixEl el guid
2018-11-27 14:49:41 -                         | false -> 
2018-11-27 14:49:41 -                             printfn "%s contains link to unknown guid %s" path guid
2018-11-27 14:49:41 -                 )
2018-11-27 14:49:41 -                 use fs = new FileStream(path, FileMode.Create)
2018-11-27 14:49:41 -                 use swWriter = new StreamWriter(fs, new UTF8Encoding(false))
2018-11-27 14:49:41 -                 use writer = new XmlTextWriter(swWriter)
2018-11-27 14:49:41 -                 writer.Formatting <- Formatting.Indented
2018-11-27 14:49:41 -                 writer.Indentation <- 2
2018-11-27 14:49:41 -                 writer.IndentChar <- ' '
2018-11-27 14:49:41 -                 doc.Root.WriteTo(writer)
2018-11-27 14:49:41 -                 swWriter.WriteLine()
2018-11-27 14:49:41 -                 writer.Dispose()
2018-11-27 14:49:41 -                 swWriter.Dispose()
2018-11-27 14:49:41 -                 fs.Dispose()
2018-11-27 14:49:41 -             with
2018-11-27 14:49:41 -             | _ -> printfn "Error with %s" path
2018-11-27 14:49:48 - pathsAndSampleEls |> Seq.iter fixAllElsAndSave
2018-11-27 14:54:01 - let samplesDir = "/Users/larryobrien/Documents/src/xamarin/ios-samples"
2018-11-27 14:54:01 - let ecmaDir = "/Users/larryobrien/Documents/src/xamarin/apple-api-docs/en"
2018-11-27 14:54:01 - #r "System.Xml.Linq"
2018-11-27 14:54:01 - open System.Xml.Linq
2018-11-27 14:54:01 - let xn s = XName.Get(s)
2018-11-27 14:54:01 - let doc (f : string) : XDocument = XDocument.Load(f)
2018-11-27 14:54:01 - open System.IO
2018-11-27 14:54:01 - let sampleXmlFiles = Directory.GetFiles(samplesDir, "Metadata.xml", SearchOption.AllDirectories)
2018-11-27 14:54:03 - let githubLinkFor (path : string) = 
2018-11-27 14:54:03 -     sprintf "https://github.com/xamarin/ios-samples/tree/master/%s" <| path.Substring(path.IndexOf("xamarin/ios-samples/")+"xamarin/ios-samples/".Length)
2018-11-27 14:54:03 -     |> fun s -> s.Substring(0, s.IndexOf("Metadata.xml"))
2018-11-27 14:54:03 - sampleXmlFiles |> Seq.head
2018-11-27 14:54:03 - let pathForGuid = 
2018-11-27 14:54:03 -     sampleXmlFiles 
2018-11-27 14:54:03 -     |> Seq.map doc 
2018-11-27 14:54:03 -     |> Seq.filter (fun d -> d.Descendants(xn "ID") |> fun ds -> Seq.length ds > 0)
2018-11-27 14:54:03 -     |> Seq.map (fun d -> d.Descendants(xn "ID") |> Seq.head |> fun el -> el.Value.ToLowerInvariant())
2018-11-27 14:54:03 -     |> Seq.zip (sampleXmlFiles |> Seq.map githubLinkFor)
2018-11-27 14:54:03 -     |> Seq.map (fun (path, guid) -> (guid, path))
2018-11-27 14:54:03 -     |> dict
2018-11-27 14:54:03 - pathForGuid.Values |> Seq.filter(fun p -> p.IndexOf("Metadata.xml") = -1)
2018-11-27 14:54:03 - pathForGuid.["22ab91f1-babe-433e-92ff-5847a5928a34"]
2018-11-27 14:54:03 - let ecmaXmlFiles = Directory.GetFiles(ecmaDir, "*.xml", SearchOption.AllDirectories)
2018-11-27 14:54:03 - let pathsAndDocs = ecmaXmlFiles |> Seq.map (fun path -> (path, doc path))
2018-11-27 14:54:03 - let sampleEls (doc : XDocument) = 
2018-11-27 14:54:03 -     let guidSamples = 
2018-11-27 14:54:03 -         doc.Descendants(xn "related")
2018-11-27 14:54:03 -         |> Seq.filter (fun el -> el.Attribute(xn "type") <> null)
2018-11-27 14:54:03 -         |> Seq.filter (fun el -> el.Attribute(xn "type").Value = "sample")
2018-11-27 14:54:03 -         |> Seq.filter (fun el -> el.Attribute(xn "href").Value.Contains("ByGuid?guid="))
2018-11-27 14:54:03 -     match guidSamples |> Seq.length with 
2018-11-27 14:54:03 -     | 0 -> None
2018-11-27 14:54:03 -     | _ -> Some guidSamples
2018-11-27 14:54:03 - let pathsAndSampleEls = 
2018-11-27 14:54:03 -     pathsAndDocs 
2018-11-27 14:54:03 -     |> Seq.map (fun (path, doc) -> (path, sampleEls doc))
2018-11-27 14:54:03 -     |> Seq.filter (fun (path, sampleEls) -> sampleEls.IsSome)
2018-11-27 14:54:03 -     
2018-11-27 14:54:03 - pathsAndSampleEls |> Seq.head
2018-11-27 14:54:04 - let guidInCref (cref : string) = cref.Substring(cref.IndexOf("ByGuid?guid=")+"ByGuid?guid=".Length).ToLowerInvariant()
2018-11-27 14:54:04 - guidInCref "http://samples.xamarin.com/Samples/ByGuid?guid=2c1eba2d-8abc-408e-8ee8-a03ffac6ffde"
2018-11-27 14:54:04 - let fixEl (el : XElement) (guid : string) = el.Attribute(xn "href").Value <- pathForGuid.[guid]
2018-11-27 14:54:04 - open System.Text
2018-11-27 14:54:04 - open System.Xml 
2018-11-27 14:54:04 - let fixAllElsAndSave (path : string, maybeEls : XElement seq option) = 
2018-11-27 14:54:04 -         let md = maybeEls |> Option.bind (fun els -> els |> Seq.head |> fun el -> el.Document |> Some)
2018-11-27 14:54:04 -         match (maybeEls, md) with 
2018-11-27 14:54:04 -         | (None, _) -> ignore()
2018-11-27 14:54:04 -         | (_, None) -> ignore()
2018-11-27 14:54:04 -         | (Some els, Some doc) -> 
2018-11-27 14:54:04 -             try
2018-11-27 14:54:04 -                 els 
2018-11-27 14:54:04 -                 |> Seq.iter (fun el -> 
2018-11-27 14:54:04 -                     el.Attribute(xn "href").Value 
2018-11-27 14:54:04 -                     |> guidInCref
2018-11-27 14:54:04 -                     |> fun guid -> 
2018-11-27 14:54:04 -                         match pathForGuid.ContainsKey(guid) with 
2018-11-27 14:54:04 -                         | true -> 
2018-11-27 14:54:04 -                             fixEl el guid
2018-11-27 14:54:04 -                         | false -> 
2018-11-27 14:54:04 -                             printfn "Unknown GUID, %s , %s" path guid
2018-11-27 14:54:04 -                 )
2018-11-27 14:54:04 -                 use fs = new FileStream(path, FileMode.Create)
2018-11-27 14:54:04 -                 use swWriter = new StreamWriter(fs, new UTF8Encoding(false))
2018-11-27 14:54:04 -                 use writer = new XmlTextWriter(swWriter)
2018-11-27 14:54:04 -                 writer.Formatting <- Formatting.Indented
2018-11-27 14:54:04 -                 writer.Indentation <- 2
2018-11-27 14:54:04 -                 writer.IndentChar <- ' '
2018-11-27 14:54:04 -                 doc.Root.WriteTo(writer)
2018-11-27 14:54:04 -                 swWriter.WriteLine()
2018-11-27 14:54:04 -                 writer.Dispose()
2018-11-27 14:54:04 -                 swWriter.Dispose()
2018-11-27 14:54:04 -                 fs.Dispose()
2018-11-27 14:54:04 -             with
2018-11-27 14:54:04 -             | _ -> printfn "Error with %s" path
2018-11-27 14:54:04 - pathsAndSampleEls |> Seq.map (fun t -> sprintf "%A" t) |> String.concat "\n" |> printfn "%A"
2018-11-27 14:54:06 - pathsAndSampleEls |> Seq.iter fixAllElsAndSave
2018-11-27 15:23:33 - shutdown request
