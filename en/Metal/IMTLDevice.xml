<Type Name="IMTLDevice" FullName="Metal.IMTLDevice">
  <TypeSignature Language="C#" Value="public interface IMTLDevice : IDisposable, ObjCRuntime.INativeObject" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IMTLDevice implements class ObjCRuntime.INativeObject, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:Metal.IMTLDevice" />
  <TypeSignature Language="F#" Value="type IMTLDevice = interface&#xA;    interface INativeObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>Xamarin.iOS</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>Xamarin.Mac</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces>
    <Interface>
      <InterfaceName>ObjCRuntime.INativeObject</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>Foundation.Protocol(Name="MTLDevice", WrapperType=typeof(Metal.MTLDeviceWrapper))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Foundation.ProtocolMember(IsProperty=false, IsRequired=true, IsStatic=false, Name="CreateCommandQueue", ReturnType=typeof(Metal.IMTLCommandQueue), Selector="newCommandQueue")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Foundation.ProtocolMember(IsProperty=false, IsRequired=true, IsStatic=false, Name="CreateDefaultLibrary", ReturnType=typeof(Metal.IMTLLibrary), Selector="newDefaultLibrary")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Foundation.ProtocolMember(IsProperty=false, IsRequired=false, IsStatic=false, Name="CreateFence", ReturnType=typeof(Metal.IMTLFence), Selector="newFence")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Foundation.ProtocolMember(IsProperty=false, IsRequired=false, IsStatic=false, Name="CreateEvent", ReturnType=typeof(Metal.IMTLEvent), Selector="newEvent")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Foundation.ProtocolMember(IsProperty=false, IsRequired=false, IsStatic=false, Name="CreateSharedEvent", ReturnType=typeof(Metal.IMTLSharedEvent), Selector="newSharedEvent")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Foundation.ProtocolMember(ArgumentSemantic=ObjCRuntime.ArgumentSemantic.None, GetterSelector="name", IsProperty=true, IsRequired=true, IsStatic=false, Name="Name", PropertyType=typeof(System.String), Selector="name")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Foundation.ProtocolMember(ArgumentSemantic=ObjCRuntime.ArgumentSemantic.None, GetterSelector="maxThreadsPerThreadgroup", IsProperty=true, IsRequired=false, IsStatic=false, Name="MaxThreadsPerThreadgroup", PropertyType=typeof(Metal.MTLSize), Selector="maxThreadsPerThreadgroup")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Foundation.ProtocolMember(ArgumentSemantic=ObjCRuntime.ArgumentSemantic.None, GetterSelector="readWriteTextureSupport", IsProperty=true, IsRequired=false, IsStatic=false, Name="ReadWriteTextureSupport", PropertyType=typeof(Metal.MTLReadWriteTextureTier), Selector="readWriteTextureSupport")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Foundation.ProtocolMember(ArgumentSemantic=ObjCRuntime.ArgumentSemantic.None, GetterSelector="argumentBuffersSupport", IsProperty=true, IsRequired=false, IsStatic=false, Name="ArgumentBuffersSupport", PropertyType=typeof(Metal.MTLArgumentBuffersTier), Selector="argumentBuffersSupport")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Foundation.ProtocolMember(ArgumentSemantic=ObjCRuntime.ArgumentSemantic.None, GetterSelector="areRasterOrderGroupsSupported", IsProperty=true, IsRequired=false, IsStatic=false, Name="RasterOrderGroupsSupported", PropertyType=typeof(System.Boolean), Selector="rasterOrderGroupsSupported")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Foundation.ProtocolMember(ArgumentSemantic=ObjCRuntime.ArgumentSemantic.None, GetterSelector="maxThreadgroupMemoryLength", IsProperty=true, IsRequired=false, IsStatic=false, Name="MaxThreadgroupMemoryLength", PropertyType=typeof(System.nuint), Selector="maxThreadgroupMemoryLength")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Foundation.ProtocolMember(ArgumentSemantic=ObjCRuntime.ArgumentSemantic.None, GetterSelector="maxArgumentBufferSamplerCount", IsProperty=true, IsRequired=false, IsStatic=false, Name="MaxArgumentBufferSamplerCount", PropertyType=typeof(System.nuint), Selector="maxArgumentBufferSamplerCount")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Foundation.ProtocolMember(ArgumentSemantic=ObjCRuntime.ArgumentSemantic.None, GetterSelector="areProgrammableSamplePositionsSupported", IsProperty=true, IsRequired=false, IsStatic=false, Name="ProgrammableSamplePositionsSupported", PropertyType=typeof(System.Boolean), Selector="programmableSamplePositionsSupported")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Foundation.ProtocolMember(ArgumentSemantic=ObjCRuntime.ArgumentSemantic.None, GetterSelector="maxBufferLength", IsProperty=true, IsRequired=false, IsStatic=false, Name="MaxBufferLength", PropertyType=typeof(System.nuint), Selector="maxBufferLength")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Foundation.ProtocolMember(ArgumentSemantic=ObjCRuntime.ArgumentSemantic.None, GetterSelector="registryID", IsProperty=true, IsRequired=false, IsStatic=false, Name="RegistryId", PropertyType=typeof(System.UInt64), Selector="registryID")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Foundation.ProtocolMember(ArgumentSemantic=ObjCRuntime.ArgumentSemantic.None, GetterSelector="currentAllocatedSize", IsProperty=true, IsRequired=false, IsStatic=false, Name="CurrentAllocatedSize", PropertyType=typeof(System.nuint), Selector="currentAllocatedSize")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.iOS, 8, 0, ObjCRuntime.PlatformArchitecture.All, null)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>ObjCRuntime.Introduced(ObjCRuntime.PlatformName.MacOSX, 10, 11, ObjCRuntime.PlatformArchitecture.Arch64, null)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Foundation.ProtocolMember(IsProperty=false, IsRequired=false, IsStatic=false, Name="GetHeapTextureSizeAndAlign", ParameterByRef=new System.Boolean[] { false }, ParameterType=new System.Type[] { typeof(Metal.MTLTextureDescriptor) }, ReturnType=typeof(Metal.MTLSizeAndAlign), Selector="heapTextureSizeAndAlignWithDescriptor:")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Foundation.ProtocolMember(IsProperty=false, IsRequired=false, IsStatic=false, Name="GetHeapBufferSizeAndAlignWithLength", ParameterByRef=new System.Boolean[] { false, false }, ParameterType=new System.Type[] { typeof(System.nuint), typeof(Metal.MTLResourceOptions) }, ReturnType=typeof(Metal.MTLSizeAndAlign), Selector="heapBufferSizeAndAlignWithLength:options:")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Foundation.ProtocolMember(IsProperty=false, IsRequired=false, IsStatic=false, Name="CreateHeap", ParameterByRef=new System.Boolean[] { false }, ParameterType=new System.Type[] { typeof(Metal.MTLHeapDescriptor) }, ReturnType=typeof(Metal.IMTLHeap), Selector="newHeapWithDescriptor:")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Foundation.ProtocolMember(IsProperty=false, IsRequired=true, IsStatic=false, Name="CreateCommandQueue", ParameterByRef=new System.Boolean[] { false }, ParameterType=new System.Type[] { typeof(System.nuint) }, ReturnType=typeof(Metal.IMTLCommandQueue), Selector="newCommandQueueWithMaxCommandBufferCount:")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Foundation.ProtocolMember(IsProperty=false, IsRequired=true, IsStatic=false, Name="CreateBuffer", ParameterByRef=new System.Boolean[] { false, false }, ParameterType=new System.Type[] { typeof(System.nuint), typeof(Metal.MTLResourceOptions) }, ReturnType=typeof(Metal.IMTLBuffer), Selector="newBufferWithLength:options:")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Foundation.ProtocolMember(IsProperty=false, IsRequired=true, IsStatic=false, Name="CreateBuffer", ParameterByRef=new System.Boolean[] { false, false, false }, ParameterType=new System.Type[] { typeof(System.IntPtr), typeof(System.nuint), typeof(Metal.MTLResourceOptions) }, ReturnType=typeof(Metal.IMTLBuffer), Selector="newBufferWithBytes:length:options:")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Foundation.ProtocolMember(IsProperty=false, IsRequired=true, IsStatic=false, Name="CreateDepthStencilState", ParameterByRef=new System.Boolean[] { false }, ParameterType=new System.Type[] { typeof(Metal.MTLDepthStencilDescriptor) }, ReturnType=typeof(Metal.IMTLDepthStencilState), Selector="newDepthStencilStateWithDescriptor:")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Foundation.ProtocolMember(IsProperty=false, IsRequired=true, IsStatic=false, Name="CreateTexture", ParameterByRef=new System.Boolean[] { false }, ParameterType=new System.Type[] { typeof(Metal.MTLTextureDescriptor) }, ReturnType=typeof(Metal.IMTLTexture), Selector="newTextureWithDescriptor:")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Foundation.ProtocolMember(IsProperty=false, IsRequired=false, IsStatic=false, Name="CreateTexture", ParameterByRef=new System.Boolean[] { false, false, false }, ParameterType=new System.Type[] { typeof(Metal.MTLTextureDescriptor), typeof(IOSurface.IOSurface), typeof(System.nuint) }, ReturnType=typeof(Metal.IMTLTexture), Selector="newTextureWithDescriptor:iosurface:plane:")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Foundation.ProtocolMember(IsProperty=false, IsRequired=true, IsStatic=false, Name="CreateSamplerState", ParameterByRef=new System.Boolean[] { false }, ParameterType=new System.Type[] { typeof(Metal.MTLSamplerDescriptor) }, ReturnType=typeof(Metal.IMTLSamplerState), Selector="newSamplerStateWithDescriptor:")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Foundation.ProtocolMember(IsProperty=false, IsRequired=true, IsStatic=false, Name="CreateLibrary", ParameterByRef=new System.Boolean[] { false, true }, ParameterType=new System.Type[] { typeof(System.String), typeof(Foundation.NSError) }, ReturnType=typeof(Metal.IMTLLibrary), Selector="newLibraryWithFile:error:")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Foundation.ProtocolMember(IsProperty=false, IsRequired=true, IsStatic=false, Name="CreateLibrary", ParameterByRef=new System.Boolean[] { false, true }, ParameterType=new System.Type[] { typeof(Foundation.NSObject), typeof(Foundation.NSError) }, ReturnType=typeof(Metal.IMTLLibrary), Selector="newLibraryWithData:error:")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Foundation.ProtocolMember(IsProperty=false, IsRequired=true, IsStatic=false, Name="CreateLibrary", ParameterByRef=new System.Boolean[] { false, false, true }, ParameterType=new System.Type[] { typeof(System.String), typeof(Metal.MTLCompileOptions), typeof(Foundation.NSError) }, ReturnType=typeof(Metal.IMTLLibrary), Selector="newLibraryWithSource:options:error:")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Foundation.ProtocolMember(IsProperty=false, IsRequired=false, IsStatic=false, Name="CreateLibrary", ParameterByRef=new System.Boolean[] { false, true }, ParameterType=new System.Type[] { typeof(Foundation.NSBundle), typeof(Foundation.NSError) }, ReturnType=typeof(Metal.IMTLLibrary), Selector="newDefaultLibraryWithBundle:error:")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Foundation.ProtocolMember(IsProperty=false, IsRequired=true, IsStatic=false, Name="CreateRenderPipelineState", ParameterByRef=new System.Boolean[] { false, true }, ParameterType=new System.Type[] { typeof(Metal.MTLRenderPipelineDescriptor), typeof(Foundation.NSError) }, ReturnType=typeof(Metal.IMTLRenderPipelineState), Selector="newRenderPipelineStateWithDescriptor:error:")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Foundation.ProtocolMember(IsProperty=false, IsRequired=true, IsStatic=false, Name="CreateRenderPipelineState", ParameterByRef=new System.Boolean[] { false, false, true, true }, ParameterType=new System.Type[] { typeof(Metal.MTLRenderPipelineDescriptor), typeof(Metal.MTLPipelineOption), typeof(Metal.MTLRenderPipelineReflection), typeof(Foundation.NSError) }, ReturnType=typeof(Metal.IMTLRenderPipelineState), Selector="newRenderPipelineStateWithDescriptor:options:reflection:error:")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Foundation.ProtocolMember(IsProperty=false, IsRequired=true, IsStatic=false, Name="CreateComputePipelineState", ParameterByRef=new System.Boolean[] { false, false, true, true }, ParameterType=new System.Type[] { typeof(Metal.IMTLFunction), typeof(Metal.MTLPipelineOption), typeof(Metal.MTLComputePipelineReflection), typeof(Foundation.NSError) }, ReturnType=typeof(Metal.IMTLComputePipelineState), Selector="newComputePipelineStateWithFunction:options:reflection:error:")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Foundation.ProtocolMember(IsProperty=false, IsRequired=true, IsStatic=false, Name="CreateComputePipelineState", ParameterByRef=new System.Boolean[] { false, true }, ParameterType=new System.Type[] { typeof(Metal.IMTLFunction), typeof(Foundation.NSError) }, ReturnType=typeof(Metal.IMTLComputePipelineState), Selector="newComputePipelineStateWithFunction:error:")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Foundation.ProtocolMember(IsProperty=false, IsRequired=false, IsStatic=false, Name="CreateComputePipelineState", ParameterByRef=new System.Boolean[] { false, false, true, true }, ParameterType=new System.Type[] { typeof(Metal.MTLComputePipelineDescriptor), typeof(Metal.MTLPipelineOption), typeof(Metal.MTLComputePipelineReflection), typeof(Foundation.NSError) }, ReturnType=typeof(Metal.IMTLComputePipelineState), Selector="newComputePipelineStateWithDescriptor:options:reflection:error:")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Foundation.ProtocolMember(IsProperty=false, IsRequired=true, IsStatic=false, Name="SupportsFeatureSet", ParameterByRef=new System.Boolean[] { false }, ParameterType=new System.Type[] { typeof(Metal.MTLFeatureSet) }, ReturnType=typeof(System.Boolean), Selector="supportsFeatureSet:")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Foundation.ProtocolMember(IsProperty=false, IsRequired=false, IsStatic=false, Name="SupportsTextureSampleCount", ParameterByRef=new System.Boolean[] { false }, ParameterType=new System.Type[] { typeof(System.nuint) }, ReturnType=typeof(System.Boolean), Selector="supportsTextureSampleCount:")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Foundation.ProtocolMember(IsProperty=false, IsRequired=false, IsStatic=false, Name="CreateLibrary", ParameterByRef=new System.Boolean[] { false, true }, ParameterType=new System.Type[] { typeof(Foundation.NSUrl), typeof(Foundation.NSError) }, ReturnType=typeof(Metal.IMTLLibrary), Selector="newLibraryWithURL:error:")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Foundation.ProtocolMember(IsProperty=false, IsRequired=false, IsStatic=false, Name="GetMinimumLinearTextureAlignment", ParameterByRef=new System.Boolean[] { false }, ParameterType=new System.Type[] { typeof(Metal.MTLPixelFormat) }, ReturnType=typeof(System.nuint), Selector="minimumLinearTextureAlignmentForPixelFormat:")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Foundation.ProtocolMember(IsProperty=false, IsRequired=false, IsStatic=false, Name="GetDefaultSamplePositions", ParameterByRef=new System.Boolean[] { false, false }, ParameterType=new System.Type[] { typeof(System.IntPtr), typeof(System.nuint) }, Selector="getDefaultSamplePositions:count:")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Foundation.ProtocolMember(IsProperty=false, IsRequired=false, IsStatic=false, Name="CreateArgumentEncoder", ParameterByRef=new System.Boolean[] { false }, ParameterType=new System.Type[] { typeof(Metal.MTLArgumentDescriptor[]) }, ReturnType=typeof(Metal.IMTLArgumentEncoder), Selector="newArgumentEncoderWithArguments:")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
      <AttributeName>Foundation.ProtocolMember(IsProperty=false, IsRequired=false, IsStatic=false, Name="CreateRenderPipelineState", ParameterByRef=new System.Boolean[] { false, false, true, true }, ParameterType=new System.Type[] { typeof(Metal.MTLTileRenderPipelineDescriptor), typeof(Metal.MTLPipelineOption), typeof(Metal.MTLRenderPipelineReflection), typeof(Foundation.NSError) }, ReturnType=typeof(Metal.IMTLRenderPipelineState), Selector="newRenderPipelineStateWithTileDescriptor:options:reflection:error:")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Foundation.ProtocolMember(IsProperty=false, IsRequired=true, IsStatic=false, Name="CreateBufferNoCopy", ParameterBlockProxy=new System.Type[] { null, null, null, typeof(ObjCRuntime.Trampolines/NIDMTLDeallocator) }, ParameterByRef=new System.Boolean[] { false, false, false, false }, ParameterType=new System.Type[] { typeof(System.IntPtr), typeof(System.nuint), typeof(Metal.MTLResourceOptions), typeof(Metal.MTLDeallocator) }, ReturnType=typeof(Metal.IMTLBuffer), Selector="newBufferWithBytesNoCopy:length:options:deallocator:")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
      <AttributeName>Foundation.ProtocolMember(IsProperty=false, IsRequired=true, IsStatic=false, Name="CreateLibrary", ParameterBlockProxy=new System.Type[] { null, null, typeof(ObjCRuntime.Trampolines/NIDActionArity2V79) }, ParameterByRef=new System.Boolean[] { false, false, false }, ParameterType=new System.Type[] { typeof(System.String), typeof(Metal.MTLCompileOptions), typeof(System.Action`2&lt;Metal.IMTLLibrary,Foundation.NSError&gt;) }, Selector="newLibraryWithSource:options:completionHandler:")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
      <AttributeName>Foundation.ProtocolMember(IsProperty=false, IsRequired=true, IsStatic=false, Name="CreateRenderPipelineState", ParameterBlockProxy=new System.Type[] { null, typeof(ObjCRuntime.Trampolines/NIDActionArity2V80) }, ParameterByRef=new System.Boolean[] { false, false }, ParameterType=new System.Type[] { typeof(Metal.MTLRenderPipelineDescriptor), typeof(System.Action`2&lt;Metal.IMTLRenderPipelineState,Foundation.NSError&gt;) }, Selector="newRenderPipelineStateWithDescriptor:completionHandler:")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
      <AttributeName>Foundation.ProtocolMember(IsProperty=false, IsRequired=true, IsStatic=false, Name="CreateRenderPipelineState", ParameterBlockProxy=new System.Type[] { null, null, typeof(ObjCRuntime.Trampolines/NIDActionArity3V6) }, ParameterByRef=new System.Boolean[] { false, false, false }, ParameterType=new System.Type[] { typeof(Metal.MTLRenderPipelineDescriptor), typeof(Metal.MTLPipelineOption), typeof(System.Action`3&lt;Metal.IMTLRenderPipelineState,Metal.MTLRenderPipelineReflection,Foundation.NSError&gt;) }, Selector="newRenderPipelineStateWithDescriptor:options:completionHandler:")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
      <AttributeName>Foundation.ProtocolMember(IsProperty=false, IsRequired=true, IsStatic=false, Name="CreateComputePipelineState", ParameterBlockProxy=new System.Type[] { null, typeof(ObjCRuntime.Trampolines/NIDActionArity2V81) }, ParameterByRef=new System.Boolean[] { false, false }, ParameterType=new System.Type[] { typeof(Metal.IMTLFunction), typeof(System.Action`2&lt;Metal.IMTLComputePipelineState,Foundation.NSError&gt;) }, Selector="newComputePipelineStateWithFunction:completionHandler:")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
      <AttributeName>Foundation.ProtocolMember(IsProperty=false, IsRequired=true, IsStatic=false, Name="CreateComputePipelineState", ParameterBlockProxy=new System.Type[] { null, null, typeof(ObjCRuntime.Trampolines/NIDActionArity3V7) }, ParameterByRef=new System.Boolean[] { false, false, false }, ParameterType=new System.Type[] { typeof(Metal.IMTLFunction), typeof(Metal.MTLPipelineOption), typeof(System.Action`3&lt;Metal.IMTLComputePipelineState,Metal.MTLComputePipelineReflection,Foundation.NSError&gt;) }, Selector="newComputePipelineStateWithFunction:options:completionHandler:")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Foundation.ProtocolMember(IsProperty=false, IsRequired=false, IsStatic=false, Name="CreateComputePipelineState", ParameterBlockProxy=new System.Type[] { null, null, typeof(ObjCRuntime.Trampolines/NIDMTLNewComputePipelineStateWithReflectionCompletionHandler) }, ParameterByRef=new System.Boolean[] { false, false, false }, ParameterType=new System.Type[] { typeof(Metal.MTLComputePipelineDescriptor), typeof(Metal.MTLPipelineOption), typeof(Metal.MTLNewComputePipelineStateWithReflectionCompletionHandler) }, Selector="newComputePipelineStateWithDescriptor:options:completionHandler:")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Foundation.ProtocolMember(IsProperty=false, IsRequired=false, IsStatic=false, Name="GetMinimumTextureBufferAlignment", ParameterByRef=new System.Boolean[] { false }, ParameterType=new System.Type[] { typeof(Metal.MTLPixelFormat) }, ReturnType=typeof(System.nuint), Selector="minimumTextureBufferAlignmentForPixelFormat:")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Foundation.ProtocolMember(IsProperty=false, IsRequired=false, IsStatic=false, Name="CreateIndirectCommandBuffer", ParameterByRef=new System.Boolean[] { false, false, false }, ParameterType=new System.Type[] { typeof(Metal.MTLIndirectCommandBufferDescriptor), typeof(System.nuint), typeof(Metal.MTLResourceOptions) }, ReturnType=typeof(Metal.IMTLIndirectCommandBuffer), Selector="newIndirectCommandBufferWithDescriptor:maxCommandCount:options:")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Foundation.ProtocolMember(IsProperty=false, IsRequired=false, IsStatic=false, Name="CreateSharedEvent", ParameterByRef=new System.Boolean[] { false }, ParameterType=new System.Type[] { typeof(Metal.MTLSharedEventHandle) }, ReturnType=typeof(Metal.IMTLSharedEvent), Selector="newSharedEventWithHandle:")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
      <AttributeName>Foundation.ProtocolMember(IsProperty=false, IsRequired=false, IsStatic=false, Name="CreateRenderPipelineState", ParameterBlockProxy=new System.Type[] { null, null, typeof(ObjCRuntime.Trampolines/NIDMTLNewRenderPipelineStateWithReflectionCompletionHandler) }, ParameterByRef=new System.Boolean[] { false, false, false }, ParameterType=new System.Type[] { typeof(Metal.MTLTileRenderPipelineDescriptor), typeof(Metal.MTLPipelineOption), typeof(Metal.MTLNewRenderPipelineStateWithReflectionCompletionHandler) }, Selector="newRenderPipelineStateWithTileDescriptor:options:completionHandler:")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarin-macos-sdk-14;xamarin-mac-sdk-14">
      <AttributeName>Foundation.ProtocolMember(IsProperty=false, IsRequired=false, IsStatic=false, Name="CreateSharedTexture", ParameterByRef=new System.Boolean[] { false }, ParameterType=new System.Type[] { typeof(Metal.MTLTextureDescriptor) }, ReturnType=typeof(Metal.IMTLTexture), Selector="newSharedTextureWithDescriptor:")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarin-macos-sdk-14;xamarin-mac-sdk-14">
      <AttributeName>Foundation.ProtocolMember(IsProperty=false, IsRequired=false, IsStatic=false, Name="CreateSharedTexture", ParameterByRef=new System.Boolean[] { false }, ParameterType=new System.Type[] { typeof(Metal.MTLSharedTextureHandle) }, ReturnType=typeof(Metal.IMTLTexture), Selector="newSharedTextureWithHandle:")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarin-macos-sdk-14;xamarin-mac-sdk-14">
      <AttributeName>Foundation.ProtocolMember(IsProperty=false, IsRequired=true, IsStatic=false, Name="CreateLibrary", ParameterBlockProxy=new System.Type[] { null, null, typeof(ObjCRuntime.Trampolines/NIDActionArity2V58) }, ParameterByRef=new System.Boolean[] { false, false, false }, ParameterType=new System.Type[] { typeof(System.String), typeof(Metal.MTLCompileOptions), typeof(System.Action`2&lt;Metal.IMTLLibrary,Foundation.NSError&gt;) }, Selector="newLibraryWithSource:options:completionHandler:")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarin-macos-sdk-14;xamarin-mac-sdk-14">
      <AttributeName>Foundation.ProtocolMember(IsProperty=false, IsRequired=true, IsStatic=false, Name="CreateRenderPipelineState", ParameterBlockProxy=new System.Type[] { null, typeof(ObjCRuntime.Trampolines/NIDActionArity2V59) }, ParameterByRef=new System.Boolean[] { false, false }, ParameterType=new System.Type[] { typeof(Metal.MTLRenderPipelineDescriptor), typeof(System.Action`2&lt;Metal.IMTLRenderPipelineState,Foundation.NSError&gt;) }, Selector="newRenderPipelineStateWithDescriptor:completionHandler:")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarin-macos-sdk-14;xamarin-mac-sdk-14">
      <AttributeName>Foundation.ProtocolMember(IsProperty=false, IsRequired=true, IsStatic=false, Name="CreateRenderPipelineState", ParameterBlockProxy=new System.Type[] { null, null, typeof(ObjCRuntime.Trampolines/NIDActionArity3V2) }, ParameterByRef=new System.Boolean[] { false, false, false }, ParameterType=new System.Type[] { typeof(Metal.MTLRenderPipelineDescriptor), typeof(Metal.MTLPipelineOption), typeof(System.Action`3&lt;Metal.IMTLRenderPipelineState,Metal.MTLRenderPipelineReflection,Foundation.NSError&gt;) }, Selector="newRenderPipelineStateWithDescriptor:options:completionHandler:")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarin-macos-sdk-14;xamarin-mac-sdk-14">
      <AttributeName>Foundation.ProtocolMember(IsProperty=false, IsRequired=true, IsStatic=false, Name="CreateComputePipelineState", ParameterBlockProxy=new System.Type[] { null, typeof(ObjCRuntime.Trampolines/NIDActionArity2V60) }, ParameterByRef=new System.Boolean[] { false, false }, ParameterType=new System.Type[] { typeof(Metal.IMTLFunction), typeof(System.Action`2&lt;Metal.IMTLComputePipelineState,Foundation.NSError&gt;) }, Selector="newComputePipelineStateWithFunction:completionHandler:")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarin-macos-sdk-14;xamarin-mac-sdk-14">
      <AttributeName>Foundation.ProtocolMember(IsProperty=false, IsRequired=true, IsStatic=false, Name="CreateComputePipelineState", ParameterBlockProxy=new System.Type[] { null, null, typeof(ObjCRuntime.Trampolines/NIDActionArity3V3) }, ParameterByRef=new System.Boolean[] { false, false, false }, ParameterType=new System.Type[] { typeof(Metal.IMTLFunction), typeof(Metal.MTLPipelineOption), typeof(System.Action`3&lt;Metal.IMTLComputePipelineState,Metal.MTLComputePipelineReflection,Foundation.NSError&gt;) }, Selector="newComputePipelineStateWithFunction:options:completionHandler:")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarin-macos-sdk-14;xamarin-mac-sdk-14">
      <AttributeName>Foundation.ProtocolMember(ArgumentSemantic=ObjCRuntime.ArgumentSemantic.None, GetterSelector="isLowPower", IsProperty=true, IsRequired=false, IsStatic=false, Name="LowPower", PropertyType=typeof(System.Boolean), Selector="lowPower")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarin-macos-sdk-14;xamarin-mac-sdk-14">
      <AttributeName>Foundation.ProtocolMember(ArgumentSemantic=ObjCRuntime.ArgumentSemantic.None, GetterSelector="isHeadless", IsProperty=true, IsRequired=false, IsStatic=false, Name="Headless", PropertyType=typeof(System.Boolean), Selector="headless")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarin-macos-sdk-14;xamarin-mac-sdk-14">
      <AttributeName>Foundation.ProtocolMember(ArgumentSemantic=ObjCRuntime.ArgumentSemantic.None, GetterSelector="recommendedMaxWorkingSetSize", IsProperty=true, IsRequired=false, IsStatic=false, Name="RecommendedMaxWorkingSetSize", PropertyType=typeof(System.UInt64), Selector="recommendedMaxWorkingSetSize")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarin-macos-sdk-14;xamarin-mac-sdk-14">
      <AttributeName>Foundation.ProtocolMember(ArgumentSemantic=ObjCRuntime.ArgumentSemantic.None, GetterSelector="isDepth24Stencil8PixelFormatSupported", IsProperty=true, IsRequired=false, IsStatic=false, Name="Depth24Stencil8PixelFormatSupported", PropertyType=typeof(System.Boolean), Selector="depth24Stencil8PixelFormatSupported")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarin-macos-sdk-14;xamarin-mac-sdk-14">
      <AttributeName>Foundation.ProtocolMember(ArgumentSemantic=ObjCRuntime.ArgumentSemantic.None, GetterSelector="isRemovable", IsProperty=true, IsRequired=false, IsStatic=false, Name="Removable", PropertyType=typeof(System.Boolean), Selector="removable")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>System protocol for interacting with a single graphics device.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="CreateBuffer">
      <MemberSignature Language="C#" Value="public Metal.IMTLBuffer CreateBuffer (nuint length, Metal.MTLResourceOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Metal.IMTLBuffer CreateBuffer(valuetype System.nuint length, valuetype Metal.MTLResourceOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:Metal.IMTLDevice.CreateBuffer(System.nuint,Metal.MTLResourceOptions)" />
      <MemberSignature Language="F#" Value="abstract member CreateBuffer : nuint * Metal.MTLResourceOptions -&gt; Metal.IMTLBuffer" Usage="iMTLDevice.CreateBuffer (length, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("newBufferWithLength:options:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Preserve(Conditional=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Metal.IMTLBuffer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="length" Type="System.nuint" />
        <Parameter Name="options" Type="Metal.MTLResourceOptions" />
      </Parameters>
      <Docs>
        <param name="length">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateBuffer">
      <MemberSignature Language="C#" Value="public Metal.IMTLBuffer CreateBuffer (IntPtr pointer, nuint length, Metal.MTLResourceOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Metal.IMTLBuffer CreateBuffer(native int pointer, valuetype System.nuint length, valuetype Metal.MTLResourceOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:Metal.IMTLDevice.CreateBuffer(System.IntPtr,System.nuint,Metal.MTLResourceOptions)" />
      <MemberSignature Language="F#" Value="abstract member CreateBuffer : nativeint * nuint * Metal.MTLResourceOptions -&gt; Metal.IMTLBuffer" Usage="iMTLDevice.CreateBuffer (pointer, length, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("newBufferWithBytes:length:options:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Preserve(Conditional=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Metal.IMTLBuffer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pointer" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.nuint" />
        <Parameter Name="options" Type="Metal.MTLResourceOptions" />
      </Parameters>
      <Docs>
        <param name="pointer">To be added.</param>
        <param name="length">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateBufferNoCopy">
      <MemberSignature Language="C#" Value="public Metal.IMTLBuffer CreateBufferNoCopy (IntPtr pointer, nuint length, Metal.MTLResourceOptions options, Metal.MTLDeallocator deallocator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Metal.IMTLBuffer CreateBufferNoCopy(native int pointer, valuetype System.nuint length, valuetype Metal.MTLResourceOptions options, class Metal.MTLDeallocator deallocator) cil managed" />
      <MemberSignature Language="DocId" Value="M:Metal.IMTLDevice.CreateBufferNoCopy(System.IntPtr,System.nuint,Metal.MTLResourceOptions,Metal.MTLDeallocator)" />
      <MemberSignature Language="F#" Value="abstract member CreateBufferNoCopy : nativeint * nuint * Metal.MTLResourceOptions * Metal.MTLDeallocator -&gt; Metal.IMTLBuffer" Usage="iMTLDevice.CreateBufferNoCopy (pointer, length, options, deallocator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("newBufferWithBytesNoCopy:length:options:deallocator:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Preserve(Conditional=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Metal.IMTLBuffer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pointer" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.nuint" />
        <Parameter Name="options" Type="Metal.MTLResourceOptions" />
        <Parameter Name="deallocator" Type="Metal.MTLDeallocator">
          <Attributes>
            <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDMTLDeallocator))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="pointer">To be added.</param>
        <param name="length">To be added.</param>
        <param name="options">To be added.</param>
        <param name="deallocator">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateCommandQueue">
      <MemberSignature Language="C#" Value="public Metal.IMTLCommandQueue CreateCommandQueue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Metal.IMTLCommandQueue CreateCommandQueue() cil managed" />
      <MemberSignature Language="DocId" Value="M:Metal.IMTLDevice.CreateCommandQueue" />
      <MemberSignature Language="F#" Value="abstract member CreateCommandQueue : unit -&gt; Metal.IMTLCommandQueue" Usage="iMTLDevice.CreateCommandQueue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("newCommandQueue")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Preserve(Conditional=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Metal.IMTLCommandQueue</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateCommandQueue">
      <MemberSignature Language="C#" Value="public Metal.IMTLCommandQueue CreateCommandQueue (nuint maxCommandBufferCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Metal.IMTLCommandQueue CreateCommandQueue(valuetype System.nuint maxCommandBufferCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:Metal.IMTLDevice.CreateCommandQueue(System.nuint)" />
      <MemberSignature Language="F#" Value="abstract member CreateCommandQueue : nuint -&gt; Metal.IMTLCommandQueue" Usage="iMTLDevice.CreateCommandQueue maxCommandBufferCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("newCommandQueueWithMaxCommandBufferCount:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Preserve(Conditional=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Metal.IMTLCommandQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxCommandBufferCount" Type="System.nuint" />
      </Parameters>
      <Docs>
        <param name="maxCommandBufferCount">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateComputePipelineState">
      <MemberSignature Language="C#" Value="public Metal.IMTLComputePipelineState CreateComputePipelineState (Metal.IMTLFunction computeFunction, out Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Metal.IMTLComputePipelineState CreateComputePipelineState(class Metal.IMTLFunction computeFunction, [out] class Foundation.NSError&amp; error) cil managed" />
      <MemberSignature Language="DocId" Value="M:Metal.IMTLDevice.CreateComputePipelineState(Metal.IMTLFunction,Foundation.NSError@)" />
      <MemberSignature Language="F#" Value="abstract member CreateComputePipelineState : Metal.IMTLFunction *  -&gt; Metal.IMTLComputePipelineState" Usage="iMTLDevice.CreateComputePipelineState (computeFunction, error)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("newComputePipelineStateWithFunction:error:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Preserve(Conditional=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Metal.IMTLComputePipelineState</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="computeFunction" Type="Metal.IMTLFunction" />
        <Parameter Name="error" Type="Foundation.NSError" RefType="out" />
      </Parameters>
      <Docs>
        <param name="computeFunction">To be added.</param>
        <param name="error">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateComputePipelineState">
      <MemberSignature Language="C#" Value="public void CreateComputePipelineState (Metal.IMTLFunction computeFunction, Action&lt;Metal.IMTLComputePipelineState,Foundation.NSError&gt; completionHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CreateComputePipelineState(class Metal.IMTLFunction computeFunction, class System.Action`2&lt;class Metal.IMTLComputePipelineState, class Foundation.NSError&gt; completionHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:Metal.IMTLDevice.CreateComputePipelineState(Metal.IMTLFunction,System.Action{Metal.IMTLComputePipelineState,Foundation.NSError})" />
      <MemberSignature Language="F#" Value="abstract member CreateComputePipelineState : Metal.IMTLFunction * Action&lt;Metal.IMTLComputePipelineState, Foundation.NSError&gt; -&gt; unit" Usage="iMTLDevice.CreateComputePipelineState (computeFunction, completionHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("newComputePipelineStateWithFunction:completionHandler:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Preserve(Conditional=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="computeFunction" Type="Metal.IMTLFunction" />
        <Parameter Name="completionHandler" Type="System.Action&lt;Metal.IMTLComputePipelineState,Foundation.NSError&gt;">
          <Attributes>
            <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDActionArity2V81))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="computeFunction">To be added.</param>
        <param name="completionHandler">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateComputePipelineState">
      <MemberSignature Language="C#" Value="public void CreateComputePipelineState (Metal.IMTLFunction computeFunction, Metal.MTLPipelineOption options, Action&lt;Metal.IMTLComputePipelineState,Metal.MTLComputePipelineReflection,Foundation.NSError&gt; completionHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CreateComputePipelineState(class Metal.IMTLFunction computeFunction, valuetype Metal.MTLPipelineOption options, class System.Action`3&lt;class Metal.IMTLComputePipelineState, class Metal.MTLComputePipelineReflection, class Foundation.NSError&gt; completionHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:Metal.IMTLDevice.CreateComputePipelineState(Metal.IMTLFunction,Metal.MTLPipelineOption,System.Action{Metal.IMTLComputePipelineState,Metal.MTLComputePipelineReflection,Foundation.NSError})" />
      <MemberSignature Language="F#" Value="abstract member CreateComputePipelineState : Metal.IMTLFunction * Metal.MTLPipelineOption * Action&lt;Metal.IMTLComputePipelineState, Metal.MTLComputePipelineReflection, Foundation.NSError&gt; -&gt; unit" Usage="iMTLDevice.CreateComputePipelineState (computeFunction, options, completionHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("newComputePipelineStateWithFunction:options:completionHandler:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Preserve(Conditional=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="computeFunction" Type="Metal.IMTLFunction" />
        <Parameter Name="options" Type="Metal.MTLPipelineOption" />
        <Parameter Name="completionHandler" Type="System.Action&lt;Metal.IMTLComputePipelineState,Metal.MTLComputePipelineReflection,Foundation.NSError&gt;">
          <Attributes>
            <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDActionArity3V7))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="computeFunction">To be added.</param>
        <param name="options">To be added.</param>
        <param name="completionHandler">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateComputePipelineState">
      <MemberSignature Language="C#" Value="public Metal.IMTLComputePipelineState CreateComputePipelineState (Metal.IMTLFunction computeFunction, Metal.MTLPipelineOption options, out Metal.MTLComputePipelineReflection reflection, out Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Metal.IMTLComputePipelineState CreateComputePipelineState(class Metal.IMTLFunction computeFunction, valuetype Metal.MTLPipelineOption options, [out] class Metal.MTLComputePipelineReflection&amp; reflection, [out] class Foundation.NSError&amp; error) cil managed" />
      <MemberSignature Language="DocId" Value="M:Metal.IMTLDevice.CreateComputePipelineState(Metal.IMTLFunction,Metal.MTLPipelineOption,Metal.MTLComputePipelineReflection@,Foundation.NSError@)" />
      <MemberSignature Language="F#" Value="abstract member CreateComputePipelineState : Metal.IMTLFunction * Metal.MTLPipelineOption *  *  -&gt; Metal.IMTLComputePipelineState" Usage="iMTLDevice.CreateComputePipelineState (computeFunction, options, reflection, error)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("newComputePipelineStateWithFunction:options:reflection:error:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Preserve(Conditional=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Metal.IMTLComputePipelineState</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="computeFunction" Type="Metal.IMTLFunction" />
        <Parameter Name="options" Type="Metal.MTLPipelineOption" />
        <Parameter Name="reflection" Type="Metal.MTLComputePipelineReflection" RefType="out" />
        <Parameter Name="error" Type="Foundation.NSError" RefType="out" />
      </Parameters>
      <Docs>
        <param name="computeFunction">To be added.</param>
        <param name="options">To be added.</param>
        <param name="reflection">To be added.</param>
        <param name="error">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDefaultLibrary">
      <MemberSignature Language="C#" Value="public Metal.IMTLLibrary CreateDefaultLibrary ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Metal.IMTLLibrary CreateDefaultLibrary() cil managed" />
      <MemberSignature Language="DocId" Value="M:Metal.IMTLDevice.CreateDefaultLibrary" />
      <MemberSignature Language="F#" Value="abstract member CreateDefaultLibrary : unit -&gt; Metal.IMTLLibrary" Usage="iMTLDevice.CreateDefaultLibrary " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("newDefaultLibrary")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Preserve(Conditional=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Metal.IMTLLibrary</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDepthStencilState">
      <MemberSignature Language="C#" Value="public Metal.IMTLDepthStencilState CreateDepthStencilState (Metal.MTLDepthStencilDescriptor descriptor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Metal.IMTLDepthStencilState CreateDepthStencilState(class Metal.MTLDepthStencilDescriptor descriptor) cil managed" />
      <MemberSignature Language="DocId" Value="M:Metal.IMTLDevice.CreateDepthStencilState(Metal.MTLDepthStencilDescriptor)" />
      <MemberSignature Language="F#" Value="abstract member CreateDepthStencilState : Metal.MTLDepthStencilDescriptor -&gt; Metal.IMTLDepthStencilState" Usage="iMTLDevice.CreateDepthStencilState descriptor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("newDepthStencilStateWithDescriptor:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Preserve(Conditional=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Metal.IMTLDepthStencilState</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="descriptor" Type="Metal.MTLDepthStencilDescriptor" />
      </Parameters>
      <Docs>
        <param name="descriptor">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateLibrary">
      <MemberSignature Language="C#" Value="public Metal.IMTLLibrary CreateLibrary (Foundation.NSObject data, out Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Metal.IMTLLibrary CreateLibrary(class Foundation.NSObject data, [out] class Foundation.NSError&amp; error) cil managed" />
      <MemberSignature Language="DocId" Value="M:Metal.IMTLDevice.CreateLibrary(Foundation.NSObject,Foundation.NSError@)" />
      <MemberSignature Language="F#" Value="abstract member CreateLibrary : Foundation.NSObject *  -&gt; Metal.IMTLLibrary" Usage="iMTLDevice.CreateLibrary (data, error)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("newLibraryWithData:error:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Preserve(Conditional=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Metal.IMTLLibrary</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="Foundation.NSObject" />
        <Parameter Name="error" Type="Foundation.NSError" RefType="out" />
      </Parameters>
      <Docs>
        <param name="data">To be added.</param>
        <param name="error">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateLibrary">
      <MemberSignature Language="C#" Value="public Metal.IMTLLibrary CreateLibrary (string filepath, out Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Metal.IMTLLibrary CreateLibrary(string filepath, [out] class Foundation.NSError&amp; error) cil managed" />
      <MemberSignature Language="DocId" Value="M:Metal.IMTLDevice.CreateLibrary(System.String,Foundation.NSError@)" />
      <MemberSignature Language="F#" Value="abstract member CreateLibrary : string *  -&gt; Metal.IMTLLibrary" Usage="iMTLDevice.CreateLibrary (filepath, error)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("newLibraryWithFile:error:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Preserve(Conditional=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Metal.IMTLLibrary</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filepath" Type="System.String" />
        <Parameter Name="error" Type="Foundation.NSError" RefType="out" />
      </Parameters>
      <Docs>
        <param name="filepath">To be added.</param>
        <param name="error">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateLibrary">
      <MemberSignature Language="C#" Value="public Metal.IMTLLibrary CreateLibrary (string source, Metal.MTLCompileOptions options, out Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Metal.IMTLLibrary CreateLibrary(string source, class Metal.MTLCompileOptions options, [out] class Foundation.NSError&amp; error) cil managed" />
      <MemberSignature Language="DocId" Value="M:Metal.IMTLDevice.CreateLibrary(System.String,Metal.MTLCompileOptions,Foundation.NSError@)" />
      <MemberSignature Language="F#" Value="abstract member CreateLibrary : string * Metal.MTLCompileOptions *  -&gt; Metal.IMTLLibrary" Usage="iMTLDevice.CreateLibrary (source, options, error)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("newLibraryWithSource:options:error:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Preserve(Conditional=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Metal.IMTLLibrary</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="options" Type="Metal.MTLCompileOptions" />
        <Parameter Name="error" Type="Foundation.NSError" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source">To be added.</param>
        <param name="options">To be added.</param>
        <param name="error">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateLibrary">
      <MemberSignature Language="C#" Value="public void CreateLibrary (string source, Metal.MTLCompileOptions options, Action&lt;Metal.IMTLLibrary,Foundation.NSError&gt; completionHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CreateLibrary(string source, class Metal.MTLCompileOptions options, class System.Action`2&lt;class Metal.IMTLLibrary, class Foundation.NSError&gt; completionHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:Metal.IMTLDevice.CreateLibrary(System.String,Metal.MTLCompileOptions,System.Action{Metal.IMTLLibrary,Foundation.NSError})" />
      <MemberSignature Language="F#" Value="abstract member CreateLibrary : string * Metal.MTLCompileOptions * Action&lt;Metal.IMTLLibrary, Foundation.NSError&gt; -&gt; unit" Usage="iMTLDevice.CreateLibrary (source, options, completionHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("newLibraryWithSource:options:completionHandler:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Preserve(Conditional=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="options" Type="Metal.MTLCompileOptions" />
        <Parameter Name="completionHandler" Type="System.Action&lt;Metal.IMTLLibrary,Foundation.NSError&gt;">
          <Attributes>
            <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDActionArity2V79))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="source">To be added.</param>
        <param name="options">To be added.</param>
        <param name="completionHandler">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateRenderPipelineState">
      <MemberSignature Language="C#" Value="public Metal.IMTLRenderPipelineState CreateRenderPipelineState (Metal.MTLRenderPipelineDescriptor descriptor, out Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Metal.IMTLRenderPipelineState CreateRenderPipelineState(class Metal.MTLRenderPipelineDescriptor descriptor, [out] class Foundation.NSError&amp; error) cil managed" />
      <MemberSignature Language="DocId" Value="M:Metal.IMTLDevice.CreateRenderPipelineState(Metal.MTLRenderPipelineDescriptor,Foundation.NSError@)" />
      <MemberSignature Language="F#" Value="abstract member CreateRenderPipelineState : Metal.MTLRenderPipelineDescriptor *  -&gt; Metal.IMTLRenderPipelineState" Usage="iMTLDevice.CreateRenderPipelineState (descriptor, error)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("newRenderPipelineStateWithDescriptor:error:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Preserve(Conditional=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Metal.IMTLRenderPipelineState</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="descriptor" Type="Metal.MTLRenderPipelineDescriptor" />
        <Parameter Name="error" Type="Foundation.NSError" RefType="out" />
      </Parameters>
      <Docs>
        <param name="descriptor">To be added.</param>
        <param name="error">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateRenderPipelineState">
      <MemberSignature Language="C#" Value="public void CreateRenderPipelineState (Metal.MTLRenderPipelineDescriptor descriptor, Action&lt;Metal.IMTLRenderPipelineState,Foundation.NSError&gt; completionHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CreateRenderPipelineState(class Metal.MTLRenderPipelineDescriptor descriptor, class System.Action`2&lt;class Metal.IMTLRenderPipelineState, class Foundation.NSError&gt; completionHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:Metal.IMTLDevice.CreateRenderPipelineState(Metal.MTLRenderPipelineDescriptor,System.Action{Metal.IMTLRenderPipelineState,Foundation.NSError})" />
      <MemberSignature Language="F#" Value="abstract member CreateRenderPipelineState : Metal.MTLRenderPipelineDescriptor * Action&lt;Metal.IMTLRenderPipelineState, Foundation.NSError&gt; -&gt; unit" Usage="iMTLDevice.CreateRenderPipelineState (descriptor, completionHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("newRenderPipelineStateWithDescriptor:completionHandler:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Preserve(Conditional=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="descriptor" Type="Metal.MTLRenderPipelineDescriptor" />
        <Parameter Name="completionHandler" Type="System.Action&lt;Metal.IMTLRenderPipelineState,Foundation.NSError&gt;">
          <Attributes>
            <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDActionArity2V80))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="descriptor">To be added.</param>
        <param name="completionHandler">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateRenderPipelineState">
      <MemberSignature Language="C#" Value="public void CreateRenderPipelineState (Metal.MTLRenderPipelineDescriptor descriptor, Metal.MTLPipelineOption options, Action&lt;Metal.IMTLRenderPipelineState,Metal.MTLRenderPipelineReflection,Foundation.NSError&gt; completionHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CreateRenderPipelineState(class Metal.MTLRenderPipelineDescriptor descriptor, valuetype Metal.MTLPipelineOption options, class System.Action`3&lt;class Metal.IMTLRenderPipelineState, class Metal.MTLRenderPipelineReflection, class Foundation.NSError&gt; completionHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:Metal.IMTLDevice.CreateRenderPipelineState(Metal.MTLRenderPipelineDescriptor,Metal.MTLPipelineOption,System.Action{Metal.IMTLRenderPipelineState,Metal.MTLRenderPipelineReflection,Foundation.NSError})" />
      <MemberSignature Language="F#" Value="abstract member CreateRenderPipelineState : Metal.MTLRenderPipelineDescriptor * Metal.MTLPipelineOption * Action&lt;Metal.IMTLRenderPipelineState, Metal.MTLRenderPipelineReflection, Foundation.NSError&gt; -&gt; unit" Usage="iMTLDevice.CreateRenderPipelineState (descriptor, options, completionHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("newRenderPipelineStateWithDescriptor:options:completionHandler:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Preserve(Conditional=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="descriptor" Type="Metal.MTLRenderPipelineDescriptor" />
        <Parameter Name="options" Type="Metal.MTLPipelineOption" />
        <Parameter Name="completionHandler" Type="System.Action&lt;Metal.IMTLRenderPipelineState,Metal.MTLRenderPipelineReflection,Foundation.NSError&gt;">
          <Attributes>
            <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDActionArity3V6))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="descriptor">To be added.</param>
        <param name="options">To be added.</param>
        <param name="completionHandler">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateRenderPipelineState">
      <MemberSignature Language="C#" Value="public Metal.IMTLRenderPipelineState CreateRenderPipelineState (Metal.MTLRenderPipelineDescriptor descriptor, Metal.MTLPipelineOption options, out Metal.MTLRenderPipelineReflection reflection, out Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Metal.IMTLRenderPipelineState CreateRenderPipelineState(class Metal.MTLRenderPipelineDescriptor descriptor, valuetype Metal.MTLPipelineOption options, [out] class Metal.MTLRenderPipelineReflection&amp; reflection, [out] class Foundation.NSError&amp; error) cil managed" />
      <MemberSignature Language="DocId" Value="M:Metal.IMTLDevice.CreateRenderPipelineState(Metal.MTLRenderPipelineDescriptor,Metal.MTLPipelineOption,Metal.MTLRenderPipelineReflection@,Foundation.NSError@)" />
      <MemberSignature Language="F#" Value="abstract member CreateRenderPipelineState : Metal.MTLRenderPipelineDescriptor * Metal.MTLPipelineOption *  *  -&gt; Metal.IMTLRenderPipelineState" Usage="iMTLDevice.CreateRenderPipelineState (descriptor, options, reflection, error)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("newRenderPipelineStateWithDescriptor:options:reflection:error:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Preserve(Conditional=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Metal.IMTLRenderPipelineState</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="descriptor" Type="Metal.MTLRenderPipelineDescriptor" />
        <Parameter Name="options" Type="Metal.MTLPipelineOption" />
        <Parameter Name="reflection" Type="Metal.MTLRenderPipelineReflection" RefType="out" />
        <Parameter Name="error" Type="Foundation.NSError" RefType="out" />
      </Parameters>
      <Docs>
        <param name="descriptor">To be added.</param>
        <param name="options">To be added.</param>
        <param name="reflection">To be added.</param>
        <param name="error">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSamplerState">
      <MemberSignature Language="C#" Value="public Metal.IMTLSamplerState CreateSamplerState (Metal.MTLSamplerDescriptor descriptor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Metal.IMTLSamplerState CreateSamplerState(class Metal.MTLSamplerDescriptor descriptor) cil managed" />
      <MemberSignature Language="DocId" Value="M:Metal.IMTLDevice.CreateSamplerState(Metal.MTLSamplerDescriptor)" />
      <MemberSignature Language="F#" Value="abstract member CreateSamplerState : Metal.MTLSamplerDescriptor -&gt; Metal.IMTLSamplerState" Usage="iMTLDevice.CreateSamplerState descriptor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("newSamplerStateWithDescriptor:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Preserve(Conditional=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Metal.IMTLSamplerState</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="descriptor" Type="Metal.MTLSamplerDescriptor" />
      </Parameters>
      <Docs>
        <param name="descriptor">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateTexture">
      <MemberSignature Language="C#" Value="public Metal.IMTLTexture CreateTexture (Metal.MTLTextureDescriptor descriptor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Metal.IMTLTexture CreateTexture(class Metal.MTLTextureDescriptor descriptor) cil managed" />
      <MemberSignature Language="DocId" Value="M:Metal.IMTLDevice.CreateTexture(Metal.MTLTextureDescriptor)" />
      <MemberSignature Language="F#" Value="abstract member CreateTexture : Metal.MTLTextureDescriptor -&gt; Metal.IMTLTexture" Usage="iMTLDevice.CreateTexture descriptor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("newTextureWithDescriptor:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Preserve(Conditional=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Metal.IMTLTexture</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="descriptor" Type="Metal.MTLTextureDescriptor" />
      </Parameters>
      <Docs>
        <param name="descriptor">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:Metal.IMTLDevice.Name" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="Metal.IMTLDevice.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Preserve(Conditional=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("name")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsFeatureSet">
      <MemberSignature Language="C#" Value="public bool SupportsFeatureSet (Metal.MTLFeatureSet featureSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool SupportsFeatureSet(valuetype Metal.MTLFeatureSet featureSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:Metal.IMTLDevice.SupportsFeatureSet(Metal.MTLFeatureSet)" />
      <MemberSignature Language="F#" Value="abstract member SupportsFeatureSet : Metal.MTLFeatureSet -&gt; bool" Usage="iMTLDevice.SupportsFeatureSet featureSet" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("supportsFeatureSet:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Foundation.Preserve(Conditional=true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="featureSet" Type="Metal.MTLFeatureSet" />
      </Parameters>
      <Docs>
        <param name="featureSet">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
