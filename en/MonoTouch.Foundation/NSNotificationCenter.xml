
<Type Name="NSNotificationCenter" FullName="MonoTouch.Foundation.NSNotificationCenter">
  <TypeSignature Language="C#" Value="public class NSNotificationCenter : MonoTouch.Foundation.NSObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit NSNotificationCenter extends MonoTouch.Foundation.NSObject" />
  <AssemblyInfo apistyle="classic">
    <AssemblyName>monotouch</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo apistyle="unified">
    <AssemblyName>Xamarin.iOS</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>MonoTouch.Foundation.NSObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>MonoTouch.Foundation.Register("NSNotificationCenter", true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>A notification hub for the application.</summary>
    <remarks>
      <para>

	The NSNotificationCenter is a hub that is used to listen to
	broadcast messages and post broadcast messages in an
	application.    The messages that are posted are synchronous.
      </para>
      <para> 
	The NSNotificationCenter.DefaultCenter plays a central
	role in the application as this is where system notifications
	are posted for interesting system-level events.  
      </para>
      <para>

	Posting a notification is a synchronous process, which means
	that invoking one of the Post messages on the notification
	center will block execution until all of the notification handlers have completed running. 

      </para>
      <para>

	Notifications are posted on the same thread as the calling
	thread which could have undesired effects.  If you need to
	deliver notifications from a background thread, use the <see cref="M:MonoTouch.Foundation.NSObject.BeginInvokeOnMainThread(MonoTouch.Foundation.NSAction&#xA; action" /> method to wrap your posting into a delegate that is
	invoked on the main thread.

      </para>
      <para>

	When subscribing to a notification, it is possible to
	subscribe only to a certain kind of notification by specifying
	the notification name (or null to listen to all notifications
	posted to the notification center).  It is also possible to
	subscribe only to notifications issued by a specific object.
	This can be used to filter the amount of notifications
	received.

      </para>
      <para>

	Notifications are usually NSString fields that are hosted in
	some class, for example the Objetive-C
	UITextViewTextDidChangeNotification is found in the class
	UITextView as the <see cref="F:MonoTouch.UIKit.UITextView.TextDidChangeNotification" />.
	For convenience there are overloads that take C# strings.

      </para>
      <para>

	To register for notifications, you can use the AddObserver
	method.  We recommend that you use the C# versions of these
	methods, as you can directly connect delegates, lambdas and
	methods directly into your code.  When you use any of the
	AddObserver methods in this class that take an
	Action&lt;NSNotification;&gt; parameter, the AddObserver will
	return a token.  This token is then used as the parameter to
	RemoveNotification when you want to stop listening to a
	particular event.

      </para>
      <example>
        <code lang="C#">
NSObject notificationToken;

void Setup ()
{
	notificationToken = NSNotificationCenter.DefaultCenter.AddObserver (FooBar.ClockNotification, OnClockChange);
}

void OnClockChange (NSNotification notification)
{
	Console.WriteLine ("The ClockNotification message was posted");
}

void Teardown ()
{
	NSNotificationCenter.DefaultCenter.RemoveObserver (notificationToken);
}
</code>
      </example>
      <para>

	Starting with MonoTouch 5.4, calling Dispose on the returned
	notification token will also remove the observer for you,
	making the code shorter.   For example:

      </para>
      <example>
        <code lang="C#">
NSObject notificationToken;

void Setup ()
{
	notificationToken = NSNotificationCenter.DefaultCenter.AddObserver (FooBar.ClockNotification, OnClockChange);
}

void OnClockChange (NSNotification notification)
{
	Console.WriteLine ("The ClockNotification message was posted");
}

void Teardown ()
{
	notificationToken.Dispose ();
}
</code>
      </example>
    </remarks>
    <related type="sample" href="http://samples.xamarin.com/Samples/ByGuid?guid=67b46eb2-81d9-477f-a448-18e68db1227b">AppPrefs</related>
    <related type="sample" href="http://samples.xamarin.com/Samples/ByGuid?guid=23a2571b-45eb-4889-bb67-d88937cb68c1">monocatalog</related>
    <related type="PlatformDocAPI" href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSNotificationCenter_Class/index.html">Apple documentation for <c>NSNotificationCenter</c></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NSNotificationCenter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("init")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Default constructor that initializes a new instance of this class with no parameters.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor" apistyle="classic">
      <MemberSignature Language="C#" Value="public NSNotificationCenter (MonoTouch.Foundation.NSCoder coder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class MonoTouch.Foundation.NSCoder coder) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("initWithCoder:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="coder" Type="MonoTouch.Foundation.NSCoder" />
      </Parameters>
      <Docs>
        <param name="coder">The unarchiver object.</param>
        <summary>A constructor that initializes the object from the data stored in the unarchiver object.</summary>
        <remarks>
          <para>This constructor is provided to allow the class to be initialized from an unarchiver (for example, during NIB deserialization).   This is part of the <see cref="T:MonoTouch.Foundation.NSCoding" />  protocol.</para>
          <para>If you want to create a subclass of this object and continue to support deserialization from an archive, you should implement a constructor with an identical signature: taking a single parameter of type <see cref="T:MonoTouch.Foundation.NSCoder" /> and decorate it with the [Export("initWithCoder:"] attribute declaration.</para>
          <para>The state of this object can also be serialized by using the companion method, EncodeTo.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NSNotificationCenter (MonoTouch.Foundation.NSObjectFlag t);" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class MonoTouch.Foundation.NSObjectFlag t) cil managed" apistyle="classic" />
      <MemberSignature Language="C#" Value="protected NSNotificationCenter (MonoTouch.Foundation.NSObjectFlag t);" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class MonoTouch.Foundation.NSObjectFlag t) cil managed" apistyle="unified" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="t" Type="MonoTouch.Foundation.NSObjectFlag" />
      </Parameters>
      <Docs>
        <param name="t">Unused sentinel value, pass NSObjectFlag.Empty.</param>
        <summary>Constructor to call on derived classes to skip initialization and merely allocate the object.</summary>
        <remarks>
          <para>This constructor should be called by derived classes when they completely construct the object in managed code and merely want the runtime to allocate and initialize the NSObject.   This is required to implement the two-step initialization process that Objective-C uses, the first step is to perform the object allocation, the second step is to initialize the object.   When you invoke the constructor that takes the NSObjectFlag.Empty you taking advantage of a direct path that goes all the way up to NSObject to merely allocate the object's memory and bind the Objective-C and C# objects together.    The actual initialization of the object is up to you.</para>
          <para>This constructor is typically used by the binding generator to allocate the object, but prevent the actual initialization to take place.   Once the allocation has taken place, the constructor has to initialize the object.   With constructors generated by the binding generator this means that it manually invokes one of the "init" methods to initialize the object.</para>
          <para>It is your responsibility to completely initialize the object if you chain up using the NSObjectFlag.Empty path.</para>
          <para>In general, if your constructors invokes the NSObjectFlag.Empty base implementation, then it should be calling an Objective-C init method.   If this is not the case, you should instead chain to the proper constructor in your class. </para>
          <para>The argument value is ignored and merely ensures that the only code that is executed is the construction phase is the basic NSObject allocation and runtime type registration.  Typically the chaining would look like this:</para>
          <example>
            <code lang="C#">
//
// The NSObjectFlag merely allocates the object and registers the
// C# class with the Objective-C runtime if necessary, but no actual
// initXxx method is invoked, that is done later in the constructor
//
// This is taken from MonoTouch's source code:
//
[Export ("initWithFrame:")]
public UIView (System.Drawing.RectangleF frame) : base (NSObjectFlag.Empty)
{
// Invoke the init method now.
	var initWithFrame = new Selector ("initWithFrame:").Handle;
	if (IsDirectBinding)
		Handle = MonoTouch.ObjCRuntime.Messaging.IntPtr_objc_msgSend_RectangleF (this.Handle, initWithFrame, frame);
	else
		Handle = MonoTouch.ObjCRuntime.Messaging.IntPtr_objc_msgSendSuper_RectangleF (this.SuperHandle, initWithFrame, frame);
}
</code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NSNotificationCenter (IntPtr handle);" apistyle="classic" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle) cil managed" apistyle="classic" />
      <MemberSignature Language="C#" Value="protected NSNotificationCenter (IntPtr handle);" apistyle="unified" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig specialname rtspecialname instance void .ctor(native int handle) cil managed" apistyle="unified" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Pointer (handle) to the unmanaged object.</param>
        <summary>A constructor used when creating managed representations of unmanaged objects;  Called by the runtime.</summary>
        <remarks>
          <para>This constructor is invoked by the runtime infrastructure (<see cref="M:MonoTouch.ObjCRuntime.GetNSObject (System.IntPtr)" />) to create a new managed representation for a pointer to an unmanaged Objective-C object.    You should not invoke this method directly, instead you should call the GetNSObject method as it will prevent two instances of a managed object to point to the same native object.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddObserver">
      <MemberSignature Language="C#" Value="public MonoTouch.Foundation.NSObject AddObserver (MonoTouch.Foundation.NSString aName, Action&lt;MonoTouch.Foundation.NSNotification&gt; notify);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class MonoTouch.Foundation.NSObject AddObserver(class MonoTouch.Foundation.NSString aName, class System.Action`1&lt;class MonoTouch.Foundation.NSNotification&gt; notify) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="aName" Type="MonoTouch.Foundation.NSString" />
        <Parameter Name="notify" Type="System.Action&lt;MonoTouch.Foundation.NSNotification&gt;" />
      </Parameters>
      <Docs>
        <param name="aName">The name of the notification to observe.</param>
        <param name="notify">The delegate that will be invoked when the notification is posted.</param>
        <summary>Adds an observer for the specified notification</summary>
        <returns>An observer token that can be used later as the parameter passed to RemoveObserver (NSObject observer).</returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddObserver" apistyle="classic">
      <MemberSignature Language="C#" Value="public MonoTouch.Foundation.NSObject AddObserver (string aName, Action&lt;MonoTouch.Foundation.NSNotification&gt; notify);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class MonoTouch.Foundation.NSObject AddObserver(string aName, class System.Action`1&lt;class MonoTouch.Foundation.NSNotification&gt; notify) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Advice("Use AddObserver(NSString, Action&lt;NSNotification&gt;) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="aName" Type="System.String" />
        <Parameter Name="notify" Type="System.Action&lt;MonoTouch.Foundation.NSNotification&gt;" />
      </Parameters>
      <Docs>
        <param name="aName">The name of the notification to observe.</param>
        <param name="notify">The delegate that will be invoked when the notification is posted.</param>
        <summary>Adds an observer for the specified notification</summary>
        <returns>An observer token that can be used later as the parameter passed to RemoveObserver (NSObject observer).</returns>
        <remarks>Use this overload if you are using a C# string.   Usually you would be using an NSString constant using the pattern ClassName.SomeNotification.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddObserver">
      <MemberSignature Language="C#" Value="public MonoTouch.Foundation.NSObject AddObserver (MonoTouch.Foundation.NSString aName, Action&lt;MonoTouch.Foundation.NSNotification&gt; notify, MonoTouch.Foundation.NSObject fromObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class MonoTouch.Foundation.NSObject AddObserver(class MonoTouch.Foundation.NSString aName, class System.Action`1&lt;class MonoTouch.Foundation.NSNotification&gt; notify, class MonoTouch.Foundation.NSObject fromObject) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="aName" Type="MonoTouch.Foundation.NSString" />
        <Parameter Name="notify" Type="System.Action&lt;MonoTouch.Foundation.NSNotification&gt;" />
        <Parameter Name="fromObject" Type="MonoTouch.Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="aName">The name of the notification to observe.</param>
        <param name="notify">The delegate that will be invoked when the notification is posted.</param>
        <param name="fromObject">If not-null, filters the notifications to those sent by this object.</param>
        <summary>Adds an observer for the specified notification</summary>
        <returns>An observer token that can be used later as the parameter passed to RemoveObserver (NSObject observer).</returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddObserver" apistyle="classic">
      <MemberSignature Language="C#" Value="public MonoTouch.Foundation.NSObject AddObserver (string aName, Action&lt;MonoTouch.Foundation.NSNotification&gt; notify, MonoTouch.Foundation.NSObject fromObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class MonoTouch.Foundation.NSObject AddObserver(string aName, class System.Action`1&lt;class MonoTouch.Foundation.NSNotification&gt; notify, class MonoTouch.Foundation.NSObject fromObject) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Advice("Use AddObserver(NSString, Action&lt;NSNotification&gt;, NSObject)")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="aName" Type="System.String" />
        <Parameter Name="notify" Type="System.Action&lt;MonoTouch.Foundation.NSNotification&gt;" />
        <Parameter Name="fromObject" Type="MonoTouch.Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="aName">The name of the notification to observe.</param>
        <param name="notify">The delegate that will be invoked when the notification is posted.</param>
        <param name="fromObject">If not-null, filters the notifications to those sent by this object.</param>
        <summary>Adds an observer for the specified notification</summary>
        <returns>An observer token that can be used later as the parameter passed to RemoveObserver (NSObject observer).</returns>
        <remarks>Use this overload if you are using a C# string.   Usually you would be using an NSString constant using the pattern ClassName.SomeNotification.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddObserver">
      <MemberSignature Language="C#" Value="public virtual void AddObserver (MonoTouch.Foundation.NSObject observer, MonoTouch.ObjCRuntime.Selector aSelector, MonoTouch.Foundation.NSString aName, MonoTouch.Foundation.NSObject anObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddObserver(class MonoTouch.Foundation.NSObject observer, class MonoTouch.ObjCRuntime.Selector aSelector, class MonoTouch.Foundation.NSString aName, class MonoTouch.Foundation.NSObject anObject) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("addObserver:selector:name:object:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="observer" Type="MonoTouch.Foundation.NSObject" />
        <Parameter Name="aSelector" Type="MonoTouch.ObjCRuntime.Selector" />
        <Parameter Name="aName" Type="MonoTouch.Foundation.NSString" />
        <Parameter Name="anObject" Type="MonoTouch.Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="observer">To be added.</param>
        <param name="aSelector">To be added.</param>
        <param name="aName">
          <para>Optional name that you want to register with and filter delivery by this name.   Use null if you do not want filtering to take place.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <param name="anObject">
          <para>The object that we want to receive notifications from, or null for receiving the specified notifications sent by all objects.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Low-level add-bserver API</summary>
        <remarks>
          <para>
	    This is a low-level version of the AddObserver API that allows the consumer to contorl the observer and the selector to notify upon notifications.   
	  </para>
          <para>
	    Users are encouraged to use the high-level <see cref="M:MonoTouch.Foundation.NSNotificationCenter.AddObserver(MonoTouch.Foundation.NSString,System.Action&lt;NSNotification&gt;, MonoTouch.Foundation.NSObject)" /> variant.
	  </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddObserver" apistyle="classic">
      <MemberSignature Language="C#" Value="public void AddObserver (MonoTouch.Foundation.NSObject observer, MonoTouch.ObjCRuntime.Selector aSelector, string aname, MonoTouch.Foundation.NSObject anObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddObserver(class MonoTouch.Foundation.NSObject observer, class MonoTouch.ObjCRuntime.Selector aSelector, string aname, class MonoTouch.Foundation.NSObject anObject) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Advice("Use AddObserver(NSObject, Selector, NSString, NSObject) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="observer" Type="MonoTouch.Foundation.NSObject" />
        <Parameter Name="aSelector" Type="MonoTouch.ObjCRuntime.Selector" />
        <Parameter Name="aname" Type="System.String" />
        <Parameter Name="anObject" Type="MonoTouch.Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="observer">To be added.</param>
        <param name="aSelector">To be added.</param>
        <param name="aname">To be added.</param>
        <param name="anObject">To be added.</param>
        <summary>To be added.</summary>
        <remarks>
          <para>
	    This is a low-level version of the AddObserver API that allows the consumer to contorl the observer and the selector to notify upon notifications.   
	  </para>
          <para>
	    Users are encouraged to use the high-level <see cref="M:MonoTouch.Foundation.NSNotificationCenter.AddObserver(MonoTouch.Foundation.NSString,System.Action&lt;NSNotification&gt;, MonoTouch.Foundation.NSObject)" /> variant.
	  </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddObserver" apistyle="classic">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.Foundation.NSObject AddObserver (string name, MonoTouch.Foundation.NSObject obj, MonoTouch.Foundation.NSOperationQueue queue, MonoTouch.Foundation.NSNotificationHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class MonoTouch.Foundation.NSObject AddObserver(string name, class MonoTouch.Foundation.NSObject obj, class MonoTouch.Foundation.NSOperationQueue queue, class MonoTouch.Foundation.NSNotificationHandler handler) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("addObserverForName:object:queue:usingBlock:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(4, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="obj" Type="MonoTouch.Foundation.NSObject" />
        <Parameter Name="queue" Type="MonoTouch.Foundation.NSOperationQueue" />
        <Parameter Name="handler" Type="MonoTouch.Foundation.NSNotificationHandler">
          <Attributes>
            <Attribute>
              <AttributeName>MonoTouch.ObjCRuntime.BlockProxy(typeof(MonoTouch.ObjCRuntime.Trampolines/NIDNSNotificationHandler))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="obj">To be added.</param>
        <param name="queue">To be added.</param>
        <param name="handler">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddObserver" apistyle="unified">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.Foundation.NSObject AddObserver (string name, MonoTouch.Foundation.NSObject obj, MonoTouch.Foundation.NSOperationQueue queue, Action&lt;MonoTouch.Foundation.NSNotification&gt; handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class MonoTouch.Foundation.NSObject AddObserver(string name, class MonoTouch.Foundation.NSObject obj, class MonoTouch.Foundation.NSOperationQueue queue, class System.Action`1&lt;class MonoTouch.Foundation.NSNotification&gt; handler) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("addObserverForName:object:queue:usingBlock:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Availability(Introduced=MonoTouch.ObjCRuntime.Platform.iOS_4_0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="obj" Type="MonoTouch.Foundation.NSObject" />
        <Parameter Name="queue" Type="MonoTouch.Foundation.NSOperationQueue" />
        <Parameter Name="handler" Type="System.Action&lt;MonoTouch.Foundation.NSNotification&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>MonoTouch.ObjCRuntime.BlockProxy(typeof(MonoTouch.ObjCRuntime.Trampolines/NIDActionArity1V18))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="obj">To be added.</param>
        <param name="queue">To be added.</param>
        <param name="handler">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClassHandle">
      <MemberSignature Language="C#" Value="public override IntPtr ClassHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ClassHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The handle for this class.</summary>
        <value>The pointer to the Objective-C class.</value>
        <remarks>Each MonoTouch class mirrors an unmanaged Objective-C class.   This value contains the pointer to the Objective-C class, it is similar to calling objc_getClass with the object name.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultCenter">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSNotificationCenter DefaultCenter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSNotificationCenter DefaultCenter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("defaultCenter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSNotificationCenter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The default notification center, system notifications and system-level events are posted to this notification center.</summary>
        <value>
        </value>
        <remarks>
          <para>

	    The NSNotificationCenter.DefaultCenter plays a central
	    role in the application as this is where system notifications
	    are posted for interesting system-level events.  

	  </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PostNotification">
      <MemberSignature Language="C#" Value="public virtual void PostNotification (MonoTouch.Foundation.NSNotification notification);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PostNotification(class MonoTouch.Foundation.NSNotification notification) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("postNotification:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="notification" Type="MonoTouch.Foundation.NSNotification" />
      </Parameters>
      <Docs>
        <param name="notification">Notification to post</param>
        <summary>Posts a notification that is broadcast to everyoned subscribing to that notification.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PostNotificationName">
      <MemberSignature Language="C#" Value="public virtual void PostNotificationName (string aName, MonoTouch.Foundation.NSObject anObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PostNotificationName(string aName, class MonoTouch.Foundation.NSObject anObject) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("postNotificationName:object:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="aName" Type="System.String" />
        <Parameter Name="anObject" Type="MonoTouch.Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="aName">To be added.</param>
        <param name="anObject">
          <para>The reference object posting this notification, can be null.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PostNotificationName">
      <MemberSignature Language="C#" Value="public virtual void PostNotificationName (string aName, MonoTouch.Foundation.NSObject anObject, MonoTouch.Foundation.NSDictionary aUserInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PostNotificationName(string aName, class MonoTouch.Foundation.NSObject anObject, class MonoTouch.Foundation.NSDictionary aUserInfo) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("postNotificationName:object:userInfo:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="aName" Type="System.String" />
        <Parameter Name="anObject" Type="MonoTouch.Foundation.NSObject" />
        <Parameter Name="aUserInfo" Type="MonoTouch.Foundation.NSDictionary" />
      </Parameters>
      <Docs>
        <param name="aName">To be added.</param>
        <param name="anObject">
          <para>The reference object posting this notification, can be null.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <param name="aUserInfo">
          <para>To be added.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveObserver">
      <MemberSignature Language="C#" Value="public virtual void RemoveObserver (MonoTouch.Foundation.NSObject observer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveObserver(class MonoTouch.Foundation.NSObject observer) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("removeObserver:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="observer" Type="MonoTouch.Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="observer">To be added.</param>
        <summary>To be added.</summary>
        <remarks> The observer parameter is either the return value
	  from the AddObserver methods that take a
	  Action&lt;NSNotification&gt; parameter (the C# style API) or
	  the "observer" parameter that is passed to AddObserver (the
	  Objective-C style API).
	</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveObserver">
      <MemberSignature Language="C#" Value="public virtual void RemoveObserver (MonoTouch.Foundation.NSObject observer, string aName, MonoTouch.Foundation.NSObject anObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveObserver(class MonoTouch.Foundation.NSObject observer, string aName, class MonoTouch.Foundation.NSObject anObject) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("removeObserver:name:object:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="observer" Type="MonoTouch.Foundation.NSObject" />
        <Parameter Name="aName" Type="System.String" />
        <Parameter Name="anObject" Type="MonoTouch.Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="observer">To be added.</param>
        <param name="aName">
          <para>Optional name that you registered.   Use null if you do not want filtering to take place.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <param name="anObject">
          <para>The object that you originally registered interest in.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveObservers">
      <MemberSignature Language="C#" Value="public void RemoveObservers (System.Collections.Generic.IEnumerable&lt;MonoTouch.Foundation.NSObject&gt; keys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveObservers(class System.Collections.Generic.IEnumerable`1&lt;class MonoTouch.Foundation.NSObject&gt; keys) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;MonoTouch.Foundation.NSObject&gt;" />
      </Parameters>
      <Docs>
        <param name="keys">To be added.</param>
        <summary>Removes multiple observers in one call.</summary>
        <remarks>This removes all of the observers in the IEnumerable&lt;NSObject&gt; parameter.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>