<Type Name="NSNotificationCenter" FullName="Foundation.NSNotificationCenter">
  <TypeSignature Language="C#" Value="public class NSNotificationCenter : Foundation.NSObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit NSNotificationCenter extends Foundation.NSObject" />
  <TypeSignature Language="DocId" Value="T:Foundation.NSNotificationCenter" />
  <TypeSignature Language="F#" Value="type NSNotificationCenter = class&#xA;    inherit NSObject" />
  <AssemblyInfo>
    <AssemblyName>Xamarin.iOS</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>Xamarin.Mac</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Foundation.NSObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Foundation.Register("NSNotificationCenter", true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>A notification hub for the application.</summary>
    <remarks>
      <para>
	The NSNotificationCenter is a hub that is used to listen to
	broadcast messages and post broadcast messages in an
	application.    The messages that are posted are synchronous.
      </para>
      <para> 
	The NSNotificationCenter.DefaultCenter plays a central
	role in the application as this is where system notifications
	are posted for interesting system-level events.  
      </para>
      <para>
	Posting a notification is a synchronous process, which means
	that invoking one of the Post messages on the notification
	center will block execution until all of the notification handlers have completed running. 

      </para>
      <para>
	Notifications are posted on the same thread as the calling
	thread which could have undesired effects.  If you need to
	deliver notifications from a background thread, use the <see cref="M:Foundation.NSObject.BeginInvokeOnMainThread(System.Action)" /> method to wrap your posting into a delegate that is
	invoked on the main thread.

      </para>
      <para>
	When subscribing to a notification, it is possible to
	subscribe only to a certain kind of notification by specifying
	the notification name (or null to listen to all notifications
	posted to the notification center).  It is also possible to
	subscribe only to notifications issued by a specific object.
	This can be used to filter the amount of notifications
	received.

      </para>
      <para>
	Notifications are usually NSString fields that are hosted in
	some class, for example the Objective-C
	UITextViewTextDidChangeNotification is found in the class
	UITextView as the <see cref="P:UIKit.UITextView.TextDidChangeNotification" />.
	For convenience there are overloads that take C# strings.

      </para>
      <para>
	To register for notifications, you can use the AddObserver
	method.  We recommend that you use the C# versions of these
	methods, as you can directly connect delegates, lambdas and
	methods directly into your code.  When you use any of the
	AddObserver methods in this class that take an
	Action&lt;NSNotification;&gt; parameter, the AddObserver will
	return a token.  This token is then used as the parameter to
	RemoveNotification when you want to stop listening to a
	particular event.

      </para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
NSObject notificationToken;

void Setup ()
{
	notificationToken = NSNotificationCenter.DefaultCenter.AddObserver (FooBar.ClockNotification, OnClockChange);
}

void OnClockChange (NSNotification notification)
{
	Console.WriteLine ("The ClockNotification message was posted");
}

void Teardown ()
{
	NSNotificationCenter.DefaultCenter.RemoveObserver (notificationToken);
}
]]></code>
      </example>
      <para>
	Starting with MonoTouch 5.4, calling Dispose on the returned
	notification token will also remove the observer for you,
	making the code shorter.   For example:

      </para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
NSObject notificationToken;

void Setup ()
{
	notificationToken = NSNotificationCenter.DefaultCenter.AddObserver (FooBar.ClockNotification, OnClockChange);
}

void OnClockChange (NSNotification notification)
{
	Console.WriteLine ("The ClockNotification message was posted");
}

void Teardown ()
{
	notificationToken.Dispose ();
}
]]></code>
      </example>
      <para>
        Similarly, if your object implements <format type="text/html"><a href="https://docs.microsoft.com/en-us/search/index?search=System%20IDisposable&amp;scope=Xamarin" title="T:System.IDisposable">T:System.IDisposable</a></format> (including any object derived from <see cref="T:Foundation.NSObject" />)
        you MUST call <see cref="M:Foundation.NSNotificationCenter.RemoveObservers(System.Collections.Generic.IEnumerable{Foundation.NSObject})" /> or <c>notificationToken.Dispose()</c> in your <c>Dispose</c> function: 
      </para>
      <example>
        <code lang="csharp lang-csharp"><![CDATA[
class MyClass : NSObject
{
      private NSObject notificationToken; 

      MyClass()
      { 
         notificationToken = NSNotificationCenter.DefaultCenter.AddObserver(notificationName, NotificationHandler);
      }

      void NotificationHandler(NSNotification notification)
      {
         // ... etc ...
      }

      private bool disposed = false;
      override protected void Dispose(bool disposing)
      {
         if (!disposed)
         {
               if (disposing)
               {
                  notificationToken.Dispose();
               }
               disposed = true;
               base.Dispose();
         }
      }
}
    ]]></code>
      </example>
    </remarks>
    <related type="sample" href="https://github.com/xamarin/ios-samples/tree/master/AppPrefs/">AppPrefs</related>
    <related type="sample" href="https://github.com/xamarin/ios-samples/tree/master/MonoCatalog-MonoDevelop/">monocatalog</related>
    <related type="externalDocumentation" href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSNotificationCenter_Class/index.html">Apple documentation for <c>NSNotificationCenter</c></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NSNotificationCenter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:Foundation.NSNotificationCenter.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("init")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Default constructor that initializes a new instance of this class with no parameters.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected NSNotificationCenter (Foundation.NSObjectFlag t);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class Foundation.NSObjectFlag t) cil managed" />
      <MemberSignature Language="DocId" Value="M:Foundation.NSNotificationCenter.#ctor(Foundation.NSObjectFlag)" />
      <MemberSignature Language="F#" Value="new Foundation.NSNotificationCenter : Foundation.NSObjectFlag -&gt; Foundation.NSNotificationCenter" Usage="new Foundation.NSNotificationCenter t" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="t" Type="Foundation.NSObjectFlag" />
      </Parameters>
      <Docs>
        <param name="t">Unused sentinel value, pass NSObjectFlag.Empty.</param>
        <summary>Constructor to call on derived classes to skip initialization and merely allocate the object.</summary>
        <remarks>
          <para>This constructor should be called by derived classes when they completely construct the object in managed code and merely want the runtime to allocate and initialize the NSObject.   This is required to implement the two-step initialization process that Objective-C uses, the first step is to perform the object allocation, the second step is to initialize the object.   When developers invoke the constructor that takes the NSObjectFlag.Empty they take advantage of a direct path that goes all the way up to NSObject to merely allocate the object's memory and bind the Objective-C and C# objects together.    The actual initialization of the object is up to the developer.</para>
          <para>This constructor is typically used by the binding generator to allocate the object, but prevent the actual initialization to take place.   Once the allocation has taken place, the constructor has to initialize the object.   With constructors generated by the binding generator this means that it manually invokes one of the "init" methods to initialize the object.</para>
          <para>It is the developer's responsibility to completely initialize the object if they chain up using the NSObjectFlag.Empty path.</para>
          <para>In general, if the developer's constructor invokes the NSObjectFlag.Empty base implementation, then it should be calling an Objective-C init method.   If this is not the case, developers should instead chain to the proper constructor in their class. </para>
          <para>The argument value is ignored and merely ensures that the only code that is executed is the construction phase is the basic NSObject allocation and runtime type registration.  Typically the chaining would look like this:</para>
          <example>
            <code lang="csharp lang-csharp"><![CDATA[
//
// The NSObjectFlag merely allocates the object and registers the
// C# class with the Objective-C runtime if necessary, but no actual
// initXxx method is invoked, that is done later in the constructor
//
// This is taken from Xamarin.iOS's source code:
//
[Export ("initWithFrame:")]
public UIView (System.Drawing.RectangleF frame) : base (NSObjectFlag.Empty)
{
// Invoke the init method now.
	var initWithFrame = new Selector ("initWithFrame:").Handle;
	if (IsDirectBinding)
		Handle = ObjCRuntime.Messaging.IntPtr_objc_msgSend_CGRect (this.Handle, initWithFrame, frame);
	else
		Handle = ObjCRuntime.Messaging.IntPtr_objc_msgSendSuper_CGRect (this.SuperHandle, initWithFrame, frame);
}
]]></code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected internal NSNotificationCenter (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig specialname rtspecialname instance void .ctor(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:Foundation.NSNotificationCenter.#ctor(System.IntPtr)" />
      <MemberSignature Language="F#" Value="new Foundation.NSNotificationCenter : nativeint -&gt; Foundation.NSNotificationCenter" Usage="new Foundation.NSNotificationCenter handle" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Pointer (handle) to the unmanaged object.</param>
        <summary>A constructor used when creating managed representations of unmanaged objects;  Called by the runtime.</summary>
        <remarks>
          <para>This constructor is invoked by the runtime infrastructure (<see cref="M:ObjCRuntime.Runtime.GetNSObject(System.IntPtr)" />) to create a new managed representation for a pointer to an unmanaged Objective-C object.    Developers should not invoke this method directly, instead they should call the GetNSObject method as it will prevent two instances of a managed object to point to the same native object.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddObserver">
      <MemberSignature Language="C#" Value="public Foundation.NSObject AddObserver (Foundation.NSString aName, Action&lt;Foundation.NSNotification&gt; notify);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Foundation.NSObject AddObserver(class Foundation.NSString aName, class System.Action`1&lt;class Foundation.NSNotification&gt; notify) cil managed" />
      <MemberSignature Language="DocId" Value="M:Foundation.NSNotificationCenter.AddObserver(Foundation.NSString,System.Action{Foundation.NSNotification})" />
      <MemberSignature Language="F#" Value="override this.AddObserver : Foundation.NSString * Action&lt;Foundation.NSNotification&gt; -&gt; Foundation.NSObject" Usage="nSNotificationCenter.AddObserver (aName, notify)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Foundation.NSObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="aName" Type="Foundation.NSString" />
        <Parameter Name="notify" Type="System.Action&lt;Foundation.NSNotification&gt;" />
      </Parameters>
      <Docs>
        <param name="aName">The name of the notification to observe.</param>
        <param name="notify">The delegate that will be invoked when the notification is posted.</param>
        <summary>Adds an observer for the specified notification</summary>
        <returns>An observer token that can be used later as the parameter passed to RemoveObserver (NSObject observer).</returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddObserver">
      <MemberSignature Language="C#" Value="public Foundation.NSObject AddObserver (Foundation.NSString aName, Action&lt;Foundation.NSNotification&gt; notify, Foundation.NSObject fromObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Foundation.NSObject AddObserver(class Foundation.NSString aName, class System.Action`1&lt;class Foundation.NSNotification&gt; notify, class Foundation.NSObject fromObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:Foundation.NSNotificationCenter.AddObserver(Foundation.NSString,System.Action{Foundation.NSNotification},Foundation.NSObject)" />
      <MemberSignature Language="F#" Value="override this.AddObserver : Foundation.NSString * Action&lt;Foundation.NSNotification&gt; * Foundation.NSObject -&gt; Foundation.NSObject" Usage="nSNotificationCenter.AddObserver (aName, notify, fromObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Foundation.NSObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="aName" Type="Foundation.NSString" />
        <Parameter Name="notify" Type="System.Action&lt;Foundation.NSNotification&gt;" />
        <Parameter Name="fromObject" Type="Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="aName">The name of the notification to observe.</param>
        <param name="notify">The delegate that will be invoked when the notification is posted.</param>
        <param name="fromObject">If not-null, filters the notifications to those sent by this object.</param>
        <summary>Adds an observer for the specified notification</summary>
        <returns>An observer token that can be used later as the parameter passed to RemoveObserver (NSObject observer).</returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddObserver">
      <MemberSignature Language="C#" Value="public virtual void AddObserver (Foundation.NSObject observer, ObjCRuntime.Selector aSelector, Foundation.NSString aName, Foundation.NSObject anObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddObserver(class Foundation.NSObject observer, class ObjCRuntime.Selector aSelector, class Foundation.NSString aName, class Foundation.NSObject anObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:Foundation.NSNotificationCenter.AddObserver(Foundation.NSObject,ObjCRuntime.Selector,Foundation.NSString,Foundation.NSObject)" />
      <MemberSignature Language="F#" Value="override this.AddObserver : Foundation.NSObject * ObjCRuntime.Selector * Foundation.NSString * Foundation.NSObject -&gt; unit" Usage="nSNotificationCenter.AddObserver (observer, aSelector, aName, anObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("addObserver:selector:name:object:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="observer" Type="Foundation.NSObject" />
        <Parameter Name="aSelector" Type="ObjCRuntime.Selector" />
        <Parameter Name="aName" Type="Foundation.NSString" />
        <Parameter Name="anObject" Type="Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="observer">To be added.</param>
        <param name="aSelector">To be added.</param>
        <param name="aName">
          <para>Optional name that you want to register with and filter delivery by this name.   Use null if you do not want filtering to take place.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <param name="anObject">
          <para>The object that we want to receive notifications from, or null for receiving the specified notifications sent by all objects.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Low-level add-observer API</summary>
        <remarks>
          <para>
	    This is a low-level version of the AddObserver API that allows the consumer to control the observer and the selector to notify upon notifications.   
	  </para>
          <para>
	    Developers are encouraged to use the high-level <see cref="M:Foundation.NSNotificationCenter.AddObserver(Foundation.NSString,System.Action{Foundation.NSNotification},Foundation.NSObject)" /> variant.
	  </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddObserver">
      <MemberSignature Language="C#" Value="public virtual Foundation.NSObject AddObserver (string name, Foundation.NSObject obj, Foundation.NSOperationQueue queue, Action&lt;Foundation.NSNotification&gt; handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Foundation.NSObject AddObserver(string name, class Foundation.NSObject obj, class Foundation.NSOperationQueue queue, class System.Action`1&lt;class Foundation.NSNotification&gt; handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:Foundation.NSNotificationCenter.AddObserver(System.String,Foundation.NSObject,Foundation.NSOperationQueue,System.Action{Foundation.NSNotification})" />
      <MemberSignature Language="F#" Value="override this.AddObserver : string * Foundation.NSObject * Foundation.NSOperationQueue * Action&lt;Foundation.NSNotification&gt; -&gt; Foundation.NSObject" Usage="nSNotificationCenter.AddObserver (name, obj, queue, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("addObserverForName:object:queue:usingBlock:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="obj" Type="Foundation.NSObject" />
        <Parameter Name="queue" Type="Foundation.NSOperationQueue" />
        <Parameter Name="handler" Type="System.Action&lt;Foundation.NSNotification&gt;">
          <Attributes>
            <Attribute FrameworkAlternate="xamarin-ios-sdk-12">
              <AttributeName>ObjCRuntime.BlockProxy(typeof(ObjCRuntime.Trampolines/NIDActionArity1V41))</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="name">
          <para>To be added.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <param name="obj">
          <para>To be added.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <param name="queue">
          <para>To be added.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <param name="handler">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClassHandle">
      <MemberSignature Language="C#" Value="public override IntPtr ClassHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ClassHandle" />
      <MemberSignature Language="DocId" Value="P:Foundation.NSNotificationCenter.ClassHandle" />
      <MemberSignature Language="F#" Value="member this.ClassHandle : nativeint" Usage="Foundation.NSNotificationCenter.ClassHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The handle for this class.</summary>
        <value>The pointer to the Objective-C class.</value>
        <remarks>Each Xamarin.iOS class mirrors an unmanaged Objective-C class.   This value contains the pointer to the Objective-C class, it is similar to calling objc_getClass with the object name.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultCenter">
      <MemberSignature Language="C#" Value="public static Foundation.NSNotificationCenter DefaultCenter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Foundation.NSNotificationCenter DefaultCenter" />
      <MemberSignature Language="DocId" Value="P:Foundation.NSNotificationCenter.DefaultCenter" />
      <MemberSignature Language="F#" Value="member this.DefaultCenter : Foundation.NSNotificationCenter" Usage="Foundation.NSNotificationCenter.DefaultCenter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: Foundation.Export("defaultCenter", ObjCRuntime.ArgumentSemantic.Strong)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Foundation.NSNotificationCenter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The default notification center, system notifications and system-level events are posted to this notification center.</summary>
        <value>
        </value>
        <remarks>
          <para>
	    The NSNotificationCenter.DefaultCenter plays a central
	    role in the application as this is where system notifications
	    are posted for interesting system-level events.  

	  </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PostNotification">
      <MemberSignature Language="C#" Value="public virtual void PostNotification (Foundation.NSNotification notification);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PostNotification(class Foundation.NSNotification notification) cil managed" />
      <MemberSignature Language="DocId" Value="M:Foundation.NSNotificationCenter.PostNotification(Foundation.NSNotification)" />
      <MemberSignature Language="F#" Value="abstract member PostNotification : Foundation.NSNotification -&gt; unit&#xA;override this.PostNotification : Foundation.NSNotification -&gt; unit" Usage="nSNotificationCenter.PostNotification notification" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("postNotification:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="notification" Type="Foundation.NSNotification" />
      </Parameters>
      <Docs>
        <param name="notification">Notification to post</param>
        <summary>Posts a notification that is broadcast to everyoned subscribing to that notification.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PostNotificationName">
      <MemberSignature Language="C#" Value="public virtual void PostNotificationName (string aName, Foundation.NSObject anObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PostNotificationName(string aName, class Foundation.NSObject anObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:Foundation.NSNotificationCenter.PostNotificationName(System.String,Foundation.NSObject)" />
      <MemberSignature Language="F#" Value="abstract member PostNotificationName : string * Foundation.NSObject -&gt; unit&#xA;override this.PostNotificationName : string * Foundation.NSObject -&gt; unit" Usage="nSNotificationCenter.PostNotificationName (aName, anObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("postNotificationName:object:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="aName" Type="System.String" />
        <Parameter Name="anObject" Type="Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="aName">To be added.</param>
        <param name="anObject">
          <para>The reference object posting this notification, can be null.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PostNotificationName">
      <MemberSignature Language="C#" Value="public virtual void PostNotificationName (string aName, Foundation.NSObject anObject, Foundation.NSDictionary aUserInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PostNotificationName(string aName, class Foundation.NSObject anObject, class Foundation.NSDictionary aUserInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:Foundation.NSNotificationCenter.PostNotificationName(System.String,Foundation.NSObject,Foundation.NSDictionary)" />
      <MemberSignature Language="F#" Value="abstract member PostNotificationName : string * Foundation.NSObject * Foundation.NSDictionary -&gt; unit&#xA;override this.PostNotificationName : string * Foundation.NSObject * Foundation.NSDictionary -&gt; unit" Usage="nSNotificationCenter.PostNotificationName (aName, anObject, aUserInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("postNotificationName:object:userInfo:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="aName" Type="System.String" />
        <Parameter Name="anObject" Type="Foundation.NSObject" />
        <Parameter Name="aUserInfo" Type="Foundation.NSDictionary" />
      </Parameters>
      <Docs>
        <param name="aName">To be added.</param>
        <param name="anObject">
          <para>The reference object posting this notification, can be null.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <param name="aUserInfo">
          <para>To be added.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveObserver">
      <MemberSignature Language="C#" Value="public virtual void RemoveObserver (Foundation.NSObject observer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveObserver(class Foundation.NSObject observer) cil managed" />
      <MemberSignature Language="DocId" Value="M:Foundation.NSNotificationCenter.RemoveObserver(Foundation.NSObject)" />
      <MemberSignature Language="F#" Value="override this.RemoveObserver : Foundation.NSObject -&gt; unit" Usage="nSNotificationCenter.RemoveObserver observer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("removeObserver:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="observer" Type="Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="observer">To be added.</param>
        <summary>To be added.</summary>
        <remarks> The observer parameter is either the return value
	  from the AddObserver methods that take a
	  Action&lt;NSNotification&gt; parameter (the C# style API) or
	  the "observer" parameter that is passed to AddObserver (the
	  Objective-C style API).
	</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveObserver">
      <MemberSignature Language="C#" Value="public virtual void RemoveObserver (Foundation.NSObject observer, string aName, Foundation.NSObject anObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveObserver(class Foundation.NSObject observer, string aName, class Foundation.NSObject anObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:Foundation.NSNotificationCenter.RemoveObserver(Foundation.NSObject,System.String,Foundation.NSObject)" />
      <MemberSignature Language="F#" Value="override this.RemoveObserver : Foundation.NSObject * string * Foundation.NSObject -&gt; unit" Usage="nSNotificationCenter.RemoveObserver (observer, aName, anObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Foundation.Export("removeObserver:name:object:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>ObjCRuntime.BindingImpl(ObjCRuntime.BindingImplOptions.GeneratedCode | ObjCRuntime.BindingImplOptions.Optimizable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="observer" Type="Foundation.NSObject" />
        <Parameter Name="aName" Type="System.String" />
        <Parameter Name="anObject" Type="Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="observer">To be added.</param>
        <param name="aName">
          <para>Optional name that you registered.   Use null if you do not want filtering to take place.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <param name="anObject">
          <para>The object that you originally registered interest in.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveObservers">
      <MemberSignature Language="C#" Value="public void RemoveObservers (System.Collections.Generic.IEnumerable&lt;Foundation.NSObject&gt; keys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveObservers(class System.Collections.Generic.IEnumerable`1&lt;class Foundation.NSObject&gt; keys) cil managed" />
      <MemberSignature Language="DocId" Value="M:Foundation.NSNotificationCenter.RemoveObservers(System.Collections.Generic.IEnumerable{Foundation.NSObject})" />
      <MemberSignature Language="F#" Value="member this.RemoveObservers : seq&lt;Foundation.NSObject&gt; -&gt; unit" Usage="nSNotificationCenter.RemoveObservers keys" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Xamarin.iOS</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Xamarin.Mac</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;Foundation.NSObject&gt;" />
      </Parameters>
      <Docs>
        <param name="keys">To be added.</param>
        <summary>Removes multiple observers in one call.</summary>
        <remarks>This removes all of the observers in the IEnumerable&lt;NSObject&gt; parameter.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
